var xu = Object.defineProperty;
var Eu = (_e,et,tt)=>et in _e ? xu(_e, et, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: tt
}) : _e[et] = tt;
var oo = (_e,et,tt)=>(Eu(_e, typeof et != "symbol" ? et + "" : et, tt),
tt)
  , lo = (_e,et,tt)=>{
    if (!et.has(_e))
        throw TypeError("Cannot " + tt)
}
;
var Kt = (_e,et,tt)=>(lo(_e, et, "read from private field"),
tt ? tt.call(_e) : et.get(_e))
  , wr = (_e,et,tt)=>{
    if (et.has(_e))
        throw TypeError("Cannot add the same private member more than once");
    et instanceof WeakSet ? et.add(_e) : et.set(_e, tt)
}
  , vr = (_e,et,tt,rt)=>(lo(_e, et, "write to private field"),
rt ? rt.call(_e, tt) : et.set(_e, tt),
tt);
var Qs = (_e,et,tt,rt)=>({
    set _(nt) {
        vr(_e, et, nt, tt)
    },
    get _() {
        return Kt(_e, et, rt)
    }
})
  , Or = (_e,et,tt)=>(lo(_e, et, "access private method"),
tt);
function _mergeNamespaces(_e, et) {
    for (var tt = 0; tt < et.length; tt++) {
        const rt = et[tt];
        if (typeof rt != "string" && !Array.isArray(rt)) {
            for (const nt in rt)
                if (nt !== "default" && !(nt in _e)) {
                    const it = Object.getOwnPropertyDescriptor(rt, nt);
                    it && Object.defineProperty(_e, nt, it.get ? it : {
                        enumerable: !0,
                        get: ()=>rt[nt]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(_e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const et = document.createElement("link").relList;
    if (et && et.supports && et.supports("modulepreload"))
        return;
    for (const nt of document.querySelectorAll('link[rel="modulepreload"]'))
        rt(nt);
    new MutationObserver(nt=>{
        for (const it of nt)
            if (it.type === "childList")
                for (const st of it.addedNodes)
                    st.tagName === "LINK" && st.rel === "modulepreload" && rt(st)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function tt(nt) {
        const it = {};
        return nt.integrity && (it.integrity = nt.integrity),
        nt.referrerPolicy && (it.referrerPolicy = nt.referrerPolicy),
        nt.crossOrigin === "use-credentials" ? it.credentials = "include" : nt.crossOrigin === "anonymous" ? it.credentials = "omit" : it.credentials = "same-origin",
        it
    }
    function rt(nt) {
        if (nt.ep)
            return;
        nt.ep = !0;
        const it = tt(nt);
        fetch(nt.href, it)
    }
}
)();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(_e) {
    return _e && _e.__esModule && Object.prototype.hasOwnProperty.call(_e, "default") ? _e.default : _e
}
function getAugmentedNamespace(_e) {
    if (_e.__esModule)
        return _e;
    var et = _e.default;
    if (typeof et == "function") {
        var tt = function rt() {
            return this instanceof rt ? Reflect.construct(et, arguments, this.constructor) : et.apply(this, arguments)
        };
        tt.prototype = et.prototype
    } else
        tt = {};
    return Object.defineProperty(tt, "__esModule", {
        value: !0
    }),
    Object.keys(_e).forEach(function(rt) {
        var nt = Object.getOwnPropertyDescriptor(_e, rt);
        Object.defineProperty(tt, rt, nt.get ? nt : {
            enumerable: !0,
            get: function() {
                return _e[rt]
            }
        })
    }),
    tt
}
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {}
  , react = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$7 = Symbol.for("react.element")
  , n$g = Symbol.for("react.portal")
  , p$a = Symbol.for("react.fragment")
  , q$5 = Symbol.for("react.strict_mode")
  , r$i = Symbol.for("react.profiler")
  , t$a = Symbol.for("react.provider")
  , u$8 = Symbol.for("react.context")
  , v$7 = Symbol.for("react.forward_ref")
  , w$5 = Symbol.for("react.suspense")
  , x$3 = Symbol.for("react.memo")
  , y$6 = Symbol.for("react.lazy")
  , z$3 = Symbol.iterator;
function A$4(_e) {
    return _e === null || typeof _e != "object" ? null : (_e = z$3 && _e[z$3] || _e["@@iterator"],
    typeof _e == "function" ? _e : null)
}
var B$2 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$4 = Object.assign
  , D$2 = {};
function E$4(_e, et, tt) {
    this.props = _e,
    this.context = et,
    this.refs = D$2,
    this.updater = tt || B$2
}
E$4.prototype.isReactComponent = {};
E$4.prototype.setState = function(_e, et) {
    if (typeof _e != "object" && typeof _e != "function" && _e != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, _e, et, "setState")
}
;
E$4.prototype.forceUpdate = function(_e) {
    this.updater.enqueueForceUpdate(this, _e, "forceUpdate")
}
;
function F() {}
F.prototype = E$4.prototype;
function G$1(_e, et, tt) {
    this.props = _e,
    this.context = et,
    this.refs = D$2,
    this.updater = tt || B$2
}
var H$4 = G$1.prototype = new F;
H$4.constructor = G$1;
C$4(H$4, E$4.prototype);
H$4.isPureReactComponent = !0;
var I$4 = Array.isArray
  , J = Object.prototype.hasOwnProperty
  , K$1 = {
    current: null
}
  , L$4 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$4(_e, et, tt) {
    var rt, nt = {}, it = null, st = null;
    if (et != null)
        for (rt in et.ref !== void 0 && (st = et.ref),
        et.key !== void 0 && (it = "" + et.key),
        et)
            J.call(et, rt) && !L$4.hasOwnProperty(rt) && (nt[rt] = et[rt]);
    var at = arguments.length - 2;
    if (at === 1)
        nt.children = tt;
    else if (1 < at) {
        for (var ot = Array(at), lt = 0; lt < at; lt++)
            ot[lt] = arguments[lt + 2];
        nt.children = ot
    }
    if (_e && _e.defaultProps)
        for (rt in at = _e.defaultProps,
        at)
            nt[rt] === void 0 && (nt[rt] = at[rt]);
    return {
        $$typeof: l$7,
        type: _e,
        key: it,
        ref: st,
        props: nt,
        _owner: K$1.current
    }
}
function N$4(_e, et) {
    return {
        $$typeof: l$7,
        type: _e.type,
        key: et,
        ref: _e.ref,
        props: _e.props,
        _owner: _e._owner
    }
}
function O$2(_e) {
    return typeof _e == "object" && _e !== null && _e.$$typeof === l$7
}
function escape(_e) {
    var et = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + _e.replace(/[=:]/g, function(tt) {
        return et[tt]
    })
}
var P$4 = /\/+/g;
function Q$2(_e, et) {
    return typeof _e == "object" && _e !== null && _e.key != null ? escape("" + _e.key) : et.toString(36)
}
function R$4(_e, et, tt, rt, nt) {
    var it = typeof _e;
    (it === "undefined" || it === "boolean") && (_e = null);
    var st = !1;
    if (_e === null)
        st = !0;
    else
        switch (it) {
        case "string":
        case "number":
            st = !0;
            break;
        case "object":
            switch (_e.$$typeof) {
            case l$7:
            case n$g:
                st = !0
            }
        }
    if (st)
        return st = _e,
        nt = nt(st),
        _e = rt === "" ? "." + Q$2(st, 0) : rt,
        I$4(nt) ? (tt = "",
        _e != null && (tt = _e.replace(P$4, "$&/") + "/"),
        R$4(nt, et, tt, "", function(lt) {
            return lt
        })) : nt != null && (O$2(nt) && (nt = N$4(nt, tt + (!nt.key || st && st.key === nt.key ? "" : ("" + nt.key).replace(P$4, "$&/") + "/") + _e)),
        et.push(nt)),
        1;
    if (st = 0,
    rt = rt === "" ? "." : rt + ":",
    I$4(_e))
        for (var at = 0; at < _e.length; at++) {
            it = _e[at];
            var ot = rt + Q$2(it, at);
            st += R$4(it, et, tt, ot, nt)
        }
    else if (ot = A$4(_e),
    typeof ot == "function")
        for (_e = ot.call(_e),
        at = 0; !(it = _e.next()).done; )
            it = it.value,
            ot = rt + Q$2(it, at++),
            st += R$4(it, et, tt, ot, nt);
    else if (it === "object")
        throw et = String(_e),
        Error("Objects are not valid as a React child (found: " + (et === "[object Object]" ? "object with keys {" + Object.keys(_e).join(", ") + "}" : et) + "). If you meant to render a collection of children, use an array instead.");
    return st
}
function S$6(_e, et, tt) {
    if (_e == null)
        return _e;
    var rt = []
      , nt = 0;
    return R$4(_e, rt, "", "", function(it) {
        return et.call(tt, it, nt++)
    }),
    rt
}
function T$4(_e) {
    if (_e._status === -1) {
        var et = _e._result;
        et = et(),
        et.then(function(tt) {
            (_e._status === 0 || _e._status === -1) && (_e._status = 1,
            _e._result = tt)
        }, function(tt) {
            (_e._status === 0 || _e._status === -1) && (_e._status = 2,
            _e._result = tt)
        }),
        _e._status === -1 && (_e._status = 0,
        _e._result = et)
    }
    if (_e._status === 1)
        return _e._result.default;
    throw _e._result
}
var U$1 = {
    current: null
}
  , V$3 = {
    transition: null
}
  , W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$3,
    ReactCurrentOwner: K$1
};
react_production_min.Children = {
    map: S$6,
    forEach: function(_e, et, tt) {
        S$6(_e, function() {
            et.apply(this, arguments)
        }, tt)
    },
    count: function(_e) {
        var et = 0;
        return S$6(_e, function() {
            et++
        }),
        et
    },
    toArray: function(_e) {
        return S$6(_e, function(et) {
            return et
        }) || []
    },
    only: function(_e) {
        if (!O$2(_e))
            throw Error("React.Children.only expected to receive a single React element child.");
        return _e
    }
};
react_production_min.Component = E$4;
react_production_min.Fragment = p$a;
react_production_min.Profiler = r$i;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$5;
react_production_min.Suspense = w$5;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(_e, et, tt) {
    if (_e == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + _e + ".");
    var rt = C$4({}, _e.props)
      , nt = _e.key
      , it = _e.ref
      , st = _e._owner;
    if (et != null) {
        if (et.ref !== void 0 && (it = et.ref,
        st = K$1.current),
        et.key !== void 0 && (nt = "" + et.key),
        _e.type && _e.type.defaultProps)
            var at = _e.type.defaultProps;
        for (ot in et)
            J.call(et, ot) && !L$4.hasOwnProperty(ot) && (rt[ot] = et[ot] === void 0 && at !== void 0 ? at[ot] : et[ot])
    }
    var ot = arguments.length - 2;
    if (ot === 1)
        rt.children = tt;
    else if (1 < ot) {
        at = Array(ot);
        for (var lt = 0; lt < ot; lt++)
            at[lt] = arguments[lt + 2];
        rt.children = at
    }
    return {
        $$typeof: l$7,
        type: _e.type,
        key: nt,
        ref: it,
        props: rt,
        _owner: st
    }
}
;
react_production_min.createContext = function(_e) {
    return _e = {
        $$typeof: u$8,
        _currentValue: _e,
        _currentValue2: _e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    _e.Provider = {
        $$typeof: t$a,
        _context: _e
    },
    _e.Consumer = _e
}
;
react_production_min.createElement = M$4;
react_production_min.createFactory = function(_e) {
    var et = M$4.bind(null, _e);
    return et.type = _e,
    et
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(_e) {
    return {
        $$typeof: v$7,
        render: _e
    }
}
;
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(_e) {
    return {
        $$typeof: y$6,
        _payload: {
            _status: -1,
            _result: _e
        },
        _init: T$4
    }
}
;
react_production_min.memo = function(_e, et) {
    return {
        $$typeof: x$3,
        type: _e,
        compare: et === void 0 ? null : et
    }
}
;
react_production_min.startTransition = function(_e) {
    var et = V$3.transition;
    V$3.transition = {};
    try {
        _e()
    } finally {
        V$3.transition = et
    }
}
;
react_production_min.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
react_production_min.useCallback = function(_e, et) {
    return U$1.current.useCallback(_e, et)
}
;
react_production_min.useContext = function(_e) {
    return U$1.current.useContext(_e)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(_e) {
    return U$1.current.useDeferredValue(_e)
}
;
react_production_min.useEffect = function(_e, et) {
    return U$1.current.useEffect(_e, et)
}
;
react_production_min.useId = function() {
    return U$1.current.useId()
}
;
react_production_min.useImperativeHandle = function(_e, et, tt) {
    return U$1.current.useImperativeHandle(_e, et, tt)
}
;
react_production_min.useInsertionEffect = function(_e, et) {
    return U$1.current.useInsertionEffect(_e, et)
}
;
react_production_min.useLayoutEffect = function(_e, et) {
    return U$1.current.useLayoutEffect(_e, et)
}
;
react_production_min.useMemo = function(_e, et) {
    return U$1.current.useMemo(_e, et)
}
;
react_production_min.useReducer = function(_e, et, tt) {
    return U$1.current.useReducer(_e, et, tt)
}
;
react_production_min.useRef = function(_e) {
    return U$1.current.useRef(_e)
}
;
react_production_min.useState = function(_e) {
    return U$1.current.useState(_e)
}
;
react_production_min.useSyncExternalStore = function(_e, et, tt) {
    return U$1.current.useSyncExternalStore(_e, et, tt)
}
;
react_production_min.useTransition = function() {
    return U$1.current.useTransition()
}
;
react_production_min.version = "18.2.0";
react.exports = react_production_min;
var reactExports = react.exports;
const React$1 = getDefaultExportFromCjs(reactExports)
  , ReactOriginal = _mergeNamespaces({
    __proto__: null,
    default: React$1
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$9 = reactExports
  , k$4 = Symbol.for("react.element")
  , l$6 = Symbol.for("react.fragment")
  , m$5 = Object.prototype.hasOwnProperty
  , n$f = f$9.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$9 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q$4(_e, et, tt) {
    var rt, nt = {}, it = null, st = null;
    tt !== void 0 && (it = "" + tt),
    et.key !== void 0 && (it = "" + et.key),
    et.ref !== void 0 && (st = et.ref);
    for (rt in et)
        m$5.call(et, rt) && !p$9.hasOwnProperty(rt) && (nt[rt] = et[rt]);
    if (_e && _e.defaultProps)
        for (rt in et = _e.defaultProps,
        et)
            nt[rt] === void 0 && (nt[rt] = et[rt]);
    return {
        $$typeof: k$4,
        type: _e,
        key: it,
        ref: st,
        props: nt,
        _owner: n$f.current
    }
}
reactJsxRuntime_production_min.Fragment = l$6;
reactJsxRuntime_production_min.jsx = q$4;
reactJsxRuntime_production_min.jsxs = q$4;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports
  , client = {}
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(_e) {
    function et(At, Pt) {
        var Dt = At.length;
        At.push(Pt);
        e: for (; 0 < Dt; ) {
            var Bt = Dt - 1 >>> 1
              , zt = At[Bt];
            if (0 < nt(zt, Pt))
                At[Bt] = Pt,
                At[Dt] = zt,
                Dt = Bt;
            else
                break e
        }
    }
    function tt(At) {
        return At.length === 0 ? null : At[0]
    }
    function rt(At) {
        if (At.length === 0)
            return null;
        var Pt = At[0]
          , Dt = At.pop();
        if (Dt !== Pt) {
            At[0] = Dt;
            e: for (var Bt = 0, zt = At.length, Yt = zt >>> 1; Bt < Yt; ) {
                var rr = 2 * (Bt + 1) - 1
                  , ar = At[rr]
                  , or = rr + 1
                  , pr = At[or];
                if (0 > nt(ar, Dt))
                    or < zt && 0 > nt(pr, ar) ? (At[Bt] = pr,
                    At[or] = Dt,
                    Bt = or) : (At[Bt] = ar,
                    At[rr] = Dt,
                    Bt = rr);
                else if (or < zt && 0 > nt(pr, Dt))
                    At[Bt] = pr,
                    At[or] = Dt,
                    Bt = or;
                else
                    break e
            }
        }
        return Pt
    }
    function nt(At, Pt) {
        var Dt = At.sortIndex - Pt.sortIndex;
        return Dt !== 0 ? Dt : At.id - Pt.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var it = performance;
        _e.unstable_now = function() {
            return it.now()
        }
    } else {
        var st = Date
          , at = st.now();
        _e.unstable_now = function() {
            return st.now() - at
        }
    }
    var ot = []
      , lt = []
      , dt = 1
      , ct = null
      , ut = 3
      , ft = !1
      , ht = !1
      , gt = !1
      , bt = typeof setTimeout == "function" ? setTimeout : null
      , pt = typeof clearTimeout == "function" ? clearTimeout : null
      , mt = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function yt(At) {
        for (var Pt = tt(lt); Pt !== null; ) {
            if (Pt.callback === null)
                rt(lt);
            else if (Pt.startTime <= At)
                rt(lt),
                Pt.sortIndex = Pt.expirationTime,
                et(ot, Pt);
            else
                break;
            Pt = tt(lt)
        }
    }
    function vt(At) {
        if (gt = !1,
        yt(At),
        !ht)
            if (tt(ot) !== null)
                ht = !0,
                $t(wt);
            else {
                var Pt = tt(lt);
                Pt !== null && kt(vt, Pt.startTime - At)
            }
    }
    function wt(At, Pt) {
        ht = !1,
        gt && (gt = !1,
        pt(xt),
        xt = -1),
        ft = !0;
        var Dt = ut;
        try {
            for (yt(Pt),
            ct = tt(ot); ct !== null && (!(ct.expirationTime > Pt) || At && !It()); ) {
                var Bt = ct.callback;
                if (typeof Bt == "function") {
                    ct.callback = null,
                    ut = ct.priorityLevel;
                    var zt = Bt(ct.expirationTime <= Pt);
                    Pt = _e.unstable_now(),
                    typeof zt == "function" ? ct.callback = zt : ct === tt(ot) && rt(ot),
                    yt(Pt)
                } else
                    rt(ot);
                ct = tt(ot)
            }
            if (ct !== null)
                var Yt = !0;
            else {
                var rr = tt(lt);
                rr !== null && kt(vt, rr.startTime - Pt),
                Yt = !1
            }
            return Yt
        } finally {
            ct = null,
            ut = Dt,
            ft = !1
        }
    }
    var _t = !1
      , Et = null
      , xt = -1
      , Ct = 5
      , Tt = -1;
    function It() {
        return !(_e.unstable_now() - Tt < Ct)
    }
    function Nt() {
        if (Et !== null) {
            var At = _e.unstable_now();
            Tt = At;
            var Pt = !0;
            try {
                Pt = Et(!0, At)
            } finally {
                Pt ? Ft() : (_t = !1,
                Et = null)
            }
        } else
            _t = !1
    }
    var Ft;
    if (typeof mt == "function")
        Ft = function() {
            mt(Nt)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Lt = new MessageChannel
          , Mt = Lt.port2;
        Lt.port1.onmessage = Nt,
        Ft = function() {
            Mt.postMessage(null)
        }
    } else
        Ft = function() {
            bt(Nt, 0)
        }
        ;
    function $t(At) {
        Et = At,
        _t || (_t = !0,
        Ft())
    }
    function kt(At, Pt) {
        xt = bt(function() {
            At(_e.unstable_now())
        }, Pt)
    }
    _e.unstable_IdlePriority = 5,
    _e.unstable_ImmediatePriority = 1,
    _e.unstable_LowPriority = 4,
    _e.unstable_NormalPriority = 3,
    _e.unstable_Profiling = null,
    _e.unstable_UserBlockingPriority = 2,
    _e.unstable_cancelCallback = function(At) {
        At.callback = null
    }
    ,
    _e.unstable_continueExecution = function() {
        ht || ft || (ht = !0,
        $t(wt))
    }
    ,
    _e.unstable_forceFrameRate = function(At) {
        0 > At || 125 < At ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ct = 0 < At ? Math.floor(1e3 / At) : 5
    }
    ,
    _e.unstable_getCurrentPriorityLevel = function() {
        return ut
    }
    ,
    _e.unstable_getFirstCallbackNode = function() {
        return tt(ot)
    }
    ,
    _e.unstable_next = function(At) {
        switch (ut) {
        case 1:
        case 2:
        case 3:
            var Pt = 3;
            break;
        default:
            Pt = ut
        }
        var Dt = ut;
        ut = Pt;
        try {
            return At()
        } finally {
            ut = Dt
        }
    }
    ,
    _e.unstable_pauseExecution = function() {}
    ,
    _e.unstable_requestPaint = function() {}
    ,
    _e.unstable_runWithPriority = function(At, Pt) {
        switch (At) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            At = 3
        }
        var Dt = ut;
        ut = At;
        try {
            return Pt()
        } finally {
            ut = Dt
        }
    }
    ,
    _e.unstable_scheduleCallback = function(At, Pt, Dt) {
        var Bt = _e.unstable_now();
        switch (typeof Dt == "object" && Dt !== null ? (Dt = Dt.delay,
        Dt = typeof Dt == "number" && 0 < Dt ? Bt + Dt : Bt) : Dt = Bt,
        At) {
        case 1:
            var zt = -1;
            break;
        case 2:
            zt = 250;
            break;
        case 5:
            zt = 1073741823;
            break;
        case 4:
            zt = 1e4;
            break;
        default:
            zt = 5e3
        }
        return zt = Dt + zt,
        At = {
            id: dt++,
            callback: Pt,
            priorityLevel: At,
            startTime: Dt,
            expirationTime: zt,
            sortIndex: -1
        },
        Dt > Bt ? (At.sortIndex = Dt,
        et(lt, At),
        tt(ot) === null && At === tt(lt) && (gt ? (pt(xt),
        xt = -1) : gt = !0,
        kt(vt, Dt - Bt))) : (At.sortIndex = zt,
        et(ot, At),
        ht || ft || (ht = !0,
        $t(wt))),
        At
    }
    ,
    _e.unstable_shouldYield = It,
    _e.unstable_wrapCallback = function(At) {
        var Pt = ut;
        return function() {
            var Dt = ut;
            ut = Pt;
            try {
                return At.apply(this, arguments)
            } finally {
                ut = Dt
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports
  , ca = schedulerExports;
function p$8(_e) {
    for (var et = "https://reactjs.org/docs/error-decoder.html?invariant=" + _e, tt = 1; tt < arguments.length; tt++)
        et += "&args[]=" + encodeURIComponent(arguments[tt]);
    return "Minified React error #" + _e + "; visit " + et + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa(_e, et) {
    ha(_e, et),
    ha(_e + "Capture", et)
}
function ha(_e, et) {
    for (ea[_e] = et,
    _e = 0; _e < et.length; _e++)
        da.add(et[_e])
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ja = Object.prototype.hasOwnProperty
  , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function oa(_e) {
    return ja.call(ma, _e) ? !0 : ja.call(la, _e) ? !1 : ka.test(_e) ? ma[_e] = !0 : (la[_e] = !0,
    !1)
}
function pa(_e, et, tt, rt) {
    if (tt !== null && tt.type === 0)
        return !1;
    switch (typeof et) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return rt ? !1 : tt !== null ? !tt.acceptsBooleans : (_e = _e.toLowerCase().slice(0, 5),
        _e !== "data-" && _e !== "aria-");
    default:
        return !1
    }
}
function qa(_e, et, tt, rt) {
    if (et === null || typeof et > "u" || pa(_e, et, tt, rt))
        return !0;
    if (rt)
        return !1;
    if (tt !== null)
        switch (tt.type) {
        case 3:
            return !et;
        case 4:
            return et === !1;
        case 5:
            return isNaN(et);
        case 6:
            return isNaN(et) || 1 > et
        }
    return !1
}
function v$6(_e, et, tt, rt, nt, it, st) {
    this.acceptsBooleans = et === 2 || et === 3 || et === 4,
    this.attributeName = rt,
    this.attributeNamespace = nt,
    this.mustUseProperty = tt,
    this.propertyName = _e,
    this.type = et,
    this.sanitizeURL = it,
    this.removeEmptyString = st
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(_e) {
    z$2[_e] = new v$6(_e,0,!1,_e,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_e) {
    var et = _e[0];
    z$2[et] = new v$6(et,1,!1,_e[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,2,!1,_e.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,2,!1,_e,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(_e) {
    z$2[_e] = new v$6(_e,3,!1,_e.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,3,!0,_e,null,!1,!1)
});
["capture", "download"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,4,!1,_e,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,6,!1,_e,null,!1,!1)
});
["rowSpan", "start"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,5,!1,_e.toLowerCase(),null,!1,!1)
});
var ra = /[\-:]([a-z])/g;
function sa(_e) {
    return _e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(_e) {
    var et = _e.replace(ra, sa);
    z$2[et] = new v$6(et,1,!1,_e,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(_e) {
    var et = _e.replace(ra, sa);
    z$2[et] = new v$6(et,1,!1,_e,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(_e) {
    var et = _e.replace(ra, sa);
    z$2[et] = new v$6(et,1,!1,_e,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,1,!1,_e.toLowerCase(),null,!1,!1)
});
z$2.xlinkHref = new v$6("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(_e) {
    z$2[_e] = new v$6(_e,1,!1,_e.toLowerCase(),null,!0,!0)
});
function ta(_e, et, tt, rt) {
    var nt = z$2.hasOwnProperty(et) ? z$2[et] : null;
    (nt !== null ? nt.type !== 0 : rt || !(2 < et.length) || et[0] !== "o" && et[0] !== "O" || et[1] !== "n" && et[1] !== "N") && (qa(et, tt, nt, rt) && (tt = null),
    rt || nt === null ? oa(et) && (tt === null ? _e.removeAttribute(et) : _e.setAttribute(et, "" + tt)) : nt.mustUseProperty ? _e[nt.propertyName] = tt === null ? nt.type === 3 ? !1 : "" : tt : (et = nt.attributeName,
    rt = nt.attributeNamespace,
    tt === null ? _e.removeAttribute(et) : (nt = nt.type,
    tt = nt === 3 || nt === 4 && tt === !0 ? "" : "" + tt,
    rt ? _e.setAttributeNS(rt, et, tt) : _e.setAttribute(et, tt))))
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , va = Symbol.for("react.element")
  , wa = Symbol.for("react.portal")
  , ya = Symbol.for("react.fragment")
  , za = Symbol.for("react.strict_mode")
  , Aa = Symbol.for("react.profiler")
  , Ba = Symbol.for("react.provider")
  , Ca = Symbol.for("react.context")
  , Da = Symbol.for("react.forward_ref")
  , Ea = Symbol.for("react.suspense")
  , Fa = Symbol.for("react.suspense_list")
  , Ga = Symbol.for("react.memo")
  , Ha = Symbol.for("react.lazy")
  , Ia = Symbol.for("react.offscreen")
  , Ja = Symbol.iterator;
function Ka(_e) {
    return _e === null || typeof _e != "object" ? null : (_e = Ja && _e[Ja] || _e["@@iterator"],
    typeof _e == "function" ? _e : null)
}
var A$3 = Object.assign, La;
function Ma(_e) {
    if (La === void 0)
        try {
            throw Error()
        } catch (tt) {
            var et = tt.stack.trim().match(/\n( *(at )?)/);
            La = et && et[1] || ""
        }
    return `
` + La + _e
}
var Na = !1;
function Oa(_e, et) {
    if (!_e || Na)
        return "";
    Na = !0;
    var tt = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (et)
            if (et = function() {
                throw Error()
            }
            ,
            Object.defineProperty(et.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(et, [])
                } catch (lt) {
                    var rt = lt
                }
                Reflect.construct(_e, [], et)
            } else {
                try {
                    et.call()
                } catch (lt) {
                    rt = lt
                }
                _e.call(et.prototype)
            }
        else {
            try {
                throw Error()
            } catch (lt) {
                rt = lt
            }
            _e()
        }
    } catch (lt) {
        if (lt && rt && typeof lt.stack == "string") {
            for (var nt = lt.stack.split(`
`), it = rt.stack.split(`
`), st = nt.length - 1, at = it.length - 1; 1 <= st && 0 <= at && nt[st] !== it[at]; )
                at--;
            for (; 1 <= st && 0 <= at; st--,
            at--)
                if (nt[st] !== it[at]) {
                    if (st !== 1 || at !== 1)
                        do
                            if (st--,
                            at--,
                            0 > at || nt[st] !== it[at]) {
                                var ot = `
` + nt[st].replace(" at new ", " at ");
                                return _e.displayName && ot.includes("<anonymous>") && (ot = ot.replace("<anonymous>", _e.displayName)),
                                ot
                            }
                        while (1 <= st && 0 <= at);
                    break
                }
        }
    } finally {
        Na = !1,
        Error.prepareStackTrace = tt
    }
    return (_e = _e ? _e.displayName || _e.name : "") ? Ma(_e) : ""
}
function Pa(_e) {
    switch (_e.tag) {
    case 5:
        return Ma(_e.type);
    case 16:
        return Ma("Lazy");
    case 13:
        return Ma("Suspense");
    case 19:
        return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
        return _e = Oa(_e.type, !1),
        _e;
    case 11:
        return _e = Oa(_e.type.render, !1),
        _e;
    case 1:
        return _e = Oa(_e.type, !0),
        _e;
    default:
        return ""
    }
}
function Qa(_e) {
    if (_e == null)
        return null;
    if (typeof _e == "function")
        return _e.displayName || _e.name || null;
    if (typeof _e == "string")
        return _e;
    switch (_e) {
    case ya:
        return "Fragment";
    case wa:
        return "Portal";
    case Aa:
        return "Profiler";
    case za:
        return "StrictMode";
    case Ea:
        return "Suspense";
    case Fa:
        return "SuspenseList"
    }
    if (typeof _e == "object")
        switch (_e.$$typeof) {
        case Ca:
            return (_e.displayName || "Context") + ".Consumer";
        case Ba:
            return (_e._context.displayName || "Context") + ".Provider";
        case Da:
            var et = _e.render;
            return _e = _e.displayName,
            _e || (_e = et.displayName || et.name || "",
            _e = _e !== "" ? "ForwardRef(" + _e + ")" : "ForwardRef"),
            _e;
        case Ga:
            return et = _e.displayName || null,
            et !== null ? et : Qa(_e.type) || "Memo";
        case Ha:
            et = _e._payload,
            _e = _e._init;
            try {
                return Qa(_e(et))
            } catch {}
        }
    return null
}
function Ra(_e) {
    var et = _e.type;
    switch (_e.tag) {
    case 24:
        return "Cache";
    case 9:
        return (et.displayName || "Context") + ".Consumer";
    case 10:
        return (et._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return _e = et.render,
        _e = _e.displayName || _e.name || "",
        et.displayName || (_e !== "" ? "ForwardRef(" + _e + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return et;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qa(et);
    case 8:
        return et === za ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof et == "function")
            return et.displayName || et.name || null;
        if (typeof et == "string")
            return et
    }
    return null
}
function Sa(_e) {
    switch (typeof _e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return _e;
    case "object":
        return _e;
    default:
        return ""
    }
}
function Ta(_e) {
    var et = _e.type;
    return (_e = _e.nodeName) && _e.toLowerCase() === "input" && (et === "checkbox" || et === "radio")
}
function Ua(_e) {
    var et = Ta(_e) ? "checked" : "value"
      , tt = Object.getOwnPropertyDescriptor(_e.constructor.prototype, et)
      , rt = "" + _e[et];
    if (!_e.hasOwnProperty(et) && typeof tt < "u" && typeof tt.get == "function" && typeof tt.set == "function") {
        var nt = tt.get
          , it = tt.set;
        return Object.defineProperty(_e, et, {
            configurable: !0,
            get: function() {
                return nt.call(this)
            },
            set: function(st) {
                rt = "" + st,
                it.call(this, st)
            }
        }),
        Object.defineProperty(_e, et, {
            enumerable: tt.enumerable
        }),
        {
            getValue: function() {
                return rt
            },
            setValue: function(st) {
                rt = "" + st
            },
            stopTracking: function() {
                _e._valueTracker = null,
                delete _e[et]
            }
        }
    }
}
function Va(_e) {
    _e._valueTracker || (_e._valueTracker = Ua(_e))
}
function Wa(_e) {
    if (!_e)
        return !1;
    var et = _e._valueTracker;
    if (!et)
        return !0;
    var tt = et.getValue()
      , rt = "";
    return _e && (rt = Ta(_e) ? _e.checked ? "true" : "false" : _e.value),
    _e = rt,
    _e !== tt ? (et.setValue(_e),
    !0) : !1
}
function Xa(_e) {
    if (_e = _e || (typeof document < "u" ? document : void 0),
    typeof _e > "u")
        return null;
    try {
        return _e.activeElement || _e.body
    } catch {
        return _e.body
    }
}
function Ya(_e, et) {
    var tt = et.checked;
    return A$3({}, et, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: tt ?? _e._wrapperState.initialChecked
    })
}
function Za(_e, et) {
    var tt = et.defaultValue == null ? "" : et.defaultValue
      , rt = et.checked != null ? et.checked : et.defaultChecked;
    tt = Sa(et.value != null ? et.value : tt),
    _e._wrapperState = {
        initialChecked: rt,
        initialValue: tt,
        controlled: et.type === "checkbox" || et.type === "radio" ? et.checked != null : et.value != null
    }
}
function ab(_e, et) {
    et = et.checked,
    et != null && ta(_e, "checked", et, !1)
}
function bb(_e, et) {
    ab(_e, et);
    var tt = Sa(et.value)
      , rt = et.type;
    if (tt != null)
        rt === "number" ? (tt === 0 && _e.value === "" || _e.value != tt) && (_e.value = "" + tt) : _e.value !== "" + tt && (_e.value = "" + tt);
    else if (rt === "submit" || rt === "reset") {
        _e.removeAttribute("value");
        return
    }
    et.hasOwnProperty("value") ? cb(_e, et.type, tt) : et.hasOwnProperty("defaultValue") && cb(_e, et.type, Sa(et.defaultValue)),
    et.checked == null && et.defaultChecked != null && (_e.defaultChecked = !!et.defaultChecked)
}
function db(_e, et, tt) {
    if (et.hasOwnProperty("value") || et.hasOwnProperty("defaultValue")) {
        var rt = et.type;
        if (!(rt !== "submit" && rt !== "reset" || et.value !== void 0 && et.value !== null))
            return;
        et = "" + _e._wrapperState.initialValue,
        tt || et === _e.value || (_e.value = et),
        _e.defaultValue = et
    }
    tt = _e.name,
    tt !== "" && (_e.name = ""),
    _e.defaultChecked = !!_e._wrapperState.initialChecked,
    tt !== "" && (_e.name = tt)
}
function cb(_e, et, tt) {
    (et !== "number" || Xa(_e.ownerDocument) !== _e) && (tt == null ? _e.defaultValue = "" + _e._wrapperState.initialValue : _e.defaultValue !== "" + tt && (_e.defaultValue = "" + tt))
}
var eb = Array.isArray;
function fb(_e, et, tt, rt) {
    if (_e = _e.options,
    et) {
        et = {};
        for (var nt = 0; nt < tt.length; nt++)
            et["$" + tt[nt]] = !0;
        for (tt = 0; tt < _e.length; tt++)
            nt = et.hasOwnProperty("$" + _e[tt].value),
            _e[tt].selected !== nt && (_e[tt].selected = nt),
            nt && rt && (_e[tt].defaultSelected = !0)
    } else {
        for (tt = "" + Sa(tt),
        et = null,
        nt = 0; nt < _e.length; nt++) {
            if (_e[nt].value === tt) {
                _e[nt].selected = !0,
                rt && (_e[nt].defaultSelected = !0);
                return
            }
            et !== null || _e[nt].disabled || (et = _e[nt])
        }
        et !== null && (et.selected = !0)
    }
}
function gb(_e, et) {
    if (et.dangerouslySetInnerHTML != null)
        throw Error(p$8(91));
    return A$3({}, et, {
        value: void 0,
        defaultValue: void 0,
        children: "" + _e._wrapperState.initialValue
    })
}
function hb(_e, et) {
    var tt = et.value;
    if (tt == null) {
        if (tt = et.children,
        et = et.defaultValue,
        tt != null) {
            if (et != null)
                throw Error(p$8(92));
            if (eb(tt)) {
                if (1 < tt.length)
                    throw Error(p$8(93));
                tt = tt[0]
            }
            et = tt
        }
        et == null && (et = ""),
        tt = et
    }
    _e._wrapperState = {
        initialValue: Sa(tt)
    }
}
function ib(_e, et) {
    var tt = Sa(et.value)
      , rt = Sa(et.defaultValue);
    tt != null && (tt = "" + tt,
    tt !== _e.value && (_e.value = tt),
    et.defaultValue == null && _e.defaultValue !== tt && (_e.defaultValue = tt)),
    rt != null && (_e.defaultValue = "" + rt)
}
function jb(_e) {
    var et = _e.textContent;
    et === _e._wrapperState.initialValue && et !== "" && et !== null && (_e.value = et)
}
function kb(_e) {
    switch (_e) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function lb(_e, et) {
    return _e == null || _e === "http://www.w3.org/1999/xhtml" ? kb(et) : _e === "http://www.w3.org/2000/svg" && et === "foreignObject" ? "http://www.w3.org/1999/xhtml" : _e
}
var mb, nb = function(_e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(et, tt, rt, nt) {
        MSApp.execUnsafeLocalFunction(function() {
            return _e(et, tt, rt, nt)
        })
    }
    : _e
}(function(_e, et) {
    if (_e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in _e)
        _e.innerHTML = et;
    else {
        for (mb = mb || document.createElement("div"),
        mb.innerHTML = "<svg>" + et.valueOf().toString() + "</svg>",
        et = mb.firstChild; _e.firstChild; )
            _e.removeChild(_e.firstChild);
        for (; et.firstChild; )
            _e.appendChild(et.firstChild)
    }
});
function ob(_e, et) {
    if (et) {
        var tt = _e.firstChild;
        if (tt && tt === _e.lastChild && tt.nodeType === 3) {
            tt.nodeValue = et;
            return
        }
    }
    _e.textContent = et
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(_e) {
    qb.forEach(function(et) {
        et = et + _e.charAt(0).toUpperCase() + _e.substring(1),
        pb[et] = pb[_e]
    })
});
function rb(_e, et, tt) {
    return et == null || typeof et == "boolean" || et === "" ? "" : tt || typeof et != "number" || et === 0 || pb.hasOwnProperty(_e) && pb[_e] ? ("" + et).trim() : et + "px"
}
function sb(_e, et) {
    _e = _e.style;
    for (var tt in et)
        if (et.hasOwnProperty(tt)) {
            var rt = tt.indexOf("--") === 0
              , nt = rb(tt, et[tt], rt);
            tt === "float" && (tt = "cssFloat"),
            rt ? _e.setProperty(tt, nt) : _e[tt] = nt
        }
}
var tb = A$3({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ub(_e, et) {
    if (et) {
        if (tb[_e] && (et.children != null || et.dangerouslySetInnerHTML != null))
            throw Error(p$8(137, _e));
        if (et.dangerouslySetInnerHTML != null) {
            if (et.children != null)
                throw Error(p$8(60));
            if (typeof et.dangerouslySetInnerHTML != "object" || !("__html"in et.dangerouslySetInnerHTML))
                throw Error(p$8(61))
        }
        if (et.style != null && typeof et.style != "object")
            throw Error(p$8(62))
    }
}
function vb(_e, et) {
    if (_e.indexOf("-") === -1)
        return typeof et.is == "string";
    switch (_e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var wb = null;
function xb(_e) {
    return _e = _e.target || _e.srcElement || window,
    _e.correspondingUseElement && (_e = _e.correspondingUseElement),
    _e.nodeType === 3 ? _e.parentNode : _e
}
var yb = null
  , zb = null
  , Ab = null;
function Bb(_e) {
    if (_e = Cb(_e)) {
        if (typeof yb != "function")
            throw Error(p$8(280));
        var et = _e.stateNode;
        et && (et = Db(et),
        yb(_e.stateNode, _e.type, et))
    }
}
function Eb(_e) {
    zb ? Ab ? Ab.push(_e) : Ab = [_e] : zb = _e
}
function Fb() {
    if (zb) {
        var _e = zb
          , et = Ab;
        if (Ab = zb = null,
        Bb(_e),
        et)
            for (_e = 0; _e < et.length; _e++)
                Bb(et[_e])
    }
}
function Gb(_e, et) {
    return _e(et)
}
function Hb() {}
var Ib = !1;
function Jb(_e, et, tt) {
    if (Ib)
        return _e(et, tt);
    Ib = !0;
    try {
        return Gb(_e, et, tt)
    } finally {
        Ib = !1,
        (zb !== null || Ab !== null) && (Hb(),
        Fb())
    }
}
function Kb(_e, et) {
    var tt = _e.stateNode;
    if (tt === null)
        return null;
    var rt = Db(tt);
    if (rt === null)
        return null;
    tt = rt[et];
    e: switch (et) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (rt = !rt.disabled) || (_e = _e.type,
        rt = !(_e === "button" || _e === "input" || _e === "select" || _e === "textarea")),
        _e = !rt;
        break e;
    default:
        _e = !1
    }
    if (_e)
        return null;
    if (tt && typeof tt != "function")
        throw Error(p$8(231, et, typeof tt));
    return tt
}
var Lb = !1;
if (ia)
    try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }),
        window.addEventListener("test", Mb, Mb),
        window.removeEventListener("test", Mb, Mb)
    } catch {
        Lb = !1
    }
function Nb(_e, et, tt, rt, nt, it, st, at, ot) {
    var lt = Array.prototype.slice.call(arguments, 3);
    try {
        et.apply(tt, lt)
    } catch (dt) {
        this.onError(dt)
    }
}
var Ob = !1
  , Pb = null
  , Qb = !1
  , Rb = null
  , Sb = {
    onError: function(_e) {
        Ob = !0,
        Pb = _e
    }
};
function Tb(_e, et, tt, rt, nt, it, st, at, ot) {
    Ob = !1,
    Pb = null,
    Nb.apply(Sb, arguments)
}
function Ub(_e, et, tt, rt, nt, it, st, at, ot) {
    if (Tb.apply(this, arguments),
    Ob) {
        if (Ob) {
            var lt = Pb;
            Ob = !1,
            Pb = null
        } else
            throw Error(p$8(198));
        Qb || (Qb = !0,
        Rb = lt)
    }
}
function Vb(_e) {
    var et = _e
      , tt = _e;
    if (_e.alternate)
        for (; et.return; )
            et = et.return;
    else {
        _e = et;
        do
            et = _e,
            et.flags & 4098 && (tt = et.return),
            _e = et.return;
        while (_e)
    }
    return et.tag === 3 ? tt : null
}
function Wb(_e) {
    if (_e.tag === 13) {
        var et = _e.memoizedState;
        if (et === null && (_e = _e.alternate,
        _e !== null && (et = _e.memoizedState)),
        et !== null)
            return et.dehydrated
    }
    return null
}
function Xb(_e) {
    if (Vb(_e) !== _e)
        throw Error(p$8(188))
}
function Yb(_e) {
    var et = _e.alternate;
    if (!et) {
        if (et = Vb(_e),
        et === null)
            throw Error(p$8(188));
        return et !== _e ? null : _e
    }
    for (var tt = _e, rt = et; ; ) {
        var nt = tt.return;
        if (nt === null)
            break;
        var it = nt.alternate;
        if (it === null) {
            if (rt = nt.return,
            rt !== null) {
                tt = rt;
                continue
            }
            break
        }
        if (nt.child === it.child) {
            for (it = nt.child; it; ) {
                if (it === tt)
                    return Xb(nt),
                    _e;
                if (it === rt)
                    return Xb(nt),
                    et;
                it = it.sibling
            }
            throw Error(p$8(188))
        }
        if (tt.return !== rt.return)
            tt = nt,
            rt = it;
        else {
            for (var st = !1, at = nt.child; at; ) {
                if (at === tt) {
                    st = !0,
                    tt = nt,
                    rt = it;
                    break
                }
                if (at === rt) {
                    st = !0,
                    rt = nt,
                    tt = it;
                    break
                }
                at = at.sibling
            }
            if (!st) {
                for (at = it.child; at; ) {
                    if (at === tt) {
                        st = !0,
                        tt = it,
                        rt = nt;
                        break
                    }
                    if (at === rt) {
                        st = !0,
                        rt = it,
                        tt = nt;
                        break
                    }
                    at = at.sibling
                }
                if (!st)
                    throw Error(p$8(189))
            }
        }
        if (tt.alternate !== rt)
            throw Error(p$8(190))
    }
    if (tt.tag !== 3)
        throw Error(p$8(188));
    return tt.stateNode.current === tt ? _e : et
}
function Zb(_e) {
    return _e = Yb(_e),
    _e !== null ? $b(_e) : null
}
function $b(_e) {
    if (_e.tag === 5 || _e.tag === 6)
        return _e;
    for (_e = _e.child; _e !== null; ) {
        var et = $b(_e);
        if (et !== null)
            return et;
        _e = _e.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback
  , bc = ca.unstable_cancelCallback
  , cc = ca.unstable_shouldYield
  , dc = ca.unstable_requestPaint
  , B$1 = ca.unstable_now
  , ec = ca.unstable_getCurrentPriorityLevel
  , fc = ca.unstable_ImmediatePriority
  , gc = ca.unstable_UserBlockingPriority
  , hc = ca.unstable_NormalPriority
  , ic = ca.unstable_LowPriority
  , jc = ca.unstable_IdlePriority
  , kc = null
  , lc = null;
function mc(_e) {
    if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
            lc.onCommitFiberRoot(kc, _e, void 0, (_e.current.flags & 128) === 128)
        } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc
  , pc = Math.log
  , qc = Math.LN2;
function nc(_e) {
    return _e >>>= 0,
    _e === 0 ? 32 : 31 - (pc(_e) / qc | 0) | 0
}
var rc = 64
  , sc = 4194304;
function tc(_e) {
    switch (_e & -_e) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return _e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return _e & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return _e
    }
}
function uc(_e, et) {
    var tt = _e.pendingLanes;
    if (tt === 0)
        return 0;
    var rt = 0
      , nt = _e.suspendedLanes
      , it = _e.pingedLanes
      , st = tt & 268435455;
    if (st !== 0) {
        var at = st & ~nt;
        at !== 0 ? rt = tc(at) : (it &= st,
        it !== 0 && (rt = tc(it)))
    } else
        st = tt & ~nt,
        st !== 0 ? rt = tc(st) : it !== 0 && (rt = tc(it));
    if (rt === 0)
        return 0;
    if (et !== 0 && et !== rt && !(et & nt) && (nt = rt & -rt,
    it = et & -et,
    nt >= it || nt === 16 && (it & 4194240) !== 0))
        return et;
    if (rt & 4 && (rt |= tt & 16),
    et = _e.entangledLanes,
    et !== 0)
        for (_e = _e.entanglements,
        et &= rt; 0 < et; )
            tt = 31 - oc(et),
            nt = 1 << tt,
            rt |= _e[tt],
            et &= ~nt;
    return rt
}
function vc(_e, et) {
    switch (_e) {
    case 1:
    case 2:
    case 4:
        return et + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return et + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wc(_e, et) {
    for (var tt = _e.suspendedLanes, rt = _e.pingedLanes, nt = _e.expirationTimes, it = _e.pendingLanes; 0 < it; ) {
        var st = 31 - oc(it)
          , at = 1 << st
          , ot = nt[st];
        ot === -1 ? (!(at & tt) || at & rt) && (nt[st] = vc(at, et)) : ot <= et && (_e.expiredLanes |= at),
        it &= ~at
    }
}
function xc(_e) {
    return _e = _e.pendingLanes & -1073741825,
    _e !== 0 ? _e : _e & 1073741824 ? 1073741824 : 0
}
function yc() {
    var _e = rc;
    return rc <<= 1,
    !(rc & 4194240) && (rc = 64),
    _e
}
function zc(_e) {
    for (var et = [], tt = 0; 31 > tt; tt++)
        et.push(_e);
    return et
}
function Ac(_e, et, tt) {
    _e.pendingLanes |= et,
    et !== 536870912 && (_e.suspendedLanes = 0,
    _e.pingedLanes = 0),
    _e = _e.eventTimes,
    et = 31 - oc(et),
    _e[et] = tt
}
function Bc(_e, et) {
    var tt = _e.pendingLanes & ~et;
    _e.pendingLanes = et,
    _e.suspendedLanes = 0,
    _e.pingedLanes = 0,
    _e.expiredLanes &= et,
    _e.mutableReadLanes &= et,
    _e.entangledLanes &= et,
    et = _e.entanglements;
    var rt = _e.eventTimes;
    for (_e = _e.expirationTimes; 0 < tt; ) {
        var nt = 31 - oc(tt)
          , it = 1 << nt;
        et[nt] = 0,
        rt[nt] = -1,
        _e[nt] = -1,
        tt &= ~it
    }
}
function Cc(_e, et) {
    var tt = _e.entangledLanes |= et;
    for (_e = _e.entanglements; tt; ) {
        var rt = 31 - oc(tt)
          , nt = 1 << rt;
        nt & et | _e[rt] & et && (_e[rt] |= et),
        tt &= ~nt
    }
}
var C$3 = 0;
function Dc(_e) {
    return _e &= -_e,
    1 < _e ? 4 < _e ? _e & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(_e, et) {
    switch (_e) {
    case "focusin":
    case "focusout":
        Lc = null;
        break;
    case "dragenter":
    case "dragleave":
        Mc = null;
        break;
    case "mouseover":
    case "mouseout":
        Nc = null;
        break;
    case "pointerover":
    case "pointerout":
        Oc.delete(et.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pc.delete(et.pointerId)
    }
}
function Tc(_e, et, tt, rt, nt, it) {
    return _e === null || _e.nativeEvent !== it ? (_e = {
        blockedOn: et,
        domEventName: tt,
        eventSystemFlags: rt,
        nativeEvent: it,
        targetContainers: [nt]
    },
    et !== null && (et = Cb(et),
    et !== null && Fc(et)),
    _e) : (_e.eventSystemFlags |= rt,
    et = _e.targetContainers,
    nt !== null && et.indexOf(nt) === -1 && et.push(nt),
    _e)
}
function Uc(_e, et, tt, rt, nt) {
    switch (et) {
    case "focusin":
        return Lc = Tc(Lc, _e, et, tt, rt, nt),
        !0;
    case "dragenter":
        return Mc = Tc(Mc, _e, et, tt, rt, nt),
        !0;
    case "mouseover":
        return Nc = Tc(Nc, _e, et, tt, rt, nt),
        !0;
    case "pointerover":
        var it = nt.pointerId;
        return Oc.set(it, Tc(Oc.get(it) || null, _e, et, tt, rt, nt)),
        !0;
    case "gotpointercapture":
        return it = nt.pointerId,
        Pc.set(it, Tc(Pc.get(it) || null, _e, et, tt, rt, nt)),
        !0
    }
    return !1
}
function Vc(_e) {
    var et = Wc(_e.target);
    if (et !== null) {
        var tt = Vb(et);
        if (tt !== null) {
            if (et = tt.tag,
            et === 13) {
                if (et = Wb(tt),
                et !== null) {
                    _e.blockedOn = et,
                    Ic(_e.priority, function() {
                        Gc(tt)
                    });
                    return
                }
            } else if (et === 3 && tt.stateNode.current.memoizedState.isDehydrated) {
                _e.blockedOn = tt.tag === 3 ? tt.stateNode.containerInfo : null;
                return
            }
        }
    }
    _e.blockedOn = null
}
function Xc(_e) {
    if (_e.blockedOn !== null)
        return !1;
    for (var et = _e.targetContainers; 0 < et.length; ) {
        var tt = Yc(_e.domEventName, _e.eventSystemFlags, et[0], _e.nativeEvent);
        if (tt === null) {
            tt = _e.nativeEvent;
            var rt = new tt.constructor(tt.type,tt);
            wb = rt,
            tt.target.dispatchEvent(rt),
            wb = null
        } else
            return et = Cb(tt),
            et !== null && Fc(et),
            _e.blockedOn = tt,
            !1;
        et.shift()
    }
    return !0
}
function Zc(_e, et, tt) {
    Xc(_e) && tt.delete(et)
}
function $c() {
    Jc = !1,
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(_e, et) {
    _e.blockedOn === et && (_e.blockedOn = null,
    Jc || (Jc = !0,
    ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(_e) {
    function et(nt) {
        return ad(nt, _e)
    }
    if (0 < Kc.length) {
        ad(Kc[0], _e);
        for (var tt = 1; tt < Kc.length; tt++) {
            var rt = Kc[tt];
            rt.blockedOn === _e && (rt.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, _e),
    Mc !== null && ad(Mc, _e),
    Nc !== null && ad(Nc, _e),
    Oc.forEach(et),
    Pc.forEach(et),
    tt = 0; tt < Qc.length; tt++)
        rt = Qc[tt],
        rt.blockedOn === _e && (rt.blockedOn = null);
    for (; 0 < Qc.length && (tt = Qc[0],
    tt.blockedOn === null); )
        Vc(tt),
        tt.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig
  , dd = !0;
function ed(_e, et, tt, rt) {
    var nt = C$3
      , it = cd.transition;
    cd.transition = null;
    try {
        C$3 = 1,
        fd(_e, et, tt, rt)
    } finally {
        C$3 = nt,
        cd.transition = it
    }
}
function gd(_e, et, tt, rt) {
    var nt = C$3
      , it = cd.transition;
    cd.transition = null;
    try {
        C$3 = 4,
        fd(_e, et, tt, rt)
    } finally {
        C$3 = nt,
        cd.transition = it
    }
}
function fd(_e, et, tt, rt) {
    if (dd) {
        var nt = Yc(_e, et, tt, rt);
        if (nt === null)
            hd(_e, et, rt, id, tt),
            Sc(_e, rt);
        else if (Uc(nt, _e, et, tt, rt))
            rt.stopPropagation();
        else if (Sc(_e, rt),
        et & 4 && -1 < Rc.indexOf(_e)) {
            for (; nt !== null; ) {
                var it = Cb(nt);
                if (it !== null && Ec(it),
                it = Yc(_e, et, tt, rt),
                it === null && hd(_e, et, rt, id, tt),
                it === nt)
                    break;
                nt = it
            }
            nt !== null && rt.stopPropagation()
        } else
            hd(_e, et, rt, null, tt)
    }
}
var id = null;
function Yc(_e, et, tt, rt) {
    if (id = null,
    _e = xb(rt),
    _e = Wc(_e),
    _e !== null)
        if (et = Vb(_e),
        et === null)
            _e = null;
        else if (tt = et.tag,
        tt === 13) {
            if (_e = Wb(et),
            _e !== null)
                return _e;
            _e = null
        } else if (tt === 3) {
            if (et.stateNode.current.memoizedState.isDehydrated)
                return et.tag === 3 ? et.stateNode.containerInfo : null;
            _e = null
        } else
            et !== _e && (_e = null);
    return id = _e,
    null
}
function jd(_e) {
    switch (_e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ec()) {
        case fc:
            return 1;
        case gc:
            return 4;
        case hc:
        case ic:
            return 16;
        case jc:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var kd = null
  , ld = null
  , md = null;
function nd() {
    if (md)
        return md;
    var _e, et = ld, tt = et.length, rt, nt = "value"in kd ? kd.value : kd.textContent, it = nt.length;
    for (_e = 0; _e < tt && et[_e] === nt[_e]; _e++)
        ;
    var st = tt - _e;
    for (rt = 1; rt <= st && et[tt - rt] === nt[it - rt]; rt++)
        ;
    return md = nt.slice(_e, 1 < rt ? 1 - rt : void 0)
}
function od(_e) {
    var et = _e.keyCode;
    return "charCode"in _e ? (_e = _e.charCode,
    _e === 0 && et === 13 && (_e = 13)) : _e = et,
    _e === 10 && (_e = 13),
    32 <= _e || _e === 13 ? _e : 0
}
function pd() {
    return !0
}
function qd() {
    return !1
}
function rd(_e) {
    function et(tt, rt, nt, it, st) {
        this._reactName = tt,
        this._targetInst = nt,
        this.type = rt,
        this.nativeEvent = it,
        this.target = st,
        this.currentTarget = null;
        for (var at in _e)
            _e.hasOwnProperty(at) && (tt = _e[at],
            this[at] = tt ? tt(it) : it[at]);
        return this.isDefaultPrevented = (it.defaultPrevented != null ? it.defaultPrevented : it.returnValue === !1) ? pd : qd,
        this.isPropagationStopped = qd,
        this
    }
    return A$3(et.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var tt = this.nativeEvent;
            tt && (tt.preventDefault ? tt.preventDefault() : typeof tt.returnValue != "unknown" && (tt.returnValue = !1),
            this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var tt = this.nativeEvent;
            tt && (tt.stopPropagation ? tt.stopPropagation() : typeof tt.cancelBubble != "unknown" && (tt.cancelBubble = !0),
            this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }),
    et
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(_e) {
        return _e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, td = rd(sd), ud = A$3({}, sd, {
    view: 0,
    detail: 0
}), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(_e) {
        return _e.relatedTarget === void 0 ? _e.fromElement === _e.srcElement ? _e.toElement : _e.fromElement : _e.relatedTarget
    },
    movementX: function(_e) {
        return "movementX"in _e ? _e.movementX : (_e !== yd && (yd && _e.type === "mousemove" ? (wd = _e.screenX - yd.screenX,
        xd = _e.screenY - yd.screenY) : xd = wd = 0,
        yd = _e),
        wd)
    },
    movementY: function(_e) {
        return "movementY"in _e ? _e.movementY : xd
    }
}), Bd = rd(Ad), Cd = A$3({}, Ad, {
    dataTransfer: 0
}), Dd = rd(Cd), Ed = A$3({}, ud, {
    relatedTarget: 0
}), Fd = rd(Ed), Gd = A$3({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hd = rd(Gd), Id = A$3({}, sd, {
    clipboardData: function(_e) {
        return "clipboardData"in _e ? _e.clipboardData : window.clipboardData
    }
}), Jd = rd(Id), Kd = A$3({}, sd, {
    data: 0
}), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Pd(_e) {
    var et = this.nativeEvent;
    return et.getModifierState ? et.getModifierState(_e) : (_e = Od[_e]) ? !!et[_e] : !1
}
function zd() {
    return Pd
}
var Qd = A$3({}, ud, {
    key: function(_e) {
        if (_e.key) {
            var et = Md[_e.key] || _e.key;
            if (et !== "Unidentified")
                return et
        }
        return _e.type === "keypress" ? (_e = od(_e),
        _e === 13 ? "Enter" : String.fromCharCode(_e)) : _e.type === "keydown" || _e.type === "keyup" ? Nd[_e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(_e) {
        return _e.type === "keypress" ? od(_e) : 0
    },
    keyCode: function(_e) {
        return _e.type === "keydown" || _e.type === "keyup" ? _e.keyCode : 0
    },
    which: function(_e) {
        return _e.type === "keypress" ? od(_e) : _e.type === "keydown" || _e.type === "keyup" ? _e.keyCode : 0
    }
})
  , Rd = rd(Qd)
  , Sd = A$3({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Td = rd(Sd)
  , Ud = A$3({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
})
  , Vd = rd(Ud)
  , Wd = A$3({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Xd = rd(Wd)
  , Yd = A$3({}, Ad, {
    deltaX: function(_e) {
        return "deltaX"in _e ? _e.deltaX : "wheelDeltaX"in _e ? -_e.wheelDeltaX : 0
    },
    deltaY: function(_e) {
        return "deltaY"in _e ? _e.deltaY : "wheelDeltaY"in _e ? -_e.wheelDeltaY : "wheelDelta"in _e ? -_e.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Zd = rd(Yd)
  , $d = [9, 13, 27, 32]
  , ae = ia && "CompositionEvent"in window
  , be = null;
ia && "documentMode"in document && (be = document.documentMode);
var ce = ia && "TextEvent"in window && !be
  , de = ia && (!ae || be && 8 < be && 11 >= be)
  , ee = " "
  , fe = !1;
function ge(_e, et) {
    switch (_e) {
    case "keyup":
        return $d.indexOf(et.keyCode) !== -1;
    case "keydown":
        return et.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function he(_e) {
    return _e = _e.detail,
    typeof _e == "object" && "data"in _e ? _e.data : null
}
var ie = !1;
function je(_e, et) {
    switch (_e) {
    case "compositionend":
        return he(et);
    case "keypress":
        return et.which !== 32 ? null : (fe = !0,
        ee);
    case "textInput":
        return _e = et.data,
        _e === ee && fe ? null : _e;
    default:
        return null
    }
}
function ke(_e, et) {
    if (ie)
        return _e === "compositionend" || !ae && ge(_e, et) ? (_e = nd(),
        md = ld = kd = null,
        ie = !1,
        _e) : null;
    switch (_e) {
    case "paste":
        return null;
    case "keypress":
        if (!(et.ctrlKey || et.altKey || et.metaKey) || et.ctrlKey && et.altKey) {
            if (et.char && 1 < et.char.length)
                return et.char;
            if (et.which)
                return String.fromCharCode(et.which)
        }
        return null;
    case "compositionend":
        return de && et.locale !== "ko" ? null : et.data;
    default:
        return null
    }
}
var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function me(_e) {
    var et = _e && _e.nodeName && _e.nodeName.toLowerCase();
    return et === "input" ? !!le[_e.type] : et === "textarea"
}
function ne(_e, et, tt, rt) {
    Eb(rt),
    et = oe(et, "onChange"),
    0 < et.length && (tt = new td("onChange","change",null,tt,rt),
    _e.push({
        event: tt,
        listeners: et
    }))
}
var pe = null
  , qe = null;
function re(_e) {
    se(_e, 0)
}
function te(_e) {
    var et = ue(_e);
    if (Wa(et))
        return _e
}
function ve(_e, et) {
    if (_e === "change")
        return et
}
var we = !1;
if (ia) {
    var xe;
    if (ia) {
        var ye = "oninput"in document;
        if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;"),
            ye = typeof ze.oninput == "function"
        }
        xe = ye
    } else
        xe = !1;
    we = xe && (!document.documentMode || 9 < document.documentMode)
}
function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be),
    qe = pe = null)
}
function Be(_e) {
    if (_e.propertyName === "value" && te(qe)) {
        var et = [];
        ne(et, qe, _e, xb(_e)),
        Jb(re, et)
    }
}
function Ce(_e, et, tt) {
    _e === "focusin" ? (Ae(),
    pe = et,
    qe = tt,
    pe.attachEvent("onpropertychange", Be)) : _e === "focusout" && Ae()
}
function De(_e) {
    if (_e === "selectionchange" || _e === "keyup" || _e === "keydown")
        return te(qe)
}
function Ee(_e, et) {
    if (_e === "click")
        return te(et)
}
function Fe(_e, et) {
    if (_e === "input" || _e === "change")
        return te(et)
}
function Ge(_e, et) {
    return _e === et && (_e !== 0 || 1 / _e === 1 / et) || _e !== _e && et !== et
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(_e, et) {
    if (He(_e, et))
        return !0;
    if (typeof _e != "object" || _e === null || typeof et != "object" || et === null)
        return !1;
    var tt = Object.keys(_e)
      , rt = Object.keys(et);
    if (tt.length !== rt.length)
        return !1;
    for (rt = 0; rt < tt.length; rt++) {
        var nt = tt[rt];
        if (!ja.call(et, nt) || !He(_e[nt], et[nt]))
            return !1
    }
    return !0
}
function Je(_e) {
    for (; _e && _e.firstChild; )
        _e = _e.firstChild;
    return _e
}
function Ke(_e, et) {
    var tt = Je(_e);
    _e = 0;
    for (var rt; tt; ) {
        if (tt.nodeType === 3) {
            if (rt = _e + tt.textContent.length,
            _e <= et && rt >= et)
                return {
                    node: tt,
                    offset: et - _e
                };
            _e = rt
        }
        e: {
            for (; tt; ) {
                if (tt.nextSibling) {
                    tt = tt.nextSibling;
                    break e
                }
                tt = tt.parentNode
            }
            tt = void 0
        }
        tt = Je(tt)
    }
}
function Le(_e, et) {
    return _e && et ? _e === et ? !0 : _e && _e.nodeType === 3 ? !1 : et && et.nodeType === 3 ? Le(_e, et.parentNode) : "contains"in _e ? _e.contains(et) : _e.compareDocumentPosition ? !!(_e.compareDocumentPosition(et) & 16) : !1 : !1
}
function Me() {
    for (var _e = window, et = Xa(); et instanceof _e.HTMLIFrameElement; ) {
        try {
            var tt = typeof et.contentWindow.location.href == "string"
        } catch {
            tt = !1
        }
        if (tt)
            _e = et.contentWindow;
        else
            break;
        et = Xa(_e.document)
    }
    return et
}
function Ne(_e) {
    var et = _e && _e.nodeName && _e.nodeName.toLowerCase();
    return et && (et === "input" && (_e.type === "text" || _e.type === "search" || _e.type === "tel" || _e.type === "url" || _e.type === "password") || et === "textarea" || _e.contentEditable === "true")
}
function Oe(_e) {
    var et = Me()
      , tt = _e.focusedElem
      , rt = _e.selectionRange;
    if (et !== tt && tt && tt.ownerDocument && Le(tt.ownerDocument.documentElement, tt)) {
        if (rt !== null && Ne(tt)) {
            if (et = rt.start,
            _e = rt.end,
            _e === void 0 && (_e = et),
            "selectionStart"in tt)
                tt.selectionStart = et,
                tt.selectionEnd = Math.min(_e, tt.value.length);
            else if (_e = (et = tt.ownerDocument || document) && et.defaultView || window,
            _e.getSelection) {
                _e = _e.getSelection();
                var nt = tt.textContent.length
                  , it = Math.min(rt.start, nt);
                rt = rt.end === void 0 ? it : Math.min(rt.end, nt),
                !_e.extend && it > rt && (nt = rt,
                rt = it,
                it = nt),
                nt = Ke(tt, it);
                var st = Ke(tt, rt);
                nt && st && (_e.rangeCount !== 1 || _e.anchorNode !== nt.node || _e.anchorOffset !== nt.offset || _e.focusNode !== st.node || _e.focusOffset !== st.offset) && (et = et.createRange(),
                et.setStart(nt.node, nt.offset),
                _e.removeAllRanges(),
                it > rt ? (_e.addRange(et),
                _e.extend(st.node, st.offset)) : (et.setEnd(st.node, st.offset),
                _e.addRange(et)))
            }
        }
        for (et = [],
        _e = tt; _e = _e.parentNode; )
            _e.nodeType === 1 && et.push({
                element: _e,
                left: _e.scrollLeft,
                top: _e.scrollTop
            });
        for (typeof tt.focus == "function" && tt.focus(),
        tt = 0; tt < et.length; tt++)
            _e = et[tt],
            _e.element.scrollLeft = _e.left,
            _e.element.scrollTop = _e.top
    }
}
var Pe = ia && "documentMode"in document && 11 >= document.documentMode
  , Qe = null
  , Re = null
  , Se = null
  , Te = !1;
function Ue(_e, et, tt) {
    var rt = tt.window === tt ? tt.document : tt.nodeType === 9 ? tt : tt.ownerDocument;
    Te || Qe == null || Qe !== Xa(rt) || (rt = Qe,
    "selectionStart"in rt && Ne(rt) ? rt = {
        start: rt.selectionStart,
        end: rt.selectionEnd
    } : (rt = (rt.ownerDocument && rt.ownerDocument.defaultView || window).getSelection(),
    rt = {
        anchorNode: rt.anchorNode,
        anchorOffset: rt.anchorOffset,
        focusNode: rt.focusNode,
        focusOffset: rt.focusOffset
    }),
    Se && Ie(Se, rt) || (Se = rt,
    rt = oe(Re, "onSelect"),
    0 < rt.length && (et = new td("onSelect","select",null,et,tt),
    _e.push({
        event: et,
        listeners: rt
    }),
    et.target = Qe)))
}
function Ve(_e, et) {
    var tt = {};
    return tt[_e.toLowerCase()] = et.toLowerCase(),
    tt["Webkit" + _e] = "webkit" + et,
    tt["Moz" + _e] = "moz" + et,
    tt
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
}
  , Xe = {}
  , Ye = {};
ia && (Ye = document.createElement("div").style,
"AnimationEvent"in window || (delete We.animationend.animation,
delete We.animationiteration.animation,
delete We.animationstart.animation),
"TransitionEvent"in window || delete We.transitionend.transition);
function Ze(_e) {
    if (Xe[_e])
        return Xe[_e];
    if (!We[_e])
        return _e;
    var et = We[_e], tt;
    for (tt in et)
        if (et.hasOwnProperty(tt) && tt in Ye)
            return Xe[_e] = et[tt];
    return _e
}
var $e = Ze("animationend")
  , af = Ze("animationiteration")
  , bf = Ze("animationstart")
  , cf = Ze("transitionend")
  , df = new Map
  , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(_e, et) {
    df.set(_e, et),
    fa(et, [_e])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf]
      , jf = hf.toLowerCase()
      , kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(_e, et, tt) {
    var rt = _e.type || "unknown-event";
    _e.currentTarget = tt,
    Ub(rt, et, void 0, _e),
    _e.currentTarget = null
}
function se(_e, et) {
    et = (et & 4) !== 0;
    for (var tt = 0; tt < _e.length; tt++) {
        var rt = _e[tt]
          , nt = rt.event;
        rt = rt.listeners;
        e: {
            var it = void 0;
            if (et)
                for (var st = rt.length - 1; 0 <= st; st--) {
                    var at = rt[st]
                      , ot = at.instance
                      , lt = at.currentTarget;
                    if (at = at.listener,
                    ot !== it && nt.isPropagationStopped())
                        break e;
                    nf(nt, at, lt),
                    it = ot
                }
            else
                for (st = 0; st < rt.length; st++) {
                    if (at = rt[st],
                    ot = at.instance,
                    lt = at.currentTarget,
                    at = at.listener,
                    ot !== it && nt.isPropagationStopped())
                        break e;
                    nf(nt, at, lt),
                    it = ot
                }
        }
    }
    if (Qb)
        throw _e = Rb,
        Qb = !1,
        Rb = null,
        _e
}
function D$1(_e, et) {
    var tt = et[of];
    tt === void 0 && (tt = et[of] = new Set);
    var rt = _e + "__bubble";
    tt.has(rt) || (pf(et, _e, 2, !1),
    tt.add(rt))
}
function qf(_e, et, tt) {
    var rt = 0;
    et && (rt |= 4),
    pf(tt, _e, rt, et)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(_e) {
    if (!_e[rf]) {
        _e[rf] = !0,
        da.forEach(function(tt) {
            tt !== "selectionchange" && (mf.has(tt) || qf(tt, !1, _e),
            qf(tt, !0, _e))
        });
        var et = _e.nodeType === 9 ? _e : _e.ownerDocument;
        et === null || et[rf] || (et[rf] = !0,
        qf("selectionchange", !1, et))
    }
}
function pf(_e, et, tt, rt) {
    switch (jd(et)) {
    case 1:
        var nt = ed;
        break;
    case 4:
        nt = gd;
        break;
    default:
        nt = fd
    }
    tt = nt.bind(null, et, tt, _e),
    nt = void 0,
    !Lb || et !== "touchstart" && et !== "touchmove" && et !== "wheel" || (nt = !0),
    rt ? nt !== void 0 ? _e.addEventListener(et, tt, {
        capture: !0,
        passive: nt
    }) : _e.addEventListener(et, tt, !0) : nt !== void 0 ? _e.addEventListener(et, tt, {
        passive: nt
    }) : _e.addEventListener(et, tt, !1)
}
function hd(_e, et, tt, rt, nt) {
    var it = rt;
    if (!(et & 1) && !(et & 2) && rt !== null)
        e: for (; ; ) {
            if (rt === null)
                return;
            var st = rt.tag;
            if (st === 3 || st === 4) {
                var at = rt.stateNode.containerInfo;
                if (at === nt || at.nodeType === 8 && at.parentNode === nt)
                    break;
                if (st === 4)
                    for (st = rt.return; st !== null; ) {
                        var ot = st.tag;
                        if ((ot === 3 || ot === 4) && (ot = st.stateNode.containerInfo,
                        ot === nt || ot.nodeType === 8 && ot.parentNode === nt))
                            return;
                        st = st.return
                    }
                for (; at !== null; ) {
                    if (st = Wc(at),
                    st === null)
                        return;
                    if (ot = st.tag,
                    ot === 5 || ot === 6) {
                        rt = it = st;
                        continue e
                    }
                    at = at.parentNode
                }
            }
            rt = rt.return
        }
    Jb(function() {
        var lt = it
          , dt = xb(tt)
          , ct = [];
        e: {
            var ut = df.get(_e);
            if (ut !== void 0) {
                var ft = td
                  , ht = _e;
                switch (_e) {
                case "keypress":
                    if (od(tt) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    ft = Rd;
                    break;
                case "focusin":
                    ht = "focus",
                    ft = Fd;
                    break;
                case "focusout":
                    ht = "blur",
                    ft = Fd;
                    break;
                case "beforeblur":
                case "afterblur":
                    ft = Fd;
                    break;
                case "click":
                    if (tt.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    ft = Bd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    ft = Dd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    ft = Vd;
                    break;
                case $e:
                case af:
                case bf:
                    ft = Hd;
                    break;
                case cf:
                    ft = Xd;
                    break;
                case "scroll":
                    ft = vd;
                    break;
                case "wheel":
                    ft = Zd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    ft = Jd;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    ft = Td
                }
                var gt = (et & 4) !== 0
                  , bt = !gt && _e === "scroll"
                  , pt = gt ? ut !== null ? ut + "Capture" : null : ut;
                gt = [];
                for (var mt = lt, yt; mt !== null; ) {
                    yt = mt;
                    var vt = yt.stateNode;
                    if (yt.tag === 5 && vt !== null && (yt = vt,
                    pt !== null && (vt = Kb(mt, pt),
                    vt != null && gt.push(tf(mt, vt, yt)))),
                    bt)
                        break;
                    mt = mt.return
                }
                0 < gt.length && (ut = new ft(ut,ht,null,tt,dt),
                ct.push({
                    event: ut,
                    listeners: gt
                }))
            }
        }
        if (!(et & 7)) {
            e: {
                if (ut = _e === "mouseover" || _e === "pointerover",
                ft = _e === "mouseout" || _e === "pointerout",
                ut && tt !== wb && (ht = tt.relatedTarget || tt.fromElement) && (Wc(ht) || ht[uf]))
                    break e;
                if ((ft || ut) && (ut = dt.window === dt ? dt : (ut = dt.ownerDocument) ? ut.defaultView || ut.parentWindow : window,
                ft ? (ht = tt.relatedTarget || tt.toElement,
                ft = lt,
                ht = ht ? Wc(ht) : null,
                ht !== null && (bt = Vb(ht),
                ht !== bt || ht.tag !== 5 && ht.tag !== 6) && (ht = null)) : (ft = null,
                ht = lt),
                ft !== ht)) {
                    if (gt = Bd,
                    vt = "onMouseLeave",
                    pt = "onMouseEnter",
                    mt = "mouse",
                    (_e === "pointerout" || _e === "pointerover") && (gt = Td,
                    vt = "onPointerLeave",
                    pt = "onPointerEnter",
                    mt = "pointer"),
                    bt = ft == null ? ut : ue(ft),
                    yt = ht == null ? ut : ue(ht),
                    ut = new gt(vt,mt + "leave",ft,tt,dt),
                    ut.target = bt,
                    ut.relatedTarget = yt,
                    vt = null,
                    Wc(dt) === lt && (gt = new gt(pt,mt + "enter",ht,tt,dt),
                    gt.target = yt,
                    gt.relatedTarget = bt,
                    vt = gt),
                    bt = vt,
                    ft && ht)
                        t: {
                            for (gt = ft,
                            pt = ht,
                            mt = 0,
                            yt = gt; yt; yt = vf(yt))
                                mt++;
                            for (yt = 0,
                            vt = pt; vt; vt = vf(vt))
                                yt++;
                            for (; 0 < mt - yt; )
                                gt = vf(gt),
                                mt--;
                            for (; 0 < yt - mt; )
                                pt = vf(pt),
                                yt--;
                            for (; mt--; ) {
                                if (gt === pt || pt !== null && gt === pt.alternate)
                                    break t;
                                gt = vf(gt),
                                pt = vf(pt)
                            }
                            gt = null
                        }
                    else
                        gt = null;
                    ft !== null && wf(ct, ut, ft, gt, !1),
                    ht !== null && bt !== null && wf(ct, bt, ht, gt, !0)
                }
            }
            e: {
                if (ut = lt ? ue(lt) : window,
                ft = ut.nodeName && ut.nodeName.toLowerCase(),
                ft === "select" || ft === "input" && ut.type === "file")
                    var wt = ve;
                else if (me(ut))
                    if (we)
                        wt = Fe;
                    else {
                        wt = De;
                        var _t = Ce
                    }
                else
                    (ft = ut.nodeName) && ft.toLowerCase() === "input" && (ut.type === "checkbox" || ut.type === "radio") && (wt = Ee);
                if (wt && (wt = wt(_e, lt))) {
                    ne(ct, wt, tt, dt);
                    break e
                }
                _t && _t(_e, ut, lt),
                _e === "focusout" && (_t = ut._wrapperState) && _t.controlled && ut.type === "number" && cb(ut, "number", ut.value)
            }
            switch (_t = lt ? ue(lt) : window,
            _e) {
            case "focusin":
                (me(_t) || _t.contentEditable === "true") && (Qe = _t,
                Re = lt,
                Se = null);
                break;
            case "focusout":
                Se = Re = Qe = null;
                break;
            case "mousedown":
                Te = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Te = !1,
                Ue(ct, tt, dt);
                break;
            case "selectionchange":
                if (Pe)
                    break;
            case "keydown":
            case "keyup":
                Ue(ct, tt, dt)
            }
            var Et;
            if (ae)
                e: {
                    switch (_e) {
                    case "compositionstart":
                        var xt = "onCompositionStart";
                        break e;
                    case "compositionend":
                        xt = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        xt = "onCompositionUpdate";
                        break e
                    }
                    xt = void 0
                }
            else
                ie ? ge(_e, tt) && (xt = "onCompositionEnd") : _e === "keydown" && tt.keyCode === 229 && (xt = "onCompositionStart");
            xt && (de && tt.locale !== "ko" && (ie || xt !== "onCompositionStart" ? xt === "onCompositionEnd" && ie && (Et = nd()) : (kd = dt,
            ld = "value"in kd ? kd.value : kd.textContent,
            ie = !0)),
            _t = oe(lt, xt),
            0 < _t.length && (xt = new Ld(xt,_e,null,tt,dt),
            ct.push({
                event: xt,
                listeners: _t
            }),
            Et ? xt.data = Et : (Et = he(tt),
            Et !== null && (xt.data = Et)))),
            (Et = ce ? je(_e, tt) : ke(_e, tt)) && (lt = oe(lt, "onBeforeInput"),
            0 < lt.length && (dt = new Ld("onBeforeInput","beforeinput",null,tt,dt),
            ct.push({
                event: dt,
                listeners: lt
            }),
            dt.data = Et))
        }
        se(ct, et)
    })
}
function tf(_e, et, tt) {
    return {
        instance: _e,
        listener: et,
        currentTarget: tt
    }
}
function oe(_e, et) {
    for (var tt = et + "Capture", rt = []; _e !== null; ) {
        var nt = _e
          , it = nt.stateNode;
        nt.tag === 5 && it !== null && (nt = it,
        it = Kb(_e, tt),
        it != null && rt.unshift(tf(_e, it, nt)),
        it = Kb(_e, et),
        it != null && rt.push(tf(_e, it, nt))),
        _e = _e.return
    }
    return rt
}
function vf(_e) {
    if (_e === null)
        return null;
    do
        _e = _e.return;
    while (_e && _e.tag !== 5);
    return _e || null
}
function wf(_e, et, tt, rt, nt) {
    for (var it = et._reactName, st = []; tt !== null && tt !== rt; ) {
        var at = tt
          , ot = at.alternate
          , lt = at.stateNode;
        if (ot !== null && ot === rt)
            break;
        at.tag === 5 && lt !== null && (at = lt,
        nt ? (ot = Kb(tt, it),
        ot != null && st.unshift(tf(tt, ot, at))) : nt || (ot = Kb(tt, it),
        ot != null && st.push(tf(tt, ot, at)))),
        tt = tt.return
    }
    st.length !== 0 && _e.push({
        event: et,
        listeners: st
    })
}
var xf = /\r\n?/g
  , yf = /\u0000|\uFFFD/g;
function zf(_e) {
    return (typeof _e == "string" ? _e : "" + _e).replace(xf, `
`).replace(yf, "")
}
function Af(_e, et, tt) {
    if (et = zf(et),
    zf(_e) !== et && tt)
        throw Error(p$8(425))
}
function Bf() {}
var Cf = null
  , Df = null;
function Ef(_e, et) {
    return _e === "textarea" || _e === "noscript" || typeof et.children == "string" || typeof et.children == "number" || typeof et.dangerouslySetInnerHTML == "object" && et.dangerouslySetInnerHTML !== null && et.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0
  , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Hf = typeof Promise == "function" ? Promise : void 0
  , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(_e) {
    return Hf.resolve(null).then(_e).catch(If)
}
: Ff;
function If(_e) {
    setTimeout(function() {
        throw _e
    })
}
function Kf(_e, et) {
    var tt = et
      , rt = 0;
    do {
        var nt = tt.nextSibling;
        if (_e.removeChild(tt),
        nt && nt.nodeType === 8)
            if (tt = nt.data,
            tt === "/$") {
                if (rt === 0) {
                    _e.removeChild(nt),
                    bd(et);
                    return
                }
                rt--
            } else
                tt !== "$" && tt !== "$?" && tt !== "$!" || rt++;
        tt = nt
    } while (tt);
    bd(et)
}
function Lf(_e) {
    for (; _e != null; _e = _e.nextSibling) {
        var et = _e.nodeType;
        if (et === 1 || et === 3)
            break;
        if (et === 8) {
            if (et = _e.data,
            et === "$" || et === "$!" || et === "$?")
                break;
            if (et === "/$")
                return null
        }
    }
    return _e
}
function Mf(_e) {
    _e = _e.previousSibling;
    for (var et = 0; _e; ) {
        if (_e.nodeType === 8) {
            var tt = _e.data;
            if (tt === "$" || tt === "$!" || tt === "$?") {
                if (et === 0)
                    return _e;
                et--
            } else
                tt === "/$" && et++
        }
        _e = _e.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2)
  , Of = "__reactFiber$" + Nf
  , Pf = "__reactProps$" + Nf
  , uf = "__reactContainer$" + Nf
  , of = "__reactEvents$" + Nf
  , Qf = "__reactListeners$" + Nf
  , Rf = "__reactHandles$" + Nf;
function Wc(_e) {
    var et = _e[Of];
    if (et)
        return et;
    for (var tt = _e.parentNode; tt; ) {
        if (et = tt[uf] || tt[Of]) {
            if (tt = et.alternate,
            et.child !== null || tt !== null && tt.child !== null)
                for (_e = Mf(_e); _e !== null; ) {
                    if (tt = _e[Of])
                        return tt;
                    _e = Mf(_e)
                }
            return et
        }
        _e = tt,
        tt = _e.parentNode
    }
    return null
}
function Cb(_e) {
    return _e = _e[Of] || _e[uf],
    !_e || _e.tag !== 5 && _e.tag !== 6 && _e.tag !== 13 && _e.tag !== 3 ? null : _e
}
function ue(_e) {
    if (_e.tag === 5 || _e.tag === 6)
        return _e.stateNode;
    throw Error(p$8(33))
}
function Db(_e) {
    return _e[Pf] || null
}
var Sf = []
  , Tf = -1;
function Uf(_e) {
    return {
        current: _e
    }
}
function E$3(_e) {
    0 > Tf || (_e.current = Sf[Tf],
    Sf[Tf] = null,
    Tf--)
}
function G(_e, et) {
    Tf++,
    Sf[Tf] = _e.current,
    _e.current = et
}
var Vf = {}
  , H$3 = Uf(Vf)
  , Wf = Uf(!1)
  , Xf = Vf;
function Yf(_e, et) {
    var tt = _e.type.contextTypes;
    if (!tt)
        return Vf;
    var rt = _e.stateNode;
    if (rt && rt.__reactInternalMemoizedUnmaskedChildContext === et)
        return rt.__reactInternalMemoizedMaskedChildContext;
    var nt = {}, it;
    for (it in tt)
        nt[it] = et[it];
    return rt && (_e = _e.stateNode,
    _e.__reactInternalMemoizedUnmaskedChildContext = et,
    _e.__reactInternalMemoizedMaskedChildContext = nt),
    nt
}
function Zf(_e) {
    return _e = _e.childContextTypes,
    _e != null
}
function $f() {
    E$3(Wf),
    E$3(H$3)
}
function ag(_e, et, tt) {
    if (H$3.current !== Vf)
        throw Error(p$8(168));
    G(H$3, et),
    G(Wf, tt)
}
function bg(_e, et, tt) {
    var rt = _e.stateNode;
    if (et = et.childContextTypes,
    typeof rt.getChildContext != "function")
        return tt;
    rt = rt.getChildContext();
    for (var nt in rt)
        if (!(nt in et))
            throw Error(p$8(108, Ra(_e) || "Unknown", nt));
    return A$3({}, tt, rt)
}
function cg(_e) {
    return _e = (_e = _e.stateNode) && _e.__reactInternalMemoizedMergedChildContext || Vf,
    Xf = H$3.current,
    G(H$3, _e),
    G(Wf, Wf.current),
    !0
}
function dg(_e, et, tt) {
    var rt = _e.stateNode;
    if (!rt)
        throw Error(p$8(169));
    tt ? (_e = bg(_e, et, Xf),
    rt.__reactInternalMemoizedMergedChildContext = _e,
    E$3(Wf),
    E$3(H$3),
    G(H$3, _e)) : E$3(Wf),
    G(Wf, tt)
}
var eg = null
  , fg = !1
  , gg = !1;
function hg(_e) {
    eg === null ? eg = [_e] : eg.push(_e)
}
function ig(_e) {
    fg = !0,
    hg(_e)
}
function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var _e = 0
          , et = C$3;
        try {
            var tt = eg;
            for (C$3 = 1; _e < tt.length; _e++) {
                var rt = tt[_e];
                do
                    rt = rt(!0);
                while (rt !== null)
            }
            eg = null,
            fg = !1
        } catch (nt) {
            throw eg !== null && (eg = eg.slice(_e + 1)),
            ac(fc, jg),
            nt
        } finally {
            C$3 = et,
            gg = !1
        }
    }
    return null
}
var kg = []
  , lg = 0
  , mg = null
  , ng = 0
  , og = []
  , pg = 0
  , qg = null
  , rg = 1
  , sg = "";
function tg(_e, et) {
    kg[lg++] = ng,
    kg[lg++] = mg,
    mg = _e,
    ng = et
}
function ug(_e, et, tt) {
    og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    qg = _e;
    var rt = rg;
    _e = sg;
    var nt = 32 - oc(rt) - 1;
    rt &= ~(1 << nt),
    tt += 1;
    var it = 32 - oc(et) + nt;
    if (30 < it) {
        var st = nt - nt % 5;
        it = (rt & (1 << st) - 1).toString(32),
        rt >>= st,
        nt -= st,
        rg = 1 << 32 - oc(et) + nt | tt << nt | rt,
        sg = it + _e
    } else
        rg = 1 << it | tt << nt | rt,
        sg = _e
}
function vg(_e) {
    _e.return !== null && (tg(_e, 1),
    ug(_e, 1, 0))
}
function wg(_e) {
    for (; _e === mg; )
        mg = kg[--lg],
        kg[lg] = null,
        ng = kg[--lg],
        kg[lg] = null;
    for (; _e === qg; )
        qg = og[--pg],
        og[pg] = null,
        sg = og[--pg],
        og[pg] = null,
        rg = og[--pg],
        og[pg] = null
}
var xg = null
  , yg = null
  , I$3 = !1
  , zg = null;
function Ag(_e, et) {
    var tt = Bg(5, null, null, 0);
    tt.elementType = "DELETED",
    tt.stateNode = et,
    tt.return = _e,
    et = _e.deletions,
    et === null ? (_e.deletions = [tt],
    _e.flags |= 16) : et.push(tt)
}
function Cg(_e, et) {
    switch (_e.tag) {
    case 5:
        var tt = _e.type;
        return et = et.nodeType !== 1 || tt.toLowerCase() !== et.nodeName.toLowerCase() ? null : et,
        et !== null ? (_e.stateNode = et,
        xg = _e,
        yg = Lf(et.firstChild),
        !0) : !1;
    case 6:
        return et = _e.pendingProps === "" || et.nodeType !== 3 ? null : et,
        et !== null ? (_e.stateNode = et,
        xg = _e,
        yg = null,
        !0) : !1;
    case 13:
        return et = et.nodeType !== 8 ? null : et,
        et !== null ? (tt = qg !== null ? {
            id: rg,
            overflow: sg
        } : null,
        _e.memoizedState = {
            dehydrated: et,
            treeContext: tt,
            retryLane: 1073741824
        },
        tt = Bg(18, null, null, 0),
        tt.stateNode = et,
        tt.return = _e,
        _e.child = tt,
        xg = _e,
        yg = null,
        !0) : !1;
    default:
        return !1
    }
}
function Dg(_e) {
    return (_e.mode & 1) !== 0 && (_e.flags & 128) === 0
}
function Eg(_e) {
    if (I$3) {
        var et = yg;
        if (et) {
            var tt = et;
            if (!Cg(_e, et)) {
                if (Dg(_e))
                    throw Error(p$8(418));
                et = Lf(tt.nextSibling);
                var rt = xg;
                et && Cg(_e, et) ? Ag(rt, tt) : (_e.flags = _e.flags & -4097 | 2,
                I$3 = !1,
                xg = _e)
            }
        } else {
            if (Dg(_e))
                throw Error(p$8(418));
            _e.flags = _e.flags & -4097 | 2,
            I$3 = !1,
            xg = _e
        }
    }
}
function Fg(_e) {
    for (_e = _e.return; _e !== null && _e.tag !== 5 && _e.tag !== 3 && _e.tag !== 13; )
        _e = _e.return;
    xg = _e
}
function Gg(_e) {
    if (_e !== xg)
        return !1;
    if (!I$3)
        return Fg(_e),
        I$3 = !0,
        !1;
    var et;
    if ((et = _e.tag !== 3) && !(et = _e.tag !== 5) && (et = _e.type,
    et = et !== "head" && et !== "body" && !Ef(_e.type, _e.memoizedProps)),
    et && (et = yg)) {
        if (Dg(_e))
            throw Hg(),
            Error(p$8(418));
        for (; et; )
            Ag(_e, et),
            et = Lf(et.nextSibling)
    }
    if (Fg(_e),
    _e.tag === 13) {
        if (_e = _e.memoizedState,
        _e = _e !== null ? _e.dehydrated : null,
        !_e)
            throw Error(p$8(317));
        e: {
            for (_e = _e.nextSibling,
            et = 0; _e; ) {
                if (_e.nodeType === 8) {
                    var tt = _e.data;
                    if (tt === "/$") {
                        if (et === 0) {
                            yg = Lf(_e.nextSibling);
                            break e
                        }
                        et--
                    } else
                        tt !== "$" && tt !== "$!" && tt !== "$?" || et++
                }
                _e = _e.nextSibling
            }
            yg = null
        }
    } else
        yg = xg ? Lf(_e.stateNode.nextSibling) : null;
    return !0
}
function Hg() {
    for (var _e = yg; _e; )
        _e = Lf(_e.nextSibling)
}
function Ig() {
    yg = xg = null,
    I$3 = !1
}
function Jg(_e) {
    zg === null ? zg = [_e] : zg.push(_e)
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(_e, et) {
    if (_e && _e.defaultProps) {
        et = A$3({}, et),
        _e = _e.defaultProps;
        for (var tt in _e)
            et[tt] === void 0 && (et[tt] = _e[tt]);
        return et
    }
    return et
}
var Mg = Uf(null)
  , Ng = null
  , Og = null
  , Pg = null;
function Qg() {
    Pg = Og = Ng = null
}
function Rg(_e) {
    var et = Mg.current;
    E$3(Mg),
    _e._currentValue = et
}
function Sg(_e, et, tt) {
    for (; _e !== null; ) {
        var rt = _e.alternate;
        if ((_e.childLanes & et) !== et ? (_e.childLanes |= et,
        rt !== null && (rt.childLanes |= et)) : rt !== null && (rt.childLanes & et) !== et && (rt.childLanes |= et),
        _e === tt)
            break;
        _e = _e.return
    }
}
function Tg(_e, et) {
    Ng = _e,
    Pg = Og = null,
    _e = _e.dependencies,
    _e !== null && _e.firstContext !== null && (_e.lanes & et && (Ug = !0),
    _e.firstContext = null)
}
function Vg(_e) {
    var et = _e._currentValue;
    if (Pg !== _e)
        if (_e = {
            context: _e,
            memoizedValue: et,
            next: null
        },
        Og === null) {
            if (Ng === null)
                throw Error(p$8(308));
            Og = _e,
            Ng.dependencies = {
                lanes: 0,
                firstContext: _e
            }
        } else
            Og = Og.next = _e;
    return et
}
var Wg = null;
function Xg(_e) {
    Wg === null ? Wg = [_e] : Wg.push(_e)
}
function Yg(_e, et, tt, rt) {
    var nt = et.interleaved;
    return nt === null ? (tt.next = tt,
    Xg(et)) : (tt.next = nt.next,
    nt.next = tt),
    et.interleaved = tt,
    Zg(_e, rt)
}
function Zg(_e, et) {
    _e.lanes |= et;
    var tt = _e.alternate;
    for (tt !== null && (tt.lanes |= et),
    tt = _e,
    _e = _e.return; _e !== null; )
        _e.childLanes |= et,
        tt = _e.alternate,
        tt !== null && (tt.childLanes |= et),
        tt = _e,
        _e = _e.return;
    return tt.tag === 3 ? tt.stateNode : null
}
var $g = !1;
function ah(_e) {
    _e.updateQueue = {
        baseState: _e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function bh(_e, et) {
    _e = _e.updateQueue,
    et.updateQueue === _e && (et.updateQueue = {
        baseState: _e.baseState,
        firstBaseUpdate: _e.firstBaseUpdate,
        lastBaseUpdate: _e.lastBaseUpdate,
        shared: _e.shared,
        effects: _e.effects
    })
}
function ch(_e, et) {
    return {
        eventTime: _e,
        lane: et,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function dh(_e, et, tt) {
    var rt = _e.updateQueue;
    if (rt === null)
        return null;
    if (rt = rt.shared,
    K & 2) {
        var nt = rt.pending;
        return nt === null ? et.next = et : (et.next = nt.next,
        nt.next = et),
        rt.pending = et,
        Zg(_e, tt)
    }
    return nt = rt.interleaved,
    nt === null ? (et.next = et,
    Xg(rt)) : (et.next = nt.next,
    nt.next = et),
    rt.interleaved = et,
    Zg(_e, tt)
}
function eh(_e, et, tt) {
    if (et = et.updateQueue,
    et !== null && (et = et.shared,
    (tt & 4194240) !== 0)) {
        var rt = et.lanes;
        rt &= _e.pendingLanes,
        tt |= rt,
        et.lanes = tt,
        Cc(_e, tt)
    }
}
function fh(_e, et) {
    var tt = _e.updateQueue
      , rt = _e.alternate;
    if (rt !== null && (rt = rt.updateQueue,
    tt === rt)) {
        var nt = null
          , it = null;
        if (tt = tt.firstBaseUpdate,
        tt !== null) {
            do {
                var st = {
                    eventTime: tt.eventTime,
                    lane: tt.lane,
                    tag: tt.tag,
                    payload: tt.payload,
                    callback: tt.callback,
                    next: null
                };
                it === null ? nt = it = st : it = it.next = st,
                tt = tt.next
            } while (tt !== null);
            it === null ? nt = it = et : it = it.next = et
        } else
            nt = it = et;
        tt = {
            baseState: rt.baseState,
            firstBaseUpdate: nt,
            lastBaseUpdate: it,
            shared: rt.shared,
            effects: rt.effects
        },
        _e.updateQueue = tt;
        return
    }
    _e = tt.lastBaseUpdate,
    _e === null ? tt.firstBaseUpdate = et : _e.next = et,
    tt.lastBaseUpdate = et
}
function gh(_e, et, tt, rt) {
    var nt = _e.updateQueue;
    $g = !1;
    var it = nt.firstBaseUpdate
      , st = nt.lastBaseUpdate
      , at = nt.shared.pending;
    if (at !== null) {
        nt.shared.pending = null;
        var ot = at
          , lt = ot.next;
        ot.next = null,
        st === null ? it = lt : st.next = lt,
        st = ot;
        var dt = _e.alternate;
        dt !== null && (dt = dt.updateQueue,
        at = dt.lastBaseUpdate,
        at !== st && (at === null ? dt.firstBaseUpdate = lt : at.next = lt,
        dt.lastBaseUpdate = ot))
    }
    if (it !== null) {
        var ct = nt.baseState;
        st = 0,
        dt = lt = ot = null,
        at = it;
        do {
            var ut = at.lane
              , ft = at.eventTime;
            if ((rt & ut) === ut) {
                dt !== null && (dt = dt.next = {
                    eventTime: ft,
                    lane: 0,
                    tag: at.tag,
                    payload: at.payload,
                    callback: at.callback,
                    next: null
                });
                e: {
                    var ht = _e
                      , gt = at;
                    switch (ut = et,
                    ft = tt,
                    gt.tag) {
                    case 1:
                        if (ht = gt.payload,
                        typeof ht == "function") {
                            ct = ht.call(ft, ct, ut);
                            break e
                        }
                        ct = ht;
                        break e;
                    case 3:
                        ht.flags = ht.flags & -65537 | 128;
                    case 0:
                        if (ht = gt.payload,
                        ut = typeof ht == "function" ? ht.call(ft, ct, ut) : ht,
                        ut == null)
                            break e;
                        ct = A$3({}, ct, ut);
                        break e;
                    case 2:
                        $g = !0
                    }
                }
                at.callback !== null && at.lane !== 0 && (_e.flags |= 64,
                ut = nt.effects,
                ut === null ? nt.effects = [at] : ut.push(at))
            } else
                ft = {
                    eventTime: ft,
                    lane: ut,
                    tag: at.tag,
                    payload: at.payload,
                    callback: at.callback,
                    next: null
                },
                dt === null ? (lt = dt = ft,
                ot = ct) : dt = dt.next = ft,
                st |= ut;
            if (at = at.next,
            at === null) {
                if (at = nt.shared.pending,
                at === null)
                    break;
                ut = at,
                at = ut.next,
                ut.next = null,
                nt.lastBaseUpdate = ut,
                nt.shared.pending = null
            }
        } while (!0);
        if (dt === null && (ot = ct),
        nt.baseState = ot,
        nt.firstBaseUpdate = lt,
        nt.lastBaseUpdate = dt,
        et = nt.shared.interleaved,
        et !== null) {
            nt = et;
            do
                st |= nt.lane,
                nt = nt.next;
            while (nt !== et)
        } else
            it === null && (nt.shared.lanes = 0);
        hh |= st,
        _e.lanes = st,
        _e.memoizedState = ct
    }
}
function ih(_e, et, tt) {
    if (_e = et.effects,
    et.effects = null,
    _e !== null)
        for (et = 0; et < _e.length; et++) {
            var rt = _e[et]
              , nt = rt.callback;
            if (nt !== null) {
                if (rt.callback = null,
                rt = tt,
                typeof nt != "function")
                    throw Error(p$8(191, nt));
                nt.call(rt)
            }
        }
}
var jh = new aa.Component().refs;
function kh(_e, et, tt, rt) {
    et = _e.memoizedState,
    tt = tt(rt, et),
    tt = tt == null ? et : A$3({}, et, tt),
    _e.memoizedState = tt,
    _e.lanes === 0 && (_e.updateQueue.baseState = tt)
}
var nh = {
    isMounted: function(_e) {
        return (_e = _e._reactInternals) ? Vb(_e) === _e : !1
    },
    enqueueSetState: function(_e, et, tt) {
        _e = _e._reactInternals;
        var rt = L$3()
          , nt = lh(_e)
          , it = ch(rt, nt);
        it.payload = et,
        tt != null && (it.callback = tt),
        et = dh(_e, it, nt),
        et !== null && (mh(et, _e, nt, rt),
        eh(et, _e, nt))
    },
    enqueueReplaceState: function(_e, et, tt) {
        _e = _e._reactInternals;
        var rt = L$3()
          , nt = lh(_e)
          , it = ch(rt, nt);
        it.tag = 1,
        it.payload = et,
        tt != null && (it.callback = tt),
        et = dh(_e, it, nt),
        et !== null && (mh(et, _e, nt, rt),
        eh(et, _e, nt))
    },
    enqueueForceUpdate: function(_e, et) {
        _e = _e._reactInternals;
        var tt = L$3()
          , rt = lh(_e)
          , nt = ch(tt, rt);
        nt.tag = 2,
        et != null && (nt.callback = et),
        et = dh(_e, nt, rt),
        et !== null && (mh(et, _e, rt, tt),
        eh(et, _e, rt))
    }
};
function oh(_e, et, tt, rt, nt, it, st) {
    return _e = _e.stateNode,
    typeof _e.shouldComponentUpdate == "function" ? _e.shouldComponentUpdate(rt, it, st) : et.prototype && et.prototype.isPureReactComponent ? !Ie(tt, rt) || !Ie(nt, it) : !0
}
function ph(_e, et, tt) {
    var rt = !1
      , nt = Vf
      , it = et.contextType;
    return typeof it == "object" && it !== null ? it = Vg(it) : (nt = Zf(et) ? Xf : H$3.current,
    rt = et.contextTypes,
    it = (rt = rt != null) ? Yf(_e, nt) : Vf),
    et = new et(tt,it),
    _e.memoizedState = et.state !== null && et.state !== void 0 ? et.state : null,
    et.updater = nh,
    _e.stateNode = et,
    et._reactInternals = _e,
    rt && (_e = _e.stateNode,
    _e.__reactInternalMemoizedUnmaskedChildContext = nt,
    _e.__reactInternalMemoizedMaskedChildContext = it),
    et
}
function qh(_e, et, tt, rt) {
    _e = et.state,
    typeof et.componentWillReceiveProps == "function" && et.componentWillReceiveProps(tt, rt),
    typeof et.UNSAFE_componentWillReceiveProps == "function" && et.UNSAFE_componentWillReceiveProps(tt, rt),
    et.state !== _e && nh.enqueueReplaceState(et, et.state, null)
}
function rh(_e, et, tt, rt) {
    var nt = _e.stateNode;
    nt.props = tt,
    nt.state = _e.memoizedState,
    nt.refs = jh,
    ah(_e);
    var it = et.contextType;
    typeof it == "object" && it !== null ? nt.context = Vg(it) : (it = Zf(et) ? Xf : H$3.current,
    nt.context = Yf(_e, it)),
    nt.state = _e.memoizedState,
    it = et.getDerivedStateFromProps,
    typeof it == "function" && (kh(_e, et, it, tt),
    nt.state = _e.memoizedState),
    typeof et.getDerivedStateFromProps == "function" || typeof nt.getSnapshotBeforeUpdate == "function" || typeof nt.UNSAFE_componentWillMount != "function" && typeof nt.componentWillMount != "function" || (et = nt.state,
    typeof nt.componentWillMount == "function" && nt.componentWillMount(),
    typeof nt.UNSAFE_componentWillMount == "function" && nt.UNSAFE_componentWillMount(),
    et !== nt.state && nh.enqueueReplaceState(nt, nt.state, null),
    gh(_e, tt, nt, rt),
    nt.state = _e.memoizedState),
    typeof nt.componentDidMount == "function" && (_e.flags |= 4194308)
}
function sh(_e, et, tt) {
    if (_e = tt.ref,
    _e !== null && typeof _e != "function" && typeof _e != "object") {
        if (tt._owner) {
            if (tt = tt._owner,
            tt) {
                if (tt.tag !== 1)
                    throw Error(p$8(309));
                var rt = tt.stateNode
            }
            if (!rt)
                throw Error(p$8(147, _e));
            var nt = rt
              , it = "" + _e;
            return et !== null && et.ref !== null && typeof et.ref == "function" && et.ref._stringRef === it ? et.ref : (et = function(st) {
                var at = nt.refs;
                at === jh && (at = nt.refs = {}),
                st === null ? delete at[it] : at[it] = st
            }
            ,
            et._stringRef = it,
            et)
        }
        if (typeof _e != "string")
            throw Error(p$8(284));
        if (!tt._owner)
            throw Error(p$8(290, _e))
    }
    return _e
}
function th(_e, et) {
    throw _e = Object.prototype.toString.call(et),
    Error(p$8(31, _e === "[object Object]" ? "object with keys {" + Object.keys(et).join(", ") + "}" : _e))
}
function uh(_e) {
    var et = _e._init;
    return et(_e._payload)
}
function vh(_e) {
    function et(pt, mt) {
        if (_e) {
            var yt = pt.deletions;
            yt === null ? (pt.deletions = [mt],
            pt.flags |= 16) : yt.push(mt)
        }
    }
    function tt(pt, mt) {
        if (!_e)
            return null;
        for (; mt !== null; )
            et(pt, mt),
            mt = mt.sibling;
        return null
    }
    function rt(pt, mt) {
        for (pt = new Map; mt !== null; )
            mt.key !== null ? pt.set(mt.key, mt) : pt.set(mt.index, mt),
            mt = mt.sibling;
        return pt
    }
    function nt(pt, mt) {
        return pt = wh(pt, mt),
        pt.index = 0,
        pt.sibling = null,
        pt
    }
    function it(pt, mt, yt) {
        return pt.index = yt,
        _e ? (yt = pt.alternate,
        yt !== null ? (yt = yt.index,
        yt < mt ? (pt.flags |= 2,
        mt) : yt) : (pt.flags |= 2,
        mt)) : (pt.flags |= 1048576,
        mt)
    }
    function st(pt) {
        return _e && pt.alternate === null && (pt.flags |= 2),
        pt
    }
    function at(pt, mt, yt, vt) {
        return mt === null || mt.tag !== 6 ? (mt = xh(yt, pt.mode, vt),
        mt.return = pt,
        mt) : (mt = nt(mt, yt),
        mt.return = pt,
        mt)
    }
    function ot(pt, mt, yt, vt) {
        var wt = yt.type;
        return wt === ya ? dt(pt, mt, yt.props.children, vt, yt.key) : mt !== null && (mt.elementType === wt || typeof wt == "object" && wt !== null && wt.$$typeof === Ha && uh(wt) === mt.type) ? (vt = nt(mt, yt.props),
        vt.ref = sh(pt, mt, yt),
        vt.return = pt,
        vt) : (vt = yh(yt.type, yt.key, yt.props, null, pt.mode, vt),
        vt.ref = sh(pt, mt, yt),
        vt.return = pt,
        vt)
    }
    function lt(pt, mt, yt, vt) {
        return mt === null || mt.tag !== 4 || mt.stateNode.containerInfo !== yt.containerInfo || mt.stateNode.implementation !== yt.implementation ? (mt = zh(yt, pt.mode, vt),
        mt.return = pt,
        mt) : (mt = nt(mt, yt.children || []),
        mt.return = pt,
        mt)
    }
    function dt(pt, mt, yt, vt, wt) {
        return mt === null || mt.tag !== 7 ? (mt = Ah(yt, pt.mode, vt, wt),
        mt.return = pt,
        mt) : (mt = nt(mt, yt),
        mt.return = pt,
        mt)
    }
    function ct(pt, mt, yt) {
        if (typeof mt == "string" && mt !== "" || typeof mt == "number")
            return mt = xh("" + mt, pt.mode, yt),
            mt.return = pt,
            mt;
        if (typeof mt == "object" && mt !== null) {
            switch (mt.$$typeof) {
            case va:
                return yt = yh(mt.type, mt.key, mt.props, null, pt.mode, yt),
                yt.ref = sh(pt, null, mt),
                yt.return = pt,
                yt;
            case wa:
                return mt = zh(mt, pt.mode, yt),
                mt.return = pt,
                mt;
            case Ha:
                var vt = mt._init;
                return ct(pt, vt(mt._payload), yt)
            }
            if (eb(mt) || Ka(mt))
                return mt = Ah(mt, pt.mode, yt, null),
                mt.return = pt,
                mt;
            th(pt, mt)
        }
        return null
    }
    function ut(pt, mt, yt, vt) {
        var wt = mt !== null ? mt.key : null;
        if (typeof yt == "string" && yt !== "" || typeof yt == "number")
            return wt !== null ? null : at(pt, mt, "" + yt, vt);
        if (typeof yt == "object" && yt !== null) {
            switch (yt.$$typeof) {
            case va:
                return yt.key === wt ? ot(pt, mt, yt, vt) : null;
            case wa:
                return yt.key === wt ? lt(pt, mt, yt, vt) : null;
            case Ha:
                return wt = yt._init,
                ut(pt, mt, wt(yt._payload), vt)
            }
            if (eb(yt) || Ka(yt))
                return wt !== null ? null : dt(pt, mt, yt, vt, null);
            th(pt, yt)
        }
        return null
    }
    function ft(pt, mt, yt, vt, wt) {
        if (typeof vt == "string" && vt !== "" || typeof vt == "number")
            return pt = pt.get(yt) || null,
            at(mt, pt, "" + vt, wt);
        if (typeof vt == "object" && vt !== null) {
            switch (vt.$$typeof) {
            case va:
                return pt = pt.get(vt.key === null ? yt : vt.key) || null,
                ot(mt, pt, vt, wt);
            case wa:
                return pt = pt.get(vt.key === null ? yt : vt.key) || null,
                lt(mt, pt, vt, wt);
            case Ha:
                var _t = vt._init;
                return ft(pt, mt, yt, _t(vt._payload), wt)
            }
            if (eb(vt) || Ka(vt))
                return pt = pt.get(yt) || null,
                dt(mt, pt, vt, wt, null);
            th(mt, vt)
        }
        return null
    }
    function ht(pt, mt, yt, vt) {
        for (var wt = null, _t = null, Et = mt, xt = mt = 0, Ct = null; Et !== null && xt < yt.length; xt++) {
            Et.index > xt ? (Ct = Et,
            Et = null) : Ct = Et.sibling;
            var Tt = ut(pt, Et, yt[xt], vt);
            if (Tt === null) {
                Et === null && (Et = Ct);
                break
            }
            _e && Et && Tt.alternate === null && et(pt, Et),
            mt = it(Tt, mt, xt),
            _t === null ? wt = Tt : _t.sibling = Tt,
            _t = Tt,
            Et = Ct
        }
        if (xt === yt.length)
            return tt(pt, Et),
            I$3 && tg(pt, xt),
            wt;
        if (Et === null) {
            for (; xt < yt.length; xt++)
                Et = ct(pt, yt[xt], vt),
                Et !== null && (mt = it(Et, mt, xt),
                _t === null ? wt = Et : _t.sibling = Et,
                _t = Et);
            return I$3 && tg(pt, xt),
            wt
        }
        for (Et = rt(pt, Et); xt < yt.length; xt++)
            Ct = ft(Et, pt, xt, yt[xt], vt),
            Ct !== null && (_e && Ct.alternate !== null && Et.delete(Ct.key === null ? xt : Ct.key),
            mt = it(Ct, mt, xt),
            _t === null ? wt = Ct : _t.sibling = Ct,
            _t = Ct);
        return _e && Et.forEach(function(It) {
            return et(pt, It)
        }),
        I$3 && tg(pt, xt),
        wt
    }
    function gt(pt, mt, yt, vt) {
        var wt = Ka(yt);
        if (typeof wt != "function")
            throw Error(p$8(150));
        if (yt = wt.call(yt),
        yt == null)
            throw Error(p$8(151));
        for (var _t = wt = null, Et = mt, xt = mt = 0, Ct = null, Tt = yt.next(); Et !== null && !Tt.done; xt++,
        Tt = yt.next()) {
            Et.index > xt ? (Ct = Et,
            Et = null) : Ct = Et.sibling;
            var It = ut(pt, Et, Tt.value, vt);
            if (It === null) {
                Et === null && (Et = Ct);
                break
            }
            _e && Et && It.alternate === null && et(pt, Et),
            mt = it(It, mt, xt),
            _t === null ? wt = It : _t.sibling = It,
            _t = It,
            Et = Ct
        }
        if (Tt.done)
            return tt(pt, Et),
            I$3 && tg(pt, xt),
            wt;
        if (Et === null) {
            for (; !Tt.done; xt++,
            Tt = yt.next())
                Tt = ct(pt, Tt.value, vt),
                Tt !== null && (mt = it(Tt, mt, xt),
                _t === null ? wt = Tt : _t.sibling = Tt,
                _t = Tt);
            return I$3 && tg(pt, xt),
            wt
        }
        for (Et = rt(pt, Et); !Tt.done; xt++,
        Tt = yt.next())
            Tt = ft(Et, pt, xt, Tt.value, vt),
            Tt !== null && (_e && Tt.alternate !== null && Et.delete(Tt.key === null ? xt : Tt.key),
            mt = it(Tt, mt, xt),
            _t === null ? wt = Tt : _t.sibling = Tt,
            _t = Tt);
        return _e && Et.forEach(function(Nt) {
            return et(pt, Nt)
        }),
        I$3 && tg(pt, xt),
        wt
    }
    function bt(pt, mt, yt, vt) {
        if (typeof yt == "object" && yt !== null && yt.type === ya && yt.key === null && (yt = yt.props.children),
        typeof yt == "object" && yt !== null) {
            switch (yt.$$typeof) {
            case va:
                e: {
                    for (var wt = yt.key, _t = mt; _t !== null; ) {
                        if (_t.key === wt) {
                            if (wt = yt.type,
                            wt === ya) {
                                if (_t.tag === 7) {
                                    tt(pt, _t.sibling),
                                    mt = nt(_t, yt.props.children),
                                    mt.return = pt,
                                    pt = mt;
                                    break e
                                }
                            } else if (_t.elementType === wt || typeof wt == "object" && wt !== null && wt.$$typeof === Ha && uh(wt) === _t.type) {
                                tt(pt, _t.sibling),
                                mt = nt(_t, yt.props),
                                mt.ref = sh(pt, _t, yt),
                                mt.return = pt,
                                pt = mt;
                                break e
                            }
                            tt(pt, _t);
                            break
                        } else
                            et(pt, _t);
                        _t = _t.sibling
                    }
                    yt.type === ya ? (mt = Ah(yt.props.children, pt.mode, vt, yt.key),
                    mt.return = pt,
                    pt = mt) : (vt = yh(yt.type, yt.key, yt.props, null, pt.mode, vt),
                    vt.ref = sh(pt, mt, yt),
                    vt.return = pt,
                    pt = vt)
                }
                return st(pt);
            case wa:
                e: {
                    for (_t = yt.key; mt !== null; ) {
                        if (mt.key === _t)
                            if (mt.tag === 4 && mt.stateNode.containerInfo === yt.containerInfo && mt.stateNode.implementation === yt.implementation) {
                                tt(pt, mt.sibling),
                                mt = nt(mt, yt.children || []),
                                mt.return = pt,
                                pt = mt;
                                break e
                            } else {
                                tt(pt, mt);
                                break
                            }
                        else
                            et(pt, mt);
                        mt = mt.sibling
                    }
                    mt = zh(yt, pt.mode, vt),
                    mt.return = pt,
                    pt = mt
                }
                return st(pt);
            case Ha:
                return _t = yt._init,
                bt(pt, mt, _t(yt._payload), vt)
            }
            if (eb(yt))
                return ht(pt, mt, yt, vt);
            if (Ka(yt))
                return gt(pt, mt, yt, vt);
            th(pt, yt)
        }
        return typeof yt == "string" && yt !== "" || typeof yt == "number" ? (yt = "" + yt,
        mt !== null && mt.tag === 6 ? (tt(pt, mt.sibling),
        mt = nt(mt, yt),
        mt.return = pt,
        pt = mt) : (tt(pt, mt),
        mt = xh(yt, pt.mode, vt),
        mt.return = pt,
        pt = mt),
        st(pt)) : tt(pt, mt)
    }
    return bt
}
var Bh = vh(!0)
  , Ch = vh(!1)
  , Dh = {}
  , Eh = Uf(Dh)
  , Fh = Uf(Dh)
  , Gh = Uf(Dh);
function Hh(_e) {
    if (_e === Dh)
        throw Error(p$8(174));
    return _e
}
function Ih(_e, et) {
    switch (G(Gh, et),
    G(Fh, _e),
    G(Eh, Dh),
    _e = et.nodeType,
    _e) {
    case 9:
    case 11:
        et = (et = et.documentElement) ? et.namespaceURI : lb(null, "");
        break;
    default:
        _e = _e === 8 ? et.parentNode : et,
        et = _e.namespaceURI || null,
        _e = _e.tagName,
        et = lb(et, _e)
    }
    E$3(Eh),
    G(Eh, et)
}
function Jh() {
    E$3(Eh),
    E$3(Fh),
    E$3(Gh)
}
function Kh(_e) {
    Hh(Gh.current);
    var et = Hh(Eh.current)
      , tt = lb(et, _e.type);
    et !== tt && (G(Fh, _e),
    G(Eh, tt))
}
function Lh(_e) {
    Fh.current === _e && (E$3(Eh),
    E$3(Fh))
}
var M$3 = Uf(0);
function Mh(_e) {
    for (var et = _e; et !== null; ) {
        if (et.tag === 13) {
            var tt = et.memoizedState;
            if (tt !== null && (tt = tt.dehydrated,
            tt === null || tt.data === "$?" || tt.data === "$!"))
                return et
        } else if (et.tag === 19 && et.memoizedProps.revealOrder !== void 0) {
            if (et.flags & 128)
                return et
        } else if (et.child !== null) {
            et.child.return = et,
            et = et.child;
            continue
        }
        if (et === _e)
            break;
        for (; et.sibling === null; ) {
            if (et.return === null || et.return === _e)
                return null;
            et = et.return
        }
        et.sibling.return = et.return,
        et = et.sibling
    }
    return null
}
var Nh = [];
function Oh() {
    for (var _e = 0; _e < Nh.length; _e++)
        Nh[_e]._workInProgressVersionPrimary = null;
    Nh.length = 0
}
var Ph = ua.ReactCurrentDispatcher
  , Qh = ua.ReactCurrentBatchConfig
  , Rh = 0
  , N$3 = null
  , O$1 = null
  , P$3 = null
  , Sh = !1
  , Th = !1
  , Uh = 0
  , Vh = 0;
function Q$1() {
    throw Error(p$8(321))
}
function Wh(_e, et) {
    if (et === null)
        return !1;
    for (var tt = 0; tt < et.length && tt < _e.length; tt++)
        if (!He(_e[tt], et[tt]))
            return !1;
    return !0
}
function Xh(_e, et, tt, rt, nt, it) {
    if (Rh = it,
    N$3 = et,
    et.memoizedState = null,
    et.updateQueue = null,
    et.lanes = 0,
    Ph.current = _e === null || _e.memoizedState === null ? Yh : Zh,
    _e = tt(rt, nt),
    Th) {
        it = 0;
        do {
            if (Th = !1,
            Uh = 0,
            25 <= it)
                throw Error(p$8(301));
            it += 1,
            P$3 = O$1 = null,
            et.updateQueue = null,
            Ph.current = $h,
            _e = tt(rt, nt)
        } while (Th)
    }
    if (Ph.current = ai,
    et = O$1 !== null && O$1.next !== null,
    Rh = 0,
    P$3 = O$1 = N$3 = null,
    Sh = !1,
    et)
        throw Error(p$8(300));
    return _e
}
function bi() {
    var _e = Uh !== 0;
    return Uh = 0,
    _e
}
function ci() {
    var _e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return P$3 === null ? N$3.memoizedState = P$3 = _e : P$3 = P$3.next = _e,
    P$3
}
function di() {
    if (O$1 === null) {
        var _e = N$3.alternate;
        _e = _e !== null ? _e.memoizedState : null
    } else
        _e = O$1.next;
    var et = P$3 === null ? N$3.memoizedState : P$3.next;
    if (et !== null)
        P$3 = et,
        O$1 = _e;
    else {
        if (_e === null)
            throw Error(p$8(310));
        O$1 = _e,
        _e = {
            memoizedState: O$1.memoizedState,
            baseState: O$1.baseState,
            baseQueue: O$1.baseQueue,
            queue: O$1.queue,
            next: null
        },
        P$3 === null ? N$3.memoizedState = P$3 = _e : P$3 = P$3.next = _e
    }
    return P$3
}
function ei(_e, et) {
    return typeof et == "function" ? et(_e) : et
}
function fi(_e) {
    var et = di()
      , tt = et.queue;
    if (tt === null)
        throw Error(p$8(311));
    tt.lastRenderedReducer = _e;
    var rt = O$1
      , nt = rt.baseQueue
      , it = tt.pending;
    if (it !== null) {
        if (nt !== null) {
            var st = nt.next;
            nt.next = it.next,
            it.next = st
        }
        rt.baseQueue = nt = it,
        tt.pending = null
    }
    if (nt !== null) {
        it = nt.next,
        rt = rt.baseState;
        var at = st = null
          , ot = null
          , lt = it;
        do {
            var dt = lt.lane;
            if ((Rh & dt) === dt)
                ot !== null && (ot = ot.next = {
                    lane: 0,
                    action: lt.action,
                    hasEagerState: lt.hasEagerState,
                    eagerState: lt.eagerState,
                    next: null
                }),
                rt = lt.hasEagerState ? lt.eagerState : _e(rt, lt.action);
            else {
                var ct = {
                    lane: dt,
                    action: lt.action,
                    hasEagerState: lt.hasEagerState,
                    eagerState: lt.eagerState,
                    next: null
                };
                ot === null ? (at = ot = ct,
                st = rt) : ot = ot.next = ct,
                N$3.lanes |= dt,
                hh |= dt
            }
            lt = lt.next
        } while (lt !== null && lt !== it);
        ot === null ? st = rt : ot.next = at,
        He(rt, et.memoizedState) || (Ug = !0),
        et.memoizedState = rt,
        et.baseState = st,
        et.baseQueue = ot,
        tt.lastRenderedState = rt
    }
    if (_e = tt.interleaved,
    _e !== null) {
        nt = _e;
        do
            it = nt.lane,
            N$3.lanes |= it,
            hh |= it,
            nt = nt.next;
        while (nt !== _e)
    } else
        nt === null && (tt.lanes = 0);
    return [et.memoizedState, tt.dispatch]
}
function gi(_e) {
    var et = di()
      , tt = et.queue;
    if (tt === null)
        throw Error(p$8(311));
    tt.lastRenderedReducer = _e;
    var rt = tt.dispatch
      , nt = tt.pending
      , it = et.memoizedState;
    if (nt !== null) {
        tt.pending = null;
        var st = nt = nt.next;
        do
            it = _e(it, st.action),
            st = st.next;
        while (st !== nt);
        He(it, et.memoizedState) || (Ug = !0),
        et.memoizedState = it,
        et.baseQueue === null && (et.baseState = it),
        tt.lastRenderedState = it
    }
    return [it, rt]
}
function hi() {}
function ii(_e, et) {
    var tt = N$3
      , rt = di()
      , nt = et()
      , it = !He(rt.memoizedState, nt);
    if (it && (rt.memoizedState = nt,
    Ug = !0),
    rt = rt.queue,
    ji(ki.bind(null, tt, rt, _e), [_e]),
    rt.getSnapshot !== et || it || P$3 !== null && P$3.memoizedState.tag & 1) {
        if (tt.flags |= 2048,
        li(9, mi.bind(null, tt, rt, nt, et), void 0, null),
        R$3 === null)
            throw Error(p$8(349));
        Rh & 30 || ni(tt, et, nt)
    }
    return nt
}
function ni(_e, et, tt) {
    _e.flags |= 16384,
    _e = {
        getSnapshot: et,
        value: tt
    },
    et = N$3.updateQueue,
    et === null ? (et = {
        lastEffect: null,
        stores: null
    },
    N$3.updateQueue = et,
    et.stores = [_e]) : (tt = et.stores,
    tt === null ? et.stores = [_e] : tt.push(_e))
}
function mi(_e, et, tt, rt) {
    et.value = tt,
    et.getSnapshot = rt,
    oi(et) && pi(_e)
}
function ki(_e, et, tt) {
    return tt(function() {
        oi(et) && pi(_e)
    })
}
function oi(_e) {
    var et = _e.getSnapshot;
    _e = _e.value;
    try {
        var tt = et();
        return !He(_e, tt)
    } catch {
        return !0
    }
}
function pi(_e) {
    var et = Zg(_e, 1);
    et !== null && mh(et, _e, 1, -1)
}
function qi(_e) {
    var et = ci();
    return typeof _e == "function" && (_e = _e()),
    et.memoizedState = et.baseState = _e,
    _e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ei,
        lastRenderedState: _e
    },
    et.queue = _e,
    _e = _e.dispatch = ri.bind(null, N$3, _e),
    [et.memoizedState, _e]
}
function li(_e, et, tt, rt) {
    return _e = {
        tag: _e,
        create: et,
        destroy: tt,
        deps: rt,
        next: null
    },
    et = N$3.updateQueue,
    et === null ? (et = {
        lastEffect: null,
        stores: null
    },
    N$3.updateQueue = et,
    et.lastEffect = _e.next = _e) : (tt = et.lastEffect,
    tt === null ? et.lastEffect = _e.next = _e : (rt = tt.next,
    tt.next = _e,
    _e.next = rt,
    et.lastEffect = _e)),
    _e
}
function si() {
    return di().memoizedState
}
function ti(_e, et, tt, rt) {
    var nt = ci();
    N$3.flags |= _e,
    nt.memoizedState = li(1 | et, tt, void 0, rt === void 0 ? null : rt)
}
function ui(_e, et, tt, rt) {
    var nt = di();
    rt = rt === void 0 ? null : rt;
    var it = void 0;
    if (O$1 !== null) {
        var st = O$1.memoizedState;
        if (it = st.destroy,
        rt !== null && Wh(rt, st.deps)) {
            nt.memoizedState = li(et, tt, it, rt);
            return
        }
    }
    N$3.flags |= _e,
    nt.memoizedState = li(1 | et, tt, it, rt)
}
function vi(_e, et) {
    return ti(8390656, 8, _e, et)
}
function ji(_e, et) {
    return ui(2048, 8, _e, et)
}
function wi(_e, et) {
    return ui(4, 2, _e, et)
}
function xi(_e, et) {
    return ui(4, 4, _e, et)
}
function yi(_e, et) {
    if (typeof et == "function")
        return _e = _e(),
        et(_e),
        function() {
            et(null)
        }
        ;
    if (et != null)
        return _e = _e(),
        et.current = _e,
        function() {
            et.current = null
        }
}
function zi(_e, et, tt) {
    return tt = tt != null ? tt.concat([_e]) : null,
    ui(4, 4, yi.bind(null, et, _e), tt)
}
function Ai() {}
function Bi(_e, et) {
    var tt = di();
    et = et === void 0 ? null : et;
    var rt = tt.memoizedState;
    return rt !== null && et !== null && Wh(et, rt[1]) ? rt[0] : (tt.memoizedState = [_e, et],
    _e)
}
function Ci(_e, et) {
    var tt = di();
    et = et === void 0 ? null : et;
    var rt = tt.memoizedState;
    return rt !== null && et !== null && Wh(et, rt[1]) ? rt[0] : (_e = _e(),
    tt.memoizedState = [_e, et],
    _e)
}
function Di(_e, et, tt) {
    return Rh & 21 ? (He(tt, et) || (tt = yc(),
    N$3.lanes |= tt,
    hh |= tt,
    _e.baseState = !0),
    et) : (_e.baseState && (_e.baseState = !1,
    Ug = !0),
    _e.memoizedState = tt)
}
function Ei(_e, et) {
    var tt = C$3;
    C$3 = tt !== 0 && 4 > tt ? tt : 4,
    _e(!0);
    var rt = Qh.transition;
    Qh.transition = {};
    try {
        _e(!1),
        et()
    } finally {
        C$3 = tt,
        Qh.transition = rt
    }
}
function Fi() {
    return di().memoizedState
}
function Gi(_e, et, tt) {
    var rt = lh(_e);
    if (tt = {
        lane: rt,
        action: tt,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Hi(_e))
        Ii(et, tt);
    else if (tt = Yg(_e, et, tt, rt),
    tt !== null) {
        var nt = L$3();
        mh(tt, _e, rt, nt),
        Ji(tt, et, rt)
    }
}
function ri(_e, et, tt) {
    var rt = lh(_e)
      , nt = {
        lane: rt,
        action: tt,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Hi(_e))
        Ii(et, nt);
    else {
        var it = _e.alternate;
        if (_e.lanes === 0 && (it === null || it.lanes === 0) && (it = et.lastRenderedReducer,
        it !== null))
            try {
                var st = et.lastRenderedState
                  , at = it(st, tt);
                if (nt.hasEagerState = !0,
                nt.eagerState = at,
                He(at, st)) {
                    var ot = et.interleaved;
                    ot === null ? (nt.next = nt,
                    Xg(et)) : (nt.next = ot.next,
                    ot.next = nt),
                    et.interleaved = nt;
                    return
                }
            } catch {} finally {}
        tt = Yg(_e, et, nt, rt),
        tt !== null && (nt = L$3(),
        mh(tt, _e, rt, nt),
        Ji(tt, et, rt))
    }
}
function Hi(_e) {
    var et = _e.alternate;
    return _e === N$3 || et !== null && et === N$3
}
function Ii(_e, et) {
    Th = Sh = !0;
    var tt = _e.pending;
    tt === null ? et.next = et : (et.next = tt.next,
    tt.next = et),
    _e.pending = et
}
function Ji(_e, et, tt) {
    if (tt & 4194240) {
        var rt = et.lanes;
        rt &= _e.pendingLanes,
        tt |= rt,
        et.lanes = tt,
        Cc(_e, tt)
    }
}
var ai = {
    readContext: Vg,
    useCallback: Q$1,
    useContext: Q$1,
    useEffect: Q$1,
    useImperativeHandle: Q$1,
    useInsertionEffect: Q$1,
    useLayoutEffect: Q$1,
    useMemo: Q$1,
    useReducer: Q$1,
    useRef: Q$1,
    useState: Q$1,
    useDebugValue: Q$1,
    useDeferredValue: Q$1,
    useTransition: Q$1,
    useMutableSource: Q$1,
    useSyncExternalStore: Q$1,
    useId: Q$1,
    unstable_isNewReconciler: !1
}
  , Yh = {
    readContext: Vg,
    useCallback: function(_e, et) {
        return ci().memoizedState = [_e, et === void 0 ? null : et],
        _e
    },
    useContext: Vg,
    useEffect: vi,
    useImperativeHandle: function(_e, et, tt) {
        return tt = tt != null ? tt.concat([_e]) : null,
        ti(4194308, 4, yi.bind(null, et, _e), tt)
    },
    useLayoutEffect: function(_e, et) {
        return ti(4194308, 4, _e, et)
    },
    useInsertionEffect: function(_e, et) {
        return ti(4, 2, _e, et)
    },
    useMemo: function(_e, et) {
        var tt = ci();
        return et = et === void 0 ? null : et,
        _e = _e(),
        tt.memoizedState = [_e, et],
        _e
    },
    useReducer: function(_e, et, tt) {
        var rt = ci();
        return et = tt !== void 0 ? tt(et) : et,
        rt.memoizedState = rt.baseState = et,
        _e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: _e,
            lastRenderedState: et
        },
        rt.queue = _e,
        _e = _e.dispatch = Gi.bind(null, N$3, _e),
        [rt.memoizedState, _e]
    },
    useRef: function(_e) {
        var et = ci();
        return _e = {
            current: _e
        },
        et.memoizedState = _e
    },
    useState: qi,
    useDebugValue: Ai,
    useDeferredValue: function(_e) {
        return ci().memoizedState = _e
    },
    useTransition: function() {
        var _e = qi(!1)
          , et = _e[0];
        return _e = Ei.bind(null, _e[1]),
        ci().memoizedState = _e,
        [et, _e]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(_e, et, tt) {
        var rt = N$3
          , nt = ci();
        if (I$3) {
            if (tt === void 0)
                throw Error(p$8(407));
            tt = tt()
        } else {
            if (tt = et(),
            R$3 === null)
                throw Error(p$8(349));
            Rh & 30 || ni(rt, et, tt)
        }
        nt.memoizedState = tt;
        var it = {
            value: tt,
            getSnapshot: et
        };
        return nt.queue = it,
        vi(ki.bind(null, rt, it, _e), [_e]),
        rt.flags |= 2048,
        li(9, mi.bind(null, rt, it, tt, et), void 0, null),
        tt
    },
    useId: function() {
        var _e = ci()
          , et = R$3.identifierPrefix;
        if (I$3) {
            var tt = sg
              , rt = rg;
            tt = (rt & ~(1 << 32 - oc(rt) - 1)).toString(32) + tt,
            et = ":" + et + "R" + tt,
            tt = Uh++,
            0 < tt && (et += "H" + tt.toString(32)),
            et += ":"
        } else
            tt = Vh++,
            et = ":" + et + "r" + tt.toString(32) + ":";
        return _e.memoizedState = et
    },
    unstable_isNewReconciler: !1
}
  , Zh = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: fi,
    useRef: si,
    useState: function() {
        return fi(ei)
    },
    useDebugValue: Ai,
    useDeferredValue: function(_e) {
        var et = di();
        return Di(et, O$1.memoizedState, _e)
    },
    useTransition: function() {
        var _e = fi(ei)[0]
          , et = di().memoizedState;
        return [_e, et]
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
}
  , $h = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: gi,
    useRef: si,
    useState: function() {
        return gi(ei)
    },
    useDebugValue: Ai,
    useDeferredValue: function(_e) {
        var et = di();
        return O$1 === null ? et.memoizedState = _e : Di(et, O$1.memoizedState, _e)
    },
    useTransition: function() {
        var _e = gi(ei)[0]
          , et = di().memoizedState;
        return [_e, et]
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
};
function Ki(_e, et) {
    try {
        var tt = ""
          , rt = et;
        do
            tt += Pa(rt),
            rt = rt.return;
        while (rt);
        var nt = tt
    } catch (it) {
        nt = `
Error generating stack: ` + it.message + `
` + it.stack
    }
    return {
        value: _e,
        source: et,
        stack: nt,
        digest: null
    }
}
function Li(_e, et, tt) {
    return {
        value: _e,
        source: null,
        stack: tt ?? null,
        digest: et ?? null
    }
}
function Mi(_e, et) {
    try {
        console.error(et.value)
    } catch (tt) {
        setTimeout(function() {
            throw tt
        })
    }
}
var Ni = typeof WeakMap == "function" ? WeakMap : Map;
function Oi(_e, et, tt) {
    tt = ch(-1, tt),
    tt.tag = 3,
    tt.payload = {
        element: null
    };
    var rt = et.value;
    return tt.callback = function() {
        Pi || (Pi = !0,
        Qi = rt),
        Mi(_e, et)
    }
    ,
    tt
}
function Ri(_e, et, tt) {
    tt = ch(-1, tt),
    tt.tag = 3;
    var rt = _e.type.getDerivedStateFromError;
    if (typeof rt == "function") {
        var nt = et.value;
        tt.payload = function() {
            return rt(nt)
        }
        ,
        tt.callback = function() {
            Mi(_e, et)
        }
    }
    var it = _e.stateNode;
    return it !== null && typeof it.componentDidCatch == "function" && (tt.callback = function() {
        Mi(_e, et),
        typeof rt != "function" && (Si === null ? Si = new Set([this]) : Si.add(this));
        var st = et.stack;
        this.componentDidCatch(et.value, {
            componentStack: st !== null ? st : ""
        })
    }
    ),
    tt
}
function Ti(_e, et, tt) {
    var rt = _e.pingCache;
    if (rt === null) {
        rt = _e.pingCache = new Ni;
        var nt = new Set;
        rt.set(et, nt)
    } else
        nt = rt.get(et),
        nt === void 0 && (nt = new Set,
        rt.set(et, nt));
    nt.has(tt) || (nt.add(tt),
    _e = Ui.bind(null, _e, et, tt),
    et.then(_e, _e))
}
function Vi(_e) {
    do {
        var et;
        if ((et = _e.tag === 13) && (et = _e.memoizedState,
        et = et !== null ? et.dehydrated !== null : !0),
        et)
            return _e;
        _e = _e.return
    } while (_e !== null);
    return null
}
function Wi(_e, et, tt, rt, nt) {
    return _e.mode & 1 ? (_e.flags |= 65536,
    _e.lanes = nt,
    _e) : (_e === et ? _e.flags |= 65536 : (_e.flags |= 128,
    tt.flags |= 131072,
    tt.flags &= -52805,
    tt.tag === 1 && (tt.alternate === null ? tt.tag = 17 : (et = ch(-1, 1),
    et.tag = 2,
    dh(tt, et, 1))),
    tt.lanes |= 1),
    _e)
}
var Xi = ua.ReactCurrentOwner
  , Ug = !1;
function Yi(_e, et, tt, rt) {
    et.child = _e === null ? Ch(et, null, tt, rt) : Bh(et, _e.child, tt, rt)
}
function Zi(_e, et, tt, rt, nt) {
    tt = tt.render;
    var it = et.ref;
    return Tg(et, nt),
    rt = Xh(_e, et, tt, rt, it, nt),
    tt = bi(),
    _e !== null && !Ug ? (et.updateQueue = _e.updateQueue,
    et.flags &= -2053,
    _e.lanes &= ~nt,
    $i(_e, et, nt)) : (I$3 && tt && vg(et),
    et.flags |= 1,
    Yi(_e, et, rt, nt),
    et.child)
}
function aj(_e, et, tt, rt, nt) {
    if (_e === null) {
        var it = tt.type;
        return typeof it == "function" && !bj(it) && it.defaultProps === void 0 && tt.compare === null && tt.defaultProps === void 0 ? (et.tag = 15,
        et.type = it,
        cj(_e, et, it, rt, nt)) : (_e = yh(tt.type, null, rt, et, et.mode, nt),
        _e.ref = et.ref,
        _e.return = et,
        et.child = _e)
    }
    if (it = _e.child,
    !(_e.lanes & nt)) {
        var st = it.memoizedProps;
        if (tt = tt.compare,
        tt = tt !== null ? tt : Ie,
        tt(st, rt) && _e.ref === et.ref)
            return $i(_e, et, nt)
    }
    return et.flags |= 1,
    _e = wh(it, rt),
    _e.ref = et.ref,
    _e.return = et,
    et.child = _e
}
function cj(_e, et, tt, rt, nt) {
    if (_e !== null) {
        var it = _e.memoizedProps;
        if (Ie(it, rt) && _e.ref === et.ref)
            if (Ug = !1,
            et.pendingProps = rt = it,
            (_e.lanes & nt) !== 0)
                _e.flags & 131072 && (Ug = !0);
            else
                return et.lanes = _e.lanes,
                $i(_e, et, nt)
    }
    return dj(_e, et, tt, rt, nt)
}
function ej(_e, et, tt) {
    var rt = et.pendingProps
      , nt = rt.children
      , it = _e !== null ? _e.memoizedState : null;
    if (rt.mode === "hidden")
        if (!(et.mode & 1))
            et.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G(fj, gj),
            gj |= tt;
        else {
            if (!(tt & 1073741824))
                return _e = it !== null ? it.baseLanes | tt : tt,
                et.lanes = et.childLanes = 1073741824,
                et.memoizedState = {
                    baseLanes: _e,
                    cachePool: null,
                    transitions: null
                },
                et.updateQueue = null,
                G(fj, gj),
                gj |= _e,
                null;
            et.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            rt = it !== null ? it.baseLanes : tt,
            G(fj, gj),
            gj |= rt
        }
    else
        it !== null ? (rt = it.baseLanes | tt,
        et.memoizedState = null) : rt = tt,
        G(fj, gj),
        gj |= rt;
    return Yi(_e, et, nt, tt),
    et.child
}
function hj(_e, et) {
    var tt = et.ref;
    (_e === null && tt !== null || _e !== null && _e.ref !== tt) && (et.flags |= 512,
    et.flags |= 2097152)
}
function dj(_e, et, tt, rt, nt) {
    var it = Zf(tt) ? Xf : H$3.current;
    return it = Yf(et, it),
    Tg(et, nt),
    tt = Xh(_e, et, tt, rt, it, nt),
    rt = bi(),
    _e !== null && !Ug ? (et.updateQueue = _e.updateQueue,
    et.flags &= -2053,
    _e.lanes &= ~nt,
    $i(_e, et, nt)) : (I$3 && rt && vg(et),
    et.flags |= 1,
    Yi(_e, et, tt, nt),
    et.child)
}
function ij(_e, et, tt, rt, nt) {
    if (Zf(tt)) {
        var it = !0;
        cg(et)
    } else
        it = !1;
    if (Tg(et, nt),
    et.stateNode === null)
        jj(_e, et),
        ph(et, tt, rt),
        rh(et, tt, rt, nt),
        rt = !0;
    else if (_e === null) {
        var st = et.stateNode
          , at = et.memoizedProps;
        st.props = at;
        var ot = st.context
          , lt = tt.contextType;
        typeof lt == "object" && lt !== null ? lt = Vg(lt) : (lt = Zf(tt) ? Xf : H$3.current,
        lt = Yf(et, lt));
        var dt = tt.getDerivedStateFromProps
          , ct = typeof dt == "function" || typeof st.getSnapshotBeforeUpdate == "function";
        ct || typeof st.UNSAFE_componentWillReceiveProps != "function" && typeof st.componentWillReceiveProps != "function" || (at !== rt || ot !== lt) && qh(et, st, rt, lt),
        $g = !1;
        var ut = et.memoizedState;
        st.state = ut,
        gh(et, rt, st, nt),
        ot = et.memoizedState,
        at !== rt || ut !== ot || Wf.current || $g ? (typeof dt == "function" && (kh(et, tt, dt, rt),
        ot = et.memoizedState),
        (at = $g || oh(et, tt, at, rt, ut, ot, lt)) ? (ct || typeof st.UNSAFE_componentWillMount != "function" && typeof st.componentWillMount != "function" || (typeof st.componentWillMount == "function" && st.componentWillMount(),
        typeof st.UNSAFE_componentWillMount == "function" && st.UNSAFE_componentWillMount()),
        typeof st.componentDidMount == "function" && (et.flags |= 4194308)) : (typeof st.componentDidMount == "function" && (et.flags |= 4194308),
        et.memoizedProps = rt,
        et.memoizedState = ot),
        st.props = rt,
        st.state = ot,
        st.context = lt,
        rt = at) : (typeof st.componentDidMount == "function" && (et.flags |= 4194308),
        rt = !1)
    } else {
        st = et.stateNode,
        bh(_e, et),
        at = et.memoizedProps,
        lt = et.type === et.elementType ? at : Lg(et.type, at),
        st.props = lt,
        ct = et.pendingProps,
        ut = st.context,
        ot = tt.contextType,
        typeof ot == "object" && ot !== null ? ot = Vg(ot) : (ot = Zf(tt) ? Xf : H$3.current,
        ot = Yf(et, ot));
        var ft = tt.getDerivedStateFromProps;
        (dt = typeof ft == "function" || typeof st.getSnapshotBeforeUpdate == "function") || typeof st.UNSAFE_componentWillReceiveProps != "function" && typeof st.componentWillReceiveProps != "function" || (at !== ct || ut !== ot) && qh(et, st, rt, ot),
        $g = !1,
        ut = et.memoizedState,
        st.state = ut,
        gh(et, rt, st, nt);
        var ht = et.memoizedState;
        at !== ct || ut !== ht || Wf.current || $g ? (typeof ft == "function" && (kh(et, tt, ft, rt),
        ht = et.memoizedState),
        (lt = $g || oh(et, tt, lt, rt, ut, ht, ot) || !1) ? (dt || typeof st.UNSAFE_componentWillUpdate != "function" && typeof st.componentWillUpdate != "function" || (typeof st.componentWillUpdate == "function" && st.componentWillUpdate(rt, ht, ot),
        typeof st.UNSAFE_componentWillUpdate == "function" && st.UNSAFE_componentWillUpdate(rt, ht, ot)),
        typeof st.componentDidUpdate == "function" && (et.flags |= 4),
        typeof st.getSnapshotBeforeUpdate == "function" && (et.flags |= 1024)) : (typeof st.componentDidUpdate != "function" || at === _e.memoizedProps && ut === _e.memoizedState || (et.flags |= 4),
        typeof st.getSnapshotBeforeUpdate != "function" || at === _e.memoizedProps && ut === _e.memoizedState || (et.flags |= 1024),
        et.memoizedProps = rt,
        et.memoizedState = ht),
        st.props = rt,
        st.state = ht,
        st.context = ot,
        rt = lt) : (typeof st.componentDidUpdate != "function" || at === _e.memoizedProps && ut === _e.memoizedState || (et.flags |= 4),
        typeof st.getSnapshotBeforeUpdate != "function" || at === _e.memoizedProps && ut === _e.memoizedState || (et.flags |= 1024),
        rt = !1)
    }
    return kj(_e, et, tt, rt, it, nt)
}
function kj(_e, et, tt, rt, nt, it) {
    hj(_e, et);
    var st = (et.flags & 128) !== 0;
    if (!rt && !st)
        return nt && dg(et, tt, !1),
        $i(_e, et, it);
    rt = et.stateNode,
    Xi.current = et;
    var at = st && typeof tt.getDerivedStateFromError != "function" ? null : rt.render();
    return et.flags |= 1,
    _e !== null && st ? (et.child = Bh(et, _e.child, null, it),
    et.child = Bh(et, null, at, it)) : Yi(_e, et, at, it),
    et.memoizedState = rt.state,
    nt && dg(et, tt, !0),
    et.child
}
function lj(_e) {
    var et = _e.stateNode;
    et.pendingContext ? ag(_e, et.pendingContext, et.pendingContext !== et.context) : et.context && ag(_e, et.context, !1),
    Ih(_e, et.containerInfo)
}
function mj(_e, et, tt, rt, nt) {
    return Ig(),
    Jg(nt),
    et.flags |= 256,
    Yi(_e, et, tt, rt),
    et.child
}
var nj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function oj(_e) {
    return {
        baseLanes: _e,
        cachePool: null,
        transitions: null
    }
}
function pj(_e, et, tt) {
    var rt = et.pendingProps, nt = M$3.current, it = !1, st = (et.flags & 128) !== 0, at;
    if ((at = st) || (at = _e !== null && _e.memoizedState === null ? !1 : (nt & 2) !== 0),
    at ? (it = !0,
    et.flags &= -129) : (_e === null || _e.memoizedState !== null) && (nt |= 1),
    G(M$3, nt & 1),
    _e === null)
        return Eg(et),
        _e = et.memoizedState,
        _e !== null && (_e = _e.dehydrated,
        _e !== null) ? (et.mode & 1 ? _e.data === "$!" ? et.lanes = 8 : et.lanes = 1073741824 : et.lanes = 1,
        null) : (st = rt.children,
        _e = rt.fallback,
        it ? (rt = et.mode,
        it = et.child,
        st = {
            mode: "hidden",
            children: st
        },
        !(rt & 1) && it !== null ? (it.childLanes = 0,
        it.pendingProps = st) : it = qj(st, rt, 0, null),
        _e = Ah(_e, rt, tt, null),
        it.return = et,
        _e.return = et,
        it.sibling = _e,
        et.child = it,
        et.child.memoizedState = oj(tt),
        et.memoizedState = nj,
        _e) : rj(et, st));
    if (nt = _e.memoizedState,
    nt !== null && (at = nt.dehydrated,
    at !== null))
        return sj(_e, et, st, rt, at, nt, tt);
    if (it) {
        it = rt.fallback,
        st = et.mode,
        nt = _e.child,
        at = nt.sibling;
        var ot = {
            mode: "hidden",
            children: rt.children
        };
        return !(st & 1) && et.child !== nt ? (rt = et.child,
        rt.childLanes = 0,
        rt.pendingProps = ot,
        et.deletions = null) : (rt = wh(nt, ot),
        rt.subtreeFlags = nt.subtreeFlags & 14680064),
        at !== null ? it = wh(at, it) : (it = Ah(it, st, tt, null),
        it.flags |= 2),
        it.return = et,
        rt.return = et,
        rt.sibling = it,
        et.child = rt,
        rt = it,
        it = et.child,
        st = _e.child.memoizedState,
        st = st === null ? oj(tt) : {
            baseLanes: st.baseLanes | tt,
            cachePool: null,
            transitions: st.transitions
        },
        it.memoizedState = st,
        it.childLanes = _e.childLanes & ~tt,
        et.memoizedState = nj,
        rt
    }
    return it = _e.child,
    _e = it.sibling,
    rt = wh(it, {
        mode: "visible",
        children: rt.children
    }),
    !(et.mode & 1) && (rt.lanes = tt),
    rt.return = et,
    rt.sibling = null,
    _e !== null && (tt = et.deletions,
    tt === null ? (et.deletions = [_e],
    et.flags |= 16) : tt.push(_e)),
    et.child = rt,
    et.memoizedState = null,
    rt
}
function rj(_e, et) {
    return et = qj({
        mode: "visible",
        children: et
    }, _e.mode, 0, null),
    et.return = _e,
    _e.child = et
}
function tj(_e, et, tt, rt) {
    return rt !== null && Jg(rt),
    Bh(et, _e.child, null, tt),
    _e = rj(et, et.pendingProps.children),
    _e.flags |= 2,
    et.memoizedState = null,
    _e
}
function sj(_e, et, tt, rt, nt, it, st) {
    if (tt)
        return et.flags & 256 ? (et.flags &= -257,
        rt = Li(Error(p$8(422))),
        tj(_e, et, st, rt)) : et.memoizedState !== null ? (et.child = _e.child,
        et.flags |= 128,
        null) : (it = rt.fallback,
        nt = et.mode,
        rt = qj({
            mode: "visible",
            children: rt.children
        }, nt, 0, null),
        it = Ah(it, nt, st, null),
        it.flags |= 2,
        rt.return = et,
        it.return = et,
        rt.sibling = it,
        et.child = rt,
        et.mode & 1 && Bh(et, _e.child, null, st),
        et.child.memoizedState = oj(st),
        et.memoizedState = nj,
        it);
    if (!(et.mode & 1))
        return tj(_e, et, st, null);
    if (nt.data === "$!") {
        if (rt = nt.nextSibling && nt.nextSibling.dataset,
        rt)
            var at = rt.dgst;
        return rt = at,
        it = Error(p$8(419)),
        rt = Li(it, rt, void 0),
        tj(_e, et, st, rt)
    }
    if (at = (st & _e.childLanes) !== 0,
    Ug || at) {
        if (rt = R$3,
        rt !== null) {
            switch (st & -st) {
            case 4:
                nt = 2;
                break;
            case 16:
                nt = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                nt = 32;
                break;
            case 536870912:
                nt = 268435456;
                break;
            default:
                nt = 0
            }
            nt = nt & (rt.suspendedLanes | st) ? 0 : nt,
            nt !== 0 && nt !== it.retryLane && (it.retryLane = nt,
            Zg(_e, nt),
            mh(rt, _e, nt, -1))
        }
        return uj(),
        rt = Li(Error(p$8(421))),
        tj(_e, et, st, rt)
    }
    return nt.data === "$?" ? (et.flags |= 128,
    et.child = _e.child,
    et = vj.bind(null, _e),
    nt._reactRetry = et,
    null) : (_e = it.treeContext,
    yg = Lf(nt.nextSibling),
    xg = et,
    I$3 = !0,
    zg = null,
    _e !== null && (og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    rg = _e.id,
    sg = _e.overflow,
    qg = et),
    et = rj(et, rt.children),
    et.flags |= 4096,
    et)
}
function wj(_e, et, tt) {
    _e.lanes |= et;
    var rt = _e.alternate;
    rt !== null && (rt.lanes |= et),
    Sg(_e.return, et, tt)
}
function xj(_e, et, tt, rt, nt) {
    var it = _e.memoizedState;
    it === null ? _e.memoizedState = {
        isBackwards: et,
        rendering: null,
        renderingStartTime: 0,
        last: rt,
        tail: tt,
        tailMode: nt
    } : (it.isBackwards = et,
    it.rendering = null,
    it.renderingStartTime = 0,
    it.last = rt,
    it.tail = tt,
    it.tailMode = nt)
}
function yj(_e, et, tt) {
    var rt = et.pendingProps
      , nt = rt.revealOrder
      , it = rt.tail;
    if (Yi(_e, et, rt.children, tt),
    rt = M$3.current,
    rt & 2)
        rt = rt & 1 | 2,
        et.flags |= 128;
    else {
        if (_e !== null && _e.flags & 128)
            e: for (_e = et.child; _e !== null; ) {
                if (_e.tag === 13)
                    _e.memoizedState !== null && wj(_e, tt, et);
                else if (_e.tag === 19)
                    wj(_e, tt, et);
                else if (_e.child !== null) {
                    _e.child.return = _e,
                    _e = _e.child;
                    continue
                }
                if (_e === et)
                    break e;
                for (; _e.sibling === null; ) {
                    if (_e.return === null || _e.return === et)
                        break e;
                    _e = _e.return
                }
                _e.sibling.return = _e.return,
                _e = _e.sibling
            }
        rt &= 1
    }
    if (G(M$3, rt),
    !(et.mode & 1))
        et.memoizedState = null;
    else
        switch (nt) {
        case "forwards":
            for (tt = et.child,
            nt = null; tt !== null; )
                _e = tt.alternate,
                _e !== null && Mh(_e) === null && (nt = tt),
                tt = tt.sibling;
            tt = nt,
            tt === null ? (nt = et.child,
            et.child = null) : (nt = tt.sibling,
            tt.sibling = null),
            xj(et, !1, nt, tt, it);
            break;
        case "backwards":
            for (tt = null,
            nt = et.child,
            et.child = null; nt !== null; ) {
                if (_e = nt.alternate,
                _e !== null && Mh(_e) === null) {
                    et.child = nt;
                    break
                }
                _e = nt.sibling,
                nt.sibling = tt,
                tt = nt,
                nt = _e
            }
            xj(et, !0, tt, null, it);
            break;
        case "together":
            xj(et, !1, null, null, void 0);
            break;
        default:
            et.memoizedState = null
        }
    return et.child
}
function jj(_e, et) {
    !(et.mode & 1) && _e !== null && (_e.alternate = null,
    et.alternate = null,
    et.flags |= 2)
}
function $i(_e, et, tt) {
    if (_e !== null && (et.dependencies = _e.dependencies),
    hh |= et.lanes,
    !(tt & et.childLanes))
        return null;
    if (_e !== null && et.child !== _e.child)
        throw Error(p$8(153));
    if (et.child !== null) {
        for (_e = et.child,
        tt = wh(_e, _e.pendingProps),
        et.child = tt,
        tt.return = et; _e.sibling !== null; )
            _e = _e.sibling,
            tt = tt.sibling = wh(_e, _e.pendingProps),
            tt.return = et;
        tt.sibling = null
    }
    return et.child
}
function zj(_e, et, tt) {
    switch (et.tag) {
    case 3:
        lj(et),
        Ig();
        break;
    case 5:
        Kh(et);
        break;
    case 1:
        Zf(et.type) && cg(et);
        break;
    case 4:
        Ih(et, et.stateNode.containerInfo);
        break;
    case 10:
        var rt = et.type._context
          , nt = et.memoizedProps.value;
        G(Mg, rt._currentValue),
        rt._currentValue = nt;
        break;
    case 13:
        if (rt = et.memoizedState,
        rt !== null)
            return rt.dehydrated !== null ? (G(M$3, M$3.current & 1),
            et.flags |= 128,
            null) : tt & et.child.childLanes ? pj(_e, et, tt) : (G(M$3, M$3.current & 1),
            _e = $i(_e, et, tt),
            _e !== null ? _e.sibling : null);
        G(M$3, M$3.current & 1);
        break;
    case 19:
        if (rt = (tt & et.childLanes) !== 0,
        _e.flags & 128) {
            if (rt)
                return yj(_e, et, tt);
            et.flags |= 128
        }
        if (nt = et.memoizedState,
        nt !== null && (nt.rendering = null,
        nt.tail = null,
        nt.lastEffect = null),
        G(M$3, M$3.current),
        rt)
            break;
        return null;
    case 22:
    case 23:
        return et.lanes = 0,
        ej(_e, et, tt)
    }
    return $i(_e, et, tt)
}
var Aj, Bj, Cj, Dj;
Aj = function(_e, et) {
    for (var tt = et.child; tt !== null; ) {
        if (tt.tag === 5 || tt.tag === 6)
            _e.appendChild(tt.stateNode);
        else if (tt.tag !== 4 && tt.child !== null) {
            tt.child.return = tt,
            tt = tt.child;
            continue
        }
        if (tt === et)
            break;
        for (; tt.sibling === null; ) {
            if (tt.return === null || tt.return === et)
                return;
            tt = tt.return
        }
        tt.sibling.return = tt.return,
        tt = tt.sibling
    }
}
;
Bj = function() {}
;
Cj = function(_e, et, tt, rt) {
    var nt = _e.memoizedProps;
    if (nt !== rt) {
        _e = et.stateNode,
        Hh(Eh.current);
        var it = null;
        switch (tt) {
        case "input":
            nt = Ya(_e, nt),
            rt = Ya(_e, rt),
            it = [];
            break;
        case "select":
            nt = A$3({}, nt, {
                value: void 0
            }),
            rt = A$3({}, rt, {
                value: void 0
            }),
            it = [];
            break;
        case "textarea":
            nt = gb(_e, nt),
            rt = gb(_e, rt),
            it = [];
            break;
        default:
            typeof nt.onClick != "function" && typeof rt.onClick == "function" && (_e.onclick = Bf)
        }
        ub(tt, rt);
        var st;
        tt = null;
        for (lt in nt)
            if (!rt.hasOwnProperty(lt) && nt.hasOwnProperty(lt) && nt[lt] != null)
                if (lt === "style") {
                    var at = nt[lt];
                    for (st in at)
                        at.hasOwnProperty(st) && (tt || (tt = {}),
                        tt[st] = "")
                } else
                    lt !== "dangerouslySetInnerHTML" && lt !== "children" && lt !== "suppressContentEditableWarning" && lt !== "suppressHydrationWarning" && lt !== "autoFocus" && (ea.hasOwnProperty(lt) ? it || (it = []) : (it = it || []).push(lt, null));
        for (lt in rt) {
            var ot = rt[lt];
            if (at = nt != null ? nt[lt] : void 0,
            rt.hasOwnProperty(lt) && ot !== at && (ot != null || at != null))
                if (lt === "style")
                    if (at) {
                        for (st in at)
                            !at.hasOwnProperty(st) || ot && ot.hasOwnProperty(st) || (tt || (tt = {}),
                            tt[st] = "");
                        for (st in ot)
                            ot.hasOwnProperty(st) && at[st] !== ot[st] && (tt || (tt = {}),
                            tt[st] = ot[st])
                    } else
                        tt || (it || (it = []),
                        it.push(lt, tt)),
                        tt = ot;
                else
                    lt === "dangerouslySetInnerHTML" ? (ot = ot ? ot.__html : void 0,
                    at = at ? at.__html : void 0,
                    ot != null && at !== ot && (it = it || []).push(lt, ot)) : lt === "children" ? typeof ot != "string" && typeof ot != "number" || (it = it || []).push(lt, "" + ot) : lt !== "suppressContentEditableWarning" && lt !== "suppressHydrationWarning" && (ea.hasOwnProperty(lt) ? (ot != null && lt === "onScroll" && D$1("scroll", _e),
                    it || at === ot || (it = [])) : (it = it || []).push(lt, ot))
        }
        tt && (it = it || []).push("style", tt);
        var lt = it;
        (et.updateQueue = lt) && (et.flags |= 4)
    }
}
;
Dj = function(_e, et, tt, rt) {
    tt !== rt && (et.flags |= 4)
}
;
function Ej(_e, et) {
    if (!I$3)
        switch (_e.tailMode) {
        case "hidden":
            et = _e.tail;
            for (var tt = null; et !== null; )
                et.alternate !== null && (tt = et),
                et = et.sibling;
            tt === null ? _e.tail = null : tt.sibling = null;
            break;
        case "collapsed":
            tt = _e.tail;
            for (var rt = null; tt !== null; )
                tt.alternate !== null && (rt = tt),
                tt = tt.sibling;
            rt === null ? et || _e.tail === null ? _e.tail = null : _e.tail.sibling = null : rt.sibling = null
        }
}
function S$5(_e) {
    var et = _e.alternate !== null && _e.alternate.child === _e.child
      , tt = 0
      , rt = 0;
    if (et)
        for (var nt = _e.child; nt !== null; )
            tt |= nt.lanes | nt.childLanes,
            rt |= nt.subtreeFlags & 14680064,
            rt |= nt.flags & 14680064,
            nt.return = _e,
            nt = nt.sibling;
    else
        for (nt = _e.child; nt !== null; )
            tt |= nt.lanes | nt.childLanes,
            rt |= nt.subtreeFlags,
            rt |= nt.flags,
            nt.return = _e,
            nt = nt.sibling;
    return _e.subtreeFlags |= rt,
    _e.childLanes = tt,
    et
}
function Fj(_e, et, tt) {
    var rt = et.pendingProps;
    switch (wg(et),
    et.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return S$5(et),
        null;
    case 1:
        return Zf(et.type) && $f(),
        S$5(et),
        null;
    case 3:
        return rt = et.stateNode,
        Jh(),
        E$3(Wf),
        E$3(H$3),
        Oh(),
        rt.pendingContext && (rt.context = rt.pendingContext,
        rt.pendingContext = null),
        (_e === null || _e.child === null) && (Gg(et) ? et.flags |= 4 : _e === null || _e.memoizedState.isDehydrated && !(et.flags & 256) || (et.flags |= 1024,
        zg !== null && (Gj(zg),
        zg = null))),
        Bj(_e, et),
        S$5(et),
        null;
    case 5:
        Lh(et);
        var nt = Hh(Gh.current);
        if (tt = et.type,
        _e !== null && et.stateNode != null)
            Cj(_e, et, tt, rt, nt),
            _e.ref !== et.ref && (et.flags |= 512,
            et.flags |= 2097152);
        else {
            if (!rt) {
                if (et.stateNode === null)
                    throw Error(p$8(166));
                return S$5(et),
                null
            }
            if (_e = Hh(Eh.current),
            Gg(et)) {
                rt = et.stateNode,
                tt = et.type;
                var it = et.memoizedProps;
                switch (rt[Of] = et,
                rt[Pf] = it,
                _e = (et.mode & 1) !== 0,
                tt) {
                case "dialog":
                    D$1("cancel", rt),
                    D$1("close", rt);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D$1("load", rt);
                    break;
                case "video":
                case "audio":
                    for (nt = 0; nt < lf.length; nt++)
                        D$1(lf[nt], rt);
                    break;
                case "source":
                    D$1("error", rt);
                    break;
                case "img":
                case "image":
                case "link":
                    D$1("error", rt),
                    D$1("load", rt);
                    break;
                case "details":
                    D$1("toggle", rt);
                    break;
                case "input":
                    Za(rt, it),
                    D$1("invalid", rt);
                    break;
                case "select":
                    rt._wrapperState = {
                        wasMultiple: !!it.multiple
                    },
                    D$1("invalid", rt);
                    break;
                case "textarea":
                    hb(rt, it),
                    D$1("invalid", rt)
                }
                ub(tt, it),
                nt = null;
                for (var st in it)
                    if (it.hasOwnProperty(st)) {
                        var at = it[st];
                        st === "children" ? typeof at == "string" ? rt.textContent !== at && (it.suppressHydrationWarning !== !0 && Af(rt.textContent, at, _e),
                        nt = ["children", at]) : typeof at == "number" && rt.textContent !== "" + at && (it.suppressHydrationWarning !== !0 && Af(rt.textContent, at, _e),
                        nt = ["children", "" + at]) : ea.hasOwnProperty(st) && at != null && st === "onScroll" && D$1("scroll", rt)
                    }
                switch (tt) {
                case "input":
                    Va(rt),
                    db(rt, it, !0);
                    break;
                case "textarea":
                    Va(rt),
                    jb(rt);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof it.onClick == "function" && (rt.onclick = Bf)
                }
                rt = nt,
                et.updateQueue = rt,
                rt !== null && (et.flags |= 4)
            } else {
                st = nt.nodeType === 9 ? nt : nt.ownerDocument,
                _e === "http://www.w3.org/1999/xhtml" && (_e = kb(tt)),
                _e === "http://www.w3.org/1999/xhtml" ? tt === "script" ? (_e = st.createElement("div"),
                _e.innerHTML = "<script><\/script>",
                _e = _e.removeChild(_e.firstChild)) : typeof rt.is == "string" ? _e = st.createElement(tt, {
                    is: rt.is
                }) : (_e = st.createElement(tt),
                tt === "select" && (st = _e,
                rt.multiple ? st.multiple = !0 : rt.size && (st.size = rt.size))) : _e = st.createElementNS(_e, tt),
                _e[Of] = et,
                _e[Pf] = rt,
                Aj(_e, et, !1, !1),
                et.stateNode = _e;
                e: {
                    switch (st = vb(tt, rt),
                    tt) {
                    case "dialog":
                        D$1("cancel", _e),
                        D$1("close", _e),
                        nt = rt;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D$1("load", _e),
                        nt = rt;
                        break;
                    case "video":
                    case "audio":
                        for (nt = 0; nt < lf.length; nt++)
                            D$1(lf[nt], _e);
                        nt = rt;
                        break;
                    case "source":
                        D$1("error", _e),
                        nt = rt;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D$1("error", _e),
                        D$1("load", _e),
                        nt = rt;
                        break;
                    case "details":
                        D$1("toggle", _e),
                        nt = rt;
                        break;
                    case "input":
                        Za(_e, rt),
                        nt = Ya(_e, rt),
                        D$1("invalid", _e);
                        break;
                    case "option":
                        nt = rt;
                        break;
                    case "select":
                        _e._wrapperState = {
                            wasMultiple: !!rt.multiple
                        },
                        nt = A$3({}, rt, {
                            value: void 0
                        }),
                        D$1("invalid", _e);
                        break;
                    case "textarea":
                        hb(_e, rt),
                        nt = gb(_e, rt),
                        D$1("invalid", _e);
                        break;
                    default:
                        nt = rt
                    }
                    ub(tt, nt),
                    at = nt;
                    for (it in at)
                        if (at.hasOwnProperty(it)) {
                            var ot = at[it];
                            it === "style" ? sb(_e, ot) : it === "dangerouslySetInnerHTML" ? (ot = ot ? ot.__html : void 0,
                            ot != null && nb(_e, ot)) : it === "children" ? typeof ot == "string" ? (tt !== "textarea" || ot !== "") && ob(_e, ot) : typeof ot == "number" && ob(_e, "" + ot) : it !== "suppressContentEditableWarning" && it !== "suppressHydrationWarning" && it !== "autoFocus" && (ea.hasOwnProperty(it) ? ot != null && it === "onScroll" && D$1("scroll", _e) : ot != null && ta(_e, it, ot, st))
                        }
                    switch (tt) {
                    case "input":
                        Va(_e),
                        db(_e, rt, !1);
                        break;
                    case "textarea":
                        Va(_e),
                        jb(_e);
                        break;
                    case "option":
                        rt.value != null && _e.setAttribute("value", "" + Sa(rt.value));
                        break;
                    case "select":
                        _e.multiple = !!rt.multiple,
                        it = rt.value,
                        it != null ? fb(_e, !!rt.multiple, it, !1) : rt.defaultValue != null && fb(_e, !!rt.multiple, rt.defaultValue, !0);
                        break;
                    default:
                        typeof nt.onClick == "function" && (_e.onclick = Bf)
                    }
                    switch (tt) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        rt = !!rt.autoFocus;
                        break e;
                    case "img":
                        rt = !0;
                        break e;
                    default:
                        rt = !1
                    }
                }
                rt && (et.flags |= 4)
            }
            et.ref !== null && (et.flags |= 512,
            et.flags |= 2097152)
        }
        return S$5(et),
        null;
    case 6:
        if (_e && et.stateNode != null)
            Dj(_e, et, _e.memoizedProps, rt);
        else {
            if (typeof rt != "string" && et.stateNode === null)
                throw Error(p$8(166));
            if (tt = Hh(Gh.current),
            Hh(Eh.current),
            Gg(et)) {
                if (rt = et.stateNode,
                tt = et.memoizedProps,
                rt[Of] = et,
                (it = rt.nodeValue !== tt) && (_e = xg,
                _e !== null))
                    switch (_e.tag) {
                    case 3:
                        Af(rt.nodeValue, tt, (_e.mode & 1) !== 0);
                        break;
                    case 5:
                        _e.memoizedProps.suppressHydrationWarning !== !0 && Af(rt.nodeValue, tt, (_e.mode & 1) !== 0)
                    }
                it && (et.flags |= 4)
            } else
                rt = (tt.nodeType === 9 ? tt : tt.ownerDocument).createTextNode(rt),
                rt[Of] = et,
                et.stateNode = rt
        }
        return S$5(et),
        null;
    case 13:
        if (E$3(M$3),
        rt = et.memoizedState,
        _e === null || _e.memoizedState !== null && _e.memoizedState.dehydrated !== null) {
            if (I$3 && yg !== null && et.mode & 1 && !(et.flags & 128))
                Hg(),
                Ig(),
                et.flags |= 98560,
                it = !1;
            else if (it = Gg(et),
            rt !== null && rt.dehydrated !== null) {
                if (_e === null) {
                    if (!it)
                        throw Error(p$8(318));
                    if (it = et.memoizedState,
                    it = it !== null ? it.dehydrated : null,
                    !it)
                        throw Error(p$8(317));
                    it[Of] = et
                } else
                    Ig(),
                    !(et.flags & 128) && (et.memoizedState = null),
                    et.flags |= 4;
                S$5(et),
                it = !1
            } else
                zg !== null && (Gj(zg),
                zg = null),
                it = !0;
            if (!it)
                return et.flags & 65536 ? et : null
        }
        return et.flags & 128 ? (et.lanes = tt,
        et) : (rt = rt !== null,
        rt !== (_e !== null && _e.memoizedState !== null) && rt && (et.child.flags |= 8192,
        et.mode & 1 && (_e === null || M$3.current & 1 ? T$3 === 0 && (T$3 = 3) : uj())),
        et.updateQueue !== null && (et.flags |= 4),
        S$5(et),
        null);
    case 4:
        return Jh(),
        Bj(_e, et),
        _e === null && sf(et.stateNode.containerInfo),
        S$5(et),
        null;
    case 10:
        return Rg(et.type._context),
        S$5(et),
        null;
    case 17:
        return Zf(et.type) && $f(),
        S$5(et),
        null;
    case 19:
        if (E$3(M$3),
        it = et.memoizedState,
        it === null)
            return S$5(et),
            null;
        if (rt = (et.flags & 128) !== 0,
        st = it.rendering,
        st === null)
            if (rt)
                Ej(it, !1);
            else {
                if (T$3 !== 0 || _e !== null && _e.flags & 128)
                    for (_e = et.child; _e !== null; ) {
                        if (st = Mh(_e),
                        st !== null) {
                            for (et.flags |= 128,
                            Ej(it, !1),
                            rt = st.updateQueue,
                            rt !== null && (et.updateQueue = rt,
                            et.flags |= 4),
                            et.subtreeFlags = 0,
                            rt = tt,
                            tt = et.child; tt !== null; )
                                it = tt,
                                _e = rt,
                                it.flags &= 14680066,
                                st = it.alternate,
                                st === null ? (it.childLanes = 0,
                                it.lanes = _e,
                                it.child = null,
                                it.subtreeFlags = 0,
                                it.memoizedProps = null,
                                it.memoizedState = null,
                                it.updateQueue = null,
                                it.dependencies = null,
                                it.stateNode = null) : (it.childLanes = st.childLanes,
                                it.lanes = st.lanes,
                                it.child = st.child,
                                it.subtreeFlags = 0,
                                it.deletions = null,
                                it.memoizedProps = st.memoizedProps,
                                it.memoizedState = st.memoizedState,
                                it.updateQueue = st.updateQueue,
                                it.type = st.type,
                                _e = st.dependencies,
                                it.dependencies = _e === null ? null : {
                                    lanes: _e.lanes,
                                    firstContext: _e.firstContext
                                }),
                                tt = tt.sibling;
                            return G(M$3, M$3.current & 1 | 2),
                            et.child
                        }
                        _e = _e.sibling
                    }
                it.tail !== null && B$1() > Hj && (et.flags |= 128,
                rt = !0,
                Ej(it, !1),
                et.lanes = 4194304)
            }
        else {
            if (!rt)
                if (_e = Mh(st),
                _e !== null) {
                    if (et.flags |= 128,
                    rt = !0,
                    tt = _e.updateQueue,
                    tt !== null && (et.updateQueue = tt,
                    et.flags |= 4),
                    Ej(it, !0),
                    it.tail === null && it.tailMode === "hidden" && !st.alternate && !I$3)
                        return S$5(et),
                        null
                } else
                    2 * B$1() - it.renderingStartTime > Hj && tt !== 1073741824 && (et.flags |= 128,
                    rt = !0,
                    Ej(it, !1),
                    et.lanes = 4194304);
            it.isBackwards ? (st.sibling = et.child,
            et.child = st) : (tt = it.last,
            tt !== null ? tt.sibling = st : et.child = st,
            it.last = st)
        }
        return it.tail !== null ? (et = it.tail,
        it.rendering = et,
        it.tail = et.sibling,
        it.renderingStartTime = B$1(),
        et.sibling = null,
        tt = M$3.current,
        G(M$3, rt ? tt & 1 | 2 : tt & 1),
        et) : (S$5(et),
        null);
    case 22:
    case 23:
        return Ij(),
        rt = et.memoizedState !== null,
        _e !== null && _e.memoizedState !== null !== rt && (et.flags |= 8192),
        rt && et.mode & 1 ? gj & 1073741824 && (S$5(et),
        et.subtreeFlags & 6 && (et.flags |= 8192)) : S$5(et),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p$8(156, et.tag))
}
function Jj(_e, et) {
    switch (wg(et),
    et.tag) {
    case 1:
        return Zf(et.type) && $f(),
        _e = et.flags,
        _e & 65536 ? (et.flags = _e & -65537 | 128,
        et) : null;
    case 3:
        return Jh(),
        E$3(Wf),
        E$3(H$3),
        Oh(),
        _e = et.flags,
        _e & 65536 && !(_e & 128) ? (et.flags = _e & -65537 | 128,
        et) : null;
    case 5:
        return Lh(et),
        null;
    case 13:
        if (E$3(M$3),
        _e = et.memoizedState,
        _e !== null && _e.dehydrated !== null) {
            if (et.alternate === null)
                throw Error(p$8(340));
            Ig()
        }
        return _e = et.flags,
        _e & 65536 ? (et.flags = _e & -65537 | 128,
        et) : null;
    case 19:
        return E$3(M$3),
        null;
    case 4:
        return Jh(),
        null;
    case 10:
        return Rg(et.type._context),
        null;
    case 22:
    case 23:
        return Ij(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Kj = !1
  , U = !1
  , Lj = typeof WeakSet == "function" ? WeakSet : Set
  , V$2 = null;
function Mj(_e, et) {
    var tt = _e.ref;
    if (tt !== null)
        if (typeof tt == "function")
            try {
                tt(null)
            } catch (rt) {
                W(_e, et, rt)
            }
        else
            tt.current = null
}
function Nj(_e, et, tt) {
    try {
        tt()
    } catch (rt) {
        W(_e, et, rt)
    }
}
var Oj = !1;
function Pj(_e, et) {
    if (Cf = dd,
    _e = Me(),
    Ne(_e)) {
        if ("selectionStart"in _e)
            var tt = {
                start: _e.selectionStart,
                end: _e.selectionEnd
            };
        else
            e: {
                tt = (tt = _e.ownerDocument) && tt.defaultView || window;
                var rt = tt.getSelection && tt.getSelection();
                if (rt && rt.rangeCount !== 0) {
                    tt = rt.anchorNode;
                    var nt = rt.anchorOffset
                      , it = rt.focusNode;
                    rt = rt.focusOffset;
                    try {
                        tt.nodeType,
                        it.nodeType
                    } catch {
                        tt = null;
                        break e
                    }
                    var st = 0
                      , at = -1
                      , ot = -1
                      , lt = 0
                      , dt = 0
                      , ct = _e
                      , ut = null;
                    t: for (; ; ) {
                        for (var ft; ct !== tt || nt !== 0 && ct.nodeType !== 3 || (at = st + nt),
                        ct !== it || rt !== 0 && ct.nodeType !== 3 || (ot = st + rt),
                        ct.nodeType === 3 && (st += ct.nodeValue.length),
                        (ft = ct.firstChild) !== null; )
                            ut = ct,
                            ct = ft;
                        for (; ; ) {
                            if (ct === _e)
                                break t;
                            if (ut === tt && ++lt === nt && (at = st),
                            ut === it && ++dt === rt && (ot = st),
                            (ft = ct.nextSibling) !== null)
                                break;
                            ct = ut,
                            ut = ct.parentNode
                        }
                        ct = ft
                    }
                    tt = at === -1 || ot === -1 ? null : {
                        start: at,
                        end: ot
                    }
                } else
                    tt = null
            }
        tt = tt || {
            start: 0,
            end: 0
        }
    } else
        tt = null;
    for (Df = {
        focusedElem: _e,
        selectionRange: tt
    },
    dd = !1,
    V$2 = et; V$2 !== null; )
        if (et = V$2,
        _e = et.child,
        (et.subtreeFlags & 1028) !== 0 && _e !== null)
            _e.return = et,
            V$2 = _e;
        else
            for (; V$2 !== null; ) {
                et = V$2;
                try {
                    var ht = et.alternate;
                    if (et.flags & 1024)
                        switch (et.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (ht !== null) {
                                var gt = ht.memoizedProps
                                  , bt = ht.memoizedState
                                  , pt = et.stateNode
                                  , mt = pt.getSnapshotBeforeUpdate(et.elementType === et.type ? gt : Lg(et.type, gt), bt);
                                pt.__reactInternalSnapshotBeforeUpdate = mt
                            }
                            break;
                        case 3:
                            var yt = et.stateNode.containerInfo;
                            yt.nodeType === 1 ? yt.textContent = "" : yt.nodeType === 9 && yt.documentElement && yt.removeChild(yt.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$8(163))
                        }
                } catch (vt) {
                    W(et, et.return, vt)
                }
                if (_e = et.sibling,
                _e !== null) {
                    _e.return = et.return,
                    V$2 = _e;
                    break
                }
                V$2 = et.return
            }
    return ht = Oj,
    Oj = !1,
    ht
}
function Qj(_e, et, tt) {
    var rt = et.updateQueue;
    if (rt = rt !== null ? rt.lastEffect : null,
    rt !== null) {
        var nt = rt = rt.next;
        do {
            if ((nt.tag & _e) === _e) {
                var it = nt.destroy;
                nt.destroy = void 0,
                it !== void 0 && Nj(et, tt, it)
            }
            nt = nt.next
        } while (nt !== rt)
    }
}
function Rj(_e, et) {
    if (et = et.updateQueue,
    et = et !== null ? et.lastEffect : null,
    et !== null) {
        var tt = et = et.next;
        do {
            if ((tt.tag & _e) === _e) {
                var rt = tt.create;
                tt.destroy = rt()
            }
            tt = tt.next
        } while (tt !== et)
    }
}
function Sj(_e) {
    var et = _e.ref;
    if (et !== null) {
        var tt = _e.stateNode;
        switch (_e.tag) {
        case 5:
            _e = tt;
            break;
        default:
            _e = tt
        }
        typeof et == "function" ? et(_e) : et.current = _e
    }
}
function Tj(_e) {
    var et = _e.alternate;
    et !== null && (_e.alternate = null,
    Tj(et)),
    _e.child = null,
    _e.deletions = null,
    _e.sibling = null,
    _e.tag === 5 && (et = _e.stateNode,
    et !== null && (delete et[Of],
    delete et[Pf],
    delete et[of],
    delete et[Qf],
    delete et[Rf])),
    _e.stateNode = null,
    _e.return = null,
    _e.dependencies = null,
    _e.memoizedProps = null,
    _e.memoizedState = null,
    _e.pendingProps = null,
    _e.stateNode = null,
    _e.updateQueue = null
}
function Uj(_e) {
    return _e.tag === 5 || _e.tag === 3 || _e.tag === 4
}
function Vj(_e) {
    e: for (; ; ) {
        for (; _e.sibling === null; ) {
            if (_e.return === null || Uj(_e.return))
                return null;
            _e = _e.return
        }
        for (_e.sibling.return = _e.return,
        _e = _e.sibling; _e.tag !== 5 && _e.tag !== 6 && _e.tag !== 18; ) {
            if (_e.flags & 2 || _e.child === null || _e.tag === 4)
                continue e;
            _e.child.return = _e,
            _e = _e.child
        }
        if (!(_e.flags & 2))
            return _e.stateNode
    }
}
function Wj(_e, et, tt) {
    var rt = _e.tag;
    if (rt === 5 || rt === 6)
        _e = _e.stateNode,
        et ? tt.nodeType === 8 ? tt.parentNode.insertBefore(_e, et) : tt.insertBefore(_e, et) : (tt.nodeType === 8 ? (et = tt.parentNode,
        et.insertBefore(_e, tt)) : (et = tt,
        et.appendChild(_e)),
        tt = tt._reactRootContainer,
        tt != null || et.onclick !== null || (et.onclick = Bf));
    else if (rt !== 4 && (_e = _e.child,
    _e !== null))
        for (Wj(_e, et, tt),
        _e = _e.sibling; _e !== null; )
            Wj(_e, et, tt),
            _e = _e.sibling
}
function Xj(_e, et, tt) {
    var rt = _e.tag;
    if (rt === 5 || rt === 6)
        _e = _e.stateNode,
        et ? tt.insertBefore(_e, et) : tt.appendChild(_e);
    else if (rt !== 4 && (_e = _e.child,
    _e !== null))
        for (Xj(_e, et, tt),
        _e = _e.sibling; _e !== null; )
            Xj(_e, et, tt),
            _e = _e.sibling
}
var X = null
  , Yj = !1;
function Zj(_e, et, tt) {
    for (tt = tt.child; tt !== null; )
        ak(_e, et, tt),
        tt = tt.sibling
}
function ak(_e, et, tt) {
    if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
            lc.onCommitFiberUnmount(kc, tt)
        } catch {}
    switch (tt.tag) {
    case 5:
        U || Mj(tt, et);
    case 6:
        var rt = X
          , nt = Yj;
        X = null,
        Zj(_e, et, tt),
        X = rt,
        Yj = nt,
        X !== null && (Yj ? (_e = X,
        tt = tt.stateNode,
        _e.nodeType === 8 ? _e.parentNode.removeChild(tt) : _e.removeChild(tt)) : X.removeChild(tt.stateNode));
        break;
    case 18:
        X !== null && (Yj ? (_e = X,
        tt = tt.stateNode,
        _e.nodeType === 8 ? Kf(_e.parentNode, tt) : _e.nodeType === 1 && Kf(_e, tt),
        bd(_e)) : Kf(X, tt.stateNode));
        break;
    case 4:
        rt = X,
        nt = Yj,
        X = tt.stateNode.containerInfo,
        Yj = !0,
        Zj(_e, et, tt),
        X = rt,
        Yj = nt;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!U && (rt = tt.updateQueue,
        rt !== null && (rt = rt.lastEffect,
        rt !== null))) {
            nt = rt = rt.next;
            do {
                var it = nt
                  , st = it.destroy;
                it = it.tag,
                st !== void 0 && (it & 2 || it & 4) && Nj(tt, et, st),
                nt = nt.next
            } while (nt !== rt)
        }
        Zj(_e, et, tt);
        break;
    case 1:
        if (!U && (Mj(tt, et),
        rt = tt.stateNode,
        typeof rt.componentWillUnmount == "function"))
            try {
                rt.props = tt.memoizedProps,
                rt.state = tt.memoizedState,
                rt.componentWillUnmount()
            } catch (at) {
                W(tt, et, at)
            }
        Zj(_e, et, tt);
        break;
    case 21:
        Zj(_e, et, tt);
        break;
    case 22:
        tt.mode & 1 ? (U = (rt = U) || tt.memoizedState !== null,
        Zj(_e, et, tt),
        U = rt) : Zj(_e, et, tt);
        break;
    default:
        Zj(_e, et, tt)
    }
}
function bk(_e) {
    var et = _e.updateQueue;
    if (et !== null) {
        _e.updateQueue = null;
        var tt = _e.stateNode;
        tt === null && (tt = _e.stateNode = new Lj),
        et.forEach(function(rt) {
            var nt = ck.bind(null, _e, rt);
            tt.has(rt) || (tt.add(rt),
            rt.then(nt, nt))
        })
    }
}
function dk(_e, et) {
    var tt = et.deletions;
    if (tt !== null)
        for (var rt = 0; rt < tt.length; rt++) {
            var nt = tt[rt];
            try {
                var it = _e
                  , st = et
                  , at = st;
                e: for (; at !== null; ) {
                    switch (at.tag) {
                    case 5:
                        X = at.stateNode,
                        Yj = !1;
                        break e;
                    case 3:
                        X = at.stateNode.containerInfo,
                        Yj = !0;
                        break e;
                    case 4:
                        X = at.stateNode.containerInfo,
                        Yj = !0;
                        break e
                    }
                    at = at.return
                }
                if (X === null)
                    throw Error(p$8(160));
                ak(it, st, nt),
                X = null,
                Yj = !1;
                var ot = nt.alternate;
                ot !== null && (ot.return = null),
                nt.return = null
            } catch (lt) {
                W(nt, et, lt)
            }
        }
    if (et.subtreeFlags & 12854)
        for (et = et.child; et !== null; )
            ek(et, _e),
            et = et.sibling
}
function ek(_e, et) {
    var tt = _e.alternate
      , rt = _e.flags;
    switch (_e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (dk(et, _e),
        fk(_e),
        rt & 4) {
            try {
                Qj(3, _e, _e.return),
                Rj(3, _e)
            } catch (gt) {
                W(_e, _e.return, gt)
            }
            try {
                Qj(5, _e, _e.return)
            } catch (gt) {
                W(_e, _e.return, gt)
            }
        }
        break;
    case 1:
        dk(et, _e),
        fk(_e),
        rt & 512 && tt !== null && Mj(tt, tt.return);
        break;
    case 5:
        if (dk(et, _e),
        fk(_e),
        rt & 512 && tt !== null && Mj(tt, tt.return),
        _e.flags & 32) {
            var nt = _e.stateNode;
            try {
                ob(nt, "")
            } catch (gt) {
                W(_e, _e.return, gt)
            }
        }
        if (rt & 4 && (nt = _e.stateNode,
        nt != null)) {
            var it = _e.memoizedProps
              , st = tt !== null ? tt.memoizedProps : it
              , at = _e.type
              , ot = _e.updateQueue;
            if (_e.updateQueue = null,
            ot !== null)
                try {
                    at === "input" && it.type === "radio" && it.name != null && ab(nt, it),
                    vb(at, st);
                    var lt = vb(at, it);
                    for (st = 0; st < ot.length; st += 2) {
                        var dt = ot[st]
                          , ct = ot[st + 1];
                        dt === "style" ? sb(nt, ct) : dt === "dangerouslySetInnerHTML" ? nb(nt, ct) : dt === "children" ? ob(nt, ct) : ta(nt, dt, ct, lt)
                    }
                    switch (at) {
                    case "input":
                        bb(nt, it);
                        break;
                    case "textarea":
                        ib(nt, it);
                        break;
                    case "select":
                        var ut = nt._wrapperState.wasMultiple;
                        nt._wrapperState.wasMultiple = !!it.multiple;
                        var ft = it.value;
                        ft != null ? fb(nt, !!it.multiple, ft, !1) : ut !== !!it.multiple && (it.defaultValue != null ? fb(nt, !!it.multiple, it.defaultValue, !0) : fb(nt, !!it.multiple, it.multiple ? [] : "", !1))
                    }
                    nt[Pf] = it
                } catch (gt) {
                    W(_e, _e.return, gt)
                }
        }
        break;
    case 6:
        if (dk(et, _e),
        fk(_e),
        rt & 4) {
            if (_e.stateNode === null)
                throw Error(p$8(162));
            nt = _e.stateNode,
            it = _e.memoizedProps;
            try {
                nt.nodeValue = it
            } catch (gt) {
                W(_e, _e.return, gt)
            }
        }
        break;
    case 3:
        if (dk(et, _e),
        fk(_e),
        rt & 4 && tt !== null && tt.memoizedState.isDehydrated)
            try {
                bd(et.containerInfo)
            } catch (gt) {
                W(_e, _e.return, gt)
            }
        break;
    case 4:
        dk(et, _e),
        fk(_e);
        break;
    case 13:
        dk(et, _e),
        fk(_e),
        nt = _e.child,
        nt.flags & 8192 && (it = nt.memoizedState !== null,
        nt.stateNode.isHidden = it,
        !it || nt.alternate !== null && nt.alternate.memoizedState !== null || (gk = B$1())),
        rt & 4 && bk(_e);
        break;
    case 22:
        if (dt = tt !== null && tt.memoizedState !== null,
        _e.mode & 1 ? (U = (lt = U) || dt,
        dk(et, _e),
        U = lt) : dk(et, _e),
        fk(_e),
        rt & 8192) {
            if (lt = _e.memoizedState !== null,
            (_e.stateNode.isHidden = lt) && !dt && _e.mode & 1)
                for (V$2 = _e,
                dt = _e.child; dt !== null; ) {
                    for (ct = V$2 = dt; V$2 !== null; ) {
                        switch (ut = V$2,
                        ft = ut.child,
                        ut.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Qj(4, ut, ut.return);
                            break;
                        case 1:
                            Mj(ut, ut.return);
                            var ht = ut.stateNode;
                            if (typeof ht.componentWillUnmount == "function") {
                                rt = ut,
                                tt = ut.return;
                                try {
                                    et = rt,
                                    ht.props = et.memoizedProps,
                                    ht.state = et.memoizedState,
                                    ht.componentWillUnmount()
                                } catch (gt) {
                                    W(rt, tt, gt)
                                }
                            }
                            break;
                        case 5:
                            Mj(ut, ut.return);
                            break;
                        case 22:
                            if (ut.memoizedState !== null) {
                                hk(ct);
                                continue
                            }
                        }
                        ft !== null ? (ft.return = ut,
                        V$2 = ft) : hk(ct)
                    }
                    dt = dt.sibling
                }
            e: for (dt = null,
            ct = _e; ; ) {
                if (ct.tag === 5) {
                    if (dt === null) {
                        dt = ct;
                        try {
                            nt = ct.stateNode,
                            lt ? (it = nt.style,
                            typeof it.setProperty == "function" ? it.setProperty("display", "none", "important") : it.display = "none") : (at = ct.stateNode,
                            ot = ct.memoizedProps.style,
                            st = ot != null && ot.hasOwnProperty("display") ? ot.display : null,
                            at.style.display = rb("display", st))
                        } catch (gt) {
                            W(_e, _e.return, gt)
                        }
                    }
                } else if (ct.tag === 6) {
                    if (dt === null)
                        try {
                            ct.stateNode.nodeValue = lt ? "" : ct.memoizedProps
                        } catch (gt) {
                            W(_e, _e.return, gt)
                        }
                } else if ((ct.tag !== 22 && ct.tag !== 23 || ct.memoizedState === null || ct === _e) && ct.child !== null) {
                    ct.child.return = ct,
                    ct = ct.child;
                    continue
                }
                if (ct === _e)
                    break e;
                for (; ct.sibling === null; ) {
                    if (ct.return === null || ct.return === _e)
                        break e;
                    dt === ct && (dt = null),
                    ct = ct.return
                }
                dt === ct && (dt = null),
                ct.sibling.return = ct.return,
                ct = ct.sibling
            }
        }
        break;
    case 19:
        dk(et, _e),
        fk(_e),
        rt & 4 && bk(_e);
        break;
    case 21:
        break;
    default:
        dk(et, _e),
        fk(_e)
    }
}
function fk(_e) {
    var et = _e.flags;
    if (et & 2) {
        try {
            e: {
                for (var tt = _e.return; tt !== null; ) {
                    if (Uj(tt)) {
                        var rt = tt;
                        break e
                    }
                    tt = tt.return
                }
                throw Error(p$8(160))
            }
            switch (rt.tag) {
            case 5:
                var nt = rt.stateNode;
                rt.flags & 32 && (ob(nt, ""),
                rt.flags &= -33);
                var it = Vj(_e);
                Xj(_e, it, nt);
                break;
            case 3:
            case 4:
                var st = rt.stateNode.containerInfo
                  , at = Vj(_e);
                Wj(_e, at, st);
                break;
            default:
                throw Error(p$8(161))
            }
        } catch (ot) {
            W(_e, _e.return, ot)
        }
        _e.flags &= -3
    }
    et & 4096 && (_e.flags &= -4097)
}
function ik(_e, et, tt) {
    V$2 = _e,
    jk(_e)
}
function jk(_e, et, tt) {
    for (var rt = (_e.mode & 1) !== 0; V$2 !== null; ) {
        var nt = V$2
          , it = nt.child;
        if (nt.tag === 22 && rt) {
            var st = nt.memoizedState !== null || Kj;
            if (!st) {
                var at = nt.alternate
                  , ot = at !== null && at.memoizedState !== null || U;
                at = Kj;
                var lt = U;
                if (Kj = st,
                (U = ot) && !lt)
                    for (V$2 = nt; V$2 !== null; )
                        st = V$2,
                        ot = st.child,
                        st.tag === 22 && st.memoizedState !== null ? kk(nt) : ot !== null ? (ot.return = st,
                        V$2 = ot) : kk(nt);
                for (; it !== null; )
                    V$2 = it,
                    jk(it),
                    it = it.sibling;
                V$2 = nt,
                Kj = at,
                U = lt
            }
            lk(_e)
        } else
            nt.subtreeFlags & 8772 && it !== null ? (it.return = nt,
            V$2 = it) : lk(_e)
    }
}
function lk(_e) {
    for (; V$2 !== null; ) {
        var et = V$2;
        if (et.flags & 8772) {
            var tt = et.alternate;
            try {
                if (et.flags & 8772)
                    switch (et.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U || Rj(5, et);
                        break;
                    case 1:
                        var rt = et.stateNode;
                        if (et.flags & 4 && !U)
                            if (tt === null)
                                rt.componentDidMount();
                            else {
                                var nt = et.elementType === et.type ? tt.memoizedProps : Lg(et.type, tt.memoizedProps);
                                rt.componentDidUpdate(nt, tt.memoizedState, rt.__reactInternalSnapshotBeforeUpdate)
                            }
                        var it = et.updateQueue;
                        it !== null && ih(et, it, rt);
                        break;
                    case 3:
                        var st = et.updateQueue;
                        if (st !== null) {
                            if (tt = null,
                            et.child !== null)
                                switch (et.child.tag) {
                                case 5:
                                    tt = et.child.stateNode;
                                    break;
                                case 1:
                                    tt = et.child.stateNode
                                }
                            ih(et, st, tt)
                        }
                        break;
                    case 5:
                        var at = et.stateNode;
                        if (tt === null && et.flags & 4) {
                            tt = at;
                            var ot = et.memoizedProps;
                            switch (et.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                ot.autoFocus && tt.focus();
                                break;
                            case "img":
                                ot.src && (tt.src = ot.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (et.memoizedState === null) {
                            var lt = et.alternate;
                            if (lt !== null) {
                                var dt = lt.memoizedState;
                                if (dt !== null) {
                                    var ct = dt.dehydrated;
                                    ct !== null && bd(ct)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p$8(163))
                    }
                U || et.flags & 512 && Sj(et)
            } catch (ut) {
                W(et, et.return, ut)
            }
        }
        if (et === _e) {
            V$2 = null;
            break
        }
        if (tt = et.sibling,
        tt !== null) {
            tt.return = et.return,
            V$2 = tt;
            break
        }
        V$2 = et.return
    }
}
function hk(_e) {
    for (; V$2 !== null; ) {
        var et = V$2;
        if (et === _e) {
            V$2 = null;
            break
        }
        var tt = et.sibling;
        if (tt !== null) {
            tt.return = et.return,
            V$2 = tt;
            break
        }
        V$2 = et.return
    }
}
function kk(_e) {
    for (; V$2 !== null; ) {
        var et = V$2;
        try {
            switch (et.tag) {
            case 0:
            case 11:
            case 15:
                var tt = et.return;
                try {
                    Rj(4, et)
                } catch (ot) {
                    W(et, tt, ot)
                }
                break;
            case 1:
                var rt = et.stateNode;
                if (typeof rt.componentDidMount == "function") {
                    var nt = et.return;
                    try {
                        rt.componentDidMount()
                    } catch (ot) {
                        W(et, nt, ot)
                    }
                }
                var it = et.return;
                try {
                    Sj(et)
                } catch (ot) {
                    W(et, it, ot)
                }
                break;
            case 5:
                var st = et.return;
                try {
                    Sj(et)
                } catch (ot) {
                    W(et, st, ot)
                }
            }
        } catch (ot) {
            W(et, et.return, ot)
        }
        if (et === _e) {
            V$2 = null;
            break
        }
        var at = et.sibling;
        if (at !== null) {
            at.return = et.return,
            V$2 = at;
            break
        }
        V$2 = et.return
    }
}
var mk = Math.ceil
  , nk = ua.ReactCurrentDispatcher
  , ok = ua.ReactCurrentOwner
  , pk = ua.ReactCurrentBatchConfig
  , K = 0
  , R$3 = null
  , Y = null
  , Z$2 = 0
  , gj = 0
  , fj = Uf(0)
  , T$3 = 0
  , qk = null
  , hh = 0
  , rk = 0
  , sk = 0
  , tk = null
  , uk = null
  , gk = 0
  , Hj = 1 / 0
  , vk = null
  , Pi = !1
  , Qi = null
  , Si = null
  , wk = !1
  , xk = null
  , yk = 0
  , zk = 0
  , Ak = null
  , Bk = -1
  , Ck = 0;
function L$3() {
    return K & 6 ? B$1() : Bk !== -1 ? Bk : Bk = B$1()
}
function lh(_e) {
    return _e.mode & 1 ? K & 2 && Z$2 !== 0 ? Z$2 & -Z$2 : Kg.transition !== null ? (Ck === 0 && (Ck = yc()),
    Ck) : (_e = C$3,
    _e !== 0 || (_e = window.event,
    _e = _e === void 0 ? 16 : jd(_e.type)),
    _e) : 1
}
function mh(_e, et, tt, rt) {
    if (50 < zk)
        throw zk = 0,
        Ak = null,
        Error(p$8(185));
    Ac(_e, tt, rt),
    (!(K & 2) || _e !== R$3) && (_e === R$3 && (!(K & 2) && (rk |= tt),
    T$3 === 4 && Dk(_e, Z$2)),
    Ek(_e, rt),
    tt === 1 && K === 0 && !(et.mode & 1) && (Hj = B$1() + 500,
    fg && jg()))
}
function Ek(_e, et) {
    var tt = _e.callbackNode;
    wc(_e, et);
    var rt = uc(_e, _e === R$3 ? Z$2 : 0);
    if (rt === 0)
        tt !== null && bc(tt),
        _e.callbackNode = null,
        _e.callbackPriority = 0;
    else if (et = rt & -rt,
    _e.callbackPriority !== et) {
        if (tt != null && bc(tt),
        et === 1)
            _e.tag === 0 ? ig(Fk.bind(null, _e)) : hg(Fk.bind(null, _e)),
            Jf(function() {
                !(K & 6) && jg()
            }),
            tt = null;
        else {
            switch (Dc(rt)) {
            case 1:
                tt = fc;
                break;
            case 4:
                tt = gc;
                break;
            case 16:
                tt = hc;
                break;
            case 536870912:
                tt = jc;
                break;
            default:
                tt = hc
            }
            tt = Gk(tt, Hk.bind(null, _e))
        }
        _e.callbackPriority = et,
        _e.callbackNode = tt
    }
}
function Hk(_e, et) {
    if (Bk = -1,
    Ck = 0,
    K & 6)
        throw Error(p$8(327));
    var tt = _e.callbackNode;
    if (Ik() && _e.callbackNode !== tt)
        return null;
    var rt = uc(_e, _e === R$3 ? Z$2 : 0);
    if (rt === 0)
        return null;
    if (rt & 30 || rt & _e.expiredLanes || et)
        et = Jk(_e, rt);
    else {
        et = rt;
        var nt = K;
        K |= 2;
        var it = Kk();
        (R$3 !== _e || Z$2 !== et) && (vk = null,
        Hj = B$1() + 500,
        Lk(_e, et));
        do
            try {
                Mk();
                break
            } catch (at) {
                Nk(_e, at)
            }
        while (!0);
        Qg(),
        nk.current = it,
        K = nt,
        Y !== null ? et = 0 : (R$3 = null,
        Z$2 = 0,
        et = T$3)
    }
    if (et !== 0) {
        if (et === 2 && (nt = xc(_e),
        nt !== 0 && (rt = nt,
        et = Ok(_e, nt))),
        et === 1)
            throw tt = qk,
            Lk(_e, 0),
            Dk(_e, rt),
            Ek(_e, B$1()),
            tt;
        if (et === 6)
            Dk(_e, rt);
        else {
            if (nt = _e.current.alternate,
            !(rt & 30) && !Pk(nt) && (et = Jk(_e, rt),
            et === 2 && (it = xc(_e),
            it !== 0 && (rt = it,
            et = Ok(_e, it))),
            et === 1))
                throw tt = qk,
                Lk(_e, 0),
                Dk(_e, rt),
                Ek(_e, B$1()),
                tt;
            switch (_e.finishedWork = nt,
            _e.finishedLanes = rt,
            et) {
            case 0:
            case 1:
                throw Error(p$8(345));
            case 2:
                Qk(_e, uk, vk);
                break;
            case 3:
                if (Dk(_e, rt),
                (rt & 130023424) === rt && (et = gk + 500 - B$1(),
                10 < et)) {
                    if (uc(_e, 0) !== 0)
                        break;
                    if (nt = _e.suspendedLanes,
                    (nt & rt) !== rt) {
                        L$3(),
                        _e.pingedLanes |= _e.suspendedLanes & nt;
                        break
                    }
                    _e.timeoutHandle = Ff(Qk.bind(null, _e, uk, vk), et);
                    break
                }
                Qk(_e, uk, vk);
                break;
            case 4:
                if (Dk(_e, rt),
                (rt & 4194240) === rt)
                    break;
                for (et = _e.eventTimes,
                nt = -1; 0 < rt; ) {
                    var st = 31 - oc(rt);
                    it = 1 << st,
                    st = et[st],
                    st > nt && (nt = st),
                    rt &= ~it
                }
                if (rt = nt,
                rt = B$1() - rt,
                rt = (120 > rt ? 120 : 480 > rt ? 480 : 1080 > rt ? 1080 : 1920 > rt ? 1920 : 3e3 > rt ? 3e3 : 4320 > rt ? 4320 : 1960 * mk(rt / 1960)) - rt,
                10 < rt) {
                    _e.timeoutHandle = Ff(Qk.bind(null, _e, uk, vk), rt);
                    break
                }
                Qk(_e, uk, vk);
                break;
            case 5:
                Qk(_e, uk, vk);
                break;
            default:
                throw Error(p$8(329))
            }
        }
    }
    return Ek(_e, B$1()),
    _e.callbackNode === tt ? Hk.bind(null, _e) : null
}
function Ok(_e, et) {
    var tt = tk;
    return _e.current.memoizedState.isDehydrated && (Lk(_e, et).flags |= 256),
    _e = Jk(_e, et),
    _e !== 2 && (et = uk,
    uk = tt,
    et !== null && Gj(et)),
    _e
}
function Gj(_e) {
    uk === null ? uk = _e : uk.push.apply(uk, _e)
}
function Pk(_e) {
    for (var et = _e; ; ) {
        if (et.flags & 16384) {
            var tt = et.updateQueue;
            if (tt !== null && (tt = tt.stores,
            tt !== null))
                for (var rt = 0; rt < tt.length; rt++) {
                    var nt = tt[rt]
                      , it = nt.getSnapshot;
                    nt = nt.value;
                    try {
                        if (!He(it(), nt))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (tt = et.child,
        et.subtreeFlags & 16384 && tt !== null)
            tt.return = et,
            et = tt;
        else {
            if (et === _e)
                break;
            for (; et.sibling === null; ) {
                if (et.return === null || et.return === _e)
                    return !0;
                et = et.return
            }
            et.sibling.return = et.return,
            et = et.sibling
        }
    }
    return !0
}
function Dk(_e, et) {
    for (et &= ~sk,
    et &= ~rk,
    _e.suspendedLanes |= et,
    _e.pingedLanes &= ~et,
    _e = _e.expirationTimes; 0 < et; ) {
        var tt = 31 - oc(et)
          , rt = 1 << tt;
        _e[tt] = -1,
        et &= ~rt
    }
}
function Fk(_e) {
    if (K & 6)
        throw Error(p$8(327));
    Ik();
    var et = uc(_e, 0);
    if (!(et & 1))
        return Ek(_e, B$1()),
        null;
    var tt = Jk(_e, et);
    if (_e.tag !== 0 && tt === 2) {
        var rt = xc(_e);
        rt !== 0 && (et = rt,
        tt = Ok(_e, rt))
    }
    if (tt === 1)
        throw tt = qk,
        Lk(_e, 0),
        Dk(_e, et),
        Ek(_e, B$1()),
        tt;
    if (tt === 6)
        throw Error(p$8(345));
    return _e.finishedWork = _e.current.alternate,
    _e.finishedLanes = et,
    Qk(_e, uk, vk),
    Ek(_e, B$1()),
    null
}
function Rk(_e, et) {
    var tt = K;
    K |= 1;
    try {
        return _e(et)
    } finally {
        K = tt,
        K === 0 && (Hj = B$1() + 500,
        fg && jg())
    }
}
function Sk(_e) {
    xk !== null && xk.tag === 0 && !(K & 6) && Ik();
    var et = K;
    K |= 1;
    var tt = pk.transition
      , rt = C$3;
    try {
        if (pk.transition = null,
        C$3 = 1,
        _e)
            return _e()
    } finally {
        C$3 = rt,
        pk.transition = tt,
        K = et,
        !(K & 6) && jg()
    }
}
function Ij() {
    gj = fj.current,
    E$3(fj)
}
function Lk(_e, et) {
    _e.finishedWork = null,
    _e.finishedLanes = 0;
    var tt = _e.timeoutHandle;
    if (tt !== -1 && (_e.timeoutHandle = -1,
    Gf(tt)),
    Y !== null)
        for (tt = Y.return; tt !== null; ) {
            var rt = tt;
            switch (wg(rt),
            rt.tag) {
            case 1:
                rt = rt.type.childContextTypes,
                rt != null && $f();
                break;
            case 3:
                Jh(),
                E$3(Wf),
                E$3(H$3),
                Oh();
                break;
            case 5:
                Lh(rt);
                break;
            case 4:
                Jh();
                break;
            case 13:
                E$3(M$3);
                break;
            case 19:
                E$3(M$3);
                break;
            case 10:
                Rg(rt.type._context);
                break;
            case 22:
            case 23:
                Ij()
            }
            tt = tt.return
        }
    if (R$3 = _e,
    Y = _e = wh(_e.current, null),
    Z$2 = gj = et,
    T$3 = 0,
    qk = null,
    sk = rk = hh = 0,
    uk = tk = null,
    Wg !== null) {
        for (et = 0; et < Wg.length; et++)
            if (tt = Wg[et],
            rt = tt.interleaved,
            rt !== null) {
                tt.interleaved = null;
                var nt = rt.next
                  , it = tt.pending;
                if (it !== null) {
                    var st = it.next;
                    it.next = nt,
                    rt.next = st
                }
                tt.pending = rt
            }
        Wg = null
    }
    return _e
}
function Nk(_e, et) {
    do {
        var tt = Y;
        try {
            if (Qg(),
            Ph.current = ai,
            Sh) {
                for (var rt = N$3.memoizedState; rt !== null; ) {
                    var nt = rt.queue;
                    nt !== null && (nt.pending = null),
                    rt = rt.next
                }
                Sh = !1
            }
            if (Rh = 0,
            P$3 = O$1 = N$3 = null,
            Th = !1,
            Uh = 0,
            ok.current = null,
            tt === null || tt.return === null) {
                T$3 = 1,
                qk = et,
                Y = null;
                break
            }
            e: {
                var it = _e
                  , st = tt.return
                  , at = tt
                  , ot = et;
                if (et = Z$2,
                at.flags |= 32768,
                ot !== null && typeof ot == "object" && typeof ot.then == "function") {
                    var lt = ot
                      , dt = at
                      , ct = dt.tag;
                    if (!(dt.mode & 1) && (ct === 0 || ct === 11 || ct === 15)) {
                        var ut = dt.alternate;
                        ut ? (dt.updateQueue = ut.updateQueue,
                        dt.memoizedState = ut.memoizedState,
                        dt.lanes = ut.lanes) : (dt.updateQueue = null,
                        dt.memoizedState = null)
                    }
                    var ft = Vi(st);
                    if (ft !== null) {
                        ft.flags &= -257,
                        Wi(ft, st, at, it, et),
                        ft.mode & 1 && Ti(it, lt, et),
                        et = ft,
                        ot = lt;
                        var ht = et.updateQueue;
                        if (ht === null) {
                            var gt = new Set;
                            gt.add(ot),
                            et.updateQueue = gt
                        } else
                            ht.add(ot);
                        break e
                    } else {
                        if (!(et & 1)) {
                            Ti(it, lt, et),
                            uj();
                            break e
                        }
                        ot = Error(p$8(426))
                    }
                } else if (I$3 && at.mode & 1) {
                    var bt = Vi(st);
                    if (bt !== null) {
                        !(bt.flags & 65536) && (bt.flags |= 256),
                        Wi(bt, st, at, it, et),
                        Jg(Ki(ot, at));
                        break e
                    }
                }
                it = ot = Ki(ot, at),
                T$3 !== 4 && (T$3 = 2),
                tk === null ? tk = [it] : tk.push(it),
                it = st;
                do {
                    switch (it.tag) {
                    case 3:
                        it.flags |= 65536,
                        et &= -et,
                        it.lanes |= et;
                        var pt = Oi(it, ot, et);
                        fh(it, pt);
                        break e;
                    case 1:
                        at = ot;
                        var mt = it.type
                          , yt = it.stateNode;
                        if (!(it.flags & 128) && (typeof mt.getDerivedStateFromError == "function" || yt !== null && typeof yt.componentDidCatch == "function" && (Si === null || !Si.has(yt)))) {
                            it.flags |= 65536,
                            et &= -et,
                            it.lanes |= et;
                            var vt = Ri(it, at, et);
                            fh(it, vt);
                            break e
                        }
                    }
                    it = it.return
                } while (it !== null)
            }
            Tk(tt)
        } catch (wt) {
            et = wt,
            Y === tt && tt !== null && (Y = tt = tt.return);
            continue
        }
        break
    } while (!0)
}
function Kk() {
    var _e = nk.current;
    return nk.current = ai,
    _e === null ? ai : _e
}
function uj() {
    (T$3 === 0 || T$3 === 3 || T$3 === 2) && (T$3 = 4),
    R$3 === null || !(hh & 268435455) && !(rk & 268435455) || Dk(R$3, Z$2)
}
function Jk(_e, et) {
    var tt = K;
    K |= 2;
    var rt = Kk();
    (R$3 !== _e || Z$2 !== et) && (vk = null,
    Lk(_e, et));
    do
        try {
            Uk();
            break
        } catch (nt) {
            Nk(_e, nt)
        }
    while (!0);
    if (Qg(),
    K = tt,
    nk.current = rt,
    Y !== null)
        throw Error(p$8(261));
    return R$3 = null,
    Z$2 = 0,
    T$3
}
function Uk() {
    for (; Y !== null; )
        Vk(Y)
}
function Mk() {
    for (; Y !== null && !cc(); )
        Vk(Y)
}
function Vk(_e) {
    var et = Wk(_e.alternate, _e, gj);
    _e.memoizedProps = _e.pendingProps,
    et === null ? Tk(_e) : Y = et,
    ok.current = null
}
function Tk(_e) {
    var et = _e;
    do {
        var tt = et.alternate;
        if (_e = et.return,
        et.flags & 32768) {
            if (tt = Jj(tt, et),
            tt !== null) {
                tt.flags &= 32767,
                Y = tt;
                return
            }
            if (_e !== null)
                _e.flags |= 32768,
                _e.subtreeFlags = 0,
                _e.deletions = null;
            else {
                T$3 = 6,
                Y = null;
                return
            }
        } else if (tt = Fj(tt, et, gj),
        tt !== null) {
            Y = tt;
            return
        }
        if (et = et.sibling,
        et !== null) {
            Y = et;
            return
        }
        Y = et = _e
    } while (et !== null);
    T$3 === 0 && (T$3 = 5)
}
function Qk(_e, et, tt) {
    var rt = C$3
      , nt = pk.transition;
    try {
        pk.transition = null,
        C$3 = 1,
        Xk(_e, et, tt, rt)
    } finally {
        pk.transition = nt,
        C$3 = rt
    }
    return null
}
function Xk(_e, et, tt, rt) {
    do
        Ik();
    while (xk !== null);
    if (K & 6)
        throw Error(p$8(327));
    tt = _e.finishedWork;
    var nt = _e.finishedLanes;
    if (tt === null)
        return null;
    if (_e.finishedWork = null,
    _e.finishedLanes = 0,
    tt === _e.current)
        throw Error(p$8(177));
    _e.callbackNode = null,
    _e.callbackPriority = 0;
    var it = tt.lanes | tt.childLanes;
    if (Bc(_e, it),
    _e === R$3 && (Y = R$3 = null,
    Z$2 = 0),
    !(tt.subtreeFlags & 2064) && !(tt.flags & 2064) || wk || (wk = !0,
    Gk(hc, function() {
        return Ik(),
        null
    })),
    it = (tt.flags & 15990) !== 0,
    tt.subtreeFlags & 15990 || it) {
        it = pk.transition,
        pk.transition = null;
        var st = C$3;
        C$3 = 1;
        var at = K;
        K |= 4,
        ok.current = null,
        Pj(_e, tt),
        ek(tt, _e),
        Oe(Df),
        dd = !!Cf,
        Df = Cf = null,
        _e.current = tt,
        ik(tt),
        dc(),
        K = at,
        C$3 = st,
        pk.transition = it
    } else
        _e.current = tt;
    if (wk && (wk = !1,
    xk = _e,
    yk = nt),
    it = _e.pendingLanes,
    it === 0 && (Si = null),
    mc(tt.stateNode),
    Ek(_e, B$1()),
    et !== null)
        for (rt = _e.onRecoverableError,
        tt = 0; tt < et.length; tt++)
            nt = et[tt],
            rt(nt.value, {
                componentStack: nt.stack,
                digest: nt.digest
            });
    if (Pi)
        throw Pi = !1,
        _e = Qi,
        Qi = null,
        _e;
    return yk & 1 && _e.tag !== 0 && Ik(),
    it = _e.pendingLanes,
    it & 1 ? _e === Ak ? zk++ : (zk = 0,
    Ak = _e) : zk = 0,
    jg(),
    null
}
function Ik() {
    if (xk !== null) {
        var _e = Dc(yk)
          , et = pk.transition
          , tt = C$3;
        try {
            if (pk.transition = null,
            C$3 = 16 > _e ? 16 : _e,
            xk === null)
                var rt = !1;
            else {
                if (_e = xk,
                xk = null,
                yk = 0,
                K & 6)
                    throw Error(p$8(331));
                var nt = K;
                for (K |= 4,
                V$2 = _e.current; V$2 !== null; ) {
                    var it = V$2
                      , st = it.child;
                    if (V$2.flags & 16) {
                        var at = it.deletions;
                        if (at !== null) {
                            for (var ot = 0; ot < at.length; ot++) {
                                var lt = at[ot];
                                for (V$2 = lt; V$2 !== null; ) {
                                    var dt = V$2;
                                    switch (dt.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(8, dt, it)
                                    }
                                    var ct = dt.child;
                                    if (ct !== null)
                                        ct.return = dt,
                                        V$2 = ct;
                                    else
                                        for (; V$2 !== null; ) {
                                            dt = V$2;
                                            var ut = dt.sibling
                                              , ft = dt.return;
                                            if (Tj(dt),
                                            dt === lt) {
                                                V$2 = null;
                                                break
                                            }
                                            if (ut !== null) {
                                                ut.return = ft,
                                                V$2 = ut;
                                                break
                                            }
                                            V$2 = ft
                                        }
                                }
                            }
                            var ht = it.alternate;
                            if (ht !== null) {
                                var gt = ht.child;
                                if (gt !== null) {
                                    ht.child = null;
                                    do {
                                        var bt = gt.sibling;
                                        gt.sibling = null,
                                        gt = bt
                                    } while (gt !== null)
                                }
                            }
                            V$2 = it
                        }
                    }
                    if (it.subtreeFlags & 2064 && st !== null)
                        st.return = it,
                        V$2 = st;
                    else
                        e: for (; V$2 !== null; ) {
                            if (it = V$2,
                            it.flags & 2048)
                                switch (it.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Qj(9, it, it.return)
                                }
                            var pt = it.sibling;
                            if (pt !== null) {
                                pt.return = it.return,
                                V$2 = pt;
                                break e
                            }
                            V$2 = it.return
                        }
                }
                var mt = _e.current;
                for (V$2 = mt; V$2 !== null; ) {
                    st = V$2;
                    var yt = st.child;
                    if (st.subtreeFlags & 2064 && yt !== null)
                        yt.return = st,
                        V$2 = yt;
                    else
                        e: for (st = mt; V$2 !== null; ) {
                            if (at = V$2,
                            at.flags & 2048)
                                try {
                                    switch (at.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Rj(9, at)
                                    }
                                } catch (wt) {
                                    W(at, at.return, wt)
                                }
                            if (at === st) {
                                V$2 = null;
                                break e
                            }
                            var vt = at.sibling;
                            if (vt !== null) {
                                vt.return = at.return,
                                V$2 = vt;
                                break e
                            }
                            V$2 = at.return
                        }
                }
                if (K = nt,
                jg(),
                lc && typeof lc.onPostCommitFiberRoot == "function")
                    try {
                        lc.onPostCommitFiberRoot(kc, _e)
                    } catch {}
                rt = !0
            }
            return rt
        } finally {
            C$3 = tt,
            pk.transition = et
        }
    }
    return !1
}
function Yk(_e, et, tt) {
    et = Ki(tt, et),
    et = Oi(_e, et, 1),
    _e = dh(_e, et, 1),
    et = L$3(),
    _e !== null && (Ac(_e, 1, et),
    Ek(_e, et))
}
function W(_e, et, tt) {
    if (_e.tag === 3)
        Yk(_e, _e, tt);
    else
        for (; et !== null; ) {
            if (et.tag === 3) {
                Yk(et, _e, tt);
                break
            } else if (et.tag === 1) {
                var rt = et.stateNode;
                if (typeof et.type.getDerivedStateFromError == "function" || typeof rt.componentDidCatch == "function" && (Si === null || !Si.has(rt))) {
                    _e = Ki(tt, _e),
                    _e = Ri(et, _e, 1),
                    et = dh(et, _e, 1),
                    _e = L$3(),
                    et !== null && (Ac(et, 1, _e),
                    Ek(et, _e));
                    break
                }
            }
            et = et.return
        }
}
function Ui(_e, et, tt) {
    var rt = _e.pingCache;
    rt !== null && rt.delete(et),
    et = L$3(),
    _e.pingedLanes |= _e.suspendedLanes & tt,
    R$3 === _e && (Z$2 & tt) === tt && (T$3 === 4 || T$3 === 3 && (Z$2 & 130023424) === Z$2 && 500 > B$1() - gk ? Lk(_e, 0) : sk |= tt),
    Ek(_e, et)
}
function Zk(_e, et) {
    et === 0 && (_e.mode & 1 ? (et = sc,
    sc <<= 1,
    !(sc & 130023424) && (sc = 4194304)) : et = 1);
    var tt = L$3();
    _e = Zg(_e, et),
    _e !== null && (Ac(_e, et, tt),
    Ek(_e, tt))
}
function vj(_e) {
    var et = _e.memoizedState
      , tt = 0;
    et !== null && (tt = et.retryLane),
    Zk(_e, tt)
}
function ck(_e, et) {
    var tt = 0;
    switch (_e.tag) {
    case 13:
        var rt = _e.stateNode
          , nt = _e.memoizedState;
        nt !== null && (tt = nt.retryLane);
        break;
    case 19:
        rt = _e.stateNode;
        break;
    default:
        throw Error(p$8(314))
    }
    rt !== null && rt.delete(et),
    Zk(_e, tt)
}
var Wk;
Wk = function(_e, et, tt) {
    if (_e !== null)
        if (_e.memoizedProps !== et.pendingProps || Wf.current)
            Ug = !0;
        else {
            if (!(_e.lanes & tt) && !(et.flags & 128))
                return Ug = !1,
                zj(_e, et, tt);
            Ug = !!(_e.flags & 131072)
        }
    else
        Ug = !1,
        I$3 && et.flags & 1048576 && ug(et, ng, et.index);
    switch (et.lanes = 0,
    et.tag) {
    case 2:
        var rt = et.type;
        jj(_e, et),
        _e = et.pendingProps;
        var nt = Yf(et, H$3.current);
        Tg(et, tt),
        nt = Xh(null, et, rt, _e, nt, tt);
        var it = bi();
        return et.flags |= 1,
        typeof nt == "object" && nt !== null && typeof nt.render == "function" && nt.$$typeof === void 0 ? (et.tag = 1,
        et.memoizedState = null,
        et.updateQueue = null,
        Zf(rt) ? (it = !0,
        cg(et)) : it = !1,
        et.memoizedState = nt.state !== null && nt.state !== void 0 ? nt.state : null,
        ah(et),
        nt.updater = nh,
        et.stateNode = nt,
        nt._reactInternals = et,
        rh(et, rt, _e, tt),
        et = kj(null, et, rt, !0, it, tt)) : (et.tag = 0,
        I$3 && it && vg(et),
        Yi(null, et, nt, tt),
        et = et.child),
        et;
    case 16:
        rt = et.elementType;
        e: {
            switch (jj(_e, et),
            _e = et.pendingProps,
            nt = rt._init,
            rt = nt(rt._payload),
            et.type = rt,
            nt = et.tag = $k(rt),
            _e = Lg(rt, _e),
            nt) {
            case 0:
                et = dj(null, et, rt, _e, tt);
                break e;
            case 1:
                et = ij(null, et, rt, _e, tt);
                break e;
            case 11:
                et = Zi(null, et, rt, _e, tt);
                break e;
            case 14:
                et = aj(null, et, rt, Lg(rt.type, _e), tt);
                break e
            }
            throw Error(p$8(306, rt, ""))
        }
        return et;
    case 0:
        return rt = et.type,
        nt = et.pendingProps,
        nt = et.elementType === rt ? nt : Lg(rt, nt),
        dj(_e, et, rt, nt, tt);
    case 1:
        return rt = et.type,
        nt = et.pendingProps,
        nt = et.elementType === rt ? nt : Lg(rt, nt),
        ij(_e, et, rt, nt, tt);
    case 3:
        e: {
            if (lj(et),
            _e === null)
                throw Error(p$8(387));
            rt = et.pendingProps,
            it = et.memoizedState,
            nt = it.element,
            bh(_e, et),
            gh(et, rt, null, tt);
            var st = et.memoizedState;
            if (rt = st.element,
            it.isDehydrated)
                if (it = {
                    element: rt,
                    isDehydrated: !1,
                    cache: st.cache,
                    pendingSuspenseBoundaries: st.pendingSuspenseBoundaries,
                    transitions: st.transitions
                },
                et.updateQueue.baseState = it,
                et.memoizedState = it,
                et.flags & 256) {
                    nt = Ki(Error(p$8(423)), et),
                    et = mj(_e, et, rt, tt, nt);
                    break e
                } else if (rt !== nt) {
                    nt = Ki(Error(p$8(424)), et),
                    et = mj(_e, et, rt, tt, nt);
                    break e
                } else
                    for (yg = Lf(et.stateNode.containerInfo.firstChild),
                    xg = et,
                    I$3 = !0,
                    zg = null,
                    tt = Ch(et, null, rt, tt),
                    et.child = tt; tt; )
                        tt.flags = tt.flags & -3 | 4096,
                        tt = tt.sibling;
            else {
                if (Ig(),
                rt === nt) {
                    et = $i(_e, et, tt);
                    break e
                }
                Yi(_e, et, rt, tt)
            }
            et = et.child
        }
        return et;
    case 5:
        return Kh(et),
        _e === null && Eg(et),
        rt = et.type,
        nt = et.pendingProps,
        it = _e !== null ? _e.memoizedProps : null,
        st = nt.children,
        Ef(rt, nt) ? st = null : it !== null && Ef(rt, it) && (et.flags |= 32),
        hj(_e, et),
        Yi(_e, et, st, tt),
        et.child;
    case 6:
        return _e === null && Eg(et),
        null;
    case 13:
        return pj(_e, et, tt);
    case 4:
        return Ih(et, et.stateNode.containerInfo),
        rt = et.pendingProps,
        _e === null ? et.child = Bh(et, null, rt, tt) : Yi(_e, et, rt, tt),
        et.child;
    case 11:
        return rt = et.type,
        nt = et.pendingProps,
        nt = et.elementType === rt ? nt : Lg(rt, nt),
        Zi(_e, et, rt, nt, tt);
    case 7:
        return Yi(_e, et, et.pendingProps, tt),
        et.child;
    case 8:
        return Yi(_e, et, et.pendingProps.children, tt),
        et.child;
    case 12:
        return Yi(_e, et, et.pendingProps.children, tt),
        et.child;
    case 10:
        e: {
            if (rt = et.type._context,
            nt = et.pendingProps,
            it = et.memoizedProps,
            st = nt.value,
            G(Mg, rt._currentValue),
            rt._currentValue = st,
            it !== null)
                if (He(it.value, st)) {
                    if (it.children === nt.children && !Wf.current) {
                        et = $i(_e, et, tt);
                        break e
                    }
                } else
                    for (it = et.child,
                    it !== null && (it.return = et); it !== null; ) {
                        var at = it.dependencies;
                        if (at !== null) {
                            st = it.child;
                            for (var ot = at.firstContext; ot !== null; ) {
                                if (ot.context === rt) {
                                    if (it.tag === 1) {
                                        ot = ch(-1, tt & -tt),
                                        ot.tag = 2;
                                        var lt = it.updateQueue;
                                        if (lt !== null) {
                                            lt = lt.shared;
                                            var dt = lt.pending;
                                            dt === null ? ot.next = ot : (ot.next = dt.next,
                                            dt.next = ot),
                                            lt.pending = ot
                                        }
                                    }
                                    it.lanes |= tt,
                                    ot = it.alternate,
                                    ot !== null && (ot.lanes |= tt),
                                    Sg(it.return, tt, et),
                                    at.lanes |= tt;
                                    break
                                }
                                ot = ot.next
                            }
                        } else if (it.tag === 10)
                            st = it.type === et.type ? null : it.child;
                        else if (it.tag === 18) {
                            if (st = it.return,
                            st === null)
                                throw Error(p$8(341));
                            st.lanes |= tt,
                            at = st.alternate,
                            at !== null && (at.lanes |= tt),
                            Sg(st, tt, et),
                            st = it.sibling
                        } else
                            st = it.child;
                        if (st !== null)
                            st.return = it;
                        else
                            for (st = it; st !== null; ) {
                                if (st === et) {
                                    st = null;
                                    break
                                }
                                if (it = st.sibling,
                                it !== null) {
                                    it.return = st.return,
                                    st = it;
                                    break
                                }
                                st = st.return
                            }
                        it = st
                    }
            Yi(_e, et, nt.children, tt),
            et = et.child
        }
        return et;
    case 9:
        return nt = et.type,
        rt = et.pendingProps.children,
        Tg(et, tt),
        nt = Vg(nt),
        rt = rt(nt),
        et.flags |= 1,
        Yi(_e, et, rt, tt),
        et.child;
    case 14:
        return rt = et.type,
        nt = Lg(rt, et.pendingProps),
        nt = Lg(rt.type, nt),
        aj(_e, et, rt, nt, tt);
    case 15:
        return cj(_e, et, et.type, et.pendingProps, tt);
    case 17:
        return rt = et.type,
        nt = et.pendingProps,
        nt = et.elementType === rt ? nt : Lg(rt, nt),
        jj(_e, et),
        et.tag = 1,
        Zf(rt) ? (_e = !0,
        cg(et)) : _e = !1,
        Tg(et, tt),
        ph(et, rt, nt),
        rh(et, rt, nt, tt),
        kj(null, et, rt, !0, _e, tt);
    case 19:
        return yj(_e, et, tt);
    case 22:
        return ej(_e, et, tt)
    }
    throw Error(p$8(156, et.tag))
}
;
function Gk(_e, et) {
    return ac(_e, et)
}
function al(_e, et, tt, rt) {
    this.tag = _e,
    this.key = tt,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = et,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = rt,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Bg(_e, et, tt, rt) {
    return new al(_e,et,tt,rt)
}
function bj(_e) {
    return _e = _e.prototype,
    !(!_e || !_e.isReactComponent)
}
function $k(_e) {
    if (typeof _e == "function")
        return bj(_e) ? 1 : 0;
    if (_e != null) {
        if (_e = _e.$$typeof,
        _e === Da)
            return 11;
        if (_e === Ga)
            return 14
    }
    return 2
}
function wh(_e, et) {
    var tt = _e.alternate;
    return tt === null ? (tt = Bg(_e.tag, et, _e.key, _e.mode),
    tt.elementType = _e.elementType,
    tt.type = _e.type,
    tt.stateNode = _e.stateNode,
    tt.alternate = _e,
    _e.alternate = tt) : (tt.pendingProps = et,
    tt.type = _e.type,
    tt.flags = 0,
    tt.subtreeFlags = 0,
    tt.deletions = null),
    tt.flags = _e.flags & 14680064,
    tt.childLanes = _e.childLanes,
    tt.lanes = _e.lanes,
    tt.child = _e.child,
    tt.memoizedProps = _e.memoizedProps,
    tt.memoizedState = _e.memoizedState,
    tt.updateQueue = _e.updateQueue,
    et = _e.dependencies,
    tt.dependencies = et === null ? null : {
        lanes: et.lanes,
        firstContext: et.firstContext
    },
    tt.sibling = _e.sibling,
    tt.index = _e.index,
    tt.ref = _e.ref,
    tt
}
function yh(_e, et, tt, rt, nt, it) {
    var st = 2;
    if (rt = _e,
    typeof _e == "function")
        bj(_e) && (st = 1);
    else if (typeof _e == "string")
        st = 5;
    else
        e: switch (_e) {
        case ya:
            return Ah(tt.children, nt, it, et);
        case za:
            st = 8,
            nt |= 8;
            break;
        case Aa:
            return _e = Bg(12, tt, et, nt | 2),
            _e.elementType = Aa,
            _e.lanes = it,
            _e;
        case Ea:
            return _e = Bg(13, tt, et, nt),
            _e.elementType = Ea,
            _e.lanes = it,
            _e;
        case Fa:
            return _e = Bg(19, tt, et, nt),
            _e.elementType = Fa,
            _e.lanes = it,
            _e;
        case Ia:
            return qj(tt, nt, it, et);
        default:
            if (typeof _e == "object" && _e !== null)
                switch (_e.$$typeof) {
                case Ba:
                    st = 10;
                    break e;
                case Ca:
                    st = 9;
                    break e;
                case Da:
                    st = 11;
                    break e;
                case Ga:
                    st = 14;
                    break e;
                case Ha:
                    st = 16,
                    rt = null;
                    break e
                }
            throw Error(p$8(130, _e == null ? _e : typeof _e, ""))
        }
    return et = Bg(st, tt, et, nt),
    et.elementType = _e,
    et.type = rt,
    et.lanes = it,
    et
}
function Ah(_e, et, tt, rt) {
    return _e = Bg(7, _e, rt, et),
    _e.lanes = tt,
    _e
}
function qj(_e, et, tt, rt) {
    return _e = Bg(22, _e, rt, et),
    _e.elementType = Ia,
    _e.lanes = tt,
    _e.stateNode = {
        isHidden: !1
    },
    _e
}
function xh(_e, et, tt) {
    return _e = Bg(6, _e, null, et),
    _e.lanes = tt,
    _e
}
function zh(_e, et, tt) {
    return et = Bg(4, _e.children !== null ? _e.children : [], _e.key, et),
    et.lanes = tt,
    et.stateNode = {
        containerInfo: _e.containerInfo,
        pendingChildren: null,
        implementation: _e.implementation
    },
    et
}
function bl(_e, et, tt, rt, nt) {
    this.tag = et,
    this.containerInfo = _e,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = zc(0),
    this.expirationTimes = zc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = zc(0),
    this.identifierPrefix = rt,
    this.onRecoverableError = nt,
    this.mutableSourceEagerHydrationData = null
}
function cl(_e, et, tt, rt, nt, it, st, at, ot) {
    return _e = new bl(_e,et,tt,at,ot),
    et === 1 ? (et = 1,
    it === !0 && (et |= 8)) : et = 0,
    it = Bg(3, null, null, et),
    _e.current = it,
    it.stateNode = _e,
    it.memoizedState = {
        element: rt,
        isDehydrated: tt,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    ah(it),
    _e
}
function dl(_e, et, tt) {
    var rt = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: rt == null ? null : "" + rt,
        children: _e,
        containerInfo: et,
        implementation: tt
    }
}
function el(_e) {
    if (!_e)
        return Vf;
    _e = _e._reactInternals;
    e: {
        if (Vb(_e) !== _e || _e.tag !== 1)
            throw Error(p$8(170));
        var et = _e;
        do {
            switch (et.tag) {
            case 3:
                et = et.stateNode.context;
                break e;
            case 1:
                if (Zf(et.type)) {
                    et = et.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            et = et.return
        } while (et !== null);
        throw Error(p$8(171))
    }
    if (_e.tag === 1) {
        var tt = _e.type;
        if (Zf(tt))
            return bg(_e, tt, et)
    }
    return et
}
function fl(_e, et, tt, rt, nt, it, st, at, ot) {
    return _e = cl(tt, rt, !0, _e, nt, it, st, at, ot),
    _e.context = el(null),
    tt = _e.current,
    rt = L$3(),
    nt = lh(tt),
    it = ch(rt, nt),
    it.callback = et ?? null,
    dh(tt, it, nt),
    _e.current.lanes = nt,
    Ac(_e, nt, rt),
    Ek(_e, rt),
    _e
}
function gl(_e, et, tt, rt) {
    var nt = et.current
      , it = L$3()
      , st = lh(nt);
    return tt = el(tt),
    et.context === null ? et.context = tt : et.pendingContext = tt,
    et = ch(it, st),
    et.payload = {
        element: _e
    },
    rt = rt === void 0 ? null : rt,
    rt !== null && (et.callback = rt),
    _e = dh(nt, et, st),
    _e !== null && (mh(_e, nt, st, it),
    eh(_e, nt, st)),
    st
}
function hl(_e) {
    if (_e = _e.current,
    !_e.child)
        return null;
    switch (_e.child.tag) {
    case 5:
        return _e.child.stateNode;
    default:
        return _e.child.stateNode
    }
}
function il(_e, et) {
    if (_e = _e.memoizedState,
    _e !== null && _e.dehydrated !== null) {
        var tt = _e.retryLane;
        _e.retryLane = tt !== 0 && tt < et ? tt : et
    }
}
function jl(_e, et) {
    il(_e, et),
    (_e = _e.alternate) && il(_e, et)
}
function kl() {
    return null
}
var ll = typeof reportError == "function" ? reportError : function(_e) {
    console.error(_e)
}
;
function ml(_e) {
    this._internalRoot = _e
}
nl.prototype.render = ml.prototype.render = function(_e) {
    var et = this._internalRoot;
    if (et === null)
        throw Error(p$8(409));
    gl(_e, et, null, null)
}
;
nl.prototype.unmount = ml.prototype.unmount = function() {
    var _e = this._internalRoot;
    if (_e !== null) {
        this._internalRoot = null;
        var et = _e.containerInfo;
        Sk(function() {
            gl(null, _e, null, null)
        }),
        et[uf] = null
    }
}
;
function nl(_e) {
    this._internalRoot = _e
}
nl.prototype.unstable_scheduleHydration = function(_e) {
    if (_e) {
        var et = Hc();
        _e = {
            blockedOn: null,
            target: _e,
            priority: et
        };
        for (var tt = 0; tt < Qc.length && et !== 0 && et < Qc[tt].priority; tt++)
            ;
        Qc.splice(tt, 0, _e),
        tt === 0 && Vc(_e)
    }
}
;
function ol(_e) {
    return !(!_e || _e.nodeType !== 1 && _e.nodeType !== 9 && _e.nodeType !== 11)
}
function pl(_e) {
    return !(!_e || _e.nodeType !== 1 && _e.nodeType !== 9 && _e.nodeType !== 11 && (_e.nodeType !== 8 || _e.nodeValue !== " react-mount-point-unstable "))
}
function ql() {}
function rl(_e, et, tt, rt, nt) {
    if (nt) {
        if (typeof rt == "function") {
            var it = rt;
            rt = function() {
                var lt = hl(st);
                it.call(lt)
            }
        }
        var st = fl(et, rt, _e, 0, null, !1, !1, "", ql);
        return _e._reactRootContainer = st,
        _e[uf] = st.current,
        sf(_e.nodeType === 8 ? _e.parentNode : _e),
        Sk(),
        st
    }
    for (; nt = _e.lastChild; )
        _e.removeChild(nt);
    if (typeof rt == "function") {
        var at = rt;
        rt = function() {
            var lt = hl(ot);
            at.call(lt)
        }
    }
    var ot = cl(_e, 0, !1, null, null, !1, !1, "", ql);
    return _e._reactRootContainer = ot,
    _e[uf] = ot.current,
    sf(_e.nodeType === 8 ? _e.parentNode : _e),
    Sk(function() {
        gl(et, ot, tt, rt)
    }),
    ot
}
function sl(_e, et, tt, rt, nt) {
    var it = tt._reactRootContainer;
    if (it) {
        var st = it;
        if (typeof nt == "function") {
            var at = nt;
            nt = function() {
                var ot = hl(st);
                at.call(ot)
            }
        }
        gl(et, st, _e, nt)
    } else
        st = rl(tt, et, _e, nt, rt);
    return hl(st)
}
Ec = function(_e) {
    switch (_e.tag) {
    case 3:
        var et = _e.stateNode;
        if (et.current.memoizedState.isDehydrated) {
            var tt = tc(et.pendingLanes);
            tt !== 0 && (Cc(et, tt | 1),
            Ek(et, B$1()),
            !(K & 6) && (Hj = B$1() + 500,
            jg()))
        }
        break;
    case 13:
        Sk(function() {
            var rt = Zg(_e, 1);
            if (rt !== null) {
                var nt = L$3();
                mh(rt, _e, 1, nt)
            }
        }),
        jl(_e, 1)
    }
}
;
Fc = function(_e) {
    if (_e.tag === 13) {
        var et = Zg(_e, 134217728);
        if (et !== null) {
            var tt = L$3();
            mh(et, _e, 134217728, tt)
        }
        jl(_e, 134217728)
    }
}
;
Gc = function(_e) {
    if (_e.tag === 13) {
        var et = lh(_e)
          , tt = Zg(_e, et);
        if (tt !== null) {
            var rt = L$3();
            mh(tt, _e, et, rt)
        }
        jl(_e, et)
    }
}
;
Hc = function() {
    return C$3
}
;
Ic = function(_e, et) {
    var tt = C$3;
    try {
        return C$3 = _e,
        et()
    } finally {
        C$3 = tt
    }
}
;
yb = function(_e, et, tt) {
    switch (et) {
    case "input":
        if (bb(_e, tt),
        et = tt.name,
        tt.type === "radio" && et != null) {
            for (tt = _e; tt.parentNode; )
                tt = tt.parentNode;
            for (tt = tt.querySelectorAll("input[name=" + JSON.stringify("" + et) + '][type="radio"]'),
            et = 0; et < tt.length; et++) {
                var rt = tt[et];
                if (rt !== _e && rt.form === _e.form) {
                    var nt = Db(rt);
                    if (!nt)
                        throw Error(p$8(90));
                    Wa(rt),
                    bb(rt, nt)
                }
            }
        }
        break;
    case "textarea":
        ib(_e, tt);
        break;
    case "select":
        et = tt.value,
        et != null && fb(_e, !!tt.multiple, et, !1)
    }
}
;
Gb = Rk;
Hb = Sk;
var tl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue, Db, Eb, Fb, Rk]
}
  , ul = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , vl = {
    bundleType: ul.bundleType,
    version: ul.version,
    rendererPackageName: ul.rendererPackageName,
    rendererConfig: ul.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(_e) {
        return _e = Zb(_e),
        _e === null ? null : _e.stateNode
    },
    findFiberByHostInstance: ul.findFiberByHostInstance || kl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!wl.isDisabled && wl.supportsFiber)
        try {
            kc = wl.inject(vl),
            lc = wl
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(_e, et) {
    var tt = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!ol(et))
        throw Error(p$8(200));
    return dl(_e, et, null, tt)
}
;
reactDom_production_min.createRoot = function(_e, et) {
    if (!ol(_e))
        throw Error(p$8(299));
    var tt = !1
      , rt = ""
      , nt = ll;
    return et != null && (et.unstable_strictMode === !0 && (tt = !0),
    et.identifierPrefix !== void 0 && (rt = et.identifierPrefix),
    et.onRecoverableError !== void 0 && (nt = et.onRecoverableError)),
    et = cl(_e, 1, !1, null, null, tt, !1, rt, nt),
    _e[uf] = et.current,
    sf(_e.nodeType === 8 ? _e.parentNode : _e),
    new ml(et)
}
;
reactDom_production_min.findDOMNode = function(_e) {
    if (_e == null)
        return null;
    if (_e.nodeType === 1)
        return _e;
    var et = _e._reactInternals;
    if (et === void 0)
        throw typeof _e.render == "function" ? Error(p$8(188)) : (_e = Object.keys(_e).join(","),
        Error(p$8(268, _e)));
    return _e = Zb(et),
    _e = _e === null ? null : _e.stateNode,
    _e
}
;
reactDom_production_min.flushSync = function(_e) {
    return Sk(_e)
}
;
reactDom_production_min.hydrate = function(_e, et, tt) {
    if (!pl(et))
        throw Error(p$8(200));
    return sl(null, _e, et, !0, tt)
}
;
reactDom_production_min.hydrateRoot = function(_e, et, tt) {
    if (!ol(_e))
        throw Error(p$8(405));
    var rt = tt != null && tt.hydratedSources || null
      , nt = !1
      , it = ""
      , st = ll;
    if (tt != null && (tt.unstable_strictMode === !0 && (nt = !0),
    tt.identifierPrefix !== void 0 && (it = tt.identifierPrefix),
    tt.onRecoverableError !== void 0 && (st = tt.onRecoverableError)),
    et = fl(et, null, _e, 1, tt ?? null, nt, !1, it, st),
    _e[uf] = et.current,
    sf(_e),
    rt)
        for (_e = 0; _e < rt.length; _e++)
            tt = rt[_e],
            nt = tt._getVersion,
            nt = nt(tt._source),
            et.mutableSourceEagerHydrationData == null ? et.mutableSourceEagerHydrationData = [tt, nt] : et.mutableSourceEagerHydrationData.push(tt, nt);
    return new nl(et)
}
;
reactDom_production_min.render = function(_e, et, tt) {
    if (!pl(et))
        throw Error(p$8(200));
    return sl(null, _e, et, !1, tt)
}
;
reactDom_production_min.unmountComponentAtNode = function(_e) {
    if (!pl(_e))
        throw Error(p$8(40));
    return _e._reactRootContainer ? (Sk(function() {
        sl(null, null, _e, !1, function() {
            _e._reactRootContainer = null,
            _e[uf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(_e, et, tt, rt) {
    if (!pl(tt))
        throw Error(p$8(200));
    if (_e == null || _e._reactInternals === void 0)
        throw Error(p$8(38));
    return sl(_e, et, tt, !1, rt)
}
;
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (_e) {
            console.error(_e)
        }
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports
  , m$4 = reactDomExports;
client.createRoot = m$4.createRoot,
client.hydrateRoot = m$4.hydrateRoot;
/**
 * @remix-run/router v1.15.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$5() {
    return _extends$5 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var et = 1; et < arguments.length; et++) {
            var tt = arguments[et];
            for (var rt in tt)
                Object.prototype.hasOwnProperty.call(tt, rt) && (_e[rt] = tt[rt])
        }
        return _e
    }
    ,
    _extends$5.apply(this, arguments)
}
var Action;
(function(_e) {
    _e.Pop = "POP",
    _e.Push = "PUSH",
    _e.Replace = "REPLACE"
}
)(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(_e) {
    _e === void 0 && (_e = {});
    function et(rt, nt) {
        let {pathname: it, search: st, hash: at} = rt.location;
        return createLocation("", {
            pathname: it,
            search: st,
            hash: at
        }, nt.state && nt.state.usr || null, nt.state && nt.state.key || "default")
    }
    function tt(rt, nt) {
        return typeof nt == "string" ? nt : createPath(nt)
    }
    return getUrlBasedHistory(et, tt, null, _e)
}
function invariant(_e, et) {
    if (_e === !1 || _e === null || typeof _e > "u")
        throw new Error(et)
}
function warning$1(_e, et) {
    if (!_e) {
        typeof console < "u" && console.warn(et);
        try {
            throw new Error(et)
        } catch {}
    }
}
function createKey() {
    return Math.random().toString(36).substr(2, 8)
}
function getHistoryState(_e, et) {
    return {
        usr: _e.state,
        key: _e.key,
        idx: et
    }
}
function createLocation(_e, et, tt, rt) {
    return tt === void 0 && (tt = null),
    _extends$5({
        pathname: typeof _e == "string" ? _e : _e.pathname,
        search: "",
        hash: ""
    }, typeof et == "string" ? parsePath(et) : et, {
        state: tt,
        key: et && et.key || rt || createKey()
    })
}
function createPath(_e) {
    let {pathname: et="/", search: tt="", hash: rt=""} = _e;
    return tt && tt !== "?" && (et += tt.charAt(0) === "?" ? tt : "?" + tt),
    rt && rt !== "#" && (et += rt.charAt(0) === "#" ? rt : "#" + rt),
    et
}
function parsePath(_e) {
    let et = {};
    if (_e) {
        let tt = _e.indexOf("#");
        tt >= 0 && (et.hash = _e.substr(tt),
        _e = _e.substr(0, tt));
        let rt = _e.indexOf("?");
        rt >= 0 && (et.search = _e.substr(rt),
        _e = _e.substr(0, rt)),
        _e && (et.pathname = _e)
    }
    return et
}
function getUrlBasedHistory(_e, et, tt, rt) {
    rt === void 0 && (rt = {});
    let {window: nt=document.defaultView, v5Compat: it=!1} = rt
      , st = nt.history
      , at = Action.Pop
      , ot = null
      , lt = dt();
    lt == null && (lt = 0,
    st.replaceState(_extends$5({}, st.state, {
        idx: lt
    }), ""));
    function dt() {
        return (st.state || {
            idx: null
        }).idx
    }
    function ct() {
        at = Action.Pop;
        let bt = dt()
          , pt = bt == null ? null : bt - lt;
        lt = bt,
        ot && ot({
            action: at,
            location: gt.location,
            delta: pt
        })
    }
    function ut(bt, pt) {
        at = Action.Push;
        let mt = createLocation(gt.location, bt, pt);
        tt && tt(mt, bt),
        lt = dt() + 1;
        let yt = getHistoryState(mt, lt)
          , vt = gt.createHref(mt);
        try {
            st.pushState(yt, "", vt)
        } catch (wt) {
            if (wt instanceof DOMException && wt.name === "DataCloneError")
                throw wt;
            nt.location.assign(vt)
        }
        it && ot && ot({
            action: at,
            location: gt.location,
            delta: 1
        })
    }
    function ft(bt, pt) {
        at = Action.Replace;
        let mt = createLocation(gt.location, bt, pt);
        tt && tt(mt, bt),
        lt = dt();
        let yt = getHistoryState(mt, lt)
          , vt = gt.createHref(mt);
        st.replaceState(yt, "", vt),
        it && ot && ot({
            action: at,
            location: gt.location,
            delta: 0
        })
    }
    function ht(bt) {
        let pt = nt.location.origin !== "null" ? nt.location.origin : nt.location.href
          , mt = typeof bt == "string" ? bt : createPath(bt);
        return mt = mt.replace(/ $/, "%20"),
        invariant(pt, "No window.location.(origin|href) available to create URL for href: " + mt),
        new URL(mt,pt)
    }
    let gt = {
        get action() {
            return at
        },
        get location() {
            return _e(nt, st)
        },
        listen(bt) {
            if (ot)
                throw new Error("A history only accepts one active listener");
            return nt.addEventListener(PopStateEventType, ct),
            ot = bt,
            ()=>{
                nt.removeEventListener(PopStateEventType, ct),
                ot = null
            }
        },
        createHref(bt) {
            return et(nt, bt)
        },
        createURL: ht,
        encodeLocation(bt) {
            let pt = ht(bt);
            return {
                pathname: pt.pathname,
                search: pt.search,
                hash: pt.hash
            }
        },
        push: ut,
        replace: ft,
        go(bt) {
            return st.go(bt)
        }
    };
    return gt
}
var ResultType;
(function(_e) {
    _e.data = "data",
    _e.deferred = "deferred",
    _e.redirect = "redirect",
    _e.error = "error"
}
)(ResultType || (ResultType = {}));
function matchRoutes(_e, et, tt) {
    tt === void 0 && (tt = "/");
    let rt = typeof et == "string" ? parsePath(et) : et
      , nt = stripBasename(rt.pathname || "/", tt);
    if (nt == null)
        return null;
    let it = flattenRoutes(_e);
    rankRouteBranches(it);
    let st = null;
    for (let at = 0; st == null && at < it.length; ++at) {
        let ot = decodePath(nt);
        st = matchRouteBranch(it[at], ot)
    }
    return st
}
function flattenRoutes(_e, et, tt, rt) {
    et === void 0 && (et = []),
    tt === void 0 && (tt = []),
    rt === void 0 && (rt = "");
    let nt = (it,st,at)=>{
        let ot = {
            relativePath: at === void 0 ? it.path || "" : at,
            caseSensitive: it.caseSensitive === !0,
            childrenIndex: st,
            route: it
        };
        ot.relativePath.startsWith("/") && (invariant(ot.relativePath.startsWith(rt), 'Absolute route path "' + ot.relativePath + '" nested under path ' + ('"' + rt + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        ot.relativePath = ot.relativePath.slice(rt.length));
        let lt = joinPaths([rt, ot.relativePath])
          , dt = tt.concat(ot);
        it.children && it.children.length > 0 && (invariant(it.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + lt + '".')),
        flattenRoutes(it.children, et, dt, lt)),
        !(it.path == null && !it.index) && et.push({
            path: lt,
            score: computeScore(lt, it.index),
            routesMeta: dt
        })
    }
    ;
    return _e.forEach((it,st)=>{
        var at;
        if (it.path === "" || !((at = it.path) != null && at.includes("?")))
            nt(it, st);
        else
            for (let ot of explodeOptionalSegments(it.path))
                nt(it, st, ot)
    }
    ),
    et
}
function explodeOptionalSegments(_e) {
    let et = _e.split("/");
    if (et.length === 0)
        return [];
    let[tt,...rt] = et
      , nt = tt.endsWith("?")
      , it = tt.replace(/\?$/, "");
    if (rt.length === 0)
        return nt ? [it, ""] : [it];
    let st = explodeOptionalSegments(rt.join("/"))
      , at = [];
    return at.push(...st.map(ot=>ot === "" ? it : [it, ot].join("/"))),
    nt && at.push(...st),
    at.map(ot=>_e.startsWith("/") && ot === "" ? "/" : ot)
}
function rankRouteBranches(_e) {
    _e.sort((et,tt)=>et.score !== tt.score ? tt.score - et.score : compareIndexes(et.routesMeta.map(rt=>rt.childrenIndex), tt.routesMeta.map(rt=>rt.childrenIndex)))
}
const paramRe = /^:[\w-]+$/
  , dynamicSegmentValue = 3
  , indexRouteValue = 2
  , emptySegmentValue = 1
  , staticSegmentValue = 10
  , splatPenalty = -2
  , isSplat = _e=>_e === "*";
function computeScore(_e, et) {
    let tt = _e.split("/")
      , rt = tt.length;
    return tt.some(isSplat) && (rt += splatPenalty),
    et && (rt += indexRouteValue),
    tt.filter(nt=>!isSplat(nt)).reduce((nt,it)=>nt + (paramRe.test(it) ? dynamicSegmentValue : it === "" ? emptySegmentValue : staticSegmentValue), rt)
}
function compareIndexes(_e, et) {
    return _e.length === et.length && _e.slice(0, -1).every((rt,nt)=>rt === et[nt]) ? _e[_e.length - 1] - et[et.length - 1] : 0
}
function matchRouteBranch(_e, et) {
    let {routesMeta: tt} = _e
      , rt = {}
      , nt = "/"
      , it = [];
    for (let st = 0; st < tt.length; ++st) {
        let at = tt[st]
          , ot = st === tt.length - 1
          , lt = nt === "/" ? et : et.slice(nt.length) || "/"
          , dt = matchPath({
            path: at.relativePath,
            caseSensitive: at.caseSensitive,
            end: ot
        }, lt);
        if (!dt)
            return null;
        Object.assign(rt, dt.params);
        let ct = at.route;
        it.push({
            params: rt,
            pathname: joinPaths([nt, dt.pathname]),
            pathnameBase: normalizePathname(joinPaths([nt, dt.pathnameBase])),
            route: ct
        }),
        dt.pathnameBase !== "/" && (nt = joinPaths([nt, dt.pathnameBase]))
    }
    return it
}
function matchPath(_e, et) {
    typeof _e == "string" && (_e = {
        path: _e,
        caseSensitive: !1,
        end: !0
    });
    let[tt,rt] = compilePath(_e.path, _e.caseSensitive, _e.end)
      , nt = et.match(tt);
    if (!nt)
        return null;
    let it = nt[0]
      , st = it.replace(/(.)\/+$/, "$1")
      , at = nt.slice(1);
    return {
        params: rt.reduce((lt,dt,ct)=>{
            let {paramName: ut, isOptional: ft} = dt;
            if (ut === "*") {
                let gt = at[ct] || "";
                st = it.slice(0, it.length - gt.length).replace(/(.)\/+$/, "$1")
            }
            const ht = at[ct];
            return ft && !ht ? lt[ut] = void 0 : lt[ut] = (ht || "").replace(/%2F/g, "/"),
            lt
        }
        , {}),
        pathname: it,
        pathnameBase: st,
        pattern: _e
    }
}
function compilePath(_e, et, tt) {
    et === void 0 && (et = !1),
    tt === void 0 && (tt = !0),
    warning$1(_e === "*" || !_e.endsWith("*") || _e.endsWith("/*"), 'Route path "' + _e + '" will be treated as if it were ' + ('"' + _e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + _e.replace(/\*$/, "/*") + '".'));
    let rt = []
      , nt = "^" + _e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (st,at,ot)=>(rt.push({
        paramName: at,
        isOptional: ot != null
    }),
    ot ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return _e.endsWith("*") ? (rt.push({
        paramName: "*"
    }),
    nt += _e === "*" || _e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : tt ? nt += "\\/*$" : _e !== "" && _e !== "/" && (nt += "(?:(?=\\/|$))"),
    [new RegExp(nt,et ? void 0 : "i"), rt]
}
function decodePath(_e) {
    try {
        return _e.split("/").map(et=>decodeURIComponent(et).replace(/\//g, "%2F")).join("/")
    } catch (et) {
        return warning$1(!1, 'The URL path "' + _e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + et + ").")),
        _e
    }
}
function stripBasename(_e, et) {
    if (et === "/")
        return _e;
    if (!_e.toLowerCase().startsWith(et.toLowerCase()))
        return null;
    let tt = et.endsWith("/") ? et.length - 1 : et.length
      , rt = _e.charAt(tt);
    return rt && rt !== "/" ? null : _e.slice(tt) || "/"
}
function resolvePath(_e, et) {
    et === void 0 && (et = "/");
    let {pathname: tt, search: rt="", hash: nt=""} = typeof _e == "string" ? parsePath(_e) : _e;
    return {
        pathname: tt ? tt.startsWith("/") ? tt : resolvePathname(tt, et) : et,
        search: normalizeSearch(rt),
        hash: normalizeHash(nt)
    }
}
function resolvePathname(_e, et) {
    let tt = et.replace(/\/+$/, "").split("/");
    return _e.split("/").forEach(nt=>{
        nt === ".." ? tt.length > 1 && tt.pop() : nt !== "." && tt.push(nt)
    }
    ),
    tt.length > 1 ? tt.join("/") : "/"
}
function getInvalidPathError(_e, et, tt, rt) {
    return "Cannot include a '" + _e + "' character in a manually specified " + ("`to." + et + "` field [" + JSON.stringify(rt) + "].  Please separate it out to the ") + ("`to." + tt + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function getPathContributingMatches(_e) {
    return _e.filter((et,tt)=>tt === 0 || et.route.path && et.route.path.length > 0)
}
function getResolveToMatches(_e, et) {
    let tt = getPathContributingMatches(_e);
    return et ? tt.map((rt,nt)=>nt === _e.length - 1 ? rt.pathname : rt.pathnameBase) : tt.map(rt=>rt.pathnameBase)
}
function resolveTo(_e, et, tt, rt) {
    rt === void 0 && (rt = !1);
    let nt;
    typeof _e == "string" ? nt = parsePath(_e) : (nt = _extends$5({}, _e),
    invariant(!nt.pathname || !nt.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", nt)),
    invariant(!nt.pathname || !nt.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", nt)),
    invariant(!nt.search || !nt.search.includes("#"), getInvalidPathError("#", "search", "hash", nt)));
    let it = _e === "" || nt.pathname === "", st = it ? "/" : nt.pathname, at;
    if (st == null)
        at = tt;
    else {
        let ct = et.length - 1;
        if (!rt && st.startsWith("..")) {
            let ut = st.split("/");
            for (; ut[0] === ".."; )
                ut.shift(),
                ct -= 1;
            nt.pathname = ut.join("/")
        }
        at = ct >= 0 ? et[ct] : "/"
    }
    let ot = resolvePath(nt, at)
      , lt = st && st !== "/" && st.endsWith("/")
      , dt = (it || st === ".") && tt.endsWith("/");
    return !ot.pathname.endsWith("/") && (lt || dt) && (ot.pathname += "/"),
    ot
}
const joinPaths = _e=>_e.join("/").replace(/\/\/+/g, "/")
  , normalizePathname = _e=>_e.replace(/\/+$/, "").replace(/^\/*/, "/")
  , normalizeSearch = _e=>!_e || _e === "?" ? "" : _e.startsWith("?") ? _e : "?" + _e
  , normalizeHash = _e=>!_e || _e === "#" ? "" : _e.startsWith("#") ? _e : "#" + _e;
function isRouteErrorResponse(_e) {
    return _e != null && typeof _e.status == "number" && typeof _e.statusText == "string" && typeof _e.internal == "boolean" && "data"in _e
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.22.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
    return _extends$4 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var et = 1; et < arguments.length; et++) {
            var tt = arguments[et];
            for (var rt in tt)
                Object.prototype.hasOwnProperty.call(tt, rt) && (_e[rt] = tt[rt])
        }
        return _e
    }
    ,
    _extends$4.apply(this, arguments)
}
const DataRouterContext = reactExports.createContext(null)
  , DataRouterStateContext = reactExports.createContext(null)
  , NavigationContext = reactExports.createContext(null)
  , LocationContext = reactExports.createContext(null)
  , RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , RouteErrorContext = reactExports.createContext(null);
function useHref(_e, et) {
    let {relative: tt} = et === void 0 ? {} : et;
    useInRouterContext() || invariant(!1);
    let {basename: rt, navigator: nt} = reactExports.useContext(NavigationContext)
      , {hash: it, pathname: st, search: at} = useResolvedPath(_e, {
        relative: tt
    })
      , ot = st;
    return rt !== "/" && (ot = st === "/" ? rt : joinPaths([rt, st])),
    nt.createHref({
        pathname: ot,
        search: at,
        hash: it
    })
}
function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}
function useLocation() {
    return useInRouterContext() || invariant(!1),
    reactExports.useContext(LocationContext).location
}
function useIsomorphicLayoutEffect$3(_e) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(_e)
}
function useNavigate() {
    let {isDataRoute: _e} = reactExports.useContext(RouteContext);
    return _e ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
    useInRouterContext() || invariant(!1);
    let _e = reactExports.useContext(DataRouterContext)
      , {basename: et, future: tt, navigator: rt} = reactExports.useContext(NavigationContext)
      , {matches: nt} = reactExports.useContext(RouteContext)
      , {pathname: it} = useLocation()
      , st = JSON.stringify(getResolveToMatches(nt, tt.v7_relativeSplatPath))
      , at = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$3(()=>{
        at.current = !0
    }
    ),
    reactExports.useCallback(function(lt, dt) {
        if (dt === void 0 && (dt = {}),
        !at.current)
            return;
        if (typeof lt == "number") {
            rt.go(lt);
            return
        }
        let ct = resolveTo(lt, JSON.parse(st), it, dt.relative === "path");
        _e == null && et !== "/" && (ct.pathname = ct.pathname === "/" ? et : joinPaths([et, ct.pathname])),
        (dt.replace ? rt.replace : rt.push)(ct, dt.state, dt)
    }, [et, rt, st, it, _e])
}
const OutletContext = reactExports.createContext(null);
function useOutlet(_e) {
    let et = reactExports.useContext(RouteContext).outlet;
    return et && reactExports.createElement(OutletContext.Provider, {
        value: _e
    }, et)
}
function useResolvedPath(_e, et) {
    let {relative: tt} = et === void 0 ? {} : et
      , {future: rt} = reactExports.useContext(NavigationContext)
      , {matches: nt} = reactExports.useContext(RouteContext)
      , {pathname: it} = useLocation()
      , st = JSON.stringify(getResolveToMatches(nt, rt.v7_relativeSplatPath));
    return reactExports.useMemo(()=>resolveTo(_e, JSON.parse(st), it, tt === "path"), [_e, st, it, tt])
}
function useRoutes(_e, et) {
    return useRoutesImpl(_e, et)
}
function useRoutesImpl(_e, et, tt, rt) {
    useInRouterContext() || invariant(!1);
    let {navigator: nt} = reactExports.useContext(NavigationContext)
      , {matches: it} = reactExports.useContext(RouteContext)
      , st = it[it.length - 1]
      , at = st ? st.params : {};
    st && st.pathname;
    let ot = st ? st.pathnameBase : "/";
    st && st.route;
    let lt = useLocation(), dt;
    if (et) {
        var ct;
        let bt = typeof et == "string" ? parsePath(et) : et;
        ot === "/" || (ct = bt.pathname) != null && ct.startsWith(ot) || invariant(!1),
        dt = bt
    } else
        dt = lt;
    let ut = dt.pathname || "/"
      , ft = ut;
    if (ot !== "/") {
        let bt = ot.replace(/^\//, "").split("/");
        ft = "/" + ut.replace(/^\//, "").split("/").slice(bt.length).join("/")
    }
    let ht = matchRoutes(_e, {
        pathname: ft
    })
      , gt = _renderMatches(ht && ht.map(bt=>Object.assign({}, bt, {
        params: Object.assign({}, at, bt.params),
        pathname: joinPaths([ot, nt.encodeLocation ? nt.encodeLocation(bt.pathname).pathname : bt.pathname]),
        pathnameBase: bt.pathnameBase === "/" ? ot : joinPaths([ot, nt.encodeLocation ? nt.encodeLocation(bt.pathnameBase).pathname : bt.pathnameBase])
    })), it, tt, rt);
    return et && gt ? reactExports.createElement(LocationContext.Provider, {
        value: {
            location: _extends$4({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, dt),
            navigationType: Action.Pop
        }
    }, gt) : gt
}
function DefaultErrorComponent() {
    let _e = useRouteError()
      , et = isRouteErrorResponse(_e) ? _e.status + " " + _e.statusText : _e instanceof Error ? _e.message : JSON.stringify(_e)
      , tt = _e instanceof Error ? _e.stack : null
      , nt = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    };
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, et), tt ? reactExports.createElement("pre", {
        style: nt
    }, tt) : null, null)
}
const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
    constructor(et) {
        super(et),
        this.state = {
            location: et.location,
            revalidation: et.revalidation,
            error: et.error
        }
    }
    static getDerivedStateFromError(et) {
        return {
            error: et
        }
    }
    static getDerivedStateFromProps(et, tt) {
        return tt.location !== et.location || tt.revalidation !== "idle" && et.revalidation === "idle" ? {
            error: et.error,
            location: et.location,
            revalidation: et.revalidation
        } : {
            error: et.error !== void 0 ? et.error : tt.error,
            location: tt.location,
            revalidation: et.revalidation || tt.revalidation
        }
    }
    componentDidCatch(et, tt) {
        console.error("React Router caught the following error during render", et, tt)
    }
    render() {
        return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function RenderedRoute(_e) {
    let {routeContext: et, match: tt, children: rt} = _e
      , nt = reactExports.useContext(DataRouterContext);
    return nt && nt.static && nt.staticContext && (tt.route.errorElement || tt.route.ErrorBoundary) && (nt.staticContext._deepestRenderedBoundaryId = tt.route.id),
    reactExports.createElement(RouteContext.Provider, {
        value: et
    }, rt)
}
function _renderMatches(_e, et, tt, rt) {
    var nt;
    if (et === void 0 && (et = []),
    tt === void 0 && (tt = null),
    rt === void 0 && (rt = null),
    _e == null) {
        var it;
        if ((it = tt) != null && it.errors)
            _e = tt.matches;
        else
            return null
    }
    let st = _e
      , at = (nt = tt) == null ? void 0 : nt.errors;
    if (at != null) {
        let dt = st.findIndex(ct=>ct.route.id && (at == null ? void 0 : at[ct.route.id]));
        dt >= 0 || invariant(!1),
        st = st.slice(0, Math.min(st.length, dt + 1))
    }
    let ot = !1
      , lt = -1;
    if (tt && rt && rt.v7_partialHydration)
        for (let dt = 0; dt < st.length; dt++) {
            let ct = st[dt];
            if ((ct.route.HydrateFallback || ct.route.hydrateFallbackElement) && (lt = dt),
            ct.route.id) {
                let {loaderData: ut, errors: ft} = tt
                  , ht = ct.route.loader && ut[ct.route.id] === void 0 && (!ft || ft[ct.route.id] === void 0);
                if (ct.route.lazy || ht) {
                    ot = !0,
                    lt >= 0 ? st = st.slice(0, lt + 1) : st = [st[0]];
                    break
                }
            }
        }
    return st.reduceRight((dt,ct,ut)=>{
        let ft, ht = !1, gt = null, bt = null;
        tt && (ft = at && ct.route.id ? at[ct.route.id] : void 0,
        gt = ct.route.errorElement || defaultErrorElement,
        ot && (lt < 0 && ut === 0 ? (warningOnce("route-fallback", !1),
        ht = !0,
        bt = null) : lt === ut && (ht = !0,
        bt = ct.route.hydrateFallbackElement || null)));
        let pt = et.concat(st.slice(0, ut + 1))
          , mt = ()=>{
            let yt;
            return ft ? yt = gt : ht ? yt = bt : ct.route.Component ? yt = reactExports.createElement(ct.route.Component, null) : ct.route.element ? yt = ct.route.element : yt = dt,
            reactExports.createElement(RenderedRoute, {
                match: ct,
                routeContext: {
                    outlet: dt,
                    matches: pt,
                    isDataRoute: tt != null
                },
                children: yt
            })
        }
        ;
        return tt && (ct.route.ErrorBoundary || ct.route.errorElement || ut === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: tt.location,
            revalidation: tt.revalidation,
            component: gt,
            error: ft,
            children: mt(),
            routeContext: {
                outlet: null,
                matches: pt,
                isDataRoute: !0
            }
        }) : mt()
    }
    , null)
}
var DataRouterHook$1 = function(_e) {
    return _e.UseBlocker = "useBlocker",
    _e.UseRevalidator = "useRevalidator",
    _e.UseNavigateStable = "useNavigate",
    _e
}(DataRouterHook$1 || {})
  , DataRouterStateHook$1 = function(_e) {
    return _e.UseBlocker = "useBlocker",
    _e.UseLoaderData = "useLoaderData",
    _e.UseActionData = "useActionData",
    _e.UseRouteError = "useRouteError",
    _e.UseNavigation = "useNavigation",
    _e.UseRouteLoaderData = "useRouteLoaderData",
    _e.UseMatches = "useMatches",
    _e.UseRevalidator = "useRevalidator",
    _e.UseNavigateStable = "useNavigate",
    _e.UseRouteId = "useRouteId",
    _e
}(DataRouterStateHook$1 || {});
function useDataRouterContext$1(_e) {
    let et = reactExports.useContext(DataRouterContext);
    return et || invariant(!1),
    et
}
function useDataRouterState(_e) {
    let et = reactExports.useContext(DataRouterStateContext);
    return et || invariant(!1),
    et
}
function useRouteContext(_e) {
    let et = reactExports.useContext(RouteContext);
    return et || invariant(!1),
    et
}
function useCurrentRouteId(_e) {
    let et = useRouteContext()
      , tt = et.matches[et.matches.length - 1];
    return tt.route.id || invariant(!1),
    tt.route.id
}
function useRouteError() {
    var _e;
    let et = reactExports.useContext(RouteErrorContext)
      , tt = useDataRouterState(DataRouterStateHook$1.UseRouteError)
      , rt = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
    return et !== void 0 ? et : (_e = tt.errors) == null ? void 0 : _e[rt]
}
function useNavigateStable() {
    let {router: _e} = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable)
      , et = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable)
      , tt = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$3(()=>{
        tt.current = !0
    }
    ),
    reactExports.useCallback(function(nt, it) {
        it === void 0 && (it = {}),
        tt.current && (typeof nt == "number" ? _e.navigate(nt) : _e.navigate(nt, _extends$4({
            fromRouteId: et
        }, it)))
    }, [_e, et])
}
const alreadyWarned = {};
function warningOnce(_e, et, tt) {
    !et && !alreadyWarned[_e] && (alreadyWarned[_e] = !0)
}
function Outlet(_e) {
    return useOutlet(_e.context)
}
function Route(_e) {
    invariant(!1)
}
function Router(_e) {
    let {basename: et="/", children: tt=null, location: rt, navigationType: nt=Action.Pop, navigator: it, static: st=!1, future: at} = _e;
    useInRouterContext() && invariant(!1);
    let ot = et.replace(/^\/*/, "/")
      , lt = reactExports.useMemo(()=>({
        basename: ot,
        navigator: it,
        static: st,
        future: _extends$4({
            v7_relativeSplatPath: !1
        }, at)
    }), [ot, at, it, st]);
    typeof rt == "string" && (rt = parsePath(rt));
    let {pathname: dt="/", search: ct="", hash: ut="", state: ft=null, key: ht="default"} = rt
      , gt = reactExports.useMemo(()=>{
        let bt = stripBasename(dt, ot);
        return bt == null ? null : {
            location: {
                pathname: bt,
                search: ct,
                hash: ut,
                state: ft,
                key: ht
            },
            navigationType: nt
        }
    }
    , [ot, dt, ct, ut, ft, ht, nt]);
    return gt == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: lt
    }, reactExports.createElement(LocationContext.Provider, {
        children: tt,
        value: gt
    }))
}
function Routes(_e) {
    let {children: et, location: tt} = _e;
    return useRoutes(createRoutesFromChildren(et), tt)
}
new Promise(()=>{}
);
function createRoutesFromChildren(_e, et) {
    et === void 0 && (et = []);
    let tt = [];
    return reactExports.Children.forEach(_e, (rt,nt)=>{
        if (!reactExports.isValidElement(rt))
            return;
        let it = [...et, nt];
        if (rt.type === reactExports.Fragment) {
            tt.push.apply(tt, createRoutesFromChildren(rt.props.children, it));
            return
        }
        rt.type !== Route && invariant(!1),
        !rt.props.index || !rt.props.children || invariant(!1);
        let st = {
            id: rt.props.id || it.join("-"),
            caseSensitive: rt.props.caseSensitive,
            element: rt.props.element,
            Component: rt.props.Component,
            index: rt.props.index,
            path: rt.props.path,
            loader: rt.props.loader,
            action: rt.props.action,
            errorElement: rt.props.errorElement,
            ErrorBoundary: rt.props.ErrorBoundary,
            hasErrorBoundary: rt.props.ErrorBoundary != null || rt.props.errorElement != null,
            shouldRevalidate: rt.props.shouldRevalidate,
            handle: rt.props.handle,
            lazy: rt.props.lazy
        };
        rt.props.children && (st.children = createRoutesFromChildren(rt.props.children, it)),
        tt.push(st)
    }
    ),
    tt
}
/**
 * React Router DOM v6.22.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
    return _extends$3 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var et = 1; et < arguments.length; et++) {
            var tt = arguments[et];
            for (var rt in tt)
                Object.prototype.hasOwnProperty.call(tt, rt) && (_e[rt] = tt[rt])
        }
        return _e
    }
    ,
    _extends$3.apply(this, arguments)
}
function _objectWithoutPropertiesLoose$2(_e, et) {
    if (_e == null)
        return {};
    var tt = {}, rt = Object.keys(_e), nt, it;
    for (it = 0; it < rt.length; it++)
        nt = rt[it],
        !(et.indexOf(nt) >= 0) && (tt[nt] = _e[nt]);
    return tt
}
function isModifiedEvent(_e) {
    return !!(_e.metaKey || _e.altKey || _e.ctrlKey || _e.shiftKey)
}
function shouldProcessLinkClick(_e, et) {
    return _e.button === 0 && (!et || et === "_self") && !isModifiedEvent(_e)
}
const _excluded$2 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]
  , _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"]
  , REACT_ROUTER_VERSION = "6";
try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION
} catch {}
const ViewTransitionContext = reactExports.createContext({
    isTransitioning: !1
})
  , START_TRANSITION = "startTransition"
  , startTransitionImpl = ReactOriginal[START_TRANSITION];
function BrowserRouter(_e) {
    let {basename: et, children: tt, future: rt, window: nt} = _e
      , it = reactExports.useRef();
    it.current == null && (it.current = createBrowserHistory({
        window: nt,
        v5Compat: !0
    }));
    let st = it.current
      , [at,ot] = reactExports.useState({
        action: st.action,
        location: st.location
    })
      , {v7_startTransition: lt} = rt || {}
      , dt = reactExports.useCallback(ct=>{
        lt && startTransitionImpl ? startTransitionImpl(()=>ot(ct)) : ot(ct)
    }
    , [ot, lt]);
    return reactExports.useLayoutEffect(()=>st.listen(dt), [st, dt]),
    reactExports.createElement(Router, {
        basename: et,
        children: tt,
        location: at.location,
        navigationType: at.action,
        navigator: st,
        future: rt
    })
}
const isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Link = reactExports.forwardRef(function(et, tt) {
    let {onClick: rt, relative: nt, reloadDocument: it, replace: st, state: at, target: ot, to: lt, preventScrollReset: dt, unstable_viewTransition: ct} = et, ut = _objectWithoutPropertiesLoose$2(et, _excluded$2), {basename: ft} = reactExports.useContext(NavigationContext), ht, gt = !1;
    if (typeof lt == "string" && ABSOLUTE_URL_REGEX.test(lt) && (ht = lt,
    isBrowser))
        try {
            let yt = new URL(window.location.href)
              , vt = lt.startsWith("//") ? new URL(yt.protocol + lt) : new URL(lt)
              , wt = stripBasename(vt.pathname, ft);
            vt.origin === yt.origin && wt != null ? lt = wt + vt.search + vt.hash : gt = !0
        } catch {}
    let bt = useHref(lt, {
        relative: nt
    })
      , pt = useLinkClickHandler(lt, {
        replace: st,
        state: at,
        target: ot,
        preventScrollReset: dt,
        relative: nt,
        unstable_viewTransition: ct
    });
    function mt(yt) {
        rt && rt(yt),
        yt.defaultPrevented || pt(yt)
    }
    return reactExports.createElement("a", _extends$3({}, ut, {
        href: ht || bt,
        onClick: gt || it ? rt : mt,
        ref: tt,
        target: ot
    }))
})
  , NavLink = reactExports.forwardRef(function(et, tt) {
    let {"aria-current": rt="page", caseSensitive: nt=!1, className: it="", end: st=!1, style: at, to: ot, unstable_viewTransition: lt, children: dt} = et
      , ct = _objectWithoutPropertiesLoose$2(et, _excluded2)
      , ut = useResolvedPath(ot, {
        relative: ct.relative
    })
      , ft = useLocation()
      , ht = reactExports.useContext(DataRouterStateContext)
      , {navigator: gt, basename: bt} = reactExports.useContext(NavigationContext)
      , pt = ht != null && useViewTransitionState(ut) && lt === !0
      , mt = gt.encodeLocation ? gt.encodeLocation(ut).pathname : ut.pathname
      , yt = ft.pathname
      , vt = ht && ht.navigation && ht.navigation.location ? ht.navigation.location.pathname : null;
    nt || (yt = yt.toLowerCase(),
    vt = vt ? vt.toLowerCase() : null,
    mt = mt.toLowerCase()),
    vt && bt && (vt = stripBasename(vt, bt) || vt);
    const wt = mt !== "/" && mt.endsWith("/") ? mt.length - 1 : mt.length;
    let _t = yt === mt || !st && yt.startsWith(mt) && yt.charAt(wt) === "/", Et = vt != null && (vt === mt || !st && vt.startsWith(mt) && vt.charAt(mt.length) === "/"), xt = {
        isActive: _t,
        isPending: Et,
        isTransitioning: pt
    }, Ct = _t ? rt : void 0, Tt;
    typeof it == "function" ? Tt = it(xt) : Tt = [it, _t ? "active" : null, Et ? "pending" : null, pt ? "transitioning" : null].filter(Boolean).join(" ");
    let It = typeof at == "function" ? at(xt) : at;
    return reactExports.createElement(Link, _extends$3({}, ct, {
        "aria-current": Ct,
        className: Tt,
        ref: tt,
        style: It,
        to: ot,
        unstable_viewTransition: lt
    }), typeof dt == "function" ? dt(xt) : dt)
});
var DataRouterHook;
(function(_e) {
    _e.UseScrollRestoration = "useScrollRestoration",
    _e.UseSubmit = "useSubmit",
    _e.UseSubmitFetcher = "useSubmitFetcher",
    _e.UseFetcher = "useFetcher",
    _e.useViewTransitionState = "useViewTransitionState"
}
)(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(_e) {
    _e.UseFetcher = "useFetcher",
    _e.UseFetchers = "useFetchers",
    _e.UseScrollRestoration = "useScrollRestoration"
}
)(DataRouterStateHook || (DataRouterStateHook = {}));
function useDataRouterContext(_e) {
    let et = reactExports.useContext(DataRouterContext);
    return et || invariant(!1),
    et
}
function useLinkClickHandler(_e, et) {
    let {target: tt, replace: rt, state: nt, preventScrollReset: it, relative: st, unstable_viewTransition: at} = et === void 0 ? {} : et
      , ot = useNavigate()
      , lt = useLocation()
      , dt = useResolvedPath(_e, {
        relative: st
    });
    return reactExports.useCallback(ct=>{
        if (shouldProcessLinkClick(ct, tt)) {
            ct.preventDefault();
            let ut = rt !== void 0 ? rt : createPath(lt) === createPath(dt);
            ot(_e, {
                replace: ut,
                state: nt,
                preventScrollReset: it,
                relative: st,
                unstable_viewTransition: at
            })
        }
    }
    , [lt, ot, dt, rt, nt, tt, _e, it, st, at])
}
function useViewTransitionState(_e, et) {
    et === void 0 && (et = {});
    let tt = reactExports.useContext(ViewTransitionContext);
    tt == null && invariant(!1);
    let {basename: rt} = useDataRouterContext(DataRouterHook.useViewTransitionState)
      , nt = useResolvedPath(_e, {
        relative: et.relative
    });
    if (!tt.isTransitioning)
        return !1;
    let it = stripBasename(tt.currentLocation.pathname, rt) || tt.currentLocation.pathname
      , st = stripBasename(tt.nextLocation.pathname, rt) || tt.nextLocation.pathname;
    return matchPath(nt.pathname, st) != null || matchPath(nt.pathname, it) != null
}
function r$h(_e) {
    var et, tt, rt = "";
    if (typeof _e == "string" || typeof _e == "number")
        rt += _e;
    else if (typeof _e == "object")
        if (Array.isArray(_e)) {
            var nt = _e.length;
            for (et = 0; et < nt; et++)
                _e[et] && (tt = r$h(_e[et])) && (rt && (rt += " "),
                rt += tt)
        } else
            for (tt in _e)
                _e[tt] && (rt && (rt += " "),
                rt += tt);
    return rt
}
function clsx() {
    for (var _e, et, tt = 0, rt = "", nt = arguments.length; tt < nt; tt++)
        (_e = arguments[tt]) && (et = r$h(_e)) && (rt && (rt += " "),
        rt += et);
    return rt
}
const c$9 = _e=>typeof _e == "number" && !isNaN(_e)
  , d$4 = _e=>typeof _e == "string"
  , u$7 = _e=>typeof _e == "function"
  , p$7 = _e=>d$4(_e) || u$7(_e) ? _e : null
  , m$3 = _e=>reactExports.isValidElement(_e) || d$4(_e) || u$7(_e) || c$9(_e);
function f$8(_e, et, tt) {
    tt === void 0 && (tt = 300);
    const {scrollHeight: rt, style: nt} = _e;
    requestAnimationFrame(()=>{
        nt.minHeight = "initial",
        nt.height = rt + "px",
        nt.transition = `all ${tt}ms`,
        requestAnimationFrame(()=>{
            nt.height = "0",
            nt.padding = "0",
            nt.margin = "0",
            setTimeout(et, tt)
        }
        )
    }
    )
}
function g$3(_e) {
    let {enter: et, exit: tt, appendPosition: rt=!1, collapse: nt=!0, collapseDuration: it=300} = _e;
    return function(st) {
        let {children: at, position: ot, preventExitTransition: lt, done: dt, nodeRef: ct, isIn: ut, playToast: ft} = st;
        const ht = rt ? `${et}--${ot}` : et
          , gt = rt ? `${tt}--${ot}` : tt
          , bt = reactExports.useRef(0);
        return reactExports.useLayoutEffect(()=>{
            const pt = ct.current
              , mt = ht.split(" ")
              , yt = vt=>{
                vt.target === ct.current && (ft(),
                pt.removeEventListener("animationend", yt),
                pt.removeEventListener("animationcancel", yt),
                bt.current === 0 && vt.type !== "animationcancel" && pt.classList.remove(...mt))
            }
            ;
            pt.classList.add(...mt),
            pt.addEventListener("animationend", yt),
            pt.addEventListener("animationcancel", yt)
        }
        , []),
        reactExports.useEffect(()=>{
            const pt = ct.current
              , mt = ()=>{
                pt.removeEventListener("animationend", mt),
                nt ? f$8(pt, dt, it) : dt()
            }
            ;
            ut || (lt ? mt() : (bt.current = 1,
            pt.className += ` ${gt}`,
            pt.addEventListener("animationend", mt)))
        }
        , [ut]),
        React$1.createElement(React$1.Fragment, null, at)
    }
}
function y$5(_e, et) {
    return _e != null ? {
        content: _e.content,
        containerId: _e.props.containerId,
        id: _e.props.toastId,
        theme: _e.props.theme,
        type: _e.props.type,
        data: _e.props.data || {},
        isLoading: _e.props.isLoading,
        icon: _e.props.icon,
        status: et
    } : {}
}
const v$5 = new Map;
let h$c = [];
const T$2 = new Set
  , E$2 = _e=>T$2.forEach(et=>et(_e))
  , b$3 = ()=>v$5.size > 0;
function I$2(_e, et) {
    var tt;
    if (et)
        return !((tt = v$5.get(et)) == null || !tt.isToastActive(_e));
    let rt = !1;
    return v$5.forEach(nt=>{
        nt.isToastActive(_e) && (rt = !0)
    }
    ),
    rt
}
function _$2(_e, et) {
    m$3(_e) && (b$3() || h$c.push({
        content: _e,
        options: et
    }),
    v$5.forEach(tt=>{
        tt.buildToast(_e, et)
    }
    ))
}
function C$2(_e, et) {
    v$5.forEach(tt=>{
        et != null && et != null && et.containerId ? (et == null ? void 0 : et.containerId) === tt.id && tt.toggle(_e, et == null ? void 0 : et.id) : tt.toggle(_e, et == null ? void 0 : et.id)
    }
    )
}
function L$2(_e) {
    const {subscribe: et, getSnapshot: tt, setProps: rt} = reactExports.useRef(function(it) {
        const st = it.containerId || 1;
        return {
            subscribe(at) {
                const ot = function(dt, ct, ut) {
                    let ft = 1
                      , ht = 0
                      , gt = []
                      , bt = []
                      , pt = []
                      , mt = ct;
                    const yt = new Map
                      , vt = new Set
                      , wt = ()=>{
                        pt = Array.from(yt.values()),
                        vt.forEach(xt=>xt())
                    }
                      , _t = xt=>{
                        bt = xt == null ? [] : bt.filter(Ct=>Ct !== xt),
                        wt()
                    }
                      , Et = xt=>{
                        const {toastId: Ct, onOpen: Tt, updateId: It, children: Nt} = xt.props
                          , Ft = It == null;
                        xt.staleId && yt.delete(xt.staleId),
                        yt.set(Ct, xt),
                        bt = [...bt, xt.props.toastId].filter(Lt=>Lt !== xt.staleId),
                        wt(),
                        ut(y$5(xt, Ft ? "added" : "updated")),
                        Ft && u$7(Tt) && Tt(reactExports.isValidElement(Nt) && Nt.props)
                    }
                    ;
                    return {
                        id: dt,
                        props: mt,
                        observe: xt=>(vt.add(xt),
                        ()=>vt.delete(xt)),
                        toggle: (xt,Ct)=>{
                            yt.forEach(Tt=>{
                                Ct != null && Ct !== Tt.props.toastId || u$7(Tt.toggle) && Tt.toggle(xt)
                            }
                            )
                        }
                        ,
                        removeToast: _t,
                        toasts: yt,
                        clearQueue: ()=>{
                            ht -= gt.length,
                            gt = []
                        }
                        ,
                        buildToast: (xt,Ct)=>{
                            if ((zt=>{
                                let {containerId: Yt, toastId: rr, updateId: ar} = zt;
                                const or = Yt ? Yt !== dt : dt !== 1
                                  , pr = yt.has(rr) && ar == null;
                                return or || pr
                            }
                            )(Ct))
                                return;
                            const {toastId: Tt, updateId: It, data: Nt, staleId: Ft, delay: Lt} = Ct
                              , Mt = ()=>{
                                _t(Tt)
                            }
                              , $t = It == null;
                            $t && ht++;
                            const kt = {
                                ...mt,
                                style: mt.toastStyle,
                                key: ft++,
                                ...Object.fromEntries(Object.entries(Ct).filter(zt=>{
                                    let[Yt,rr] = zt;
                                    return rr != null
                                }
                                )),
                                toastId: Tt,
                                updateId: It,
                                data: Nt,
                                closeToast: Mt,
                                isIn: !1,
                                className: p$7(Ct.className || mt.toastClassName),
                                bodyClassName: p$7(Ct.bodyClassName || mt.bodyClassName),
                                progressClassName: p$7(Ct.progressClassName || mt.progressClassName),
                                autoClose: !Ct.isLoading && (At = Ct.autoClose,
                                Pt = mt.autoClose,
                                At === !1 || c$9(At) && At > 0 ? At : Pt),
                                deleteToast() {
                                    const zt = yt.get(Tt)
                                      , {onClose: Yt, children: rr} = zt.props;
                                    u$7(Yt) && Yt(reactExports.isValidElement(rr) && rr.props),
                                    ut(y$5(zt, "removed")),
                                    yt.delete(Tt),
                                    ht--,
                                    ht < 0 && (ht = 0),
                                    gt.length > 0 ? Et(gt.shift()) : wt()
                                }
                            };
                            var At, Pt;
                            kt.closeButton = mt.closeButton,
                            Ct.closeButton === !1 || m$3(Ct.closeButton) ? kt.closeButton = Ct.closeButton : Ct.closeButton === !0 && (kt.closeButton = !m$3(mt.closeButton) || mt.closeButton);
                            let Dt = xt;
                            reactExports.isValidElement(xt) && !d$4(xt.type) ? Dt = reactExports.cloneElement(xt, {
                                closeToast: Mt,
                                toastProps: kt,
                                data: Nt
                            }) : u$7(xt) && (Dt = xt({
                                closeToast: Mt,
                                toastProps: kt,
                                data: Nt
                            }));
                            const Bt = {
                                content: Dt,
                                props: kt,
                                staleId: Ft
                            };
                            mt.limit && mt.limit > 0 && ht > mt.limit && $t ? gt.push(Bt) : c$9(Lt) ? setTimeout(()=>{
                                Et(Bt)
                            }
                            , Lt) : Et(Bt)
                        }
                        ,
                        setProps(xt) {
                            mt = xt
                        },
                        setToggle: (xt,Ct)=>{
                            yt.get(xt).toggle = Ct
                        }
                        ,
                        isToastActive: xt=>bt.some(Ct=>Ct === xt),
                        getSnapshot: ()=>mt.newestOnTop ? pt.reverse() : pt
                    }
                }(st, it, E$2);
                v$5.set(st, ot);
                const lt = ot.observe(at);
                return h$c.forEach(dt=>_$2(dt.content, dt.options)),
                h$c = [],
                ()=>{
                    lt(),
                    v$5.delete(st)
                }
            },
            setProps(at) {
                var ot;
                (ot = v$5.get(st)) == null || ot.setProps(at)
            },
            getSnapshot() {
                var at;
                return (at = v$5.get(st)) == null ? void 0 : at.getSnapshot()
            }
        }
    }(_e)).current;
    rt(_e);
    const nt = reactExports.useSyncExternalStore(et, tt, tt);
    return {
        getToastToRender: function(it) {
            if (!nt)
                return [];
            const st = new Map;
            return nt.forEach(at=>{
                const {position: ot} = at.props;
                st.has(ot) || st.set(ot, []),
                st.get(ot).push(at)
            }
            ),
            Array.from(st, at=>it(at[0], at[1]))
        },
        isToastActive: I$2,
        count: nt == null ? void 0 : nt.length
    }
}
function N$2(_e) {
    const [et,tt] = reactExports.useState(!1)
      , [rt,nt] = reactExports.useState(!1)
      , it = reactExports.useRef(null)
      , st = reactExports.useRef({
        start: 0,
        delta: 0,
        removalDistance: 0,
        canCloseOnClick: !0,
        canDrag: !1,
        didMove: !1
    }).current
      , {autoClose: at, pauseOnHover: ot, closeToast: lt, onClick: dt, closeOnClick: ct} = _e;
    var ut, ft;
    function ht() {
        tt(!0)
    }
    function gt() {
        tt(!1)
    }
    function bt(yt) {
        const vt = it.current;
        st.canDrag && vt && (st.didMove = !0,
        et && gt(),
        st.delta = _e.draggableDirection === "x" ? yt.clientX - st.start : yt.clientY - st.start,
        st.start !== yt.clientX && (st.canCloseOnClick = !1),
        vt.style.transform = `translate3d(${_e.draggableDirection === "x" ? `${st.delta}px, var(--y)` : `0, calc(${st.delta}px + var(--y))`},0)`,
        vt.style.opacity = "" + (1 - Math.abs(st.delta / st.removalDistance)))
    }
    function pt() {
        document.removeEventListener("pointermove", bt),
        document.removeEventListener("pointerup", pt);
        const yt = it.current;
        if (st.canDrag && st.didMove && yt) {
            if (st.canDrag = !1,
            Math.abs(st.delta) > st.removalDistance)
                return nt(!0),
                _e.closeToast(),
                void _e.collapseAll();
            yt.style.transition = "transform 0.2s, opacity 0.2s",
            yt.style.removeProperty("transform"),
            yt.style.removeProperty("opacity")
        }
    }
    (ft = v$5.get((ut = {
        id: _e.toastId,
        containerId: _e.containerId,
        fn: tt
    }).containerId || 1)) == null || ft.setToggle(ut.id, ut.fn),
    reactExports.useEffect(()=>{
        if (_e.pauseOnFocusLoss)
            return document.hasFocus() || gt(),
            window.addEventListener("focus", ht),
            window.addEventListener("blur", gt),
            ()=>{
                window.removeEventListener("focus", ht),
                window.removeEventListener("blur", gt)
            }
    }
    , [_e.pauseOnFocusLoss]);
    const mt = {
        onPointerDown: function(yt) {
            if (_e.draggable === !0 || _e.draggable === yt.pointerType) {
                st.didMove = !1,
                document.addEventListener("pointermove", bt),
                document.addEventListener("pointerup", pt);
                const vt = it.current;
                st.canCloseOnClick = !0,
                st.canDrag = !0,
                vt.style.transition = "none",
                _e.draggableDirection === "x" ? (st.start = yt.clientX,
                st.removalDistance = vt.offsetWidth * (_e.draggablePercent / 100)) : (st.start = yt.clientY,
                st.removalDistance = vt.offsetHeight * (_e.draggablePercent === 80 ? 1.5 * _e.draggablePercent : _e.draggablePercent) / 100)
            }
        },
        onPointerUp: function(yt) {
            const {top: vt, bottom: wt, left: _t, right: Et} = it.current.getBoundingClientRect();
            yt.nativeEvent.type !== "touchend" && _e.pauseOnHover && yt.clientX >= _t && yt.clientX <= Et && yt.clientY >= vt && yt.clientY <= wt ? gt() : ht()
        }
    };
    return at && ot && (mt.onMouseEnter = gt,
    _e.stacked || (mt.onMouseLeave = ht)),
    ct && (mt.onClick = yt=>{
        dt && dt(yt),
        st.canCloseOnClick && lt()
    }
    ),
    {
        playToast: ht,
        pauseToast: gt,
        isRunning: et,
        preventExitTransition: rt,
        toastRef: it,
        eventHandlers: mt
    }
}
function $$2(_e) {
    let {delay: et, isRunning: tt, closeToast: rt, type: nt="default", hide: it, className: st, style: at, controlledProgress: ot, progress: lt, rtl: dt, isIn: ct, theme: ut} = _e;
    const ft = it || ot && lt === 0
      , ht = {
        ...at,
        animationDuration: `${et}ms`,
        animationPlayState: tt ? "running" : "paused"
    };
    ot && (ht.transform = `scaleX(${lt})`);
    const gt = clsx("Toastify__progress-bar", ot ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${ut}`, `Toastify__progress-bar--${nt}`, {
        "Toastify__progress-bar--rtl": dt
    })
      , bt = u$7(st) ? st({
        rtl: dt,
        type: nt,
        defaultClassName: gt
    }) : clsx(gt, st)
      , pt = {
        [ot && lt >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: ot && lt < 1 ? null : ()=>{
            ct && rt()
        }
    };
    return React$1.createElement("div", {
        className: "Toastify__progress-bar--wrp",
        "data-hidden": ft
    }, React$1.createElement("div", {
        className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${ut} Toastify__progress-bar--${nt}`
    }), React$1.createElement("div", {
        role: "progressbar",
        "aria-hidden": ft ? "true" : "false",
        "aria-label": "notification timer",
        className: bt,
        style: ht,
        ...pt
    }))
}
let w$4 = 1;
const k$3 = ()=>"" + w$4++;
function P$2(_e) {
    return _e && (d$4(_e.toastId) || c$9(_e.toastId)) ? _e.toastId : k$3()
}
function M$2(_e, et) {
    return _$2(_e, et),
    et.toastId
}
function x$2(_e, et) {
    return {
        ...et,
        type: et && et.type || _e,
        toastId: P$2(et)
    }
}
function A$2(_e) {
    return (et,tt)=>M$2(et, x$2(_e, tt))
}
function B(_e, et) {
    return M$2(_e, x$2("default", et))
}
B.loading = (_e,et)=>M$2(_e, x$2("default", {
    isLoading: !0,
    autoClose: !1,
    closeOnClick: !1,
    closeButton: !1,
    draggable: !1,
    ...et
})),
B.promise = function(_e, et, tt) {
    let rt, {pending: nt, error: it, success: st} = et;
    nt && (rt = d$4(nt) ? B.loading(nt, tt) : B.loading(nt.render, {
        ...tt,
        ...nt
    }));
    const at = {
        isLoading: null,
        autoClose: null,
        closeOnClick: null,
        closeButton: null,
        draggable: null
    }
      , ot = (dt,ct,ut)=>{
        if (ct == null)
            return void B.dismiss(rt);
        const ft = {
            type: dt,
            ...at,
            ...tt,
            data: ut
        }
          , ht = d$4(ct) ? {
            render: ct
        } : ct;
        return rt ? B.update(rt, {
            ...ft,
            ...ht
        }) : B(ht.render, {
            ...ft,
            ...ht
        }),
        ut
    }
      , lt = u$7(_e) ? _e() : _e;
    return lt.then(dt=>ot("success", st, dt)).catch(dt=>ot("error", it, dt)),
    lt
}
,
B.success = A$2("success"),
B.info = A$2("info"),
B.error = A$2("error"),
B.warning = A$2("warning"),
B.warn = B.warning,
B.dark = (_e,et)=>M$2(_e, x$2("default", {
    theme: "dark",
    ...et
})),
B.dismiss = function(_e) {
    (function(et) {
        var tt;
        if (b$3()) {
            if (et == null || d$4(tt = et) || c$9(tt))
                v$5.forEach(nt=>{
                    nt.removeToast(et)
                }
                );
            else if (et && ("containerId"in et || "id"in et)) {
                var rt;
                (rt = v$5.get(et.containerId)) != null && rt.removeToast(et.id) || v$5.forEach(nt=>{
                    nt.removeToast(et.id)
                }
                )
            }
        } else
            h$c = h$c.filter(nt=>et != null && nt.options.toastId !== et)
    }
    )(_e)
}
,
B.clearWaitingQueue = function(_e) {
    _e === void 0 && (_e = {}),
    v$5.forEach(et=>{
        !et.props.limit || _e.containerId && et.id !== _e.containerId || et.clearQueue()
    }
    )
}
,
B.isActive = I$2,
B.update = function(_e, et) {
    et === void 0 && (et = {});
    const tt = ((rt,nt)=>{
        var it;
        let {containerId: st} = nt;
        return (it = v$5.get(st || 1)) == null ? void 0 : it.toasts.get(rt)
    }
    )(_e, et);
    if (tt) {
        const {props: rt, content: nt} = tt
          , it = {
            delay: 100,
            ...rt,
            ...et,
            toastId: et.toastId || _e,
            updateId: k$3()
        };
        it.toastId !== _e && (it.staleId = _e);
        const st = it.render || nt;
        delete it.render,
        M$2(st, it)
    }
}
,
B.done = _e=>{
    B.update(_e, {
        progress: 1
    })
}
,
B.onChange = function(_e) {
    return T$2.add(_e),
    ()=>{
        T$2.delete(_e)
    }
}
,
B.play = _e=>C$2(!0, _e),
B.pause = _e=>C$2(!1, _e);
const O = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect
  , D = _e=>{
    let {theme: et, type: tt, isLoading: rt, ...nt} = _e;
    return React$1.createElement("svg", {
        viewBox: "0 0 24 24",
        width: "100%",
        height: "100%",
        fill: et === "colored" ? "currentColor" : `var(--toastify-icon-color-${tt})`,
        ...nt
    })
}
  , z$1 = {
    info: function(_e) {
        return React$1.createElement(D, {
            ..._e
        }, React$1.createElement("path", {
            d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
        }))
    },
    warning: function(_e) {
        return React$1.createElement(D, {
            ..._e
        }, React$1.createElement("path", {
            d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
        }))
    },
    success: function(_e) {
        return React$1.createElement(D, {
            ..._e
        }, React$1.createElement("path", {
            d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
        }))
    },
    error: function(_e) {
        return React$1.createElement(D, {
            ..._e
        }, React$1.createElement("path", {
            d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
        }))
    },
    spinner: function() {
        return React$1.createElement("div", {
            className: "Toastify__spinner"
        })
    }
}
  , R$2 = _e=>{
    const {isRunning: et, preventExitTransition: tt, toastRef: rt, eventHandlers: nt, playToast: it} = N$2(_e)
      , {closeButton: st, children: at, autoClose: ot, onClick: lt, type: dt, hideProgressBar: ct, closeToast: ut, transition: ft, position: ht, className: gt, style: bt, bodyClassName: pt, bodyStyle: mt, progressClassName: yt, progressStyle: vt, updateId: wt, role: _t, progress: Et, rtl: xt, toastId: Ct, deleteToast: Tt, isIn: It, isLoading: Nt, closeOnClick: Ft, theme: Lt} = _e
      , Mt = clsx("Toastify__toast", `Toastify__toast-theme--${Lt}`, `Toastify__toast--${dt}`, {
        "Toastify__toast--rtl": xt
    }, {
        "Toastify__toast--close-on-click": Ft
    })
      , $t = u$7(gt) ? gt({
        rtl: xt,
        position: ht,
        type: dt,
        defaultClassName: Mt
    }) : clsx(Mt, gt)
      , kt = function(Bt) {
        let {theme: zt, type: Yt, isLoading: rr, icon: ar} = Bt
          , or = null;
        const pr = {
            theme: zt,
            type: Yt
        };
        return ar === !1 || (u$7(ar) ? or = ar({
            ...pr,
            isLoading: rr
        }) : reactExports.isValidElement(ar) ? or = reactExports.cloneElement(ar, pr) : rr ? or = z$1.spinner() : (gr=>gr in z$1)(Yt) && (or = z$1[Yt](pr))),
        or
    }(_e)
      , At = !!Et || !ot
      , Pt = {
        closeToast: ut,
        type: dt,
        theme: Lt
    };
    let Dt = null;
    return st === !1 || (Dt = u$7(st) ? st(Pt) : reactExports.isValidElement(st) ? reactExports.cloneElement(st, Pt) : function(Bt) {
        let {closeToast: zt, theme: Yt, ariaLabel: rr="close"} = Bt;
        return React$1.createElement("button", {
            className: `Toastify__close-button Toastify__close-button--${Yt}`,
            type: "button",
            onClick: ar=>{
                ar.stopPropagation(),
                zt(ar)
            }
            ,
            "aria-label": rr
        }, React$1.createElement("svg", {
            "aria-hidden": "true",
            viewBox: "0 0 14 16"
        }, React$1.createElement("path", {
            fillRule: "evenodd",
            d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
        })))
    }(Pt)),
    React$1.createElement(ft, {
        isIn: It,
        done: Tt,
        position: ht,
        preventExitTransition: tt,
        nodeRef: rt,
        playToast: it
    }, React$1.createElement("div", {
        id: Ct,
        onClick: lt,
        "data-in": It,
        className: $t,
        ...nt,
        style: bt,
        ref: rt
    }, React$1.createElement("div", {
        ...It && {
            role: _t
        },
        className: u$7(pt) ? pt({
            type: dt
        }) : clsx("Toastify__toast-body", pt),
        style: mt
    }, kt != null && React$1.createElement("div", {
        className: clsx("Toastify__toast-icon", {
            "Toastify--animate-icon Toastify__zoom-enter": !Nt
        })
    }, kt), React$1.createElement("div", null, at)), Dt, React$1.createElement($$2, {
        ...wt && !At ? {
            key: `pb-${wt}`
        } : {},
        rtl: xt,
        theme: Lt,
        delay: ot,
        isRunning: et,
        isIn: It,
        closeToast: ut,
        hide: ct,
        type: dt,
        style: vt,
        className: yt,
        controlledProgress: At,
        progress: Et || 0
    })))
}
  , S$4 = function(_e, et) {
    return et === void 0 && (et = !1),
    {
        enter: `Toastify--animate Toastify__${_e}-enter`,
        exit: `Toastify--animate Toastify__${_e}-exit`,
        appendPosition: et
    }
}
  , H$2 = g$3(S$4("bounce", !0));
g$3(S$4("slide", !0));
g$3(S$4("zoom"));
g$3(S$4("flip"));
const q$3 = {
    position: "top-right",
    transition: H$2,
    autoClose: 5e3,
    closeButton: !0,
    pauseOnHover: !0,
    pauseOnFocusLoss: !0,
    draggable: "touch",
    draggablePercent: 80,
    draggableDirection: "x",
    role: "alert",
    theme: "light"
};
function Q(_e) {
    let et = {
        ...q$3,
        ..._e
    };
    const tt = _e.stacked
      , [rt,nt] = reactExports.useState(!0)
      , it = reactExports.useRef(null)
      , {getToastToRender: st, isToastActive: at, count: ot} = L$2(et)
      , {className: lt, style: dt, rtl: ct, containerId: ut} = et;
    function ft(gt) {
        const bt = clsx("Toastify__toast-container", `Toastify__toast-container--${gt}`, {
            "Toastify__toast-container--rtl": ct
        });
        return u$7(lt) ? lt({
            position: gt,
            rtl: ct,
            defaultClassName: bt
        }) : clsx(bt, p$7(lt))
    }
    function ht() {
        tt && (nt(!0),
        B.play())
    }
    return O(()=>{
        if (tt) {
            var gt;
            const bt = it.current.querySelectorAll('[data-in="true"]')
              , pt = 12
              , mt = (gt = et.position) == null ? void 0 : gt.includes("top");
            let yt = 0
              , vt = 0;
            Array.from(bt).reverse().forEach((wt,_t)=>{
                const Et = wt;
                Et.classList.add("Toastify__toast--stacked"),
                _t > 0 && (Et.dataset.collapsed = `${rt}`),
                Et.dataset.pos || (Et.dataset.pos = mt ? "top" : "bot");
                const xt = yt * (rt ? .2 : 1) + (rt ? 0 : pt * _t);
                Et.style.setProperty("--y", `${mt ? xt : -1 * xt}px`),
                Et.style.setProperty("--g", `${pt}`),
                Et.style.setProperty("--s", "" + (1 - (rt ? vt : 0))),
                yt += Et.offsetHeight,
                vt += .025
            }
            )
        }
    }
    , [rt, ot, tt]),
    React$1.createElement("div", {
        ref: it,
        className: "Toastify",
        id: ut,
        onMouseEnter: ()=>{
            tt && (nt(!1),
            B.pause())
        }
        ,
        onMouseLeave: ht
    }, st((gt,bt)=>{
        const pt = bt.length ? {
            ...dt
        } : {
            ...dt,
            pointerEvents: "none"
        };
        return React$1.createElement("div", {
            className: ft(gt),
            style: pt,
            key: `container-${gt}`
        }, bt.map(mt=>{
            let {content: yt, props: vt} = mt;
            return React$1.createElement(R$2, {
                ...vt,
                stacked: tt,
                collapseAll: ht,
                isIn: at(vt.toastId, vt.containerId),
                style: vt.style,
                key: `toast-${vt.key}`
            }, yt)
        }
        ))
    }
    ))
}
const logo = "/assets/logo-CRanshjO.webp"
  , Footer = ()=>jsxRuntimeExports.jsx("footer", {
    className: "container-fluid footer",
    children: jsxRuntimeExports.jsx("div", {
        className: "row",
        children: jsxRuntimeExports.jsxs("div", {
            className: "col-11 mx-auto max-width",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "row py-5",
                children: [jsxRuntimeExports.jsx("div", {
                    className: "col-lg-4 mb-5 mb-lg-0 d-flex justify-content-center justify-content-lg-start",
                    children: jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("a", {
                            href: "",
                            children: jsxRuntimeExports.jsx("img", {
                                className: "img-fluid footerLogo",
                                src: logo,
                                alt: "logo",
                                title: "Baby Halving"
                            })
                        }), jsxRuntimeExports.jsxs("p", {
                            className: "footerContactPara",
                            children: [jsxRuntimeExports.jsx("span", {
                                children: jsxRuntimeExports.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    width: "25",
                                    height: "25",
                                    fill: "currentColor",
                                    className: "bi bi-at",
                                    viewBox: "0 0 16 16",
                                    children: jsxRuntimeExports.jsx("path", {
                                        d: "M13.106 7.222c0-2.967-2.249-5.032-5.482-5.032-3.35 0-5.646 2.318-5.646 5.702 0 3.493 2.235 5.708 5.762 5.708.862 0 1.689-.123 2.304-.335v-.862c-.43.199-1.354.328-2.29.328-2.926 0-4.813-1.88-4.813-4.798 0-2.844 1.921-4.881 4.594-4.881 2.735 0 4.608 1.688 4.608 4.156 0 1.682-.554 2.769-1.416 2.769-.492 0-.772-.28-.772-.76V5.206H8.923v.834h-.11c-.266-.595-.881-.964-1.6-.964-1.4 0-2.378 1.162-2.378 2.823 0 1.737.957 2.906 2.379 2.906.8 0 1.415-.39 1.709-1.087h.11c.081.67.703 1.148 1.503 1.148 1.572 0 2.57-1.415 2.57-3.643zm-7.177.704c0-1.197.54-1.907 1.456-1.907.93 0 1.524.738 1.524 1.907S8.308 9.84 7.371 9.84c-.895 0-1.442-.725-1.442-1.914"
                                    })
                                })
                            }), "contact@cloudbtc.io"]
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-lg-4 mb-5 mb-lg-0 d-flex justify-content-center",
                    children: jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("h3", {
                            className: "socialHead",
                            children: "Stay Connected"
                        }), jsxRuntimeExports.jsxs("ul", {
                            className: "socialIcons",
                            children: [jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "https://twitter.com/CBTC_CloudBTC",
                                    target: "_blank",
                                    children: jsxRuntimeExports.jsx("i", {
                                        className: "bi bi-twitter-x"
                                    })
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "https://t.me/cloudbtcofficial_1",
                                    target: "_blank",
                                    children: jsxRuntimeExports.jsx("i", {
                                        className: "bi bi-telegram"
                                    })
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "https://t.me/CloudBTC_Global",
                                    target: "_blank",
                                    children: jsxRuntimeExports.jsx("i", {
                                        className: "bi bi-telegram"
                                    })
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "https://cloudbtc.io/",
                                    target: "_blank",
                                    children: jsxRuntimeExports.jsx("i", {
                                        className: "bi bi-currency-bitcoin"
                                    })
                                })
                            })]
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-lg-4 mb-5 mb-lg-0 d-flex justify-content-center justify-content-lg-end",
                    children: jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("h3", {
                            className: "subscribeHead",
                            children: "Subscribe"
                        }), jsxRuntimeExports.jsxs("form", {
                            children: [jsxRuntimeExports.jsxs("div", {
                                className: "subscribeInputWrapper",
                                children: [jsxRuntimeExports.jsx("input", {
                                    type: "text",
                                    placeholder: "Your email address",
                                    className: "subscribeInput"
                                }), jsxRuntimeExports.jsx("button", {
                                    className: "subscribeBtn",
                                    children: jsxRuntimeExports.jsx("i", {
                                        className: "bi bi-send-fill"
                                    })
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                children: [jsxRuntimeExports.jsx("input", {
                                    id: "subscribe",
                                    type: "checkbox"
                                }), " ", jsxRuntimeExports.jsxs("label", {
                                    htmlFor: "subscribe",
                                    children: ["I agree to the", " ", jsxRuntimeExports.jsx("a", {
                                        href: "",
                                        className: "privacyPolicy",
                                        children: "Privacy Policy"
                                    })]
                                })]
                            })]
                        })]
                    })
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "row py-3",
                children: [jsxRuntimeExports.jsx("div", {
                    className: "col-md-6",
                    children: jsxRuntimeExports.jsx("div", {
                        children: jsxRuntimeExports.jsxs("ul", {
                            className: "footerLinks justify-content-center justify-content-md-start",
                            children: [jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx(Link, {
                                    to: "/",
                                    children: "Home"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "#about",
                                    children: "About"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "#tokenomics",
                                    children: "Tokenomics"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "#roadmap",
                                    children: "Roadmap"
                                })
                            })]
                        })
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-6",
                    children: jsxRuntimeExports.jsx("div", {
                        className: "text-center text-md-end",
                        children: "© 2024 CloudBTC"
                    })
                })]
            })]
        })
    })
});
let modal$1;
function getWeb3Modal(_e) {
    _e && (modal$1 = _e)
}
function useWeb3Modal() {
    if (!modal$1)
        throw new Error('Please call "createWeb3Modal" before using "useWeb3Modal" hook');
    async function _e(tt) {
        await (modal$1 == null ? void 0 : modal$1.open(tt))
    }
    async function et() {
        await (modal$1 == null ? void 0 : modal$1.close())
    }
    return {
        open: _e,
        close: et
    }
}
const scriptRel = "modulepreload"
  , assetsURL = function(_e) {
    return "/" + _e
}
  , seen = {}
  , __vitePreload = function(et, tt, rt) {
    let nt = Promise.resolve();
    if (tt && tt.length > 0) {
        const it = document.getElementsByTagName("link");
        nt = Promise.all(tt.map(st=>{
            if (st = assetsURL(st),
            st in seen)
                return;
            seen[st] = !0;
            const at = st.endsWith(".css")
              , ot = at ? '[rel="stylesheet"]' : "";
            if (!!rt)
                for (let ct = it.length - 1; ct >= 0; ct--) {
                    const ut = it[ct];
                    if (ut.href === st && (!at || ut.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${st}"]${ot}`))
                return;
            const dt = document.createElement("link");
            if (dt.rel = at ? "stylesheet" : scriptRel,
            at || (dt.as = "script",
            dt.crossOrigin = ""),
            dt.href = st,
            document.head.appendChild(dt),
            at)
                return new Promise((ct,ut)=>{
                    dt.addEventListener("load", ct),
                    dt.addEventListener("error", ()=>ut(new Error(`Unable to preload CSS for ${st}`)))
                }
                )
        }
        ))
    }
    return nt.then(()=>et()).catch(it=>{
        const st = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (st.payload = it,
        window.dispatchEvent(st),
        !st.defaultPrevented)
            throw it
    }
    )
}
  , version$3 = "2.7.10"
  , getContractAddress = _e=>_e
  , getUrl = _e=>_e
  , getVersion$2 = ()=>`viem@${version$3}`;
let BaseError$2 = class co extends Error {
    constructor(et, tt={}) {
        var it;
        super(),
        Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ViemError"
        }),
        Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: getVersion$2()
        });
        const rt = tt.cause instanceof co ? tt.cause.details : (it = tt.cause) != null && it.message ? tt.cause.message : tt.details
          , nt = tt.cause instanceof co && tt.cause.docsPath || tt.docsPath;
        this.message = [et || "An error occurred.", "", ...tt.metaMessages ? [...tt.metaMessages, ""] : [], ...nt ? [`Docs: https://viem.sh${nt}${tt.docsSlug ? `#${tt.docsSlug}` : ""}`] : [], ...rt ? [`Details: ${rt}`] : [], `Version: ${this.version}`].join(`
`),
        tt.cause && (this.cause = tt.cause),
        this.details = rt,
        this.docsPath = nt,
        this.metaMessages = tt.metaMessages,
        this.shortMessage = et
    }
    walk(et) {
        return walk(this, et)
    }
}
;
function walk(_e, et) {
    return et != null && et(_e) ? _e : _e && typeof _e == "object" && "cause"in _e ? walk(_e.cause, et) : et ? null : _e
}
class IntegerOutOfRangeError extends BaseError$2 {
    constructor({max: et, min: tt, signed: rt, size: nt, value: it}) {
        super(`Number "${it}" is not in safe ${nt ? `${nt * 8}-bit ${rt ? "signed" : "unsigned"} ` : ""}integer range ${et ? `(${tt} to ${et})` : `(above ${tt})`}`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntegerOutOfRangeError"
        })
    }
}
class InvalidBytesBooleanError extends BaseError$2 {
    constructor(et) {
        super(`Bytes value "${et}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidBytesBooleanError"
        })
    }
}
class SizeOverflowError extends BaseError$2 {
    constructor({givenSize: et, maxSize: tt}) {
        super(`Size cannot exceed ${tt} bytes. Given size: ${et} bytes.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeOverflowError"
        })
    }
}
class SliceOffsetOutOfBoundsError extends BaseError$2 {
    constructor({offset: et, position: tt, size: rt}) {
        super(`Slice ${tt === "start" ? "starting" : "ending"} at offset "${et}" is out-of-bounds (size: ${rt}).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SliceOffsetOutOfBoundsError"
        })
    }
}
class SizeExceedsPaddingSizeError extends BaseError$2 {
    constructor({size: et, targetSize: tt, type: rt}) {
        super(`${rt.charAt(0).toUpperCase()}${rt.slice(1).toLowerCase()} size (${et}) exceeds padding size (${tt}).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeExceedsPaddingSizeError"
        })
    }
}
class InvalidBytesLengthError extends BaseError$2 {
    constructor({size: et, targetSize: tt, type: rt}) {
        super(`${rt.charAt(0).toUpperCase()}${rt.slice(1).toLowerCase()} is expected to be ${tt} ${rt} long, but is ${et} ${rt} long.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidBytesLengthError"
        })
    }
}
function pad(_e, {dir: et, size: tt=32}={}) {
    return typeof _e == "string" ? padHex(_e, {
        dir: et,
        size: tt
    }) : padBytes(_e, {
        dir: et,
        size: tt
    })
}
function padHex(_e, {dir: et, size: tt=32}={}) {
    if (tt === null)
        return _e;
    const rt = _e.replace("0x", "");
    if (rt.length > tt * 2)
        throw new SizeExceedsPaddingSizeError({
            size: Math.ceil(rt.length / 2),
            targetSize: tt,
            type: "hex"
        });
    return `0x${rt[et === "right" ? "padEnd" : "padStart"](tt * 2, "0")}`
}
function padBytes(_e, {dir: et, size: tt=32}={}) {
    if (tt === null)
        return _e;
    if (_e.length > tt)
        throw new SizeExceedsPaddingSizeError({
            size: _e.length,
            targetSize: tt,
            type: "bytes"
        });
    const rt = new Uint8Array(tt);
    for (let nt = 0; nt < tt; nt++) {
        const it = et === "right";
        rt[it ? nt : tt - nt - 1] = _e[it ? nt : _e.length - nt - 1]
    }
    return rt
}
function isHex(_e, {strict: et=!0}={}) {
    return !_e || typeof _e != "string" ? !1 : et ? /^0x[0-9a-fA-F]*$/.test(_e) : _e.startsWith("0x")
}
function size$2(_e) {
    return isHex(_e, {
        strict: !1
    }) ? Math.ceil((_e.length - 2) / 2) : _e.length
}
function trim(_e, {dir: et="left"}={}) {
    let tt = typeof _e == "string" ? _e.replace("0x", "") : _e
      , rt = 0;
    for (let nt = 0; nt < tt.length - 1 && tt[et === "left" ? nt : tt.length - nt - 1].toString() === "0"; nt++)
        rt++;
    return tt = et === "left" ? tt.slice(rt) : tt.slice(0, tt.length - rt),
    typeof _e == "string" ? (tt.length === 1 && et === "right" && (tt = `${tt}0`),
    `0x${tt.length % 2 === 1 ? `0${tt}` : tt}`) : tt
}
const encoder$1 = new TextEncoder;
function toBytes$1(_e, et={}) {
    return typeof _e == "number" || typeof _e == "bigint" ? numberToBytes(_e, et) : typeof _e == "boolean" ? boolToBytes(_e, et) : isHex(_e) ? hexToBytes(_e, et) : stringToBytes(_e, et)
}
function boolToBytes(_e, et={}) {
    const tt = new Uint8Array(1);
    return tt[0] = Number(_e),
    typeof et.size == "number" ? (assertSize(tt, {
        size: et.size
    }),
    pad(tt, {
        size: et.size
    })) : tt
}
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function charCodeToBase16(_e) {
    if (_e >= charCodeMap.zero && _e <= charCodeMap.nine)
        return _e - charCodeMap.zero;
    if (_e >= charCodeMap.A && _e <= charCodeMap.F)
        return _e - (charCodeMap.A - 10);
    if (_e >= charCodeMap.a && _e <= charCodeMap.f)
        return _e - (charCodeMap.a - 10)
}
function hexToBytes(_e, et={}) {
    let tt = _e;
    et.size && (assertSize(tt, {
        size: et.size
    }),
    tt = pad(tt, {
        dir: "right",
        size: et.size
    }));
    let rt = tt.slice(2);
    rt.length % 2 && (rt = `0${rt}`);
    const nt = rt.length / 2
      , it = new Uint8Array(nt);
    for (let st = 0, at = 0; st < nt; st++) {
        const ot = charCodeToBase16(rt.charCodeAt(at++))
          , lt = charCodeToBase16(rt.charCodeAt(at++));
        if (ot === void 0 || lt === void 0)
            throw new BaseError$2(`Invalid byte sequence ("${rt[at - 2]}${rt[at - 1]}" in "${rt}").`);
        it[st] = ot * 16 + lt
    }
    return it
}
function numberToBytes(_e, et) {
    const tt = numberToHex(_e, et);
    return hexToBytes(tt)
}
function stringToBytes(_e, et={}) {
    const tt = encoder$1.encode(_e);
    return typeof et.size == "number" ? (assertSize(tt, {
        size: et.size
    }),
    pad(tt, {
        dir: "right",
        size: et.size
    })) : tt
}
function assertSize(_e, {size: et}) {
    if (size$2(_e) > et)
        throw new SizeOverflowError({
            givenSize: size$2(_e),
            maxSize: et
        })
}
function hexToBigInt(_e, et={}) {
    const {signed: tt} = et;
    et.size && assertSize(_e, {
        size: et.size
    });
    const rt = BigInt(_e);
    if (!tt)
        return rt;
    const nt = (_e.length - 2) / 2
      , it = (1n << BigInt(nt) * 8n - 1n) - 1n;
    return rt <= it ? rt : rt - BigInt(`0x${"f".padStart(nt * 2, "f")}`) - 1n
}
function hexToNumber(_e, et={}) {
    return Number(hexToBigInt(_e, et))
}
function hexToString(_e, et={}) {
    let tt = hexToBytes(_e);
    return et.size && (assertSize(tt, {
        size: et.size
    }),
    tt = trim(tt, {
        dir: "right"
    })),
    new TextDecoder().decode(tt)
}
const hexes = Array.from({
    length: 256
}, (_e,et)=>et.toString(16).padStart(2, "0"));
function toHex(_e, et={}) {
    return typeof _e == "number" || typeof _e == "bigint" ? numberToHex(_e, et) : typeof _e == "string" ? stringToHex(_e, et) : typeof _e == "boolean" ? boolToHex(_e, et) : bytesToHex(_e, et)
}
function boolToHex(_e, et={}) {
    const tt = `0x${Number(_e)}`;
    return typeof et.size == "number" ? (assertSize(tt, {
        size: et.size
    }),
    pad(tt, {
        size: et.size
    })) : tt
}
function bytesToHex(_e, et={}) {
    let tt = "";
    for (let nt = 0; nt < _e.length; nt++)
        tt += hexes[_e[nt]];
    const rt = `0x${tt}`;
    return typeof et.size == "number" ? (assertSize(rt, {
        size: et.size
    }),
    pad(rt, {
        dir: "right",
        size: et.size
    })) : rt
}
function numberToHex(_e, et={}) {
    const {signed: tt, size: rt} = et
      , nt = BigInt(_e);
    let it;
    rt ? tt ? it = (1n << BigInt(rt) * 8n - 1n) - 1n : it = 2n ** (BigInt(rt) * 8n) - 1n : typeof _e == "number" && (it = BigInt(Number.MAX_SAFE_INTEGER));
    const st = typeof it == "bigint" && tt ? -it - 1n : 0;
    if (it && nt > it || nt < st) {
        const ot = typeof _e == "bigint" ? "n" : "";
        throw new IntegerOutOfRangeError({
            max: it ? `${it}${ot}` : void 0,
            min: `${st}${ot}`,
            signed: tt,
            size: rt,
            value: `${_e}${ot}`
        })
    }
    const at = `0x${(tt && nt < 0 ? (1n << BigInt(rt * 8)) + BigInt(nt) : nt).toString(16)}`;
    return rt ? pad(at, {
        size: rt
    }) : at
}
const encoder = new TextEncoder;
function stringToHex(_e, et={}) {
    const tt = encoder.encode(_e);
    return bytesToHex(tt, et)
}
function formatAbiItem$1(_e, {includeName: et=!1}={}) {
    if (_e.type !== "function" && _e.type !== "event" && _e.type !== "error")
        throw new InvalidDefinitionTypeError(_e.type);
    return `${_e.name}(${formatAbiParams(_e.inputs, {
        includeName: et
    })})`
}
function formatAbiParams(_e, {includeName: et=!1}={}) {
    return _e ? _e.map(tt=>formatAbiParam(tt, {
        includeName: et
    })).join(et ? ", " : ",") : ""
}
function formatAbiParam(_e, {includeName: et}) {
    return _e.type.startsWith("tuple") ? `(${formatAbiParams(_e.components, {
        includeName: et
    })})${_e.type.slice(5)}` : _e.type + (et && _e.name ? ` ${_e.name}` : "")
}
class AbiDecodingDataSizeTooSmallError extends BaseError$2 {
    constructor({data: et, params: tt, size: rt}) {
        super([`Data size of ${rt} bytes is too small for given parameters.`].join(`
`), {
            metaMessages: [`Params: (${formatAbiParams(tt, {
                includeName: !0
            })})`, `Data:   ${et} (${rt} bytes)`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiDecodingDataSizeTooSmallError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "params", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "size", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = et,
        this.params = tt,
        this.size = rt
    }
}
class AbiDecodingZeroDataError extends BaseError$2 {
    constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.'),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiDecodingZeroDataError"
        })
    }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$2 {
    constructor({expectedLength: et, givenLength: tt, type: rt}) {
        super([`ABI encoding array length mismatch for type ${rt}.`, `Expected length: ${et}`, `Given length: ${tt}`].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingArrayLengthMismatchError"
        })
    }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$2 {
    constructor({expectedSize: et, value: tt}) {
        super(`Size of bytes "${tt}" (bytes${size$2(tt)}) does not match expected size (bytes${et}).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingBytesSizeMismatchError"
        })
    }
}
class AbiEncodingLengthMismatchError extends BaseError$2 {
    constructor({expectedLength: et, givenLength: tt}) {
        super(["ABI encoding params/values length mismatch.", `Expected length (params): ${et}`, `Given length (values): ${tt}`].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingLengthMismatchError"
        })
    }
}
class AbiErrorSignatureNotFoundError extends BaseError$2 {
    constructor(et, {docsPath: tt}) {
        super([`Encoded error signature "${et}" not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${et}.`].join(`
`), {
            docsPath: tt
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiErrorSignatureNotFoundError"
        }),
        Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.signature = et
    }
}
class AbiFunctionNotFoundError extends BaseError$2 {
    constructor(et, {docsPath: tt}={}) {
        super([`Function ${et ? `"${et}" ` : ""}not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
            docsPath: tt
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiFunctionNotFoundError"
        })
    }
}
class AbiFunctionOutputsNotFoundError extends BaseError$2 {
    constructor(et, {docsPath: tt}) {
        super([`Function "${et}" does not contain any \`outputs\` on ABI.`, "Cannot decode function result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
            docsPath: tt
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiFunctionOutputsNotFoundError"
        })
    }
}
class AbiItemAmbiguityError extends BaseError$2 {
    constructor(et, tt) {
        super("Found ambiguous types in overloaded ABI items.", {
            metaMessages: [`\`${et.type}\` in \`${formatAbiItem$1(et.abiItem)}\`, and`, `\`${tt.type}\` in \`${formatAbiItem$1(tt.abiItem)}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiItemAmbiguityError"
        })
    }
}
class InvalidAbiEncodingTypeError extends BaseError$2 {
    constructor(et, {docsPath: tt}) {
        super([`Type "${et}" is not a valid encoding type.`, "Please provide a valid ABI type."].join(`
`), {
            docsPath: tt
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiEncodingType"
        })
    }
}
class InvalidAbiDecodingTypeError extends BaseError$2 {
    constructor(et, {docsPath: tt}) {
        super([`Type "${et}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), {
            docsPath: tt
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiDecodingType"
        })
    }
}
class InvalidArrayError extends BaseError$2 {
    constructor(et) {
        super([`Value "${et}" is not a valid array.`].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidArrayError"
        })
    }
}
class InvalidDefinitionTypeError extends BaseError$2 {
    constructor(et) {
        super([`"${et}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidDefinitionTypeError"
        })
    }
}
function concat(_e) {
    return typeof _e[0] == "string" ? concatHex(_e) : concatBytes(_e)
}
function concatBytes(_e) {
    let et = 0;
    for (const nt of _e)
        et += nt.length;
    const tt = new Uint8Array(et);
    let rt = 0;
    for (const nt of _e)
        tt.set(nt, rt),
        rt += nt.length;
    return tt
}
function concatHex(_e) {
    return `0x${_e.reduce((et,tt)=>et + tt.replace("0x", ""), "")}`
}
class InvalidAddressError extends BaseError$2 {
    constructor({address: et}) {
        super(`Address "${et}" is invalid.`, {
            metaMessages: ["- Address must be a hex value of 20 bytes (40 hex characters).", "- Address must match its checksum counterpart."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAddressError"
        })
    }
}
class LruMap extends Map {
    constructor(et) {
        super(),
        Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.maxSize = et
    }
    set(et, tt) {
        return super.set(et, tt),
        this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value),
        this
    }
}
function number$1(_e) {
    if (!Number.isSafeInteger(_e) || _e < 0)
        throw new Error(`Wrong positive integer: ${_e}`)
}
function bytes(_e, ...et) {
    if (!(_e instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
    if (et.length > 0 && !et.includes(_e.length))
        throw new Error(`Expected Uint8Array of length ${et}, not of length=${_e.length}`)
}
function exists(_e, et=!0) {
    if (_e.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (et && _e.finished)
        throw new Error("Hash#digest() has already been called")
}
function output(_e, et) {
    bytes(_e);
    const tt = et.outputLen;
    if (_e.length < tt)
        throw new Error(`digestInto() expects output buffer of length at least ${tt}`)
}
const U32_MASK64 = BigInt(2 ** 32 - 1)
  , _32n = BigInt(32);
function fromBig(_e, et=!1) {
    return et ? {
        h: Number(_e & U32_MASK64),
        l: Number(_e >> _32n & U32_MASK64)
    } : {
        h: Number(_e >> _32n & U32_MASK64) | 0,
        l: Number(_e & U32_MASK64) | 0
    }
}
function split(_e, et=!1) {
    let tt = new Uint32Array(_e.length)
      , rt = new Uint32Array(_e.length);
    for (let nt = 0; nt < _e.length; nt++) {
        const {h: it, l: st} = fromBig(_e[nt], et);
        [tt[nt],rt[nt]] = [it, st]
    }
    return [tt, rt]
}
const rotlSH = (_e,et,tt)=>_e << tt | et >>> 32 - tt
  , rotlSL = (_e,et,tt)=>et << tt | _e >>> 32 - tt
  , rotlBH = (_e,et,tt)=>et << tt - 32 | _e >>> 64 - tt
  , rotlBL = (_e,et,tt)=>_e << tt - 32 | et >>> 64 - tt;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a = _e=>_e instanceof Uint8Array
  , u32 = _e=>new Uint32Array(_e.buffer,_e.byteOffset,Math.floor(_e.byteLength / 4))
  , isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes(_e) {
    if (typeof _e != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof _e}`);
    return new Uint8Array(new TextEncoder().encode(_e))
}
function toBytes(_e) {
    if (typeof _e == "string" && (_e = utf8ToBytes(_e)),
    !u8a(_e))
        throw new Error(`expected Uint8Array, got ${typeof _e}`);
    return _e
}
class Hash {
    clone() {
        return this._cloneInto()
    }
}
function wrapConstructor(_e) {
    const et = rt=>_e().update(toBytes(rt)).digest()
      , tt = _e();
    return et.outputLen = tt.outputLen,
    et.blockLen = tt.blockLen,
    et.create = ()=>_e(),
    et
}
const [SHA3_PI,SHA3_ROTL,_SHA3_IOTA] = [[], [], []]
  , _0n = BigInt(0)
  , _1n = BigInt(1)
  , _2n = BigInt(2)
  , _7n = BigInt(7)
  , _256n = BigInt(256)
  , _0x71n = BigInt(113);
for (let _e = 0, et = _1n, tt = 1, rt = 0; _e < 24; _e++) {
    [tt,rt] = [rt, (2 * tt + 3 * rt) % 5],
    SHA3_PI.push(2 * (5 * rt + tt)),
    SHA3_ROTL.push((_e + 1) * (_e + 2) / 2 % 64);
    let nt = _0n;
    for (let it = 0; it < 7; it++)
        et = (et << _1n ^ (et >> _7n) * _0x71n) % _256n,
        et & _2n && (nt ^= _1n << (_1n << BigInt(it)) - _1n);
    _SHA3_IOTA.push(nt)
}
const [SHA3_IOTA_H,SHA3_IOTA_L] = split(_SHA3_IOTA, !0)
  , rotlH = (_e,et,tt)=>tt > 32 ? rotlBH(_e, et, tt) : rotlSH(_e, et, tt)
  , rotlL = (_e,et,tt)=>tt > 32 ? rotlBL(_e, et, tt) : rotlSL(_e, et, tt);
function keccakP(_e, et=24) {
    const tt = new Uint32Array(10);
    for (let rt = 24 - et; rt < 24; rt++) {
        for (let st = 0; st < 10; st++)
            tt[st] = _e[st] ^ _e[st + 10] ^ _e[st + 20] ^ _e[st + 30] ^ _e[st + 40];
        for (let st = 0; st < 10; st += 2) {
            const at = (st + 8) % 10
              , ot = (st + 2) % 10
              , lt = tt[ot]
              , dt = tt[ot + 1]
              , ct = rotlH(lt, dt, 1) ^ tt[at]
              , ut = rotlL(lt, dt, 1) ^ tt[at + 1];
            for (let ft = 0; ft < 50; ft += 10)
                _e[st + ft] ^= ct,
                _e[st + ft + 1] ^= ut
        }
        let nt = _e[2]
          , it = _e[3];
        for (let st = 0; st < 24; st++) {
            const at = SHA3_ROTL[st]
              , ot = rotlH(nt, it, at)
              , lt = rotlL(nt, it, at)
              , dt = SHA3_PI[st];
            nt = _e[dt],
            it = _e[dt + 1],
            _e[dt] = ot,
            _e[dt + 1] = lt
        }
        for (let st = 0; st < 50; st += 10) {
            for (let at = 0; at < 10; at++)
                tt[at] = _e[st + at];
            for (let at = 0; at < 10; at++)
                _e[st + at] ^= ~tt[(at + 2) % 10] & tt[(at + 4) % 10]
        }
        _e[0] ^= SHA3_IOTA_H[rt],
        _e[1] ^= SHA3_IOTA_L[rt]
    }
    tt.fill(0)
}
class Keccak extends Hash {
    constructor(et, tt, rt, nt=!1, it=24) {
        if (super(),
        this.blockLen = et,
        this.suffix = tt,
        this.outputLen = rt,
        this.enableXOF = nt,
        this.rounds = it,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        number$1(rt),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = u32(this.state)
    }
    keccak() {
        keccakP(this.state32, this.rounds),
        this.posOut = 0,
        this.pos = 0
    }
    update(et) {
        exists(this);
        const {blockLen: tt, state: rt} = this;
        et = toBytes(et);
        const nt = et.length;
        for (let it = 0; it < nt; ) {
            const st = Math.min(tt - this.pos, nt - it);
            for (let at = 0; at < st; at++)
                rt[this.pos++] ^= et[it++];
            this.pos === tt && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: et, suffix: tt, pos: rt, blockLen: nt} = this;
        et[rt] ^= tt,
        tt & 128 && rt === nt - 1 && this.keccak(),
        et[nt - 1] ^= 128,
        this.keccak()
    }
    writeInto(et) {
        exists(this, !1),
        bytes(et),
        this.finish();
        const tt = this.state
          , {blockLen: rt} = this;
        for (let nt = 0, it = et.length; nt < it; ) {
            this.posOut >= rt && this.keccak();
            const st = Math.min(rt - this.posOut, it - nt);
            et.set(tt.subarray(this.posOut, this.posOut + st), nt),
            this.posOut += st,
            nt += st
        }
        return et
    }
    xofInto(et) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(et)
    }
    xof(et) {
        return number$1(et),
        this.xofInto(new Uint8Array(et))
    }
    digestInto(et) {
        if (output(et, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(et),
        this.destroy(),
        et
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(et) {
        const {blockLen: tt, suffix: rt, outputLen: nt, rounds: it, enableXOF: st} = this;
        return et || (et = new Keccak(tt,rt,nt,st,it)),
        et.state32.set(this.state32),
        et.pos = this.pos,
        et.posOut = this.posOut,
        et.finished = this.finished,
        et.rounds = it,
        et.suffix = rt,
        et.outputLen = nt,
        et.enableXOF = st,
        et.destroyed = this.destroyed,
        et
    }
}
const gen = (_e,et,tt)=>wrapConstructor(()=>new Keccak(et,_e,tt))
  , keccak_256 = gen(1, 136, 256 / 8);
function keccak256(_e, et) {
    const tt = et || "hex"
      , rt = keccak_256(isHex(_e, {
        strict: !1
    }) ? toBytes$1(_e) : _e);
    return tt === "bytes" ? rt : toHex(rt)
}
function checksumAddress(_e, et) {
    const tt = et ? `${et}${_e.toLowerCase()}` : _e.substring(2).toLowerCase()
      , rt = keccak256(stringToBytes(tt), "bytes")
      , nt = (et ? tt.substring(`${et}0x`.length) : tt).split("");
    for (let it = 0; it < 40; it += 2)
        rt[it >> 1] >> 4 >= 8 && nt[it] && (nt[it] = nt[it].toUpperCase()),
        (rt[it >> 1] & 15) >= 8 && nt[it + 1] && (nt[it + 1] = nt[it + 1].toUpperCase());
    return `0x${nt.join("")}`
}
function getAddress(_e, et) {
    if (!isAddress(_e))
        throw new InvalidAddressError({
            address: _e
        });
    return checksumAddress(_e, et)
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/
  , isAddressCache = new LruMap(8192);
function isAddress(_e, {strict: et=!0}={}) {
    if (isAddressCache.has(_e))
        return isAddressCache.get(_e);
    const tt = addressRegex.test(_e) ? _e.toLowerCase() === _e ? !0 : et ? checksumAddress(_e) === _e : !0 : !1;
    return isAddressCache.set(_e, tt),
    tt
}
function slice(_e, et, tt, {strict: rt}={}) {
    return isHex(_e, {
        strict: !1
    }) ? sliceHex(_e, et, tt, {
        strict: rt
    }) : sliceBytes(_e, et, tt, {
        strict: rt
    })
}
function assertStartOffset(_e, et) {
    if (typeof et == "number" && et > 0 && et > size$2(_e) - 1)
        throw new SliceOffsetOutOfBoundsError({
            offset: et,
            position: "start",
            size: size$2(_e)
        })
}
function assertEndOffset(_e, et, tt) {
    if (typeof et == "number" && typeof tt == "number" && size$2(_e) !== tt - et)
        throw new SliceOffsetOutOfBoundsError({
            offset: tt,
            position: "end",
            size: size$2(_e)
        })
}
function sliceBytes(_e, et, tt, {strict: rt}={}) {
    assertStartOffset(_e, et);
    const nt = _e.slice(et, tt);
    return rt && assertEndOffset(nt, et, tt),
    nt
}
function sliceHex(_e, et, tt, {strict: rt}={}) {
    assertStartOffset(_e, et);
    const nt = `0x${_e.replace("0x", "").slice((et ?? 0) * 2, (tt ?? _e.length) * 2)}`;
    return rt && assertEndOffset(nt, et, tt),
    nt
}
function encodeAbiParameters(_e, et) {
    if (_e.length !== et.length)
        throw new AbiEncodingLengthMismatchError({
            expectedLength: _e.length,
            givenLength: et.length
        });
    const tt = prepareParams({
        params: _e,
        values: et
    })
      , rt = encodeParams(tt);
    return rt.length === 0 ? "0x" : rt
}
function prepareParams({params: _e, values: et}) {
    const tt = [];
    for (let rt = 0; rt < _e.length; rt++)
        tt.push(prepareParam({
            param: _e[rt],
            value: et[rt]
        }));
    return tt
}
function prepareParam({param: _e, value: et}) {
    const tt = getArrayComponents(_e.type);
    if (tt) {
        const [rt,nt] = tt;
        return encodeArray(et, {
            length: rt,
            param: {
                ..._e,
                type: nt
            }
        })
    }
    if (_e.type === "tuple")
        return encodeTuple(et, {
            param: _e
        });
    if (_e.type === "address")
        return encodeAddress(et);
    if (_e.type === "bool")
        return encodeBool(et);
    if (_e.type.startsWith("uint") || _e.type.startsWith("int")) {
        const rt = _e.type.startsWith("int");
        return encodeNumber(et, {
            signed: rt
        })
    }
    if (_e.type.startsWith("bytes"))
        return encodeBytes(et, {
            param: _e
        });
    if (_e.type === "string")
        return encodeString(et);
    throw new InvalidAbiEncodingTypeError(_e.type,{
        docsPath: "/docs/contract/encodeAbiParameters"
    })
}
function encodeParams(_e) {
    let et = 0;
    for (let it = 0; it < _e.length; it++) {
        const {dynamic: st, encoded: at} = _e[it];
        st ? et += 32 : et += size$2(at)
    }
    const tt = []
      , rt = [];
    let nt = 0;
    for (let it = 0; it < _e.length; it++) {
        const {dynamic: st, encoded: at} = _e[it];
        st ? (tt.push(numberToHex(et + nt, {
            size: 32
        })),
        rt.push(at),
        nt += size$2(at)) : tt.push(at)
    }
    return concat([...tt, ...rt])
}
function encodeAddress(_e) {
    if (!isAddress(_e))
        throw new InvalidAddressError({
            address: _e
        });
    return {
        dynamic: !1,
        encoded: padHex(_e.toLowerCase())
    }
}
function encodeArray(_e, {length: et, param: tt}) {
    const rt = et === null;
    if (!Array.isArray(_e))
        throw new InvalidArrayError(_e);
    if (!rt && _e.length !== et)
        throw new AbiEncodingArrayLengthMismatchError({
            expectedLength: et,
            givenLength: _e.length,
            type: `${tt.type}[${et}]`
        });
    let nt = !1;
    const it = [];
    for (let st = 0; st < _e.length; st++) {
        const at = prepareParam({
            param: tt,
            value: _e[st]
        });
        at.dynamic && (nt = !0),
        it.push(at)
    }
    if (rt || nt) {
        const st = encodeParams(it);
        if (rt) {
            const at = numberToHex(it.length, {
                size: 32
            });
            return {
                dynamic: !0,
                encoded: it.length > 0 ? concat([at, st]) : at
            }
        }
        if (nt)
            return {
                dynamic: !0,
                encoded: st
            }
    }
    return {
        dynamic: !1,
        encoded: concat(it.map(({encoded: st})=>st))
    }
}
function encodeBytes(_e, {param: et}) {
    const [,tt] = et.type.split("bytes")
      , rt = size$2(_e);
    if (!tt) {
        let nt = _e;
        return rt % 32 !== 0 && (nt = padHex(nt, {
            dir: "right",
            size: Math.ceil((_e.length - 2) / 2 / 32) * 32
        })),
        {
            dynamic: !0,
            encoded: concat([padHex(numberToHex(rt, {
                size: 32
            })), nt])
        }
    }
    if (rt !== parseInt(tt))
        throw new AbiEncodingBytesSizeMismatchError({
            expectedSize: parseInt(tt),
            value: _e
        });
    return {
        dynamic: !1,
        encoded: padHex(_e, {
            dir: "right"
        })
    }
}
function encodeBool(_e) {
    return {
        dynamic: !1,
        encoded: padHex(boolToHex(_e))
    }
}
function encodeNumber(_e, {signed: et}) {
    return {
        dynamic: !1,
        encoded: numberToHex(_e, {
            size: 32,
            signed: et
        })
    }
}
function encodeString(_e) {
    const et = stringToHex(_e)
      , tt = Math.ceil(size$2(et) / 32)
      , rt = [];
    for (let nt = 0; nt < tt; nt++)
        rt.push(padHex(slice(et, nt * 32, (nt + 1) * 32), {
            dir: "right"
        }));
    return {
        dynamic: !0,
        encoded: concat([padHex(numberToHex(size$2(et), {
            size: 32
        })), ...rt])
    }
}
function encodeTuple(_e, {param: et}) {
    let tt = !1;
    const rt = [];
    for (let nt = 0; nt < et.components.length; nt++) {
        const it = et.components[nt]
          , st = Array.isArray(_e) ? nt : it.name
          , at = prepareParam({
            param: it,
            value: _e[st]
        });
        rt.push(at),
        at.dynamic && (tt = !0)
    }
    return {
        dynamic: tt,
        encoded: tt ? encodeParams(rt) : concat(rt.map(({encoded: nt})=>nt))
    }
}
function getArrayComponents(_e) {
    const et = _e.match(/^(.*)\[(\d+)?\]$/);
    return et ? [et[2] ? Number(et[2]) : null, et[1]] : void 0
}
function parseAccount(_e) {
    return typeof _e == "string" ? {
        address: _e,
        type: "json-rpc"
    } : _e
}
class AccountNotFoundError extends BaseError$2 {
    constructor({docsPath: et}={}) {
        super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join(`
`), {
            docsPath: et,
            docsSlug: "account"
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AccountNotFoundError"
        })
    }
}
class ChainDoesNotSupportContract extends BaseError$2 {
    constructor({blockNumber: et, chain: tt, contract: rt}) {
        super(`Chain "${tt.name}" does not support contract "${rt.name}".`, {
            metaMessages: ["This could be due to any of the following:", ...et && rt.blockCreated && rt.blockCreated > et ? [`- The contract "${rt.name}" was not deployed until block ${rt.blockCreated} (current block ${et}).`] : [`- The chain does not have the contract "${rt.name}" configured.`]]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainDoesNotSupportContract"
        })
    }
}
class ChainMismatchError extends BaseError$2 {
    constructor({chain: et, currentChainId: tt}) {
        super(`The current chain of the wallet (id: ${tt}) does not match the target chain for the transaction (id: ${et.id} – ${et.name}).`, {
            metaMessages: [`Current Chain ID:  ${tt}`, `Expected Chain ID: ${et.id} – ${et.name}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainMismatchError"
        })
    }
}
class ChainNotFoundError extends BaseError$2 {
    constructor() {
        super(["No chain was provided to the request.", "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainNotFoundError"
        })
    }
}
class ClientChainNotConfiguredError extends BaseError$2 {
    constructor() {
        super("No chain was provided to the Client."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ClientChainNotConfiguredError"
        })
    }
}
function assertCurrentChain({chain: _e, currentChainId: et}) {
    if (!_e)
        throw new ChainNotFoundError;
    if (et !== _e.id)
        throw new ChainMismatchError({
            chain: _e,
            currentChainId: et
        })
}
const etherUnits = {
    gwei: 9,
    wei: 18
}
  , gweiUnits = {
    ether: -9,
    wei: 9
}
  , weiUnits = {
    ether: -18,
    gwei: -9
};
function formatUnits(_e, et) {
    let tt = _e.toString();
    const rt = tt.startsWith("-");
    rt && (tt = tt.slice(1)),
    tt = tt.padStart(et, "0");
    let[nt,it] = [tt.slice(0, tt.length - et), tt.slice(tt.length - et)];
    return it = it.replace(/(0+)$/, ""),
    `${rt ? "-" : ""}${nt || "0"}${it ? `.${it}` : ""}`
}
function formatGwei(_e, et="wei") {
    return formatUnits(_e, gweiUnits[et])
}
class ExecutionRevertedError extends BaseError$2 {
    constructor({cause: et, message: tt}={}) {
        var nt;
        const rt = (nt = tt == null ? void 0 : tt.replace("execution reverted: ", "")) == null ? void 0 : nt.replace("execution reverted", "");
        super(`Execution reverted ${rt ? `with reason: ${rt}` : "for an unknown reason"}.`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ExecutionRevertedError"
        })
    }
}
Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /execution reverted/
});
class FeeCapTooHighError extends BaseError$2 {
    constructor({cause: et, maxFeePerGas: tt}={}) {
        super(`The fee cap (\`maxFeePerGas\`${tt ? ` = ${formatGwei(tt)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeCapTooHigh"
        })
    }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError$2 {
    constructor({cause: et, maxFeePerGas: tt}={}) {
        super(`The fee cap (\`maxFeePerGas\`${tt ? ` = ${formatGwei(tt)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeCapTooLow"
        })
    }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError$2 {
    constructor({cause: et, nonce: tt}={}) {
        super(`Nonce provided for the transaction ${tt ? `(${tt}) ` : ""}is higher than the next one expected.`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceTooHighError"
        })
    }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce too high/
});
class NonceTooLowError extends BaseError$2 {
    constructor({cause: et, nonce: tt}={}) {
        super([`Nonce provided for the transaction ${tt ? `(${tt}) ` : ""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join(`
`), {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceTooLowError"
        })
    }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError$2 {
    constructor({cause: et, nonce: tt}={}) {
        super(`Nonce provided for the transaction ${tt ? `(${tt}) ` : ""}exceeds the maximum allowed nonce.`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceMaxValueError"
        })
    }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce has max value/
});
class InsufficientFundsError extends BaseError$2 {
    constructor({cause: et}={}) {
        super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join(`
`), {
            cause: et,
            metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InsufficientFundsError"
        })
    }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /insufficient funds/
});
class IntrinsicGasTooHighError extends BaseError$2 {
    constructor({cause: et, gas: tt}={}) {
        super(`The amount of gas ${tt ? `(${tt}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntrinsicGasTooHighError"
        })
    }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError$2 {
    constructor({cause: et, gas: tt}={}) {
        super(`The amount of gas ${tt ? `(${tt}) ` : ""}provided for the transaction is too low.`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntrinsicGasTooLowError"
        })
    }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError$2 {
    constructor({cause: et}) {
        super("The transaction type is not supported for this chain.", {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionTypeNotSupportedError"
        })
    }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError$2 {
    constructor({cause: et, maxPriorityFeePerGas: tt, maxFeePerGas: rt}={}) {
        super([`The provided tip (\`maxPriorityFeePerGas\`${tt ? ` = ${formatGwei(tt)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${rt ? ` = ${formatGwei(rt)} gwei` : ""}).`].join(`
`), {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TipAboveFeeCapError"
        })
    }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError$2 {
    constructor({cause: et}) {
        super(`An error occurred while executing: ${et == null ? void 0 : et.shortMessage}`, {
            cause: et
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownNodeError"
        })
    }
}
function formatEther(_e, et="wei") {
    return formatUnits(_e, etherUnits[et])
}
function prettyPrint(_e) {
    const et = Object.entries(_e).map(([rt,nt])=>nt === void 0 || nt === !1 ? null : [rt, nt]).filter(Boolean)
      , tt = et.reduce((rt,[nt])=>Math.max(rt, nt.length), 0);
    return et.map(([rt,nt])=>`  ${`${rt}:`.padEnd(tt + 1)}  ${nt}`).join(`
`)
}
class FeeConflictError extends BaseError$2 {
    constructor() {
        super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.", "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeConflictError"
        })
    }
}
class InvalidSerializableTransactionError extends BaseError$2 {
    constructor({transaction: et}) {
        super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: ["Provided Transaction:", "{", prettyPrint(et), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- a Legacy Transaction with `gasPrice`"]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidSerializableTransactionError"
        })
    }
}
class TransactionExecutionError extends BaseError$2 {
    constructor(et, {account: tt, docsPath: rt, chain: nt, data: it, gas: st, gasPrice: at, maxFeePerGas: ot, maxPriorityFeePerGas: lt, nonce: dt, to: ct, value: ut}) {
        var ht;
        const ft = prettyPrint({
            chain: nt && `${nt == null ? void 0 : nt.name} (id: ${nt == null ? void 0 : nt.id})`,
            from: tt == null ? void 0 : tt.address,
            to: ct,
            value: typeof ut < "u" && `${formatEther(ut)} ${((ht = nt == null ? void 0 : nt.nativeCurrency) == null ? void 0 : ht.symbol) || "ETH"}`,
            data: it,
            gas: st,
            gasPrice: typeof at < "u" && `${formatGwei(at)} gwei`,
            maxFeePerGas: typeof ot < "u" && `${formatGwei(ot)} gwei`,
            maxPriorityFeePerGas: typeof lt < "u" && `${formatGwei(lt)} gwei`,
            nonce: dt
        });
        super(et.shortMessage, {
            cause: et,
            docsPath: rt,
            metaMessages: [...et.metaMessages ? [...et.metaMessages, " "] : [], "Request Arguments:", ft].filter(Boolean)
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionExecutionError"
        }),
        this.cause = et
    }
}
class TransactionNotFoundError extends BaseError$2 {
    constructor({blockHash: et, blockNumber: tt, blockTag: rt, hash: nt, index: it}) {
        let st = "Transaction";
        rt && it !== void 0 && (st = `Transaction at block time "${rt}" at index "${it}"`),
        et && it !== void 0 && (st = `Transaction at block hash "${et}" at index "${it}"`),
        tt && it !== void 0 && (st = `Transaction at block number "${tt}" at index "${it}"`),
        nt && (st = `Transaction with hash "${nt}"`),
        super(`${st} could not be found.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionNotFoundError"
        })
    }
}
class TransactionReceiptNotFoundError extends BaseError$2 {
    constructor({hash: et}) {
        super(`Transaction receipt with hash "${et}" could not be found. The Transaction may not be processed on a block yet.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionReceiptNotFoundError"
        })
    }
}
class WaitForTransactionReceiptTimeoutError extends BaseError$2 {
    constructor({hash: et}) {
        super(`Timed out while waiting for transaction with hash "${et}" to be confirmed.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WaitForTransactionReceiptTimeoutError"
        })
    }
}
const stringify = (_e,et,tt)=>JSON.stringify(_e, (rt,nt)=>{
    const it = typeof nt == "bigint" ? nt.toString() : nt;
    return typeof et == "function" ? et(rt, it) : it
}
, tt);
class HttpRequestError extends BaseError$2 {
    constructor({body: et, details: tt, headers: rt, status: nt, url: it}) {
        super("HTTP request failed.", {
            details: tt,
            metaMessages: [nt && `Status: ${nt}`, `URL: ${getUrl(it)}`, et && `Request body: ${stringify(et)}`].filter(Boolean)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "HttpRequestError"
        }),
        Object.defineProperty(this, "body", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "headers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "status", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "url", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.body = et,
        this.headers = rt,
        this.status = nt,
        this.url = it
    }
}
class RpcRequestError extends BaseError$2 {
    constructor({body: et, error: tt, url: rt}) {
        super("RPC Request failed.", {
            cause: tt,
            details: tt.message,
            metaMessages: [`URL: ${getUrl(rt)}`, `Request body: ${stringify(et)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcRequestError"
        }),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.code = tt.code
    }
}
class TimeoutError extends BaseError$2 {
    constructor({body: et, url: tt}) {
        super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${getUrl(tt)}`, `Request body: ${stringify(et)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TimeoutError"
        })
    }
}
const unknownErrorCode = -1;
class RpcError extends BaseError$2 {
    constructor(et, {code: tt, docsPath: rt, metaMessages: nt, shortMessage: it}) {
        super(it, {
            cause: et,
            docsPath: rt,
            metaMessages: nt || (et == null ? void 0 : et.metaMessages)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcError"
        }),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.name = et.name,
        this.code = et instanceof RpcRequestError ? et.code : tt ?? unknownErrorCode
    }
}
class ProviderRpcError extends RpcError {
    constructor(et, tt) {
        super(et, tt),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderRpcError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = tt.data
    }
}
class ParseRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: ParseRpcError.code,
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ParseRpcError"
        })
    }
}
Object.defineProperty(ParseRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32700
});
class InvalidRequestRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: InvalidRequestRpcError.code,
            shortMessage: "JSON is not a valid request object."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidRequestRpcError"
        })
    }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32600
});
class MethodNotFoundRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: MethodNotFoundRpcError.code,
            shortMessage: "The method does not exist / is not available."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotFoundRpcError"
        })
    }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32601
});
class InvalidParamsRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: InvalidParamsRpcError.code,
            shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join(`
`)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidParamsRpcError"
        })
    }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32602
});
class InternalRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: InternalRpcError.code,
            shortMessage: "An internal error was received."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InternalRpcError"
        })
    }
}
Object.defineProperty(InternalRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32603
});
class InvalidInputRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: InvalidInputRpcError.code,
            shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join(`
`)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidInputRpcError"
        })
    }
}
Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: ResourceNotFoundRpcError.code,
            shortMessage: "Requested resource not found."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceNotFoundRpcError"
        })
    }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: ResourceUnavailableRpcError.code,
            shortMessage: "Requested resource not available."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceUnavailableRpcError"
        })
    }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32002
});
class TransactionRejectedRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: TransactionRejectedRpcError.code,
            shortMessage: "Transaction creation failed."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionRejectedRpcError"
        })
    }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: MethodNotSupportedRpcError.code,
            shortMessage: "Method is not implemented."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotSupportedRpcError"
        })
    }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32004
});
class LimitExceededRpcError extends RpcError {
    constructor(et) {
        super(et, {
            code: LimitExceededRpcError.code,
            shortMessage: "Request exceeds defined limit."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "LimitExceededRpcError"
        })
    }
}
Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(et) {
        super(et, {
            code: JsonRpcVersionUnsupportedError.code,
            shortMessage: "Version of JSON-RPC protocol is not supported."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "JsonRpcVersionUnsupportedError"
        })
    }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
    constructor(et) {
        super(et, {
            code: UserRejectedRequestError.code,
            shortMessage: "User rejected the request."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UserRejectedRequestError"
        })
    }
}
Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
    constructor(et) {
        super(et, {
            code: UnauthorizedProviderError.code,
            shortMessage: "The requested method and/or account has not been authorized by the user."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnauthorizedProviderError"
        })
    }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(et) {
        super(et, {
            code: UnsupportedProviderMethodError.code,
            shortMessage: "The Provider does not support the requested method."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnsupportedProviderMethodError"
        })
    }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
    constructor(et) {
        super(et, {
            code: ProviderDisconnectedError.code,
            shortMessage: "The Provider is disconnected from all chains."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderDisconnectedError"
        })
    }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
    constructor(et) {
        super(et, {
            code: ChainDisconnectedError.code,
            shortMessage: "The Provider is not connected to the requested chain."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainDisconnectedError"
        })
    }
}
Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4901
});
class SwitchChainError extends ProviderRpcError {
    constructor(et) {
        super(et, {
            code: SwitchChainError.code,
            shortMessage: "An error occurred when attempting to switch chain."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SwitchChainError"
        })
    }
}
Object.defineProperty(SwitchChainError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4902
});
class UnknownRpcError extends RpcError {
    constructor(et) {
        super(et, {
            shortMessage: "An unknown RPC error occurred."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownRpcError"
        })
    }
}
function getNodeError(_e, et) {
    const tt = (_e.details || "").toLowerCase()
      , rt = _e instanceof BaseError$2 ? _e.walk(nt=>nt.code === ExecutionRevertedError.code) : _e;
    return rt instanceof BaseError$2 ? new ExecutionRevertedError({
        cause: _e,
        message: rt.details
    }) : ExecutionRevertedError.nodeMessage.test(tt) ? new ExecutionRevertedError({
        cause: _e,
        message: _e.details
    }) : FeeCapTooHighError.nodeMessage.test(tt) ? new FeeCapTooHighError({
        cause: _e,
        maxFeePerGas: et == null ? void 0 : et.maxFeePerGas
    }) : FeeCapTooLowError.nodeMessage.test(tt) ? new FeeCapTooLowError({
        cause: _e,
        maxFeePerGas: et == null ? void 0 : et.maxFeePerGas
    }) : NonceTooHighError.nodeMessage.test(tt) ? new NonceTooHighError({
        cause: _e,
        nonce: et == null ? void 0 : et.nonce
    }) : NonceTooLowError.nodeMessage.test(tt) ? new NonceTooLowError({
        cause: _e,
        nonce: et == null ? void 0 : et.nonce
    }) : NonceMaxValueError.nodeMessage.test(tt) ? new NonceMaxValueError({
        cause: _e,
        nonce: et == null ? void 0 : et.nonce
    }) : InsufficientFundsError.nodeMessage.test(tt) ? new InsufficientFundsError({
        cause: _e
    }) : IntrinsicGasTooHighError.nodeMessage.test(tt) ? new IntrinsicGasTooHighError({
        cause: _e,
        gas: et == null ? void 0 : et.gas
    }) : IntrinsicGasTooLowError.nodeMessage.test(tt) ? new IntrinsicGasTooLowError({
        cause: _e,
        gas: et == null ? void 0 : et.gas
    }) : TransactionTypeNotSupportedError.nodeMessage.test(tt) ? new TransactionTypeNotSupportedError({
        cause: _e
    }) : TipAboveFeeCapError.nodeMessage.test(tt) ? new TipAboveFeeCapError({
        cause: _e,
        maxFeePerGas: et == null ? void 0 : et.maxFeePerGas,
        maxPriorityFeePerGas: et == null ? void 0 : et.maxPriorityFeePerGas
    }) : new UnknownNodeError({
        cause: _e
    })
}
function getTransactionError(_e, {docsPath: et, ...tt}) {
    const rt = (()=>{
        const nt = getNodeError(_e, tt);
        return nt instanceof UnknownNodeError ? _e : nt
    }
    )();
    return new TransactionExecutionError(rt,{
        docsPath: et,
        ...tt
    })
}
function extract(_e, {format: et}) {
    if (!et)
        return {};
    const tt = {};
    function rt(it) {
        const st = Object.keys(it);
        for (const at of st)
            at in _e && (tt[at] = _e[at]),
            it[at] && typeof it[at] == "object" && !Array.isArray(it[at]) && rt(it[at])
    }
    const nt = et(_e || {});
    return rt(nt),
    tt
}
const rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2",
    eip4844: "0x3"
};
function formatTransactionRequest(_e) {
    return {
        ..._e,
        gas: typeof _e.gas < "u" ? numberToHex(_e.gas) : void 0,
        gasPrice: typeof _e.gasPrice < "u" ? numberToHex(_e.gasPrice) : void 0,
        maxFeePerGas: typeof _e.maxFeePerGas < "u" ? numberToHex(_e.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: typeof _e.maxPriorityFeePerGas < "u" ? numberToHex(_e.maxPriorityFeePerGas) : void 0,
        nonce: typeof _e.nonce < "u" ? numberToHex(_e.nonce) : void 0,
        type: typeof _e.type < "u" ? rpcTransactionType[_e.type] : void 0,
        value: typeof _e.value < "u" ? numberToHex(_e.value) : void 0
    }
}
function getAction$1(_e, et, tt) {
    return rt=>{
        var nt;
        return ((nt = _e[et.name || tt]) == null ? void 0 : nt.call(_e, rt)) ?? et(_e, rt)
    }
}
function assertRequest(_e) {
    const {account: et, gasPrice: tt, maxFeePerGas: rt, maxPriorityFeePerGas: nt, to: it} = _e
      , st = et ? parseAccount(et) : void 0;
    if (st && !isAddress(st.address))
        throw new InvalidAddressError({
            address: st.address
        });
    if (it && !isAddress(it))
        throw new InvalidAddressError({
            address: it
        });
    if (typeof tt < "u" && (typeof rt < "u" || typeof nt < "u"))
        throw new FeeConflictError;
    if (rt && rt > 2n ** 256n - 1n)
        throw new FeeCapTooHighError({
            maxFeePerGas: rt
        });
    if (nt && rt && nt > rt)
        throw new TipAboveFeeCapError({
            maxFeePerGas: rt,
            maxPriorityFeePerGas: nt
        })
}
async function getChainId$1(_e) {
    const et = await _e.request({
        method: "eth_chainId"
    });
    return hexToNumber(et)
}
class BaseFeeScalarError extends BaseError$2 {
    constructor() {
        super("`baseFeeMultiplier` must be greater than 1."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseFeeScalarError"
        })
    }
}
class Eip1559FeesNotSupportedError extends BaseError$2 {
    constructor() {
        super("Chain does not support EIP-1559 fees."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Eip1559FeesNotSupportedError"
        })
    }
}
class MaxFeePerGasTooLowError extends BaseError$2 {
    constructor({maxPriorityFeePerGas: et}) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(et)} gwei).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MaxFeePerGasTooLowError"
        })
    }
}
class BlockNotFoundError extends BaseError$2 {
    constructor({blockHash: et, blockNumber: tt}) {
        let rt = "Block";
        et && (rt = `Block at hash "${et}"`),
        tt && (rt = `Block at number "${tt}"`),
        super(`${rt} could not be found.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BlockNotFoundError"
        })
    }
}
const transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559",
    "0x3": "eip4844"
};
function formatTransaction(_e) {
    const et = {
        ..._e,
        blockHash: _e.blockHash ? _e.blockHash : null,
        blockNumber: _e.blockNumber ? BigInt(_e.blockNumber) : null,
        chainId: _e.chainId ? hexToNumber(_e.chainId) : void 0,
        gas: _e.gas ? BigInt(_e.gas) : void 0,
        gasPrice: _e.gasPrice ? BigInt(_e.gasPrice) : void 0,
        maxFeePerBlobGas: _e.maxFeePerBlobGas ? BigInt(_e.maxFeePerBlobGas) : void 0,
        maxFeePerGas: _e.maxFeePerGas ? BigInt(_e.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: _e.maxPriorityFeePerGas ? BigInt(_e.maxPriorityFeePerGas) : void 0,
        nonce: _e.nonce ? hexToNumber(_e.nonce) : void 0,
        to: _e.to ? _e.to : null,
        transactionIndex: _e.transactionIndex ? Number(_e.transactionIndex) : null,
        type: _e.type ? transactionType[_e.type] : void 0,
        typeHex: _e.type ? _e.type : void 0,
        value: _e.value ? BigInt(_e.value) : void 0,
        v: _e.v ? BigInt(_e.v) : void 0
    };
    return et.yParity = (()=>{
        if (_e.yParity)
            return Number(_e.yParity);
        if (typeof et.v == "bigint") {
            if (et.v === 0n || et.v === 27n)
                return 0;
            if (et.v === 1n || et.v === 28n)
                return 1;
            if (et.v >= 35n)
                return et.v % 2n === 0n ? 1 : 0
        }
    }
    )(),
    et.type === "legacy" && (delete et.accessList,
    delete et.maxFeePerBlobGas,
    delete et.maxFeePerGas,
    delete et.maxPriorityFeePerGas,
    delete et.yParity),
    et.type === "eip2930" && (delete et.maxFeePerBlobGas,
    delete et.maxFeePerGas,
    delete et.maxPriorityFeePerGas),
    et.type === "eip1559" && delete et.maxFeePerBlobGas,
    et
}
function formatBlock(_e) {
    var tt;
    const et = (tt = _e.transactions) == null ? void 0 : tt.map(rt=>typeof rt == "string" ? rt : formatTransaction(rt));
    return {
        ..._e,
        baseFeePerGas: _e.baseFeePerGas ? BigInt(_e.baseFeePerGas) : null,
        blobGasUsed: _e.blobGasUsed ? BigInt(_e.blobGasUsed) : void 0,
        difficulty: _e.difficulty ? BigInt(_e.difficulty) : void 0,
        excessBlobGas: _e.excessBlobGas ? BigInt(_e.excessBlobGas) : void 0,
        gasLimit: _e.gasLimit ? BigInt(_e.gasLimit) : void 0,
        gasUsed: _e.gasUsed ? BigInt(_e.gasUsed) : void 0,
        hash: _e.hash ? _e.hash : null,
        logsBloom: _e.logsBloom ? _e.logsBloom : null,
        nonce: _e.nonce ? _e.nonce : null,
        number: _e.number ? BigInt(_e.number) : null,
        size: _e.size ? BigInt(_e.size) : void 0,
        timestamp: _e.timestamp ? BigInt(_e.timestamp) : void 0,
        transactions: et,
        totalDifficulty: _e.totalDifficulty ? BigInt(_e.totalDifficulty) : null
    }
}
async function getBlock(_e, {blockHash: et, blockNumber: tt, blockTag: rt, includeTransactions: nt}={}) {
    var dt, ct, ut;
    const it = rt ?? "latest"
      , st = nt ?? !1
      , at = tt !== void 0 ? numberToHex(tt) : void 0;
    let ot = null;
    if (et ? ot = await _e.request({
        method: "eth_getBlockByHash",
        params: [et, st]
    }) : ot = await _e.request({
        method: "eth_getBlockByNumber",
        params: [at || it, st]
    }),
    !ot)
        throw new BlockNotFoundError({
            blockHash: et,
            blockNumber: tt
        });
    return (((ut = (ct = (dt = _e.chain) == null ? void 0 : dt.formatters) == null ? void 0 : ct.block) == null ? void 0 : ut.format) || formatBlock)(ot)
}
async function getGasPrice(_e) {
    const et = await _e.request({
        method: "eth_gasPrice"
    });
    return BigInt(et)
}
async function internal_estimateMaxPriorityFeePerGas(_e, et) {
    var it, st, at;
    const {block: tt, chain: rt=_e.chain, request: nt} = et || {};
    if (typeof ((it = rt == null ? void 0 : rt.fees) == null ? void 0 : it.defaultPriorityFee) == "function") {
        const ot = tt || await getAction$1(_e, getBlock, "getBlock")({});
        return rt.fees.defaultPriorityFee({
            block: ot,
            client: _e,
            request: nt
        })
    }
    if (typeof ((st = rt == null ? void 0 : rt.fees) == null ? void 0 : st.defaultPriorityFee) < "u")
        return (at = rt == null ? void 0 : rt.fees) == null ? void 0 : at.defaultPriorityFee;
    try {
        const ot = await _e.request({
            method: "eth_maxPriorityFeePerGas"
        });
        return hexToBigInt(ot)
    } catch {
        const [ot,lt] = await Promise.all([tt ? Promise.resolve(tt) : getAction$1(_e, getBlock, "getBlock")({}), getAction$1(_e, getGasPrice, "getGasPrice")({})]);
        if (typeof ot.baseFeePerGas != "bigint")
            throw new Eip1559FeesNotSupportedError;
        const dt = lt - ot.baseFeePerGas;
        return dt < 0n ? 0n : dt
    }
}
async function internal_estimateFeesPerGas(_e, et) {
    var ut, ft;
    const {block: tt, chain: rt=_e.chain, request: nt, type: it="eip1559"} = et || {}
      , st = await (async()=>{
        var ht, gt;
        return typeof ((ht = rt == null ? void 0 : rt.fees) == null ? void 0 : ht.baseFeeMultiplier) == "function" ? rt.fees.baseFeeMultiplier({
            block: tt,
            client: _e,
            request: nt
        }) : ((gt = rt == null ? void 0 : rt.fees) == null ? void 0 : gt.baseFeeMultiplier) ?? 1.2
    }
    )();
    if (st < 1)
        throw new BaseFeeScalarError;
    const ot = 10 ** (((ut = st.toString().split(".")[1]) == null ? void 0 : ut.length) ?? 0)
      , lt = ht=>ht * BigInt(Math.ceil(st * ot)) / BigInt(ot)
      , dt = tt || await getAction$1(_e, getBlock, "getBlock")({});
    if (typeof ((ft = rt == null ? void 0 : rt.fees) == null ? void 0 : ft.estimateFeesPerGas) == "function")
        return rt.fees.estimateFeesPerGas({
            block: tt,
            client: _e,
            multiply: lt,
            request: nt,
            type: it
        });
    if (it === "eip1559") {
        if (typeof dt.baseFeePerGas != "bigint")
            throw new Eip1559FeesNotSupportedError;
        const ht = typeof (nt == null ? void 0 : nt.maxPriorityFeePerGas) == "bigint" ? nt.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(_e, {
            block: dt,
            chain: rt,
            request: nt
        })
          , gt = lt(dt.baseFeePerGas);
        return {
            maxFeePerGas: (nt == null ? void 0 : nt.maxFeePerGas) ?? gt + ht,
            maxPriorityFeePerGas: ht
        }
    }
    return {
        gasPrice: (nt == null ? void 0 : nt.gasPrice) ?? lt(await getAction$1(_e, getGasPrice, "getGasPrice")({}))
    }
}
class EstimateGasExecutionError extends BaseError$2 {
    constructor(et, {account: tt, docsPath: rt, chain: nt, data: it, gas: st, gasPrice: at, maxFeePerGas: ot, maxPriorityFeePerGas: lt, nonce: dt, to: ct, value: ut}) {
        var ht;
        const ft = prettyPrint({
            from: tt == null ? void 0 : tt.address,
            to: ct,
            value: typeof ut < "u" && `${formatEther(ut)} ${((ht = nt == null ? void 0 : nt.nativeCurrency) == null ? void 0 : ht.symbol) || "ETH"}`,
            data: it,
            gas: st,
            gasPrice: typeof at < "u" && `${formatGwei(at)} gwei`,
            maxFeePerGas: typeof ot < "u" && `${formatGwei(ot)} gwei`,
            maxPriorityFeePerGas: typeof lt < "u" && `${formatGwei(lt)} gwei`,
            nonce: dt
        });
        super(et.shortMessage, {
            cause: et,
            docsPath: rt,
            metaMessages: [...et.metaMessages ? [...et.metaMessages, " "] : [], "Estimate Gas Arguments:", ft].filter(Boolean)
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EstimateGasExecutionError"
        }),
        this.cause = et
    }
}
function getEstimateGasError(_e, {docsPath: et, ...tt}) {
    const rt = (()=>{
        const nt = getNodeError(_e, tt);
        return nt instanceof UnknownNodeError ? _e : nt
    }
    )();
    return new EstimateGasExecutionError(rt,{
        docsPath: et,
        ...tt
    })
}
async function estimateGas(_e, et) {
    var nt, it, st;
    const tt = et.account ?? _e.account
      , rt = tt ? parseAccount(tt) : void 0;
    try {
        const {accessList: at, blockNumber: ot, blockTag: lt, data: dt, gas: ct, gasPrice: ut, maxFeePerGas: ft, maxPriorityFeePerGas: ht, nonce: gt, to: bt, value: pt, ...mt} = (rt == null ? void 0 : rt.type) === "local" ? await prepareTransactionRequest(_e, et) : et
          , vt = (ot ? numberToHex(ot) : void 0) || lt;
        assertRequest(et);
        const wt = (st = (it = (nt = _e.chain) == null ? void 0 : nt.formatters) == null ? void 0 : it.transactionRequest) == null ? void 0 : st.format
          , Et = (wt || formatTransactionRequest)({
            ...extract(mt, {
                format: wt
            }),
            from: rt == null ? void 0 : rt.address,
            accessList: at,
            data: dt,
            gas: ct,
            gasPrice: ut,
            maxFeePerGas: ft,
            maxPriorityFeePerGas: ht,
            nonce: gt,
            to: bt,
            value: pt
        })
          , xt = await _e.request({
            method: "eth_estimateGas",
            params: vt ? [Et, vt] : [Et]
        });
        return BigInt(xt)
    } catch (at) {
        throw getEstimateGasError(at, {
            ...et,
            account: rt,
            chain: _e.chain
        })
    }
}
async function getTransactionCount(_e, {address: et, blockTag: tt="latest", blockNumber: rt}) {
    const nt = await _e.request({
        method: "eth_getTransactionCount",
        params: [et, rt ? numberToHex(rt) : tt]
    });
    return hexToNumber(nt)
}
function getTransactionType(_e) {
    if (_e.type)
        return _e.type;
    if (typeof _e.maxFeePerGas < "u" || typeof _e.maxPriorityFeePerGas < "u")
        return "eip1559";
    if (typeof _e.gasPrice < "u")
        return typeof _e.accessList < "u" ? "eip2930" : "legacy";
    throw new InvalidSerializableTransactionError({
        transaction: _e
    })
}
async function prepareTransactionRequest(_e, et) {
    const {account: tt=_e.account, chain: rt, gas: nt, nonce: it, parameters: st=["fees", "gas", "nonce", "type"], type: at} = et
      , ot = tt ? parseAccount(tt) : void 0
      , lt = await getAction$1(_e, getBlock, "getBlock")({
        blockTag: "latest"
    })
      , dt = {
        ...et,
        ...ot ? {
            from: ot == null ? void 0 : ot.address
        } : {}
    };
    if (st.includes("nonce") && typeof it > "u" && ot && (dt.nonce = await getAction$1(_e, getTransactionCount, "getTransactionCount")({
        address: ot.address,
        blockTag: "pending"
    })),
    (st.includes("fees") || st.includes("type")) && typeof at > "u")
        try {
            dt.type = getTransactionType(dt)
        } catch {
            dt.type = typeof lt.baseFeePerGas == "bigint" ? "eip1559" : "legacy"
        }
    if (st.includes("fees"))
        if (dt.type === "eip1559") {
            const {maxFeePerGas: ct, maxPriorityFeePerGas: ut} = await internal_estimateFeesPerGas(_e, {
                block: lt,
                chain: rt,
                request: dt
            });
            if (typeof et.maxPriorityFeePerGas > "u" && et.maxFeePerGas && et.maxFeePerGas < ut)
                throw new MaxFeePerGasTooLowError({
                    maxPriorityFeePerGas: ut
                });
            dt.maxPriorityFeePerGas = ut,
            dt.maxFeePerGas = ct
        } else {
            if (typeof et.maxFeePerGas < "u" || typeof et.maxPriorityFeePerGas < "u")
                throw new Eip1559FeesNotSupportedError;
            const {gasPrice: ct} = await internal_estimateFeesPerGas(_e, {
                block: lt,
                chain: rt,
                request: dt,
                type: "legacy"
            });
            dt.gasPrice = ct
        }
    return st.includes("gas") && typeof nt > "u" && (dt.gas = await getAction$1(_e, estimateGas, "estimateGas")({
        ...dt,
        account: ot ? {
            address: ot.address,
            type: "json-rpc"
        } : void 0
    })),
    assertRequest(dt),
    delete dt.parameters,
    dt
}
async function sendRawTransaction(_e, {serializedTransaction: et}) {
    return _e.request({
        method: "eth_sendRawTransaction",
        params: [et]
    }, {
        retryCount: 0
    })
}
async function sendTransaction(_e, et) {
    var gt, bt, pt, mt;
    const {account: tt=_e.account, chain: rt=_e.chain, accessList: nt, data: it, gas: st, gasPrice: at, maxFeePerGas: ot, maxPriorityFeePerGas: lt, nonce: dt, to: ct, value: ut, ...ft} = et;
    if (!tt)
        throw new AccountNotFoundError({
            docsPath: "/docs/actions/wallet/sendTransaction"
        });
    const ht = parseAccount(tt);
    try {
        assertRequest(et);
        let yt;
        if (rt !== null && (yt = await getAction$1(_e, getChainId$1, "getChainId")({}),
        assertCurrentChain({
            currentChainId: yt,
            chain: rt
        })),
        ht.type === "local") {
            const Et = await getAction$1(_e, prepareTransactionRequest, "prepareTransactionRequest")({
                account: ht,
                accessList: nt,
                chain: rt,
                data: it,
                gas: st,
                gasPrice: at,
                maxFeePerGas: ot,
                maxPriorityFeePerGas: lt,
                nonce: dt,
                to: ct,
                value: ut,
                ...ft
            });
            yt || (yt = await getAction$1(_e, getChainId$1, "getChainId")({}));
            const xt = (gt = rt == null ? void 0 : rt.serializers) == null ? void 0 : gt.transaction
              , Ct = await ht.signTransaction({
                ...Et,
                chainId: yt
            }, {
                serializer: xt
            });
            return await getAction$1(_e, sendRawTransaction, "sendRawTransaction")({
                serializedTransaction: Ct
            })
        }
        const vt = (mt = (pt = (bt = _e.chain) == null ? void 0 : bt.formatters) == null ? void 0 : pt.transactionRequest) == null ? void 0 : mt.format
          , _t = (vt || formatTransactionRequest)({
            ...extract(ft, {
                format: vt
            }),
            accessList: nt,
            data: it,
            from: ht.address,
            gas: st,
            gasPrice: at,
            maxFeePerGas: ot,
            maxPriorityFeePerGas: lt,
            nonce: dt,
            to: ct,
            value: ut
        });
        return await _e.request({
            method: "eth_sendTransaction",
            params: [_t]
        }, {
            retryCount: 0
        })
    } catch (yt) {
        throw getTransactionError(yt, {
            ...et,
            account: ht,
            chain: et.chain || void 0
        })
    }
}
const multicall3Abi = [{
    inputs: [{
        components: [{
            name: "target",
            type: "address"
        }, {
            name: "allowFailure",
            type: "bool"
        }, {
            name: "callData",
            type: "bytes"
        }],
        name: "calls",
        type: "tuple[]"
    }],
    name: "aggregate3",
    outputs: [{
        components: [{
            name: "success",
            type: "bool"
        }, {
            name: "returnData",
            type: "bytes"
        }],
        name: "returnData",
        type: "tuple[]"
    }],
    stateMutability: "view",
    type: "function"
}]
  , universalResolverErrors = [{
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
}, {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
}, {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
}, {
    inputs: [{
        name: "returnData",
        type: "bytes"
    }],
    name: "ResolverError",
    type: "error"
}, {
    inputs: [{
        components: [{
            name: "status",
            type: "uint16"
        }, {
            name: "message",
            type: "string"
        }],
        name: "errors",
        type: "tuple[]"
    }],
    name: "HttpError",
    type: "error"
}]
  , universalResolverResolveAbi = [...universalResolverErrors, {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [{
        name: "name",
        type: "bytes"
    }, {
        name: "data",
        type: "bytes"
    }],
    outputs: [{
        name: "",
        type: "bytes"
    }, {
        name: "address",
        type: "address"
    }]
}, {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [{
        name: "name",
        type: "bytes"
    }, {
        name: "data",
        type: "bytes"
    }, {
        name: "gateways",
        type: "string[]"
    }],
    outputs: [{
        name: "",
        type: "bytes"
    }, {
        name: "address",
        type: "address"
    }]
}]
  , universalResolverReverseAbi = [...universalResolverErrors, {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{
        type: "bytes",
        name: "reverseName"
    }],
    outputs: [{
        type: "string",
        name: "resolvedName"
    }, {
        type: "address",
        name: "resolvedAddress"
    }, {
        type: "address",
        name: "reverseResolver"
    }, {
        type: "address",
        name: "resolver"
    }]
}, {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{
        type: "bytes",
        name: "reverseName"
    }, {
        type: "string[]",
        name: "gateways"
    }],
    outputs: [{
        type: "string",
        name: "resolvedName"
    }, {
        type: "address",
        name: "resolvedAddress"
    }, {
        type: "address",
        name: "reverseResolver"
    }, {
        type: "address",
        name: "resolver"
    }]
}]
  , textResolverAbi = [{
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [{
        name: "name",
        type: "bytes32"
    }, {
        name: "key",
        type: "string"
    }],
    outputs: [{
        name: "",
        type: "string"
    }]
}];
class NegativeOffsetError extends BaseError$2 {
    constructor({offset: et}) {
        super(`Offset \`${et}\` cannot be negative.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NegativeOffsetError"
        })
    }
}
class PositionOutOfBoundsError extends BaseError$2 {
    constructor({length: et, position: tt}) {
        super(`Position \`${tt}\` is out of bounds (\`0 < position < ${et}\`).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PositionOutOfBoundsError"
        })
    }
}
class RecursiveReadLimitExceededError extends BaseError$2 {
    constructor({count: et, limit: tt}) {
        super(`Recursive read limit of \`${tt}\` exceeded (recursive read count: \`${et}\`).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RecursiveReadLimitExceededError"
        })
    }
}
const staticCursor = {
    bytes: new Uint8Array,
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map,
    recursiveReadCount: 0,
    recursiveReadLimit: 1 / 0,
    assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new RecursiveReadLimitExceededError({
                count: this.recursiveReadCount + 1,
                limit: this.recursiveReadLimit
            })
    },
    assertPosition(_e) {
        if (_e < 0 || _e > this.bytes.length - 1)
            throw new PositionOutOfBoundsError({
                length: this.bytes.length,
                position: _e
            })
    },
    decrementPosition(_e) {
        if (_e < 0)
            throw new NegativeOffsetError({
                offset: _e
            });
        const et = this.position - _e;
        this.assertPosition(et),
        this.position = et
    },
    getReadCount(_e) {
        return this.positionReadCount.get(_e || this.position) || 0
    },
    incrementPosition(_e) {
        if (_e < 0)
            throw new NegativeOffsetError({
                offset: _e
            });
        const et = this.position + _e;
        this.assertPosition(et),
        this.position = et
    },
    inspectByte(_e) {
        const et = _e ?? this.position;
        return this.assertPosition(et),
        this.bytes[et]
    },
    inspectBytes(_e, et) {
        const tt = et ?? this.position;
        return this.assertPosition(tt + _e - 1),
        this.bytes.subarray(tt, tt + _e)
    },
    inspectUint8(_e) {
        const et = _e ?? this.position;
        return this.assertPosition(et),
        this.bytes[et]
    },
    inspectUint16(_e) {
        const et = _e ?? this.position;
        return this.assertPosition(et + 1),
        this.dataView.getUint16(et)
    },
    inspectUint24(_e) {
        const et = _e ?? this.position;
        return this.assertPosition(et + 2),
        (this.dataView.getUint16(et) << 8) + this.dataView.getUint8(et + 2)
    },
    inspectUint32(_e) {
        const et = _e ?? this.position;
        return this.assertPosition(et + 3),
        this.dataView.getUint32(et)
    },
    pushByte(_e) {
        this.assertPosition(this.position),
        this.bytes[this.position] = _e,
        this.position++
    },
    pushBytes(_e) {
        this.assertPosition(this.position + _e.length - 1),
        this.bytes.set(_e, this.position),
        this.position += _e.length
    },
    pushUint8(_e) {
        this.assertPosition(this.position),
        this.bytes[this.position] = _e,
        this.position++
    },
    pushUint16(_e) {
        this.assertPosition(this.position + 1),
        this.dataView.setUint16(this.position, _e),
        this.position += 2
    },
    pushUint24(_e) {
        this.assertPosition(this.position + 2),
        this.dataView.setUint16(this.position, _e >> 8),
        this.dataView.setUint8(this.position + 2, _e & 255),
        this.position += 3
    },
    pushUint32(_e) {
        this.assertPosition(this.position + 3),
        this.dataView.setUint32(this.position, _e),
        this.position += 4
    },
    readByte() {
        this.assertReadLimit(),
        this._touch();
        const _e = this.inspectByte();
        return this.position++,
        _e
    },
    readBytes(_e, et) {
        this.assertReadLimit(),
        this._touch();
        const tt = this.inspectBytes(_e);
        return this.position += et ?? _e,
        tt
    },
    readUint8() {
        this.assertReadLimit(),
        this._touch();
        const _e = this.inspectUint8();
        return this.position += 1,
        _e
    },
    readUint16() {
        this.assertReadLimit(),
        this._touch();
        const _e = this.inspectUint16();
        return this.position += 2,
        _e
    },
    readUint24() {
        this.assertReadLimit(),
        this._touch();
        const _e = this.inspectUint24();
        return this.position += 3,
        _e
    },
    readUint32() {
        this.assertReadLimit(),
        this._touch();
        const _e = this.inspectUint32();
        return this.position += 4,
        _e
    },
    setPosition(_e) {
        const et = this.position;
        return this.assertPosition(_e),
        this.position = _e,
        ()=>this.position = et
    },
    _touch() {
        if (this.recursiveReadLimit === 1 / 0)
            return;
        const _e = this.getReadCount();
        this.positionReadCount.set(this.position, _e + 1),
        _e > 0 && this.recursiveReadCount++
    }
};
function createCursor(_e, {recursiveReadLimit: et=8192}={}) {
    const tt = Object.create(staticCursor);
    return tt.bytes = _e,
    tt.dataView = new DataView(_e.buffer,_e.byteOffset,_e.byteLength),
    tt.positionReadCount = new Map,
    tt.recursiveReadLimit = et,
    tt
}
function bytesToBigInt(_e, et={}) {
    typeof et.size < "u" && assertSize(_e, {
        size: et.size
    });
    const tt = bytesToHex(_e, et);
    return hexToBigInt(tt, et)
}
function bytesToBool(_e, et={}) {
    let tt = _e;
    if (typeof et.size < "u" && (assertSize(tt, {
        size: et.size
    }),
    tt = trim(tt)),
    tt.length > 1 || tt[0] > 1)
        throw new InvalidBytesBooleanError(tt);
    return !!tt[0]
}
function bytesToNumber(_e, et={}) {
    typeof et.size < "u" && assertSize(_e, {
        size: et.size
    });
    const tt = bytesToHex(_e, et);
    return hexToNumber(tt, et)
}
function bytesToString(_e, et={}) {
    let tt = _e;
    return typeof et.size < "u" && (assertSize(tt, {
        size: et.size
    }),
    tt = trim(tt, {
        dir: "right"
    })),
    new TextDecoder().decode(tt)
}
function decodeAbiParameters(_e, et) {
    const tt = typeof et == "string" ? hexToBytes(et) : et
      , rt = createCursor(tt);
    if (size$2(tt) === 0 && _e.length > 0)
        throw new AbiDecodingZeroDataError;
    if (size$2(et) && size$2(et) < 32)
        throw new AbiDecodingDataSizeTooSmallError({
            data: typeof et == "string" ? et : bytesToHex(et),
            params: _e,
            size: size$2(et)
        });
    let nt = 0;
    const it = [];
    for (let st = 0; st < _e.length; ++st) {
        const at = _e[st];
        rt.setPosition(nt);
        const [ot,lt] = decodeParameter(rt, at, {
            staticPosition: 0
        });
        nt += lt,
        it.push(ot)
    }
    return it
}
function decodeParameter(_e, et, {staticPosition: tt}) {
    const rt = getArrayComponents(et.type);
    if (rt) {
        const [nt,it] = rt;
        return decodeArray(_e, {
            ...et,
            type: it
        }, {
            length: nt,
            staticPosition: tt
        })
    }
    if (et.type === "tuple")
        return decodeTuple(_e, et, {
            staticPosition: tt
        });
    if (et.type === "address")
        return decodeAddress(_e);
    if (et.type === "bool")
        return decodeBool(_e);
    if (et.type.startsWith("bytes"))
        return decodeBytes(_e, et, {
            staticPosition: tt
        });
    if (et.type.startsWith("uint") || et.type.startsWith("int"))
        return decodeNumber(_e, et);
    if (et.type === "string")
        return decodeString(_e, {
            staticPosition: tt
        });
    throw new InvalidAbiDecodingTypeError(et.type,{
        docsPath: "/docs/contract/decodeAbiParameters"
    })
}
const sizeOfLength = 32
  , sizeOfOffset = 32;
function decodeAddress(_e) {
    const et = _e.readBytes(32);
    return [checksumAddress(bytesToHex(sliceBytes(et, -20))), 32]
}
function decodeArray(_e, et, {length: tt, staticPosition: rt}) {
    if (!tt) {
        const st = bytesToNumber(_e.readBytes(sizeOfOffset))
          , at = rt + st
          , ot = at + sizeOfLength;
        _e.setPosition(at);
        const lt = bytesToNumber(_e.readBytes(sizeOfLength))
          , dt = hasDynamicChild(et);
        let ct = 0;
        const ut = [];
        for (let ft = 0; ft < lt; ++ft) {
            _e.setPosition(ot + (dt ? ft * 32 : ct));
            const [ht,gt] = decodeParameter(_e, et, {
                staticPosition: ot
            });
            ct += gt,
            ut.push(ht)
        }
        return _e.setPosition(rt + 32),
        [ut, 32]
    }
    if (hasDynamicChild(et)) {
        const st = bytesToNumber(_e.readBytes(sizeOfOffset))
          , at = rt + st
          , ot = [];
        for (let lt = 0; lt < tt; ++lt) {
            _e.setPosition(at + lt * 32);
            const [dt] = decodeParameter(_e, et, {
                staticPosition: at
            });
            ot.push(dt)
        }
        return _e.setPosition(rt + 32),
        [ot, 32]
    }
    let nt = 0;
    const it = [];
    for (let st = 0; st < tt; ++st) {
        const [at,ot] = decodeParameter(_e, et, {
            staticPosition: rt + nt
        });
        nt += ot,
        it.push(at)
    }
    return [it, nt]
}
function decodeBool(_e) {
    return [bytesToBool(_e.readBytes(32), {
        size: 32
    }), 32]
}
function decodeBytes(_e, et, {staticPosition: tt}) {
    const [rt,nt] = et.type.split("bytes");
    if (!nt) {
        const st = bytesToNumber(_e.readBytes(32));
        _e.setPosition(tt + st);
        const at = bytesToNumber(_e.readBytes(32));
        if (at === 0)
            return _e.setPosition(tt + 32),
            ["0x", 32];
        const ot = _e.readBytes(at);
        return _e.setPosition(tt + 32),
        [bytesToHex(ot), 32]
    }
    return [bytesToHex(_e.readBytes(parseInt(nt), 32)), 32]
}
function decodeNumber(_e, et) {
    const tt = et.type.startsWith("int")
      , rt = parseInt(et.type.split("int")[1] || "256")
      , nt = _e.readBytes(32);
    return [rt > 48 ? bytesToBigInt(nt, {
        signed: tt
    }) : bytesToNumber(nt, {
        signed: tt
    }), 32]
}
function decodeTuple(_e, et, {staticPosition: tt}) {
    const rt = et.components.length === 0 || et.components.some(({name: st})=>!st)
      , nt = rt ? [] : {};
    let it = 0;
    if (hasDynamicChild(et)) {
        const st = bytesToNumber(_e.readBytes(sizeOfOffset))
          , at = tt + st;
        for (let ot = 0; ot < et.components.length; ++ot) {
            const lt = et.components[ot];
            _e.setPosition(at + it);
            const [dt,ct] = decodeParameter(_e, lt, {
                staticPosition: at
            });
            it += ct,
            nt[rt ? ot : lt == null ? void 0 : lt.name] = dt
        }
        return _e.setPosition(tt + 32),
        [nt, 32]
    }
    for (let st = 0; st < et.components.length; ++st) {
        const at = et.components[st]
          , [ot,lt] = decodeParameter(_e, at, {
            staticPosition: tt
        });
        nt[rt ? st : at == null ? void 0 : at.name] = ot,
        it += lt
    }
    return [nt, it]
}
function decodeString(_e, {staticPosition: et}) {
    const tt = bytesToNumber(_e.readBytes(32))
      , rt = et + tt;
    _e.setPosition(rt);
    const nt = bytesToNumber(_e.readBytes(32));
    if (nt === 0)
        return _e.setPosition(et + 32),
        ["", 32];
    const it = _e.readBytes(nt, 32)
      , st = bytesToString(trim(it));
    return _e.setPosition(et + 32),
    [st, 32]
}
function hasDynamicChild(_e) {
    var rt;
    const {type: et} = _e;
    if (et === "string" || et === "bytes" || et.endsWith("[]"))
        return !0;
    if (et === "tuple")
        return (rt = _e.components) == null ? void 0 : rt.some(hasDynamicChild);
    const tt = getArrayComponents(_e.type);
    return !!(tt && hasDynamicChild({
        ..._e,
        type: tt[1]
    }))
}
function execTyped(_e, et) {
    const tt = _e.exec(et);
    return tt == null ? void 0 : tt.groups
}
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(_e) {
    let et = _e.type;
    if (tupleRegex.test(_e.type) && "components"in _e) {
        et = "(";
        const tt = _e.components.length;
        for (let nt = 0; nt < tt; nt++) {
            const it = _e.components[nt];
            et += formatAbiParameter(it),
            nt < tt - 1 && (et += ", ")
        }
        const rt = execTyped(tupleRegex, _e.type);
        return et += `)${(rt == null ? void 0 : rt.array) ?? ""}`,
        formatAbiParameter({
            ..._e,
            type: et
        })
    }
    return "indexed"in _e && _e.indexed && (et = `${et} indexed`),
    _e.name ? `${et} ${_e.name}` : et
}
function formatAbiParameters(_e) {
    let et = "";
    const tt = _e.length;
    for (let rt = 0; rt < tt; rt++) {
        const nt = _e[rt];
        et += formatAbiParameter(nt),
        rt !== tt - 1 && (et += ", ")
    }
    return et
}
function formatAbiItem(_e) {
    return _e.type === "function" ? `function ${_e.name}(${formatAbiParameters(_e.inputs)})${_e.stateMutability && _e.stateMutability !== "nonpayable" ? ` ${_e.stateMutability}` : ""}${_e.outputs.length ? ` returns (${formatAbiParameters(_e.outputs)})` : ""}` : _e.type === "event" ? `event ${_e.name}(${formatAbiParameters(_e.inputs)})` : _e.type === "error" ? `error ${_e.name}(${formatAbiParameters(_e.inputs)})` : _e.type === "constructor" ? `constructor(${formatAbiParameters(_e.inputs)})${_e.stateMutability === "payable" ? " payable" : ""}` : _e.type === "fallback" ? "fallback()" : "receive() external payable"
}
const hash = _e=>keccak256(toBytes$1(_e));
function hashSignature(_e) {
    return hash(_e)
}
function normalizeSignature(_e) {
    let et = !0
      , tt = ""
      , rt = 0
      , nt = ""
      , it = !1;
    for (let st = 0; st < _e.length; st++) {
        const at = _e[st];
        if (["(", ")", ","].includes(at) && (et = !0),
        at === "(" && rt++,
        at === ")" && rt--,
        !!et) {
            if (rt === 0) {
                if (at === " " && ["event", "function", ""].includes(nt))
                    nt = "";
                else if (nt += at,
                at === ")") {
                    it = !0;
                    break
                }
                continue
            }
            if (at === " ") {
                _e[st - 1] !== "," && tt !== "," && tt !== ",(" && (tt = "",
                et = !1);
                continue
            }
            nt += at,
            tt += at
        }
    }
    if (!it)
        throw new BaseError$2("Unable to normalize signature.");
    return nt
}
const toSignature = _e=>{
    const et = typeof _e == "string" ? _e : formatAbiItem(_e);
    return normalizeSignature(et)
}
;
function toSignatureHash(_e) {
    return hashSignature(toSignature(_e))
}
const toEventSelector = toSignatureHash
  , toFunctionSelector = _e=>slice(toSignatureHash(_e), 0, 4);
function getAbiItem(_e) {
    const {abi: et, args: tt=[], name: rt} = _e
      , nt = isHex(rt, {
        strict: !1
    })
      , it = et.filter(at=>nt ? at.type === "function" ? toFunctionSelector(at) === rt : at.type === "event" ? toEventSelector(at) === rt : !1 : "name"in at && at.name === rt);
    if (it.length === 0)
        return;
    if (it.length === 1)
        return it[0];
    let st;
    for (const at of it) {
        if (!("inputs"in at))
            continue;
        if (!tt || tt.length === 0) {
            if (!at.inputs || at.inputs.length === 0)
                return at;
            continue
        }
        if (!at.inputs || at.inputs.length === 0 || at.inputs.length !== tt.length)
            continue;
        if (tt.every((lt,dt)=>{
            const ct = "inputs"in at && at.inputs[dt];
            return ct ? isArgOfType(lt, ct) : !1
        }
        )) {
            if (st && "inputs"in st && st.inputs) {
                const lt = getAmbiguousTypes(at.inputs, st.inputs, tt);
                if (lt)
                    throw new AbiItemAmbiguityError({
                        abiItem: at,
                        type: lt[0]
                    },{
                        abiItem: st,
                        type: lt[1]
                    })
            }
            st = at
        }
    }
    return st || it[0]
}
function isArgOfType(_e, et) {
    const tt = typeof _e
      , rt = et.type;
    switch (rt) {
    case "address":
        return isAddress(_e, {
            strict: !1
        });
    case "bool":
        return tt === "boolean";
    case "function":
        return tt === "string";
    case "string":
        return tt === "string";
    default:
        return rt === "tuple" && "components"in et ? Object.values(et.components).every((nt,it)=>isArgOfType(Object.values(_e)[it], nt)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(rt) ? tt === "number" || tt === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(rt) ? tt === "string" || _e instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(rt) ? Array.isArray(_e) && _e.every(nt=>isArgOfType(nt, {
            ...et,
            type: rt.replace(/(\[[0-9]{0,}\])$/, "")
        })) : !1
    }
}
function getAmbiguousTypes(_e, et, tt) {
    for (const rt in _e) {
        const nt = _e[rt]
          , it = et[rt];
        if (nt.type === "tuple" && it.type === "tuple" && "components"in nt && "components"in it)
            return getAmbiguousTypes(nt.components, it.components, tt[rt]);
        const st = [nt.type, it.type];
        if (st.includes("address") && st.includes("bytes20") ? !0 : st.includes("address") && st.includes("string") ? isAddress(tt[rt], {
            strict: !1
        }) : st.includes("address") && st.includes("bytes") ? isAddress(tt[rt], {
            strict: !1
        }) : !1)
            return st
    }
}
const docsPath$1 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(_e) {
    const {abi: et, args: tt, functionName: rt, data: nt} = _e;
    let it = et[0];
    if (rt) {
        const at = getAbiItem({
            abi: et,
            args: tt,
            name: rt
        });
        if (!at)
            throw new AbiFunctionNotFoundError(rt,{
                docsPath: docsPath$1
            });
        it = at
    }
    if (it.type !== "function")
        throw new AbiFunctionNotFoundError(void 0,{
            docsPath: docsPath$1
        });
    if (!it.outputs)
        throw new AbiFunctionOutputsNotFoundError(it.name,{
            docsPath: docsPath$1
        });
    const st = decodeAbiParameters(it.outputs, nt);
    if (st && st.length > 1)
        return st;
    if (st && st.length === 1)
        return st[0]
}
const docsPath = "/docs/contract/encodeFunctionData";
function encodeFunctionData(_e) {
    const {abi: et, args: tt, functionName: rt} = _e;
    let nt = et[0];
    if (rt) {
        const ot = getAbiItem({
            abi: et,
            args: tt,
            name: rt
        });
        if (!ot)
            throw new AbiFunctionNotFoundError(rt,{
                docsPath
            });
        nt = ot
    }
    if (nt.type !== "function")
        throw new AbiFunctionNotFoundError(void 0,{
            docsPath
        });
    const it = formatAbiItem$1(nt)
      , st = toFunctionSelector(it)
      , at = "inputs"in nt && nt.inputs ? encodeAbiParameters(nt.inputs, tt ?? []) : void 0;
    return concatHex([st, at ?? "0x"])
}
function getChainContractAddress({blockNumber: _e, chain: et, contract: tt}) {
    var nt;
    const rt = (nt = et == null ? void 0 : et.contracts) == null ? void 0 : nt[tt];
    if (!rt)
        throw new ChainDoesNotSupportContract({
            chain: et,
            contract: {
                name: tt
            }
        });
    if (_e && rt.blockCreated && rt.blockCreated > _e)
        throw new ChainDoesNotSupportContract({
            blockNumber: _e,
            chain: et,
            contract: {
                name: tt,
                blockCreated: rt.blockCreated
            }
        });
    return rt.address
}
const panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
}
  , solidityError = {
    inputs: [{
        name: "message",
        type: "string"
    }],
    name: "Error",
    type: "error"
}
  , solidityPanic = {
    inputs: [{
        name: "reason",
        type: "uint256"
    }],
    name: "Panic",
    type: "error"
};
function decodeErrorResult(_e) {
    const {abi: et, data: tt} = _e
      , rt = slice(tt, 0, 4);
    if (rt === "0x")
        throw new AbiDecodingZeroDataError;
    const it = [...et || [], solidityError, solidityPanic].find(st=>st.type === "error" && rt === toFunctionSelector(formatAbiItem$1(st)));
    if (!it)
        throw new AbiErrorSignatureNotFoundError(rt,{
            docsPath: "/docs/contract/decodeErrorResult"
        });
    return {
        abiItem: it,
        args: "inputs"in it && it.inputs && it.inputs.length > 0 ? decodeAbiParameters(it.inputs, slice(tt, 4)) : void 0,
        errorName: it.name
    }
}
function formatAbiItemWithArgs({abiItem: _e, args: et, includeFunctionName: tt=!0, includeName: rt=!1}) {
    if ("name"in _e && "inputs"in _e && _e.inputs)
        return `${tt ? _e.name : ""}(${_e.inputs.map((nt,it)=>`${rt && nt.name ? `${nt.name}: ` : ""}${typeof et[it] == "object" ? stringify(et[it]) : et[it]}`).join(", ")})`
}
class AccountStateConflictError extends BaseError$2 {
    constructor({address: et}) {
        super(`State for account "${et}" is set multiple times.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AccountStateConflictError"
        })
    }
}
class StateAssignmentConflictError extends BaseError$2 {
    constructor() {
        super("state and stateDiff are set on the same account."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "StateAssignmentConflictError"
        })
    }
}
function prettyStateMapping(_e) {
    return _e.reduce((et,{slot: tt, value: rt})=>`${et}        ${tt}: ${rt}
`, "")
}
function prettyStateOverride(_e) {
    return _e.reduce((et,{address: tt, ...rt})=>{
        let nt = `${et}    ${tt}:
`;
        return rt.nonce && (nt += `      nonce: ${rt.nonce}
`),
        rt.balance && (nt += `      balance: ${rt.balance}
`),
        rt.code && (nt += `      code: ${rt.code}
`),
        rt.state && (nt += `      state:
`,
        nt += prettyStateMapping(rt.state)),
        rt.stateDiff && (nt += `      stateDiff:
`,
        nt += prettyStateMapping(rt.stateDiff)),
        nt
    }
    , `  State Override:
`).slice(0, -1)
}
class CallExecutionError extends BaseError$2 {
    constructor(et, {account: tt, docsPath: rt, chain: nt, data: it, gas: st, gasPrice: at, maxFeePerGas: ot, maxPriorityFeePerGas: lt, nonce: dt, to: ct, value: ut, stateOverride: ft}) {
        var bt;
        const ht = tt ? parseAccount(tt) : void 0;
        let gt = prettyPrint({
            from: ht == null ? void 0 : ht.address,
            to: ct,
            value: typeof ut < "u" && `${formatEther(ut)} ${((bt = nt == null ? void 0 : nt.nativeCurrency) == null ? void 0 : bt.symbol) || "ETH"}`,
            data: it,
            gas: st,
            gasPrice: typeof at < "u" && `${formatGwei(at)} gwei`,
            maxFeePerGas: typeof ot < "u" && `${formatGwei(ot)} gwei`,
            maxPriorityFeePerGas: typeof lt < "u" && `${formatGwei(lt)} gwei`,
            nonce: dt
        });
        ft && (gt += `
${prettyStateOverride(ft)}`),
        super(et.shortMessage, {
            cause: et,
            docsPath: rt,
            metaMessages: [...et.metaMessages ? [...et.metaMessages, " "] : [], "Raw Call Arguments:", gt].filter(Boolean)
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "CallExecutionError"
        }),
        this.cause = et
    }
}
class ContractFunctionExecutionError extends BaseError$2 {
    constructor(et, {abi: tt, args: rt, contractAddress: nt, docsPath: it, functionName: st, sender: at}) {
        const ot = getAbiItem({
            abi: tt,
            args: rt,
            name: st
        })
          , lt = ot ? formatAbiItemWithArgs({
            abiItem: ot,
            args: rt,
            includeFunctionName: !1,
            includeName: !1
        }) : void 0
          , dt = ot ? formatAbiItem$1(ot, {
            includeName: !0
        }) : void 0
          , ct = prettyPrint({
            address: nt && getContractAddress(nt),
            function: dt,
            args: lt && lt !== "()" && `${[...Array((st == null ? void 0 : st.length) ?? 0).keys()].map(()=>" ").join("")}${lt}`,
            sender: at
        });
        super(et.shortMessage || `An unknown error occurred while executing the contract function "${st}".`, {
            cause: et,
            docsPath: it,
            metaMessages: [...et.metaMessages ? [...et.metaMessages, " "] : [], "Contract Call:", ct].filter(Boolean)
        }),
        Object.defineProperty(this, "abi", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "args", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "contractAddress", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "formattedArgs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "functionName", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "sender", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionExecutionError"
        }),
        this.abi = tt,
        this.args = rt,
        this.cause = et,
        this.contractAddress = nt,
        this.functionName = st,
        this.sender = at
    }
}
class ContractFunctionRevertedError extends BaseError$2 {
    constructor({abi: et, data: tt, functionName: rt, message: nt}) {
        let it, st, at, ot;
        if (tt && tt !== "0x")
            try {
                st = decodeErrorResult({
                    abi: et,
                    data: tt
                });
                const {abiItem: dt, errorName: ct, args: ut} = st;
                if (ct === "Error")
                    ot = ut[0];
                else if (ct === "Panic") {
                    const [ft] = ut;
                    ot = panicReasons[ft]
                } else {
                    const ft = dt ? formatAbiItem$1(dt, {
                        includeName: !0
                    }) : void 0
                      , ht = dt && ut ? formatAbiItemWithArgs({
                        abiItem: dt,
                        args: ut,
                        includeFunctionName: !1,
                        includeName: !1
                    }) : void 0;
                    at = [ft ? `Error: ${ft}` : "", ht && ht !== "()" ? `       ${[...Array((ct == null ? void 0 : ct.length) ?? 0).keys()].map(()=>" ").join("")}${ht}` : ""]
                }
            } catch (dt) {
                it = dt
            }
        else
            nt && (ot = nt);
        let lt;
        it instanceof AbiErrorSignatureNotFoundError && (lt = it.signature,
        at = [`Unable to decode signature "${lt}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${lt}.`]),
        super(ot && ot !== "execution reverted" || lt ? [`The contract function "${rt}" reverted with the following ${lt ? "signature" : "reason"}:`, ot || lt].join(`
`) : `The contract function "${rt}" reverted.`, {
            cause: it,
            metaMessages: at
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionRevertedError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "reason", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = st,
        this.reason = ot,
        this.signature = lt
    }
}
class ContractFunctionZeroDataError extends BaseError$2 {
    constructor({functionName: et}) {
        super(`The contract function "${et}" returned no data ("0x").`, {
            metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${et}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionZeroDataError"
        })
    }
}
class RawContractError extends BaseError$2 {
    constructor({data: et, message: tt}) {
        super(tt || ""),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 3
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RawContractError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = et
    }
}
function isNullUniversalResolverError(_e, et) {
    var rt, nt, it, st, at, ot;
    if (!(_e instanceof BaseError$2))
        return !1;
    const tt = _e.walk(lt=>lt instanceof ContractFunctionRevertedError);
    return tt instanceof ContractFunctionRevertedError ? !!(((rt = tt.data) == null ? void 0 : rt.errorName) === "ResolverNotFound" || ((nt = tt.data) == null ? void 0 : nt.errorName) === "ResolverWildcardNotSupported" || ((it = tt.data) == null ? void 0 : it.errorName) === "ResolverNotContract" || ((st = tt.data) == null ? void 0 : st.errorName) === "ResolverError" || ((at = tt.data) == null ? void 0 : at.errorName) === "HttpError" || (ot = tt.reason) != null && ot.includes("Wildcard on non-extended resolvers is not supported") || et === "reverse" && tt.reason === panicReasons[50]) : !1
}
function encodedLabelToLabelhash(_e) {
    if (_e.length !== 66 || _e.indexOf("[") !== 0 || _e.indexOf("]") !== 65)
        return null;
    const et = `0x${_e.slice(1, 65)}`;
    return isHex(et) ? et : null
}
function namehash(_e) {
    let et = new Uint8Array(32).fill(0);
    if (!_e)
        return bytesToHex(et);
    const tt = _e.split(".");
    for (let rt = tt.length - 1; rt >= 0; rt -= 1) {
        const nt = encodedLabelToLabelhash(tt[rt])
          , it = nt ? toBytes$1(nt) : keccak256(stringToBytes(tt[rt]), "bytes");
        et = keccak256(concat([et, it]), "bytes")
    }
    return bytesToHex(et)
}
function encodeLabelhash(_e) {
    return `[${_e.slice(2)}]`
}
function labelhash(_e) {
    const et = new Uint8Array(32).fill(0);
    return _e ? encodedLabelToLabelhash(_e) || keccak256(stringToBytes(_e)) : bytesToHex(et)
}
function packetToBytes(_e) {
    const et = _e.replace(/^\.|\.$/gm, "");
    if (et.length === 0)
        return new Uint8Array(1);
    const tt = new Uint8Array(stringToBytes(et).byteLength + 2);
    let rt = 0;
    const nt = et.split(".");
    for (let it = 0; it < nt.length; it++) {
        let st = stringToBytes(nt[it]);
        st.byteLength > 255 && (st = stringToBytes(encodeLabelhash(labelhash(nt[it])))),
        tt[rt] = st.length,
        tt.set(st, rt + 1),
        rt += st.length + 1
    }
    return tt.byteLength !== rt + 1 ? tt.slice(0, rt + 1) : tt
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(_e, {abi: et, address: tt, args: rt, docsPath: nt, functionName: it, sender: st}) {
    const {code: at, data: ot, message: lt, shortMessage: dt} = _e instanceof RawContractError ? _e : _e instanceof BaseError$2 ? _e.walk(ut=>"data"in ut) || _e.walk() : {}
      , ct = _e instanceof AbiDecodingZeroDataError ? new ContractFunctionZeroDataError({
        functionName: it
    }) : [EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(at) && (ot || lt || dt) ? new ContractFunctionRevertedError({
        abi: et,
        data: typeof ot == "object" ? ot.data : ot,
        functionName: it,
        message: dt ?? lt
    }) : _e;
    return new ContractFunctionExecutionError(ct,{
        abi: et,
        args: rt,
        contractAddress: tt,
        docsPath: nt,
        functionName: it,
        sender: st
    })
}
const aggregate3Signature = "0x82ad56cb";
function getCallError(_e, {docsPath: et, ...tt}) {
    const rt = (()=>{
        const nt = getNodeError(_e, tt);
        return nt instanceof UnknownNodeError ? _e : nt
    }
    )();
    return new CallExecutionError(rt,{
        docsPath: et,
        ...tt
    })
}
const schedulerCache = new Map;
function createBatchScheduler({fn: _e, id: et, shouldSplitBatch: tt, wait: rt=0, sort: nt}) {
    const it = async()=>{
        const dt = ot();
        st();
        const ct = dt.map(({args: ut})=>ut);
        ct.length !== 0 && _e(ct).then(ut=>{
            var ft;
            nt && Array.isArray(ut) && ut.sort(nt);
            for (let ht = 0; ht < dt.length; ht++) {
                const {pendingPromise: gt} = dt[ht];
                (ft = gt.resolve) == null || ft.call(gt, [ut[ht], ut])
            }
        }
        ).catch(ut=>{
            var ft;
            for (let ht = 0; ht < dt.length; ht++) {
                const {pendingPromise: gt} = dt[ht];
                (ft = gt.reject) == null || ft.call(gt, ut)
            }
        }
        )
    }
      , st = ()=>schedulerCache.delete(et)
      , at = ()=>ot().map(({args: dt})=>dt)
      , ot = ()=>schedulerCache.get(et) || []
      , lt = dt=>schedulerCache.set(et, [...ot(), dt]);
    return {
        flush: st,
        async schedule(dt) {
            const ct = {}
              , ut = new Promise((gt,bt)=>{
                ct.resolve = gt,
                ct.reject = bt
            }
            );
            return (tt == null ? void 0 : tt([...at(), dt])) && it(),
            ot().length > 0 ? (lt({
                args: dt,
                pendingPromise: ct
            }),
            ut) : (lt({
                args: dt,
                pendingPromise: ct
            }),
            setTimeout(it, rt),
            ut)
        }
    }
}
async function call(_e, et) {
    var mt, yt, vt, wt;
    const {account: tt=_e.account, batch: rt=!!((mt = _e.batch) != null && mt.multicall), blockNumber: nt, blockTag: it="latest", accessList: st, data: at, gas: ot, gasPrice: lt, maxFeePerGas: dt, maxPriorityFeePerGas: ct, nonce: ut, to: ft, value: ht, stateOverride: gt, ...bt} = et
      , pt = tt ? parseAccount(tt) : void 0;
    try {
        assertRequest(et);
        const Et = (nt ? numberToHex(nt) : void 0) || it
          , xt = parseStateOverride(gt)
          , Ct = (wt = (vt = (yt = _e.chain) == null ? void 0 : yt.formatters) == null ? void 0 : vt.transactionRequest) == null ? void 0 : wt.format
          , It = (Ct || formatTransactionRequest)({
            ...extract(bt, {
                format: Ct
            }),
            from: pt == null ? void 0 : pt.address,
            accessList: st,
            data: at,
            gas: ot,
            gasPrice: lt,
            maxFeePerGas: dt,
            maxPriorityFeePerGas: ct,
            nonce: ut,
            to: ft,
            value: ht
        });
        if (rt && shouldPerformMulticall({
            request: It
        }) && !xt)
            try {
                return await scheduleMulticall(_e, {
                    ...It,
                    blockNumber: nt,
                    blockTag: it
                })
            } catch (Ft) {
                if (!(Ft instanceof ClientChainNotConfiguredError) && !(Ft instanceof ChainDoesNotSupportContract))
                    throw Ft
            }
        const Nt = await _e.request({
            method: "eth_call",
            params: xt ? [It, Et, xt] : [It, Et]
        });
        return Nt === "0x" ? {
            data: void 0
        } : {
            data: Nt
        }
    } catch (_t) {
        const Et = getRevertErrorData(_t)
          , {offchainLookup: xt, offchainLookupSignature: Ct} = await __vitePreload(()=>import("./ccip-C4JZVwH4.js"), __vite__mapDeps([]));
        if ((Et == null ? void 0 : Et.slice(0, 10)) === Ct && ft)
            return {
                data: await xt(_e, {
                    data: Et,
                    to: ft
                })
            };
        throw getCallError(_t, {
            ...et,
            account: pt,
            chain: _e.chain
        })
    }
}
function shouldPerformMulticall({request: _e}) {
    const {data: et, to: tt, ...rt} = _e;
    return !(!et || et.startsWith(aggregate3Signature) || !tt || Object.values(rt).filter(nt=>typeof nt < "u").length > 0)
}
async function scheduleMulticall(_e, et) {
    var gt;
    const {batchSize: tt=1024, wait: rt=0} = typeof ((gt = _e.batch) == null ? void 0 : gt.multicall) == "object" ? _e.batch.multicall : {}
      , {blockNumber: nt, blockTag: it="latest", data: st, multicallAddress: at, to: ot} = et;
    let lt = at;
    if (!lt) {
        if (!_e.chain)
            throw new ClientChainNotConfiguredError;
        lt = getChainContractAddress({
            blockNumber: nt,
            chain: _e.chain,
            contract: "multicall3"
        })
    }
    const ct = (nt ? numberToHex(nt) : void 0) || it
      , {schedule: ut} = createBatchScheduler({
        id: `${_e.uid}.${ct}`,
        wait: rt,
        shouldSplitBatch(bt) {
            return bt.reduce((mt,{data: yt})=>mt + (yt.length - 2), 0) > tt * 2
        },
        fn: async bt=>{
            const pt = bt.map(vt=>({
                allowFailure: !0,
                callData: vt.data,
                target: vt.to
            }))
              , mt = encodeFunctionData({
                abi: multicall3Abi,
                args: [pt],
                functionName: "aggregate3"
            })
              , yt = await _e.request({
                method: "eth_call",
                params: [{
                    data: mt,
                    to: lt
                }, ct]
            });
            return decodeFunctionResult({
                abi: multicall3Abi,
                args: [pt],
                functionName: "aggregate3",
                data: yt || "0x"
            })
        }
    })
      , [{returnData: ft, success: ht}] = await ut({
        data: st,
        to: ot
    });
    if (!ht)
        throw new RawContractError({
            data: ft
        });
    return ft === "0x" ? {
        data: void 0
    } : {
        data: ft
    }
}
function getRevertErrorData(_e) {
    if (!(_e instanceof BaseError$2))
        return;
    const et = _e.walk();
    return typeof et.data == "object" ? et.data.data : et.data
}
function parseStateMapping(_e) {
    if (!(!_e || _e.length === 0))
        return _e.reduce((et,{slot: tt, value: rt})=>{
            if (tt.length !== 66)
                throw new InvalidBytesLengthError({
                    size: tt.length,
                    targetSize: 66,
                    type: "hex"
                });
            if (rt.length !== 66)
                throw new InvalidBytesLengthError({
                    size: rt.length,
                    targetSize: 66,
                    type: "hex"
                });
            return et[tt] = rt,
            et
        }
        , {})
}
function parseAccountStateOverride(_e) {
    const {balance: et, nonce: tt, state: rt, stateDiff: nt, code: it} = _e
      , st = {};
    if (it !== void 0 && (st.code = it),
    et !== void 0 && (st.balance = numberToHex(et, {
        size: 32
    })),
    tt !== void 0 && (st.nonce = numberToHex(tt, {
        size: 8
    })),
    rt !== void 0 && (st.state = parseStateMapping(rt)),
    nt !== void 0) {
        if (st.state)
            throw new StateAssignmentConflictError;
        st.stateDiff = parseStateMapping(nt)
    }
    return st
}
function parseStateOverride(_e) {
    if (!_e)
        return;
    const et = {};
    for (const {address: tt, ...rt} of _e) {
        if (!isAddress(tt, {
            strict: !1
        }))
            throw new InvalidAddressError({
                address: tt
            });
        if (et[tt])
            throw new AccountStateConflictError({
                address: tt
            });
        et[tt] = parseAccountStateOverride(rt)
    }
    return et
}
async function readContract$1(_e, et) {
    const {abi: tt, address: rt, args: nt, functionName: it, ...st} = et
      , at = encodeFunctionData({
        abi: tt,
        args: nt,
        functionName: it
    });
    try {
        const {data: ot} = await getAction$1(_e, call, "call")({
            ...st,
            data: at,
            to: rt
        });
        return decodeFunctionResult({
            abi: tt,
            args: nt,
            functionName: it,
            data: ot || "0x"
        })
    } catch (ot) {
        throw getContractError(ot, {
            abi: tt,
            address: rt,
            args: nt,
            docsPath: "/docs/contract/readContract",
            functionName: it
        })
    }
}
class EnsAvatarInvalidMetadataError extends BaseError$2 {
    constructor({data: et}) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
            metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(et)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarInvalidMetadataError"
        })
    }
}
class EnsAvatarInvalidNftUriError extends BaseError$2 {
    constructor({reason: et}) {
        super(`ENS NFT avatar URI is invalid. ${et}`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarInvalidNftUriError"
        })
    }
}
class EnsAvatarUriResolutionError extends BaseError$2 {
    constructor({uri: et}) {
        super(`Unable to resolve ENS avatar URI "${et}". The URI may be malformed, invalid, or does not respond with a valid image.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarUriResolutionError"
        })
    }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError$2 {
    constructor({namespace: et}) {
        super(`ENS NFT avatar namespace "${et}" is not supported. Must be "erc721" or "erc1155".`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarUnsupportedNamespaceError"
        })
    }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/
  , ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/
  , base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/
  , dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(_e) {
    try {
        const et = await fetch(_e, {
            method: "HEAD"
        });
        if (et.status === 200) {
            const tt = et.headers.get("content-type");
            return tt == null ? void 0 : tt.startsWith("image/")
        }
        return !1
    } catch (et) {
        return typeof et == "object" && typeof et.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise(tt=>{
            const rt = new Image;
            rt.onload = ()=>{
                tt(!0)
            }
            ,
            rt.onerror = ()=>{
                tt(!1)
            }
            ,
            rt.src = _e
        }
        )
    }
}
function getGateway(_e, et) {
    return _e ? _e.endsWith("/") ? _e.slice(0, -1) : _e : et
}
function resolveAvatarUri({uri: _e, gatewayUrls: et}) {
    const tt = base64Regex.test(_e);
    if (tt)
        return {
            uri: _e,
            isOnChain: !0,
            isEncoded: tt
        };
    const rt = getGateway(et == null ? void 0 : et.ipfs, "https://ipfs.io")
      , nt = getGateway(et == null ? void 0 : et.arweave, "https://arweave.net")
      , it = _e.match(networkRegex)
      , {protocol: st, subpath: at, target: ot, subtarget: lt=""} = (it == null ? void 0 : it.groups) || {}
      , dt = st === "ipns:/" || at === "ipns/"
      , ct = st === "ipfs:/" || at === "ipfs/" || ipfsHashRegex.test(_e);
    if (_e.startsWith("http") && !dt && !ct) {
        let ft = _e;
        return et != null && et.arweave && (ft = _e.replace(/https:\/\/arweave.net/g, et == null ? void 0 : et.arweave)),
        {
            uri: ft,
            isOnChain: !1,
            isEncoded: !1
        }
    }
    if ((dt || ct) && ot)
        return {
            uri: `${rt}/${dt ? "ipns" : "ipfs"}/${ot}${lt}`,
            isOnChain: !1,
            isEncoded: !1
        };
    if (st === "ar:/" && ot)
        return {
            uri: `${nt}/${ot}${lt || ""}`,
            isOnChain: !1,
            isEncoded: !1
        };
    let ut = _e.replace(dataURIRegex, "");
    if (ut.startsWith("<svg") && (ut = `data:image/svg+xml;base64,${btoa(ut)}`),
    ut.startsWith("data:") || ut.startsWith("{"))
        return {
            uri: ut,
            isOnChain: !0,
            isEncoded: !1
        };
    throw new EnsAvatarUriResolutionError({
        uri: _e
    })
}
function getJsonImage(_e) {
    if (typeof _e != "object" || !("image"in _e) && !("image_url"in _e) && !("image_data"in _e))
        throw new EnsAvatarInvalidMetadataError({
            data: _e
        });
    return _e.image || _e.image_url || _e.image_data
}
async function getMetadataAvatarUri({gatewayUrls: _e, uri: et}) {
    try {
        const tt = await fetch(et).then(nt=>nt.json());
        return await parseAvatarUri({
            gatewayUrls: _e,
            uri: getJsonImage(tt)
        })
    } catch {
        throw new EnsAvatarUriResolutionError({
            uri: et
        })
    }
}
async function parseAvatarUri({gatewayUrls: _e, uri: et}) {
    const {uri: tt, isOnChain: rt} = resolveAvatarUri({
        uri: et,
        gatewayUrls: _e
    });
    if (rt || await isImageUri(tt))
        return tt;
    throw new EnsAvatarUriResolutionError({
        uri: et
    })
}
function parseNftUri(_e) {
    let et = _e;
    et.startsWith("did:nft:") && (et = et.replace("did:nft:", "").replace(/_/g, "/"));
    const [tt,rt,nt] = et.split("/")
      , [it,st] = tt.split(":")
      , [at,ot] = rt.split(":");
    if (!it || it.toLowerCase() !== "eip155")
        throw new EnsAvatarInvalidNftUriError({
            reason: "Only EIP-155 supported"
        });
    if (!st)
        throw new EnsAvatarInvalidNftUriError({
            reason: "Chain ID not found"
        });
    if (!ot)
        throw new EnsAvatarInvalidNftUriError({
            reason: "Contract address not found"
        });
    if (!nt)
        throw new EnsAvatarInvalidNftUriError({
            reason: "Token ID not found"
        });
    if (!at)
        throw new EnsAvatarInvalidNftUriError({
            reason: "ERC namespace not found"
        });
    return {
        chainID: parseInt(st),
        namespace: at.toLowerCase(),
        contractAddress: ot,
        tokenID: nt
    }
}
async function getNftTokenUri(_e, {nft: et}) {
    if (et.namespace === "erc721")
        return readContract$1(_e, {
            address: et.contractAddress,
            abi: [{
                name: "tokenURI",
                type: "function",
                stateMutability: "view",
                inputs: [{
                    name: "tokenId",
                    type: "uint256"
                }],
                outputs: [{
                    name: "",
                    type: "string"
                }]
            }],
            functionName: "tokenURI",
            args: [BigInt(et.tokenID)]
        });
    if (et.namespace === "erc1155")
        return readContract$1(_e, {
            address: et.contractAddress,
            abi: [{
                name: "uri",
                type: "function",
                stateMutability: "view",
                inputs: [{
                    name: "_id",
                    type: "uint256"
                }],
                outputs: [{
                    name: "",
                    type: "string"
                }]
            }],
            functionName: "uri",
            args: [BigInt(et.tokenID)]
        });
    throw new EnsAvatarUnsupportedNamespaceError({
        namespace: et.namespace
    })
}
async function parseAvatarRecord(_e, {gatewayUrls: et, record: tt}) {
    return /eip155:/i.test(tt) ? parseNftAvatarUri(_e, {
        gatewayUrls: et,
        record: tt
    }) : parseAvatarUri({
        uri: tt,
        gatewayUrls: et
    })
}
async function parseNftAvatarUri(_e, {gatewayUrls: et, record: tt}) {
    const rt = parseNftUri(tt)
      , nt = await getNftTokenUri(_e, {
        nft: rt
    })
      , {uri: it, isOnChain: st, isEncoded: at} = resolveAvatarUri({
        uri: nt,
        gatewayUrls: et
    });
    if (st && (it.includes("data:application/json;base64,") || it.startsWith("{"))) {
        const lt = at ? atob(it.replace("data:application/json;base64,", "")) : it
          , dt = JSON.parse(lt);
        return parseAvatarUri({
            uri: getJsonImage(dt),
            gatewayUrls: et
        })
    }
    let ot = rt.tokenID;
    return rt.namespace === "erc1155" && (ot = ot.replace("0x", "").padStart(64, "0")),
    getMetadataAvatarUri({
        gatewayUrls: et,
        uri: it.replace(/(?:0x)?{id}/, ot)
    })
}
async function getEnsText(_e, {blockNumber: et, blockTag: tt, name: rt, key: nt, gatewayUrls: it, strict: st, universalResolverAddress: at}) {
    let ot = at;
    if (!ot) {
        if (!_e.chain)
            throw new Error("client chain not configured. universalResolverAddress is required.");
        ot = getChainContractAddress({
            blockNumber: et,
            chain: _e.chain,
            contract: "ensUniversalResolver"
        })
    }
    try {
        const lt = {
            address: ot,
            abi: universalResolverResolveAbi,
            functionName: "resolve",
            args: [toHex(packetToBytes(rt)), encodeFunctionData({
                abi: textResolverAbi,
                functionName: "text",
                args: [namehash(rt), nt]
            })],
            blockNumber: et,
            blockTag: tt
        }
          , dt = getAction$1(_e, readContract$1, "readContract")
          , ct = it ? await dt({
            ...lt,
            args: [...lt.args, it]
        }) : await dt(lt);
        if (ct[0] === "0x")
            return null;
        const ut = decodeFunctionResult({
            abi: textResolverAbi,
            functionName: "text",
            data: ct[0]
        });
        return ut === "" ? null : ut
    } catch (lt) {
        if (st)
            throw lt;
        if (isNullUniversalResolverError(lt, "resolve"))
            return null;
        throw lt
    }
}
async function getEnsAvatar$1(_e, {blockNumber: et, blockTag: tt, assetGatewayUrls: rt, name: nt, gatewayUrls: it, strict: st, universalResolverAddress: at}) {
    const ot = await getAction$1(_e, getEnsText, "getEnsText")({
        blockNumber: et,
        blockTag: tt,
        key: "avatar",
        name: nt,
        universalResolverAddress: at,
        gatewayUrls: it,
        strict: st
    });
    if (!ot)
        return null;
    try {
        return await parseAvatarRecord(_e, {
            record: ot,
            gatewayUrls: rt
        })
    } catch {
        return null
    }
}
async function getEnsName$1(_e, {address: et, blockNumber: tt, blockTag: rt, gatewayUrls: nt, strict: it, universalResolverAddress: st}) {
    let at = st;
    if (!at) {
        if (!_e.chain)
            throw new Error("client chain not configured. universalResolverAddress is required.");
        at = getChainContractAddress({
            blockNumber: tt,
            chain: _e.chain,
            contract: "ensUniversalResolver"
        })
    }
    const ot = `${et.toLowerCase().substring(2)}.addr.reverse`;
    try {
        const lt = {
            address: at,
            abi: universalResolverReverseAbi,
            functionName: "reverse",
            args: [toHex(packetToBytes(ot))],
            blockNumber: tt,
            blockTag: rt
        }
          , dt = getAction$1(_e, readContract$1, "readContract")
          , [ct,ut] = nt ? await dt({
            ...lt,
            args: [...lt.args, nt]
        }) : await dt(lt);
        return et.toLowerCase() !== ut.toLowerCase() ? null : ct
    } catch (lt) {
        if (it)
            throw lt;
        if (isNullUniversalResolverError(lt, "reverse"))
            return null;
        throw lt
    }
}
async function getBalance$1(_e, {address: et, blockNumber: tt, blockTag: rt="latest"}) {
    const nt = tt ? numberToHex(tt) : void 0
      , it = await _e.request({
        method: "eth_getBalance",
        params: [et, nt || rt]
    });
    return BigInt(it)
}
const promiseCache = new Map
  , responseCache = new Map;
function getCache(_e) {
    const et = (nt,it)=>({
        clear: ()=>it.delete(nt),
        get: ()=>it.get(nt),
        set: st=>it.set(nt, st)
    })
      , tt = et(_e, promiseCache)
      , rt = et(_e, responseCache);
    return {
        clear: ()=>{
            tt.clear(),
            rt.clear()
        }
        ,
        promise: tt,
        response: rt
    }
}
async function withCache(_e, {cacheKey: et, cacheTime: tt=1 / 0}) {
    const rt = getCache(et)
      , nt = rt.response.get();
    if (nt && tt > 0 && new Date().getTime() - nt.created.getTime() < tt)
        return nt.data;
    let it = rt.promise.get();
    it || (it = _e(),
    rt.promise.set(it));
    try {
        const st = await it;
        return rt.response.set({
            created: new Date,
            data: st
        }),
        st
    } finally {
        rt.promise.clear()
    }
}
const cacheKey = _e=>`blockNumber.${_e}`;
async function getBlockNumber(_e, {cacheTime: et=_e.cacheTime}={}) {
    const tt = await withCache(()=>_e.request({
        method: "eth_blockNumber"
    }), {
        cacheKey: cacheKey(_e.uid),
        cacheTime: et
    });
    return BigInt(tt)
}
async function simulateContract$1(_e, et) {
    const {abi: tt, address: rt, args: nt, dataSuffix: it, functionName: st, ...at} = et
      , ot = at.account ? parseAccount(at.account) : _e.account
      , lt = encodeFunctionData({
        abi: tt,
        args: nt,
        functionName: st
    });
    try {
        const {data: dt} = await getAction$1(_e, call, "call")({
            batch: !1,
            data: `${lt}${it ? it.replace("0x", "") : ""}`,
            to: rt,
            ...at,
            account: ot
        })
          , ct = decodeFunctionResult({
            abi: tt,
            args: nt,
            functionName: st,
            data: dt || "0x"
        })
          , ut = tt.filter(ft=>"name"in ft && ft.name === et.functionName);
        return {
            result: ct,
            request: {
                abi: ut,
                address: rt,
                args: nt,
                dataSuffix: it,
                functionName: st,
                ...at,
                account: ot
            }
        }
    } catch (dt) {
        throw getContractError(dt, {
            abi: tt,
            address: rt,
            args: nt,
            docsPath: "/docs/contract/simulateContract",
            functionName: st,
            sender: ot == null ? void 0 : ot.address
        })
    }
}
function formatLog(_e, {args: et, eventName: tt}={}) {
    return {
        ..._e,
        blockHash: _e.blockHash ? _e.blockHash : null,
        blockNumber: _e.blockNumber ? BigInt(_e.blockNumber) : null,
        logIndex: _e.logIndex ? Number(_e.logIndex) : null,
        transactionHash: _e.transactionHash ? _e.transactionHash : null,
        transactionIndex: _e.transactionIndex ? Number(_e.transactionIndex) : null,
        ...tt ? {
            args: et,
            eventName: tt
        } : {}
    }
}
const listenersCache = new Map
  , cleanupCache = new Map;
let callbackCount = 0;
function observe(_e, et, tt) {
    const rt = ++callbackCount
      , nt = ()=>listenersCache.get(_e) || []
      , it = ()=>{
        const dt = nt();
        listenersCache.set(_e, dt.filter(ct=>ct.id !== rt))
    }
      , st = ()=>{
        const dt = cleanupCache.get(_e);
        nt().length === 1 && dt && dt(),
        it()
    }
      , at = nt();
    if (listenersCache.set(_e, [...at, {
        id: rt,
        fns: et
    }]),
    at && at.length > 0)
        return st;
    const ot = {};
    for (const dt in et)
        ot[dt] = (...ct)=>{
            var ft, ht;
            const ut = nt();
            if (ut.length !== 0)
                for (const gt of ut)
                    (ht = (ft = gt.fns)[dt]) == null || ht.call(ft, ...ct)
        }
        ;
    const lt = tt(ot);
    return typeof lt == "function" && cleanupCache.set(_e, lt),
    st
}
async function wait(_e) {
    return new Promise(et=>setTimeout(et, _e))
}
function poll(_e, {emitOnBegin: et, initialWaitTime: tt, interval: rt}) {
    let nt = !0;
    const it = ()=>nt = !1;
    return (async()=>{
        let at;
        et && (at = await _e({
            unpoll: it
        }));
        const ot = await (tt == null ? void 0 : tt(at)) ?? rt;
        await wait(ot);
        const lt = async()=>{
            nt && (await _e({
                unpoll: it
            }),
            await wait(rt),
            lt())
        }
        ;
        lt()
    }
    )(),
    it
}
async function writeContract$1(_e, et) {
    const {abi: tt, address: rt, args: nt, dataSuffix: it, functionName: st, ...at} = et
      , ot = encodeFunctionData({
        abi: tt,
        args: nt,
        functionName: st
    });
    return getAction$1(_e, sendTransaction, "sendTransaction")({
        data: `${ot}${it ? it.replace("0x", "") : ""}`,
        to: rt,
        ...at
    })
}
const size$1 = 256;
let index$3 = size$1, buffer$2;
function uid$1(_e=11) {
    if (!buffer$2 || index$3 + _e > size$1 * 2) {
        buffer$2 = "",
        index$3 = 0;
        for (let et = 0; et < size$1; et++)
            buffer$2 += (256 + Math.random() * 256 | 0).toString(16).substring(1)
    }
    return buffer$2.substring(index$3, index$3++ + _e)
}
function createClient(_e) {
    const {batch: et, cacheTime: tt=_e.pollingInterval ?? 4e3, key: rt="base", name: nt="Base Client", pollingInterval: it=4e3, type: st="base"} = _e
      , at = _e.chain
      , ot = _e.account ? parseAccount(_e.account) : void 0
      , {config: lt, request: dt, value: ct} = _e.transport({
        chain: at,
        pollingInterval: it
    })
      , ut = {
        ...lt,
        ...ct
    }
      , ft = {
        account: ot,
        batch: et,
        cacheTime: tt,
        chain: at,
        key: rt,
        name: nt,
        pollingInterval: it,
        request: dt,
        transport: ut,
        type: st,
        uid: uid$1()
    };
    function ht(gt) {
        return bt=>{
            const pt = bt(gt);
            for (const yt in ft)
                delete pt[yt];
            const mt = {
                ...gt,
                ...pt
            };
            return Object.assign(mt, {
                extend: ht(mt)
            })
        }
    }
    return Object.assign(ft, {
        extend: ht(ft)
    })
}
function withRetry(_e, {delay: et=100, retryCount: tt=2, shouldRetry: rt=()=>!0}={}) {
    return new Promise((nt,it)=>{
        const st = async({count: at=0}={})=>{
            const ot = async({error: lt})=>{
                const dt = typeof et == "function" ? et({
                    count: at,
                    error: lt
                }) : et;
                dt && await wait(dt),
                st({
                    count: at + 1
                })
            }
            ;
            try {
                const lt = await _e();
                nt(lt)
            } catch (lt) {
                if (at < tt && await rt({
                    count: at,
                    error: lt
                }))
                    return ot({
                        error: lt
                    });
                it(lt)
            }
        }
        ;
        st()
    }
    )
}
function buildRequest(_e, et={}) {
    return async(tt,rt={})=>{
        const {retryDelay: nt=150, retryCount: it=3} = {
            ...et,
            ...rt
        };
        return withRetry(async()=>{
            try {
                return await _e(tt)
            } catch (st) {
                const at = st;
                switch (at.code) {
                case ParseRpcError.code:
                    throw new ParseRpcError(at);
                case InvalidRequestRpcError.code:
                    throw new InvalidRequestRpcError(at);
                case MethodNotFoundRpcError.code:
                    throw new MethodNotFoundRpcError(at);
                case InvalidParamsRpcError.code:
                    throw new InvalidParamsRpcError(at);
                case InternalRpcError.code:
                    throw new InternalRpcError(at);
                case InvalidInputRpcError.code:
                    throw new InvalidInputRpcError(at);
                case ResourceNotFoundRpcError.code:
                    throw new ResourceNotFoundRpcError(at);
                case ResourceUnavailableRpcError.code:
                    throw new ResourceUnavailableRpcError(at);
                case TransactionRejectedRpcError.code:
                    throw new TransactionRejectedRpcError(at);
                case MethodNotSupportedRpcError.code:
                    throw new MethodNotSupportedRpcError(at);
                case LimitExceededRpcError.code:
                    throw new LimitExceededRpcError(at);
                case JsonRpcVersionUnsupportedError.code:
                    throw new JsonRpcVersionUnsupportedError(at);
                case UserRejectedRequestError.code:
                    throw new UserRejectedRequestError(at);
                case UnauthorizedProviderError.code:
                    throw new UnauthorizedProviderError(at);
                case UnsupportedProviderMethodError.code:
                    throw new UnsupportedProviderMethodError(at);
                case ProviderDisconnectedError.code:
                    throw new ProviderDisconnectedError(at);
                case ChainDisconnectedError.code:
                    throw new ChainDisconnectedError(at);
                case SwitchChainError.code:
                    throw new SwitchChainError(at);
                case 5e3:
                    throw new UserRejectedRequestError(at);
                default:
                    throw st instanceof BaseError$2 ? st : new UnknownRpcError(at)
                }
            }
        }
        , {
            delay: ({count: st, error: at})=>{
                var ot;
                if (at && at instanceof HttpRequestError) {
                    const lt = (ot = at == null ? void 0 : at.headers) == null ? void 0 : ot.get("Retry-After");
                    if (lt != null && lt.match(/\d/))
                        return parseInt(lt) * 1e3
                }
                return ~~(1 << st) * nt
            }
            ,
            retryCount: it,
            shouldRetry: ({error: st})=>shouldRetry(st)
        })
    }
}
function shouldRetry(_e) {
    return "code"in _e && typeof _e.code == "number" ? _e.code === -1 || _e.code === LimitExceededRpcError.code || _e.code === InternalRpcError.code : _e instanceof HttpRequestError && _e.status ? _e.status === 403 || _e.status === 408 || _e.status === 413 || _e.status === 429 || _e.status === 500 || _e.status === 502 || _e.status === 503 || _e.status === 504 : !0
}
function createTransport({key: _e, name: et, request: tt, retryCount: rt=3, retryDelay: nt=150, timeout: it, type: st}, at) {
    return {
        config: {
            key: _e,
            name: et,
            request: tt,
            retryCount: rt,
            retryDelay: nt,
            timeout: it,
            type: st
        },
        request: buildRequest(tt, {
            retryCount: rt,
            retryDelay: nt
        }),
        value: at
    }
}
function custom$1(_e, et={}) {
    const {key: tt="custom", name: rt="Custom Provider", retryDelay: nt} = et;
    return ({retryCount: it})=>createTransport({
        key: tt,
        name: rt,
        request: _e.request.bind(_e),
        retryCount: et.retryCount ?? it,
        retryDelay: nt,
        type: "custom"
    })
}
class UrlRequiredError extends BaseError$2 {
    constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
            docsPath: "/docs/clients/intro"
        })
    }
}
function withTimeout(_e, {errorInstance: et=new Error("timed out"), timeout: tt, signal: rt}) {
    return new Promise((nt,it)=>{
        (async()=>{
            let st;
            try {
                const at = new AbortController;
                tt > 0 && (st = setTimeout(()=>{
                    rt ? at.abort() : it(et)
                }
                , tt)),
                nt(await _e({
                    signal: at == null ? void 0 : at.signal
                }))
            } catch (at) {
                at.name === "AbortError" && it(et),
                it(at)
            } finally {
                clearTimeout(st)
            }
        }
        )()
    }
    )
}
function createIdStore() {
    return {
        current: 0,
        take() {
            return this.current++
        },
        reset() {
            this.current = 0
        }
    }
}
const idCache = createIdStore();
function getHttpRpcClient(_e, et={}) {
    return {
        async request(tt) {
            var lt;
            const {body: rt, fetchOptions: nt={}, timeout: it=et.timeout ?? 1e4} = tt
              , {headers: st, method: at, signal: ot} = {
                ...et.fetchOptions,
                ...nt
            };
            try {
                const dt = await withTimeout(async({signal: ut})=>await fetch(_e, {
                    ...nt,
                    body: Array.isArray(rt) ? stringify(rt.map(ht=>({
                        jsonrpc: "2.0",
                        id: ht.id ?? idCache.take(),
                        ...ht
                    }))) : stringify({
                        jsonrpc: "2.0",
                        id: rt.id ?? idCache.take(),
                        ...rt
                    }),
                    headers: {
                        ...st,
                        "Content-Type": "application/json"
                    },
                    method: at || "POST",
                    signal: ot || (it > 0 ? ut : void 0)
                }), {
                    errorInstance: new TimeoutError({
                        body: rt,
                        url: _e
                    }),
                    timeout: it,
                    signal: !0
                });
                let ct;
                if ((lt = dt.headers.get("Content-Type")) != null && lt.startsWith("application/json") ? ct = await dt.json() : ct = await dt.text(),
                !dt.ok)
                    throw new HttpRequestError({
                        body: rt,
                        details: stringify(ct.error) || dt.statusText,
                        headers: dt.headers,
                        status: dt.status,
                        url: _e
                    });
                return ct
            } catch (dt) {
                throw dt instanceof HttpRequestError || dt instanceof TimeoutError ? dt : new HttpRequestError({
                    body: rt,
                    details: dt.message,
                    url: _e
                })
            }
        }
    }
}
function http(_e, et={}) {
    const {batch: tt, fetchOptions: rt, key: nt="http", name: it="HTTP JSON-RPC", retryDelay: st} = et;
    return ({chain: at, retryCount: ot, timeout: lt})=>{
        const {batchSize: dt=1e3, wait: ct=0} = typeof tt == "object" ? tt : {}
          , ut = et.retryCount ?? ot
          , ft = lt ?? et.timeout ?? 1e4
          , ht = _e || (at == null ? void 0 : at.rpcUrls.default.http[0]);
        if (!ht)
            throw new UrlRequiredError;
        const gt = getHttpRpcClient(ht, {
            fetchOptions: rt,
            timeout: ft
        });
        return createTransport({
            key: nt,
            name: it,
            async request({method: bt, params: pt}) {
                const mt = {
                    method: bt,
                    params: pt
                }
                  , {schedule: yt} = createBatchScheduler({
                    id: `${_e}`,
                    wait: ct,
                    shouldSplitBatch(Et) {
                        return Et.length > dt
                    },
                    fn: Et=>gt.request({
                        body: Et
                    }),
                    sort: (Et,xt)=>Et.id - xt.id
                })
                  , vt = async Et=>tt ? yt(Et) : [await gt.request({
                    body: Et
                })]
                  , [{error: wt, result: _t}] = await vt(mt);
                if (wt)
                    throw new RpcRequestError({
                        body: mt,
                        error: wt,
                        url: ht
                    });
                return _t
            },
            retryCount: ut,
            retryDelay: st,
            timeout: ft,
            type: "http"
        }, {
            fetchOptions: rt,
            url: ht
        })
    }
}
function defineChain(_e) {
    return {
        formatters: void 0,
        fees: void 0,
        serializers: void 0,
        ..._e
    }
}
const statuses = {
    "0x0": "reverted",
    "0x1": "success"
};
function formatTransactionReceipt(_e) {
    const et = {
        ..._e,
        blockNumber: _e.blockNumber ? BigInt(_e.blockNumber) : null,
        contractAddress: _e.contractAddress ? _e.contractAddress : null,
        cumulativeGasUsed: _e.cumulativeGasUsed ? BigInt(_e.cumulativeGasUsed) : null,
        effectiveGasPrice: _e.effectiveGasPrice ? BigInt(_e.effectiveGasPrice) : null,
        gasUsed: _e.gasUsed ? BigInt(_e.gasUsed) : null,
        logs: _e.logs ? _e.logs.map(tt=>formatLog(tt)) : null,
        to: _e.to ? _e.to : null,
        transactionIndex: _e.transactionIndex ? hexToNumber(_e.transactionIndex) : null,
        status: _e.status ? statuses[_e.status] : null,
        type: _e.type ? transactionType[_e.type] || _e.type : null
    };
    return _e.blobGasPrice && (et.blobGasPrice = BigInt(_e.blobGasPrice)),
    _e.blobGasUsed && (et.blobGasUsed = BigInt(_e.blobGasUsed)),
    et
}
function parseUnits(_e, et) {
    let[tt,rt="0"] = _e.split(".");
    const nt = tt.startsWith("-");
    if (nt && (tt = tt.slice(1)),
    rt = rt.replace(/(0+)$/, ""),
    et === 0)
        Math.round(+`.${rt}`) === 1 && (tt = `${BigInt(tt) + 1n}`),
        rt = "";
    else if (rt.length > et) {
        const [it,st,at] = [rt.slice(0, et - 1), rt.slice(et - 1, et), rt.slice(et)]
          , ot = Math.round(+`${st}.${at}`);
        ot > 9 ? rt = `${BigInt(it) + BigInt(1)}0`.padStart(it.length + 1, "0") : rt = `${it}${ot}`,
        rt.length > et && (rt = rt.slice(1),
        tt = `${BigInt(tt) + 1n}`),
        rt = rt.slice(0, et)
    } else
        rt = rt.padEnd(et, "0");
    return BigInt(`${nt ? "-" : ""}${tt}${rt}`)
}
function parseEther(_e, et="wei") {
    return parseUnits(_e, etherUnits[et])
}
async function getTransaction(_e, {blockHash: et, blockNumber: tt, blockTag: rt, hash: nt, index: it}) {
    var dt, ct, ut;
    const st = rt || "latest"
      , at = tt !== void 0 ? numberToHex(tt) : void 0;
    let ot = null;
    if (nt ? ot = await _e.request({
        method: "eth_getTransactionByHash",
        params: [nt]
    }) : et ? ot = await _e.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [et, numberToHex(it)]
    }) : (at || st) && (ot = await _e.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [at || st, numberToHex(it)]
    })),
    !ot)
        throw new TransactionNotFoundError({
            blockHash: et,
            blockNumber: tt,
            blockTag: st,
            hash: nt,
            index: it
        });
    return (((ut = (ct = (dt = _e.chain) == null ? void 0 : dt.formatters) == null ? void 0 : ct.transaction) == null ? void 0 : ut.format) || formatTransaction)(ot)
}
async function getTransactionReceipt(_e, {hash: et}) {
    var nt, it, st;
    const tt = await _e.request({
        method: "eth_getTransactionReceipt",
        params: [et]
    });
    if (!tt)
        throw new TransactionReceiptNotFoundError({
            hash: et
        });
    return (((st = (it = (nt = _e.chain) == null ? void 0 : nt.formatters) == null ? void 0 : it.transactionReceipt) == null ? void 0 : st.format) || formatTransactionReceipt)(tt)
}
async function multicall$1(_e, et) {
    var bt;
    const {allowFailure: tt=!0, batchSize: rt, blockNumber: nt, blockTag: it, multicallAddress: st, stateOverride: at} = et
      , ot = et.contracts
      , lt = rt ?? (typeof ((bt = _e.batch) == null ? void 0 : bt.multicall) == "object" && _e.batch.multicall.batchSize || 1024);
    let dt = st;
    if (!dt) {
        if (!_e.chain)
            throw new Error("client chain not configured. multicallAddress is required.");
        dt = getChainContractAddress({
            blockNumber: nt,
            chain: _e.chain,
            contract: "multicall3"
        })
    }
    const ct = [[]];
    let ut = 0
      , ft = 0;
    for (let pt = 0; pt < ot.length; pt++) {
        const {abi: mt, address: yt, args: vt, functionName: wt} = ot[pt];
        try {
            const _t = encodeFunctionData({
                abi: mt,
                args: vt,
                functionName: wt
            });
            ft += (_t.length - 2) / 2,
            lt > 0 && ft > lt && ct[ut].length > 0 && (ut++,
            ft = (_t.length - 2) / 2,
            ct[ut] = []),
            ct[ut] = [...ct[ut], {
                allowFailure: !0,
                callData: _t,
                target: yt
            }]
        } catch (_t) {
            const Et = getContractError(_t, {
                abi: mt,
                address: yt,
                args: vt,
                docsPath: "/docs/contract/multicall",
                functionName: wt
            });
            if (!tt)
                throw Et;
            ct[ut] = [...ct[ut], {
                allowFailure: !0,
                callData: "0x",
                target: yt
            }]
        }
    }
    const ht = await Promise.allSettled(ct.map(pt=>getAction$1(_e, readContract$1, "readContract")({
        abi: multicall3Abi,
        address: dt,
        args: [pt],
        blockNumber: nt,
        blockTag: it,
        functionName: "aggregate3",
        stateOverride: at
    })))
      , gt = [];
    for (let pt = 0; pt < ht.length; pt++) {
        const mt = ht[pt];
        if (mt.status === "rejected") {
            if (!tt)
                throw mt.reason;
            for (let vt = 0; vt < ct[pt].length; vt++)
                gt.push({
                    status: "failure",
                    error: mt.reason,
                    result: void 0
                });
            continue
        }
        const yt = mt.value;
        for (let vt = 0; vt < yt.length; vt++) {
            const {returnData: wt, success: _t} = yt[vt]
              , {callData: Et} = ct[pt][vt]
              , {abi: xt, address: Ct, functionName: Tt, args: It} = ot[gt.length];
            try {
                if (Et === "0x")
                    throw new AbiDecodingZeroDataError;
                if (!_t)
                    throw new RawContractError({
                        data: wt
                    });
                const Nt = decodeFunctionResult({
                    abi: xt,
                    args: It,
                    data: wt,
                    functionName: Tt
                });
                gt.push(tt ? {
                    result: Nt,
                    status: "success"
                } : Nt)
            } catch (Nt) {
                const Ft = getContractError(Nt, {
                    abi: xt,
                    address: Ct,
                    args: It,
                    docsPath: "/docs/contract/multicall",
                    functionName: Tt
                });
                if (!tt)
                    throw Ft;
                gt.push({
                    error: Ft,
                    result: void 0,
                    status: "failure"
                })
            }
        }
    }
    if (gt.length !== ot.length)
        throw new BaseError$2("multicall results mismatch");
    return gt
}
function watchBlockNumber(_e, {emitOnBegin: et=!1, emitMissed: tt=!1, onBlockNumber: rt, onError: nt, poll: it, pollingInterval: st=_e.pollingInterval}) {
    const at = typeof it < "u" ? it : _e.transport.type !== "webSocket";
    let ot;
    return at ? (()=>{
        const ct = stringify(["watchBlockNumber", _e.uid, et, tt, st]);
        return observe(ct, {
            onBlockNumber: rt,
            onError: nt
        }, ut=>poll(async()=>{
            var ft;
            try {
                const ht = await getAction$1(_e, getBlockNumber, "getBlockNumber")({
                    cacheTime: 0
                });
                if (ot) {
                    if (ht === ot)
                        return;
                    if (ht - ot > 1 && tt)
                        for (let gt = ot + 1n; gt < ht; gt++)
                            ut.onBlockNumber(gt, ot),
                            ot = gt
                }
                (!ot || ht > ot) && (ut.onBlockNumber(ht, ot),
                ot = ht)
            } catch (ht) {
                (ft = ut.onError) == null || ft.call(ut, ht)
            }
        }
        , {
            emitOnBegin: et,
            interval: st
        }))
    }
    )() : (()=>{
        let ct = !0
          , ut = ()=>ct = !1;
        return (async()=>{
            try {
                const {unsubscribe: ft} = await _e.transport.subscribe({
                    params: ["newHeads"],
                    onData(ht) {
                        var bt;
                        if (!ct)
                            return;
                        const gt = hexToBigInt((bt = ht.result) == null ? void 0 : bt.number);
                        rt(gt, ot),
                        ot = gt
                    },
                    onError(ht) {
                        nt == null || nt(ht)
                    }
                });
                ut = ft,
                ct || ut()
            } catch (ft) {
                nt == null || nt(ft)
            }
        }
        )(),
        ut
    }
    )()
}
async function waitForTransactionReceipt$1(_e, {confirmations: et=1, hash: tt, onReplaced: rt, pollingInterval: nt=_e.pollingInterval, retryCount: it=6, retryDelay: st=({count: ot})=>~~(1 << ot) * 200, timeout: at}) {
    const ot = stringify(["waitForTransactionReceipt", _e.uid, tt]);
    let lt, dt, ct, ut = !1;
    return new Promise((ft,ht)=>{
        at && setTimeout(()=>ht(new WaitForTransactionReceiptTimeoutError({
            hash: tt
        })), at);
        const gt = observe(ot, {
            onReplaced: rt,
            resolve: ft,
            reject: ht
        }, bt=>{
            const pt = getAction$1(_e, watchBlockNumber, "watchBlockNumber")({
                emitMissed: !0,
                emitOnBegin: !0,
                poll: !0,
                pollingInterval: nt,
                async onBlockNumber(mt) {
                    if (ut)
                        return;
                    let yt = mt;
                    const vt = wt=>{
                        pt(),
                        wt(),
                        gt()
                    }
                    ;
                    try {
                        if (ct) {
                            if (et > 1 && (!ct.blockNumber || yt - ct.blockNumber + 1n < et))
                                return;
                            vt(()=>bt.resolve(ct));
                            return
                        }
                        if (lt || (ut = !0,
                        await withRetry(async()=>{
                            lt = await getAction$1(_e, getTransaction, "getTransaction")({
                                hash: tt
                            }),
                            lt.blockNumber && (yt = lt.blockNumber)
                        }
                        , {
                            delay: st,
                            retryCount: it
                        }),
                        ut = !1),
                        ct = await getAction$1(_e, getTransactionReceipt, "getTransactionReceipt")({
                            hash: tt
                        }),
                        et > 1 && (!ct.blockNumber || yt - ct.blockNumber + 1n < et))
                            return;
                        vt(()=>bt.resolve(ct))
                    } catch (wt) {
                        if (wt instanceof TransactionNotFoundError || wt instanceof TransactionReceiptNotFoundError) {
                            if (!lt) {
                                ut = !1;
                                return
                            }
                            try {
                                dt = lt,
                                ut = !0;
                                const _t = await withRetry(()=>getAction$1(_e, getBlock, "getBlock")({
                                    blockNumber: yt,
                                    includeTransactions: !0
                                }), {
                                    delay: st,
                                    retryCount: it,
                                    shouldRetry: ({error: Ct})=>Ct instanceof BlockNotFoundError
                                });
                                ut = !1;
                                const Et = _t.transactions.find(({from: Ct, nonce: Tt})=>Ct === dt.from && Tt === dt.nonce);
                                if (!Et || (ct = await getAction$1(_e, getTransactionReceipt, "getTransactionReceipt")({
                                    hash: Et.hash
                                }),
                                et > 1 && (!ct.blockNumber || yt - ct.blockNumber + 1n < et)))
                                    return;
                                let xt = "replaced";
                                Et.to === dt.to && Et.value === dt.value ? xt = "repriced" : Et.from === Et.to && Et.value === 0n && (xt = "cancelled"),
                                vt(()=>{
                                    var Ct;
                                    (Ct = bt.onReplaced) == null || Ct.call(bt, {
                                        reason: xt,
                                        replacedTransaction: dt,
                                        transaction: Et,
                                        transactionReceipt: ct
                                    }),
                                    bt.resolve(ct)
                                }
                                )
                            } catch (_t) {
                                vt(()=>bt.reject(_t))
                            }
                        } else
                            vt(()=>bt.reject(wt))
                    }
                }
            })
        }
        )
    }
    )
}
async function signMessage$1(_e, {account: et=_e.account, message: tt}) {
    if (!et)
        throw new AccountNotFoundError({
            docsPath: "/docs/actions/wallet/signMessage"
        });
    const rt = parseAccount(et);
    if (rt.type === "local")
        return rt.signMessage({
            message: tt
        });
    const nt = typeof tt == "string" ? stringToHex(tt) : tt.raw instanceof Uint8Array ? toHex(tt.raw) : tt.raw;
    return _e.request({
        method: "personal_sign",
        params: [nt, rt.address]
    }, {
        retryCount: 0
    })
}
function requestProviders(_e) {
    const et = tt=>_e(tt.detail);
    return window.addEventListener("eip6963:announceProvider", et),
    window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),
    ()=>window.removeEventListener("eip6963:announceProvider", et)
}
function createStore$2() {
    const _e = new Set;
    let et = [];
    const tt = ()=>requestProviders(nt=>{
        et.some(({info: it})=>it.uuid === nt.info.uuid) || (et = [...et, nt],
        _e.forEach(it=>it(et, {
            added: [nt]
        })))
    }
    );
    let rt = tt();
    return {
        _listeners() {
            return _e
        },
        clear() {
            _e.forEach(nt=>nt([], {
                removed: [...et]
            })),
            et = []
        },
        destroy() {
            this.clear(),
            _e.clear(),
            rt()
        },
        findProvider({rdns: nt}) {
            return et.find(it=>it.info.rdns === nt)
        },
        getProviders() {
            return et
        },
        reset() {
            this.clear(),
            rt(),
            rt = tt()
        },
        subscribe(nt, {emitImmediately: it}={}) {
            return _e.add(nt),
            it && nt(et, {
                added: et
            }),
            ()=>_e.delete(nt)
        }
    }
}
var define_import_meta_env_default$2 = {
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
const subscribeWithSelectorImpl = _e=>(et,tt,rt)=>{
    const nt = rt.subscribe;
    return rt.subscribe = (st,at,ot)=>{
        let lt = st;
        if (at) {
            const dt = (ot == null ? void 0 : ot.equalityFn) || Object.is;
            let ct = st(rt.getState());
            lt = ut=>{
                const ft = st(ut);
                if (!dt(ct, ft)) {
                    const ht = ct;
                    at(ct = ft, ht)
                }
            }
            ,
            ot != null && ot.fireImmediately && at(ct, ct)
        }
        return nt(lt)
    }
    ,
    _e(et, tt, rt)
}
  , subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(_e, et) {
    let tt;
    try {
        tt = _e()
    } catch {
        return
    }
    return {
        getItem: nt=>{
            var it;
            const st = ot=>ot === null ? null : JSON.parse(ot, et == null ? void 0 : et.reviver)
              , at = (it = tt.getItem(nt)) != null ? it : null;
            return at instanceof Promise ? at.then(st) : st(at)
        }
        ,
        setItem: (nt,it)=>tt.setItem(nt, JSON.stringify(it, et == null ? void 0 : et.replacer)),
        removeItem: nt=>tt.removeItem(nt)
    }
}
const toThenable = _e=>et=>{
    try {
        const tt = _e(et);
        return tt instanceof Promise ? tt : {
            then(rt) {
                return toThenable(rt)(tt)
            },
            catch(rt) {
                return this
            }
        }
    } catch (tt) {
        return {
            then(rt) {
                return this
            },
            catch(rt) {
                return toThenable(rt)(tt)
            }
        }
    }
}
  , oldImpl = (_e,et)=>(tt,rt,nt)=>{
    let it = {
        getStorage: ()=>localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: bt=>bt,
        version: 0,
        merge: (bt,pt)=>({
            ...pt,
            ...bt
        }),
        ...et
    }
      , st = !1;
    const at = new Set
      , ot = new Set;
    let lt;
    try {
        lt = it.getStorage()
    } catch {}
    if (!lt)
        return _e((...bt)=>{
            console.warn(`[zustand persist middleware] Unable to update item '${it.name}', the given storage is currently unavailable.`),
            tt(...bt)
        }
        , rt, nt);
    const dt = toThenable(it.serialize)
      , ct = ()=>{
        const bt = it.partialize({
            ...rt()
        });
        let pt;
        const mt = dt({
            state: bt,
            version: it.version
        }).then(yt=>lt.setItem(it.name, yt)).catch(yt=>{
            pt = yt
        }
        );
        if (pt)
            throw pt;
        return mt
    }
      , ut = nt.setState;
    nt.setState = (bt,pt)=>{
        ut(bt, pt),
        ct()
    }
    ;
    const ft = _e((...bt)=>{
        tt(...bt),
        ct()
    }
    , rt, nt);
    let ht;
    const gt = ()=>{
        var bt;
        if (!lt)
            return;
        st = !1,
        at.forEach(mt=>mt(rt()));
        const pt = ((bt = it.onRehydrateStorage) == null ? void 0 : bt.call(it, rt())) || void 0;
        return toThenable(lt.getItem.bind(lt))(it.name).then(mt=>{
            if (mt)
                return it.deserialize(mt)
        }
        ).then(mt=>{
            if (mt)
                if (typeof mt.version == "number" && mt.version !== it.version) {
                    if (it.migrate)
                        return it.migrate(mt.state, mt.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return mt.state
        }
        ).then(mt=>{
            var yt;
            return ht = it.merge(mt, (yt = rt()) != null ? yt : ft),
            tt(ht, !0),
            ct()
        }
        ).then(()=>{
            pt == null || pt(ht, void 0),
            st = !0,
            ot.forEach(mt=>mt(ht))
        }
        ).catch(mt=>{
            pt == null || pt(void 0, mt)
        }
        )
    }
    ;
    return nt.persist = {
        setOptions: bt=>{
            it = {
                ...it,
                ...bt
            },
            bt.getStorage && (lt = bt.getStorage())
        }
        ,
        clearStorage: ()=>{
            lt == null || lt.removeItem(it.name)
        }
        ,
        getOptions: ()=>it,
        rehydrate: ()=>gt(),
        hasHydrated: ()=>st,
        onHydrate: bt=>(at.add(bt),
        ()=>{
            at.delete(bt)
        }
        ),
        onFinishHydration: bt=>(ot.add(bt),
        ()=>{
            ot.delete(bt)
        }
        )
    },
    gt(),
    ht || ft
}
  , newImpl = (_e,et)=>(tt,rt,nt)=>{
    let it = {
        storage: createJSONStorage(()=>localStorage),
        partialize: gt=>gt,
        version: 0,
        merge: (gt,bt)=>({
            ...bt,
            ...gt
        }),
        ...et
    }
      , st = !1;
    const at = new Set
      , ot = new Set;
    let lt = it.storage;
    if (!lt)
        return _e((...gt)=>{
            console.warn(`[zustand persist middleware] Unable to update item '${it.name}', the given storage is currently unavailable.`),
            tt(...gt)
        }
        , rt, nt);
    const dt = ()=>{
        const gt = it.partialize({
            ...rt()
        });
        return lt.setItem(it.name, {
            state: gt,
            version: it.version
        })
    }
      , ct = nt.setState;
    nt.setState = (gt,bt)=>{
        ct(gt, bt),
        dt()
    }
    ;
    const ut = _e((...gt)=>{
        tt(...gt),
        dt()
    }
    , rt, nt);
    let ft;
    const ht = ()=>{
        var gt, bt;
        if (!lt)
            return;
        st = !1,
        at.forEach(mt=>{
            var yt;
            return mt((yt = rt()) != null ? yt : ut)
        }
        );
        const pt = ((bt = it.onRehydrateStorage) == null ? void 0 : bt.call(it, (gt = rt()) != null ? gt : ut)) || void 0;
        return toThenable(lt.getItem.bind(lt))(it.name).then(mt=>{
            if (mt)
                if (typeof mt.version == "number" && mt.version !== it.version) {
                    if (it.migrate)
                        return it.migrate(mt.state, mt.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return mt.state
        }
        ).then(mt=>{
            var yt;
            return ft = it.merge(mt, (yt = rt()) != null ? yt : ut),
            tt(ft, !0),
            dt()
        }
        ).then(()=>{
            pt == null || pt(ft, void 0),
            ft = rt(),
            st = !0,
            ot.forEach(mt=>mt(ft))
        }
        ).catch(mt=>{
            pt == null || pt(void 0, mt)
        }
        )
    }
    ;
    return nt.persist = {
        setOptions: gt=>{
            it = {
                ...it,
                ...gt
            },
            gt.storage && (lt = gt.storage)
        }
        ,
        clearStorage: ()=>{
            lt == null || lt.removeItem(it.name)
        }
        ,
        getOptions: ()=>it,
        rehydrate: ()=>ht(),
        hasHydrated: ()=>st,
        onHydrate: gt=>(at.add(gt),
        ()=>{
            at.delete(gt)
        }
        ),
        onFinishHydration: gt=>(ot.add(gt),
        ()=>{
            ot.delete(gt)
        }
        )
    },
    it.skipHydration || ht(),
    ft || ut
}
  , persistImpl = (_e,et)=>"getStorage"in et || "serialize"in et || "deserialize"in et ? ((define_import_meta_env_default$2 ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),
oldImpl(_e, et)) : newImpl(_e, et)
  , persist = persistImpl;
var define_import_meta_env_default$1 = {
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
const createStoreImpl = _e=>{
    let et;
    const tt = new Set
      , rt = (ot,lt)=>{
        const dt = typeof ot == "function" ? ot(et) : ot;
        if (!Object.is(dt, et)) {
            const ct = et;
            et = lt ?? typeof dt != "object" ? dt : Object.assign({}, et, dt),
            tt.forEach(ut=>ut(et, ct))
        }
    }
      , nt = ()=>et
      , at = {
        setState: rt,
        getState: nt,
        subscribe: ot=>(tt.add(ot),
        ()=>tt.delete(ot)),
        destroy: ()=>{
            (define_import_meta_env_default$1 ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),
            tt.clear()
        }
    };
    return et = _e(rt, nt, at),
    at
}
  , createStore$1 = _e=>_e ? createStoreImpl(_e) : createStoreImpl;
var eventemitter3 = {
    exports: {}
};
(function(_e) {
    var et = Object.prototype.hasOwnProperty
      , tt = "~";
    function rt() {}
    Object.create && (rt.prototype = Object.create(null),
    new rt().__proto__ || (tt = !1));
    function nt(ot, lt, dt) {
        this.fn = ot,
        this.context = lt,
        this.once = dt || !1
    }
    function it(ot, lt, dt, ct, ut) {
        if (typeof dt != "function")
            throw new TypeError("The listener must be a function");
        var ft = new nt(dt,ct || ot,ut)
          , ht = tt ? tt + lt : lt;
        return ot._events[ht] ? ot._events[ht].fn ? ot._events[ht] = [ot._events[ht], ft] : ot._events[ht].push(ft) : (ot._events[ht] = ft,
        ot._eventsCount++),
        ot
    }
    function st(ot, lt) {
        --ot._eventsCount === 0 ? ot._events = new rt : delete ot._events[lt]
    }
    function at() {
        this._events = new rt,
        this._eventsCount = 0
    }
    at.prototype.eventNames = function() {
        var lt = [], dt, ct;
        if (this._eventsCount === 0)
            return lt;
        for (ct in dt = this._events)
            et.call(dt, ct) && lt.push(tt ? ct.slice(1) : ct);
        return Object.getOwnPropertySymbols ? lt.concat(Object.getOwnPropertySymbols(dt)) : lt
    }
    ,
    at.prototype.listeners = function(lt) {
        var dt = tt ? tt + lt : lt
          , ct = this._events[dt];
        if (!ct)
            return [];
        if (ct.fn)
            return [ct.fn];
        for (var ut = 0, ft = ct.length, ht = new Array(ft); ut < ft; ut++)
            ht[ut] = ct[ut].fn;
        return ht
    }
    ,
    at.prototype.listenerCount = function(lt) {
        var dt = tt ? tt + lt : lt
          , ct = this._events[dt];
        return ct ? ct.fn ? 1 : ct.length : 0
    }
    ,
    at.prototype.emit = function(lt, dt, ct, ut, ft, ht) {
        var gt = tt ? tt + lt : lt;
        if (!this._events[gt])
            return !1;
        var bt = this._events[gt], pt = arguments.length, mt, yt;
        if (bt.fn) {
            switch (bt.once && this.removeListener(lt, bt.fn, void 0, !0),
            pt) {
            case 1:
                return bt.fn.call(bt.context),
                !0;
            case 2:
                return bt.fn.call(bt.context, dt),
                !0;
            case 3:
                return bt.fn.call(bt.context, dt, ct),
                !0;
            case 4:
                return bt.fn.call(bt.context, dt, ct, ut),
                !0;
            case 5:
                return bt.fn.call(bt.context, dt, ct, ut, ft),
                !0;
            case 6:
                return bt.fn.call(bt.context, dt, ct, ut, ft, ht),
                !0
            }
            for (yt = 1,
            mt = new Array(pt - 1); yt < pt; yt++)
                mt[yt - 1] = arguments[yt];
            bt.fn.apply(bt.context, mt)
        } else {
            var vt = bt.length, wt;
            for (yt = 0; yt < vt; yt++)
                switch (bt[yt].once && this.removeListener(lt, bt[yt].fn, void 0, !0),
                pt) {
                case 1:
                    bt[yt].fn.call(bt[yt].context);
                    break;
                case 2:
                    bt[yt].fn.call(bt[yt].context, dt);
                    break;
                case 3:
                    bt[yt].fn.call(bt[yt].context, dt, ct);
                    break;
                case 4:
                    bt[yt].fn.call(bt[yt].context, dt, ct, ut);
                    break;
                default:
                    if (!mt)
                        for (wt = 1,
                        mt = new Array(pt - 1); wt < pt; wt++)
                            mt[wt - 1] = arguments[wt];
                    bt[yt].fn.apply(bt[yt].context, mt)
                }
        }
        return !0
    }
    ,
    at.prototype.on = function(lt, dt, ct) {
        return it(this, lt, dt, ct, !1)
    }
    ,
    at.prototype.once = function(lt, dt, ct) {
        return it(this, lt, dt, ct, !0)
    }
    ,
    at.prototype.removeListener = function(lt, dt, ct, ut) {
        var ft = tt ? tt + lt : lt;
        if (!this._events[ft])
            return this;
        if (!dt)
            return st(this, ft),
            this;
        var ht = this._events[ft];
        if (ht.fn)
            ht.fn === dt && (!ut || ht.once) && (!ct || ht.context === ct) && st(this, ft);
        else {
            for (var gt = 0, bt = [], pt = ht.length; gt < pt; gt++)
                (ht[gt].fn !== dt || ut && !ht[gt].once || ct && ht[gt].context !== ct) && bt.push(ht[gt]);
            bt.length ? this._events[ft] = bt.length === 1 ? bt[0] : bt : st(this, ft)
        }
        return this
    }
    ,
    at.prototype.removeAllListeners = function(lt) {
        var dt;
        return lt ? (dt = tt ? tt + lt : lt,
        this._events[dt] && st(this, dt)) : (this._events = new rt,
        this._eventsCount = 0),
        this
    }
    ,
    at.prototype.off = at.prototype.removeListener,
    at.prototype.addListener = at.prototype.on,
    at.prefixed = tt,
    at.EventEmitter = at,
    _e.exports = at
}
)(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = getDefaultExportFromCjs(eventemitter3Exports);
var __classPrivateFieldGet$1 = function(_e, et, tt, rt) {
    if (tt === "a" && !rt)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof et == "function" ? _e !== et || !rt : !et.has(_e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return tt === "m" ? rt : tt === "a" ? rt.call(_e) : rt ? rt.value : et.get(_e)
}, _Emitter_emitter;
class Emitter {
    constructor(et) {
        Object.defineProperty(this, "uid", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: et
        }),
        _Emitter_emitter.set(this, new EventEmitter)
    }
    on(et, tt) {
        __classPrivateFieldGet$1(this, _Emitter_emitter, "f").on(et, tt)
    }
    once(et, tt) {
        __classPrivateFieldGet$1(this, _Emitter_emitter, "f").once(et, tt)
    }
    off(et, tt) {
        __classPrivateFieldGet$1(this, _Emitter_emitter, "f").off(et, tt)
    }
    emit(et, ...tt) {
        const rt = tt[0];
        __classPrivateFieldGet$1(this, _Emitter_emitter, "f").emit(et, {
            uid: this.uid,
            ...rt
        })
    }
    listenerCount(et) {
        return __classPrivateFieldGet$1(this, _Emitter_emitter, "f").listenerCount(et)
    }
}
_Emitter_emitter = new WeakMap;
function createEmitter(_e) {
    return new Emitter(_e)
}
function deserialize(_e, et) {
    return JSON.parse(_e, (tt,rt)=>{
        let nt = rt;
        return (nt == null ? void 0 : nt.__type) === "bigint" && (nt = BigInt(nt.value)),
        (nt == null ? void 0 : nt.__type) === "Map" && (nt = new Map(nt.value)),
        (et == null ? void 0 : et(tt, nt)) ?? nt
    }
    )
}
function getReferenceKey(_e, et) {
    return _e.slice(0, et).join(".") || "."
}
function getCutoff(_e, et) {
    const {length: tt} = _e;
    for (let rt = 0; rt < tt; ++rt)
        if (_e[rt] === et)
            return rt + 1;
    return 0
}
function createReplacer(_e, et) {
    const tt = typeof _e == "function"
      , rt = typeof et == "function"
      , nt = []
      , it = [];
    return function(at, ot) {
        if (typeof ot == "object")
            if (nt.length) {
                const lt = getCutoff(nt, this);
                lt === 0 ? nt[nt.length] = this : (nt.splice(lt),
                it.splice(lt)),
                it[it.length] = at;
                const dt = getCutoff(nt, ot);
                if (dt !== 0)
                    return rt ? et.call(this, at, ot, getReferenceKey(it, dt)) : `[ref=${getReferenceKey(it, dt)}]`
            } else
                nt[0] = ot,
                it[0] = at;
        return tt ? _e.call(this, at, ot) : ot
    }
}
function serialize(_e, et, tt, rt) {
    return JSON.stringify(_e, createReplacer((nt,it)=>{
        let st = it;
        return typeof st == "bigint" && (st = {
            __type: "bigint",
            value: it.toString()
        }),
        st instanceof Map && (st = {
            __type: "Map",
            value: Array.from(it.entries())
        }),
        (et == null ? void 0 : et(nt, st)) ?? st
    }
    , rt), tt ?? void 0)
}
function createStorage(_e) {
    const {deserialize: et=deserialize, key: tt="wagmi", serialize: rt=serialize, storage: nt=noopStorage} = _e;
    function it(st) {
        return st instanceof Promise ? st.then(at=>at).catch(()=>null) : st
    }
    return {
        ...nt,
        key: tt,
        async getItem(st, at) {
            const ot = nt.getItem(`${tt}.${st}`)
              , lt = await it(ot);
            return lt ? et(lt) ?? null : at ?? null
        },
        async setItem(st, at) {
            const ot = `${tt}.${st}`;
            at === null ? await it(nt.removeItem(ot)) : await it(nt.setItem(ot, rt(at)))
        },
        async removeItem(st) {
            await it(nt.removeItem(`${tt}.${st}`))
        }
    }
}
const noopStorage = {
    getItem: ()=>null,
    setItem: ()=>{}
    ,
    removeItem: ()=>{}
};
function createConnector(_e) {
    return _e
}
const version$2 = "2.6.5"
  , getVersion$1 = ()=>`@wagmi/core@${version$2}`;
var __classPrivateFieldGet = function(_e, et, tt, rt) {
    if (tt === "a" && !rt)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof et == "function" ? _e !== et || !rt : !et.has(_e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return tt === "m" ? rt : tt === "a" ? rt.call(_e) : rt ? rt.value : et.get(_e)
}, _BaseError_instances, _BaseError_walk;
let BaseError$1 = class uo extends Error {
    get docsBaseUrl() {
        return "https://wagmi.sh/core"
    }
    get version() {
        return getVersion$1()
    }
    constructor(et, tt={}) {
        var it;
        super(),
        _BaseError_instances.add(this),
        Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiCoreError"
        });
        const rt = tt.cause instanceof uo ? tt.cause.details : (it = tt.cause) != null && it.message ? tt.cause.message : tt.details
          , nt = tt.cause instanceof uo && tt.cause.docsPath || tt.docsPath;
        this.message = [et || "An error occurred.", "", ...tt.metaMessages ? [...tt.metaMessages, ""] : [], ...nt ? [`Docs: ${this.docsBaseUrl}${nt}.html${tt.docsSlug ? `#${tt.docsSlug}` : ""}`] : [], ...rt ? [`Details: ${rt}`] : [], `Version: ${this.version}`].join(`
`),
        tt.cause && (this.cause = tt.cause),
        this.details = rt,
        this.docsPath = nt,
        this.metaMessages = tt.metaMessages,
        this.shortMessage = et
    }
    walk(et) {
        return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, et)
    }
}
;
_BaseError_instances = new WeakSet,
_BaseError_walk = function _e(et, tt) {
    return tt != null && tt(et) ? et : et.cause ? __classPrivateFieldGet(this, _BaseError_instances, "m", _e).call(this, et.cause, tt) : et
}
;
class ChainNotConfiguredError extends BaseError$1 {
    constructor() {
        super("Chain not configured."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainNotConfiguredError"
        })
    }
}
class ConnectorAlreadyConnectedError extends BaseError$1 {
    constructor() {
        super("Connector already connected."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorAlreadyConnectedError"
        })
    }
}
class ConnectorNotConnectedError extends BaseError$1 {
    constructor() {
        super("Connector not connected."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorNotConnectedError"
        })
    }
}
class ConnectorAccountNotFoundError extends BaseError$1 {
    constructor({address: et, connector: tt}) {
        super(`Account "${et}" not found for connector "${tt.name}".`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorAccountNotFoundError"
        })
    }
}
class ProviderNotFoundError extends BaseError$1 {
    constructor() {
        super("Provider not found."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderNotFoundError"
        })
    }
}
class SwitchChainNotSupportedError extends BaseError$1 {
    constructor({connector: et}) {
        super(`"${et.name}" does not support programmatic chain switching.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SwitchChainNotSupportedError"
        })
    }
}
function normalizeChainId(_e) {
    if (typeof _e == "string")
        return Number.parseInt(_e, _e.trim().substring(0, 2) === "0x" ? 16 : 10);
    if (typeof _e == "bigint")
        return Number(_e);
    if (typeof _e == "number")
        return _e;
    throw new Error(`Cannot normalize chainId "${_e}" of type "${typeof _e}"`)
}
const targetMap = {
    coinbaseWallet: {
        id: "coinbaseWallet",
        name: "Coinbase Wallet",
        provider(_e) {
            return _e != null && _e.coinbaseWalletExtension ? _e.coinbaseWalletExtension : findProvider(_e, "isCoinbaseWallet")
        }
    },
    metaMask: {
        id: "metaMask",
        name: "MetaMask",
        provider(_e) {
            return findProvider(_e, et=>{
                if (!et.isMetaMask || et.isBraveWallet && !et._events && !et._state)
                    return !1;
                const tt = ["isApexWallet", "isAvalanche", "isBitKeep", "isBlockWallet", "isKuCoinWallet", "isMathWallet", "isOkxWallet", "isOKExWallet", "isOneInchIOSWallet", "isOneInchAndroidWallet", "isOpera", "isPortal", "isRabby", "isTokenPocket", "isTokenary", "isZerion"];
                for (const rt of tt)
                    if (et[rt])
                        return !1;
                return !0
            }
            )
        }
    },
    phantom: {
        id: "phantom",
        name: "Phantom",
        provider(_e) {
            var et, tt;
            return (et = _e == null ? void 0 : _e.phantom) != null && et.ethereum ? (tt = _e.phantom) == null ? void 0 : tt.ethereum : findProvider(_e, "isPhantom")
        }
    }
};
injected.type = "injected";
function injected(_e={}) {
    const {shimDisconnect: et=!0, unstable_shimAsyncInject: tt} = _e;
    function rt() {
        const nt = _e.target;
        if (typeof nt == "function") {
            const it = nt();
            if (it)
                return it
        }
        return typeof nt == "object" ? nt : typeof nt == "string" ? {
            ...targetMap[nt] ?? {
                id: nt,
                name: `${nt[0].toUpperCase()}${nt.slice(1)}`,
                provider: `is${nt[0].toUpperCase()}${nt.slice(1)}`
            }
        } : {
            id: "injected",
            name: "Injected",
            provider(it) {
                return it == null ? void 0 : it.ethereum
            }
        }
    }
    return nt=>({
        get icon() {
            return rt().icon
        },
        get id() {
            return rt().id
        },
        get name() {
            return rt().name
        },
        type: injected.type,
        async setup() {
            const it = await this.getProvider();
            it && _e.target && it.on("connect", this.onConnect.bind(this))
        },
        async connect({chainId: it, isReconnecting: st}={}) {
            var lt, dt, ct, ut, ft, ht;
            const at = await this.getProvider();
            if (!at)
                throw new ProviderNotFoundError;
            let ot = null;
            if (!st && (ot = await this.getAccounts().catch(()=>null),
            !!(ot != null && ot.length)))
                try {
                    ot = (ut = (ct = (dt = (lt = (await at.request({
                        method: "wallet_requestPermissions",
                        params: [{
                            eth_accounts: {}
                        }]
                    }))[0]) == null ? void 0 : lt.caveats) == null ? void 0 : dt[0]) == null ? void 0 : ct.value) == null ? void 0 : ut.map(pt=>getAddress(pt))
                } catch (bt) {
                    const pt = bt;
                    if (pt.code === UserRejectedRequestError.code)
                        throw new UserRejectedRequestError(pt);
                    if (pt.code === ResourceUnavailableRpcError.code)
                        throw pt
                }
            try {
                ot != null && ot.length || (ot = (await at.request({
                    method: "eth_requestAccounts"
                })).map(pt=>getAddress(pt))),
                at.removeListener("connect", this.onConnect.bind(this)),
                at.on("accountsChanged", this.onAccountsChanged.bind(this)),
                at.on("chainChanged", this.onChainChanged),
                at.on("disconnect", this.onDisconnect.bind(this));
                let gt = await this.getChainId();
                if (it && gt !== it) {
                    const bt = await this.switchChain({
                        chainId: it
                    }).catch(pt=>{
                        if (pt.code === UserRejectedRequestError.code)
                            throw pt;
                        return {
                            id: gt
                        }
                    }
                    );
                    gt = (bt == null ? void 0 : bt.id) ?? gt
                }
                return et && (await ((ft = nt.storage) == null ? void 0 : ft.removeItem(`${this.id}.disconnected`)),
                _e.target || await ((ht = nt.storage) == null ? void 0 : ht.setItem("injected.connected", !0))),
                {
                    accounts: ot,
                    chainId: gt
                }
            } catch (gt) {
                const bt = gt;
                throw bt.code === UserRejectedRequestError.code ? new UserRejectedRequestError(bt) : bt.code === ResourceUnavailableRpcError.code ? new ResourceUnavailableRpcError(bt) : bt
            }
        },
        async disconnect() {
            var st, at;
            const it = await this.getProvider();
            if (!it)
                throw new ProviderNotFoundError;
            it.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
            it.removeListener("chainChanged", this.onChainChanged),
            it.removeListener("disconnect", this.onDisconnect.bind(this)),
            it.on("connect", this.onConnect.bind(this)),
            et && (await ((st = nt.storage) == null ? void 0 : st.setItem(`${this.id}.disconnected`, !0)),
            _e.target || await ((at = nt.storage) == null ? void 0 : at.removeItem("injected.connected")))
        },
        async getAccounts() {
            const it = await this.getProvider();
            if (!it)
                throw new ProviderNotFoundError;
            return (await it.request({
                method: "eth_accounts"
            })).map(at=>getAddress(at))
        },
        async getChainId() {
            const it = await this.getProvider();
            if (!it)
                throw new ProviderNotFoundError;
            const st = await it.request({
                method: "eth_chainId"
            });
            return normalizeChainId(st)
        },
        async getProvider() {
            if (typeof window > "u")
                return;
            let it;
            const st = rt();
            return typeof st.provider == "function" ? it = st.provider(window) : typeof st.provider == "string" ? it = findProvider(window, st.provider) : it = st.provider,
            it && !it.removeListener && ("off"in it && typeof it.off == "function" ? it.removeListener = it.off : it.removeListener = ()=>{}
            ),
            it
        },
        async isAuthorized() {
            var it, st;
            try {
                if (et && await ((it = nt.storage) == null ? void 0 : it.getItem(`${this.id}.disconnected`)) || !_e.target && !await ((st = nt.storage) == null ? void 0 : st.getItem("injected.connected")))
                    return !1;
                if (!await this.getProvider()) {
                    if (tt !== void 0 && tt !== !1) {
                        const dt = async()=>(typeof window < "u" && window.removeEventListener("ethereum#initialized", dt),
                        !!await this.getProvider())
                          , ct = typeof tt == "number" ? tt : 1e3;
                        if (await Promise.race([...typeof window < "u" ? [new Promise(ft=>window.addEventListener("ethereum#initialized", ()=>ft(dt()), {
                            once: !0
                        }))] : [], new Promise(ft=>setTimeout(()=>ft(dt()), ct))]))
                            return !0
                    }
                    throw new ProviderNotFoundError
                }
                return !!(await withRetry(()=>withTimeout(()=>this.getAccounts(), {
                    timeout: 100
                }))).length
            } catch {
                return !1
            }
        },
        async switchChain({chainId: it}) {
            var ot, lt, dt;
            const st = await this.getProvider();
            if (!st)
                throw new ProviderNotFoundError;
            const at = nt.chains.find(ct=>ct.id === it);
            if (!at)
                throw new SwitchChainError(new ChainNotConfiguredError);
            try {
                return await Promise.all([st.request({
                    method: "wallet_switchEthereumChain",
                    params: [{
                        chainId: numberToHex(it)
                    }]
                }), new Promise(ct=>nt.emitter.once("change", ({chainId: ut})=>{
                    ut === it && ct()
                }
                ))]),
                at
            } catch (ct) {
                const ut = ct;
                if (ut.code === 4902 || ((lt = (ot = ut == null ? void 0 : ut.data) == null ? void 0 : ot.originalError) == null ? void 0 : lt.code) === 4902)
                    try {
                        const {default: ft, ...ht} = at.blockExplorers ?? {};
                        let gt = [];
                        if (ft && (gt = [ft.url, ...Object.values(ht).map(pt=>pt.url)]),
                        await st.request({
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: numberToHex(it),
                                chainName: at.name,
                                nativeCurrency: at.nativeCurrency,
                                rpcUrls: [((dt = at.rpcUrls.default) == null ? void 0 : dt.http[0]) ?? ""],
                                blockExplorerUrls: gt
                            }]
                        }),
                        await this.getChainId() !== it)
                            throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
                        return at
                    } catch (ft) {
                        throw new UserRejectedRequestError(ft)
                    }
                throw ut.code === UserRejectedRequestError.code ? new UserRejectedRequestError(ut) : new SwitchChainError(ut)
            }
        },
        async onAccountsChanged(it) {
            var st;
            if (it.length === 0)
                this.onDisconnect();
            else if (nt.emitter.listenerCount("connect")) {
                const at = (await this.getChainId()).toString();
                this.onConnect({
                    chainId: at
                }),
                et && await ((st = nt.storage) == null ? void 0 : st.removeItem(`${this.id}.disconnected`))
            } else
                nt.emitter.emit("change", {
                    accounts: it.map(at=>getAddress(at))
                })
        },
        onChainChanged(it) {
            const st = normalizeChainId(it);
            nt.emitter.emit("change", {
                chainId: st
            })
        },
        async onConnect(it) {
            const st = await this.getAccounts();
            if (st.length === 0)
                return;
            const at = normalizeChainId(it.chainId);
            nt.emitter.emit("connect", {
                accounts: st,
                chainId: at
            });
            const ot = await this.getProvider();
            ot && (ot.removeListener("connect", this.onConnect.bind(this)),
            ot.on("accountsChanged", this.onAccountsChanged.bind(this)),
            ot.on("chainChanged", this.onChainChanged),
            ot.on("disconnect", this.onDisconnect.bind(this)))
        },
        async onDisconnect(it) {
            const st = await this.getProvider();
            it && it.code === 1013 && st && (await this.getAccounts()).length || (nt.emitter.emit("disconnect"),
            st && (st.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
            st.removeListener("chainChanged", this.onChainChanged),
            st.removeListener("disconnect", this.onDisconnect.bind(this)),
            st.on("connect", this.onConnect.bind(this))))
        }
    })
}
function findProvider(_e, et) {
    function tt(nt) {
        return typeof et == "function" ? et(nt) : typeof et == "string" ? nt[et] : !0
    }
    const rt = _e.ethereum;
    if (rt != null && rt.providers)
        return rt.providers.find(nt=>tt(nt));
    if (rt && tt(rt))
        return rt
}
const size = 256;
let index$2 = size, buffer$1;
function uid(_e=11) {
    if (!buffer$1 || index$2 + _e > size * 2) {
        buffer$1 = "",
        index$2 = 0;
        for (let et = 0; et < size; et++)
            buffer$1 += (256 + Math.random() * 256 | 0).toString(16).substring(1)
    }
    return buffer$1.substring(index$2, index$2++ + _e)
}
function createConfig(_e) {
    const {multiInjectedProviderDiscovery: et=!0, storage: tt=createStorage({
        storage: typeof window < "u" && window.localStorage ? window.localStorage : noopStorage
    }), syncConnectedChain: rt=!0, ssr: nt, ...it} = _e
      , st = typeof window < "u" && et ? createStore$2() : void 0
      , at = createStore$1(()=>it.chains)
      , ot = createStore$1(()=>[...it.connectors ?? [], ...nt ? [] : (st == null ? void 0 : st.getProviders().map(dt)) ?? []].map(lt));
    function lt(vt) {
        var Et;
        const wt = createEmitter(uid())
          , _t = {
            ...vt({
                emitter: wt,
                chains: at.getState(),
                storage: tt
            }),
            emitter: wt,
            uid: wt.uid
        };
        return wt.on("connect", mt),
        (Et = _t.setup) == null || Et.call(_t),
        _t
    }
    function dt(vt) {
        const {info: wt} = vt
          , _t = vt.provider;
        return injected({
            target: {
                ...wt,
                id: wt.rdns,
                provider: _t
            }
        })
    }
    const ct = new Map;
    function ut(vt={}) {
        const wt = vt.chainId ?? bt.getState().chainId
          , _t = at.getState().find(xt=>xt.id === wt);
        if (vt.chainId && !_t)
            throw new ChainNotConfiguredError;
        {
            const xt = ct.get(bt.getState().chainId);
            if (xt && !_t)
                return xt;
            if (!_t)
                throw new ChainNotConfiguredError
        }
        {
            const xt = ct.get(wt);
            if (xt)
                return xt
        }
        let Et;
        if (it.client)
            Et = it.client({
                chain: _t
            });
        else {
            const xt = _t.id
              , Ct = at.getState().map(Nt=>Nt.id)
              , Tt = {}
              , It = Object.entries(it);
            for (const [Nt,Ft] of It)
                if (!(Nt === "chains" || Nt === "client" || Nt === "connectors" || Nt === "transports"))
                    if (typeof Ft == "object")
                        if (xt in Ft)
                            Tt[Nt] = Ft[xt];
                        else {
                            if (Ct.some(Mt=>Mt in Ft))
                                continue;
                            Tt[Nt] = Ft
                        }
                    else
                        Tt[Nt] = Ft;
            Et = createClient({
                ...Tt,
                chain: _t,
                batch: Tt.batch ?? {
                    multicall: !0
                },
                transport: Nt=>it.transports[xt]({
                    ...Nt,
                    connectors: ot
                })
            })
        }
        return ct.set(wt, Et),
        Et
    }
    function ft() {
        return {
            chainId: at.getState()[0].id,
            connections: new Map,
            current: void 0,
            status: "disconnected"
        }
    }
    let ht;
    const gt = "0.0.0-canary-";
    version$2.startsWith(gt) ? ht = parseInt(version$2.replace(gt, "")) : ht = parseInt(version$2.split(".")[0] ?? "0");
    const bt = createStore$1(subscribeWithSelector(tt ? persist(ft, {
        migrate(vt, wt) {
            if (wt === ht)
                return vt;
            const _t = ft()
              , Et = vt && typeof vt == "object" && "chainId"in vt && typeof vt.chainId == "number" ? vt.chainId : _t.chainId;
            return {
                ..._t,
                chainId: Et
            }
        },
        name: "store",
        partialize(vt) {
            return {
                connections: {
                    __type: "Map",
                    value: Array.from(vt.connections.entries()).map(([wt,_t])=>{
                        const {id: Et, name: xt, type: Ct, uid: Tt} = _t.connector;
                        return [wt, {
                            ..._t,
                            connector: {
                                id: Et,
                                name: xt,
                                type: Ct,
                                uid: Tt
                            }
                        }]
                    }
                    )
                },
                chainId: vt.chainId,
                current: vt.current
            }
        },
        skipHydration: nt,
        storage: tt,
        version: ht
    }) : ft));
    rt && bt.subscribe(({connections: vt, current: wt})=>{
        var _t;
        return wt ? (_t = vt.get(wt)) == null ? void 0 : _t.chainId : void 0
    }
    , vt=>{
        if (at.getState().some(_t=>_t.id === vt))
            return bt.setState(_t=>({
                ..._t,
                chainId: vt ?? _t.chainId
            }))
    }
    ),
    st == null || st.subscribe(vt=>{
        const wt = new Map;
        for (const Et of ot.getState())
            wt.set(Et.id, !0);
        const _t = [];
        for (const Et of vt) {
            const xt = lt(dt(Et));
            wt.has(xt.id) || _t.push(xt)
        }
        ot.setState(Et=>[...Et, ..._t], !0)
    }
    );
    function pt(vt) {
        bt.setState(wt=>{
            const _t = wt.connections.get(vt.uid);
            return _t ? {
                ...wt,
                connections: new Map(wt.connections).set(vt.uid, {
                    accounts: vt.accounts ?? _t.accounts,
                    chainId: vt.chainId ?? _t.chainId,
                    connector: _t.connector
                })
            } : wt
        }
        )
    }
    function mt(vt) {
        bt.getState().status === "connecting" || bt.getState().status === "reconnecting" || bt.setState(wt=>{
            const _t = ot.getState().find(Et=>Et.uid === vt.uid);
            return _t ? {
                ...wt,
                connections: new Map(wt.connections).set(vt.uid, {
                    accounts: vt.accounts,
                    chainId: vt.chainId,
                    connector: _t
                }),
                current: vt.uid,
                status: "connected"
            } : wt
        }
        )
    }
    function yt(vt) {
        bt.setState(wt=>{
            const _t = wt.connections.get(vt.uid);
            if (_t && (_t.connector.emitter.off("change", pt),
            _t.connector.emitter.off("disconnect", yt),
            _t.connector.emitter.on("connect", mt)),
            wt.connections.delete(vt.uid),
            wt.connections.size === 0)
                return {
                    ...wt,
                    connections: new Map,
                    current: void 0,
                    status: "disconnected"
                };
            const Et = wt.connections.values().next().value;
            return {
                ...wt,
                connections: new Map(wt.connections),
                current: Et.connector.uid
            }
        }
        )
    }
    return {
        get chains() {
            return at.getState()
        },
        get connectors() {
            return ot.getState()
        },
        storage: tt,
        getClient: ut,
        get state() {
            return bt.getState()
        },
        setState(vt) {
            let wt;
            typeof vt == "function" ? wt = vt(bt.getState()) : wt = vt;
            const _t = ft();
            typeof wt != "object" && (wt = _t),
            Object.keys(_t).some(xt=>!(xt in wt)) && (wt = _t),
            bt.setState(wt, !0)
        },
        subscribe(vt, wt, _t) {
            return bt.subscribe(vt, wt, _t ? {
                ..._t,
                fireImmediately: _t.emitImmediately
            } : void 0)
        },
        _internal: {
            mipd: st,
            store: bt,
            ssr: !!nt,
            syncConnectedChain: rt,
            transports: it.transports,
            chains: {
                setState(vt) {
                    const wt = typeof vt == "function" ? vt(at.getState()) : vt;
                    if (wt.length !== 0)
                        return at.setState(wt, !0)
                },
                subscribe(vt) {
                    return at.subscribe(vt)
                }
            },
            connectors: {
                providerDetailToConnector: dt,
                setup: lt,
                setState(vt) {
                    return ot.setState(typeof vt == "function" ? vt(ot.getState()) : vt, !0)
                },
                subscribe(vt) {
                    return ot.subscribe(vt)
                }
            },
            events: {
                change: pt,
                connect: mt,
                disconnect: yt
            }
        }
    }
}
function getAction(_e, et, tt) {
    const rt = _e[et.name ?? tt];
    return typeof rt == "function" ? rt : nt=>et(_e, nt)
}
async function connect(_e, et) {
    var rt;
    let tt;
    if (typeof et.connector == "function" ? tt = _e._internal.connectors.setup(et.connector) : tt = et.connector,
    tt.uid === _e.state.current)
        throw new ConnectorAlreadyConnectedError;
    try {
        _e.setState(st=>({
            ...st,
            status: "connecting"
        })),
        tt.emitter.emit("message", {
            type: "connecting"
        });
        const nt = await tt.connect({
            chainId: et.chainId
        })
          , it = nt.accounts;
        return tt.emitter.off("connect", _e._internal.events.connect),
        tt.emitter.on("change", _e._internal.events.change),
        tt.emitter.on("disconnect", _e._internal.events.disconnect),
        await ((rt = _e.storage) == null ? void 0 : rt.setItem("recentConnectorId", tt.id)),
        _e.setState(st=>({
            ...st,
            connections: new Map(st.connections).set(tt.uid, {
                accounts: it,
                chainId: nt.chainId,
                connector: tt
            }),
            current: tt.uid,
            status: "connected"
        })),
        {
            accounts: it,
            chainId: nt.chainId
        }
    } catch (nt) {
        throw _e.setState(it=>({
            ...it,
            status: it.current ? "connected" : "disconnected"
        })),
        nt
    }
}
async function disconnect(_e, et={}) {
    var nt, it;
    let tt;
    if (et.connector)
        tt = et.connector;
    else {
        const {connections: st, current: at} = _e.state
          , ot = st.get(at);
        tt = ot == null ? void 0 : ot.connector
    }
    const rt = _e.state.connections;
    tt && (await tt.disconnect(),
    tt.emitter.off("change", _e._internal.events.change),
    tt.emitter.off("disconnect", _e._internal.events.disconnect),
    tt.emitter.on("connect", _e._internal.events.connect),
    rt.delete(tt.uid)),
    _e.setState(st=>{
        if (rt.size === 0)
            return {
                ...st,
                connections: new Map,
                current: void 0,
                status: "disconnected"
            };
        const at = rt.values().next().value;
        return {
            ...st,
            connections: new Map(rt),
            current: at.connector.uid
        }
    }
    );
    {
        const st = _e.state.current;
        if (!st)
            return;
        const at = (nt = _e.state.connections.get(st)) == null ? void 0 : nt.connector;
        if (!at)
            return;
        await ((it = _e.storage) == null ? void 0 : it.setItem("recentConnectorId", at.id))
    }
}
async function getConnectorClient(_e, et={}) {
    let tt;
    if (et.connector) {
        const {connector: ot} = et
          , [lt,dt] = await Promise.all([ot.getAccounts(), ot.getChainId()]);
        tt = {
            accounts: lt,
            chainId: dt,
            connector: ot
        }
    } else
        tt = _e.state.connections.get(_e.state.current);
    if (!tt)
        throw new ConnectorNotConnectedError;
    const rt = et.chainId ?? tt.chainId
      , nt = tt.connector;
    if (nt.getClient)
        return nt.getClient({
            chainId: rt
        });
    const it = parseAccount(et.account ?? tt.accounts[0])
      , st = _e.chains.find(ot=>ot.id === rt)
      , at = await tt.connector.getProvider({
        chainId: rt
    });
    if (et.account && !tt.accounts.includes(it.address))
        throw new ConnectorAccountNotFoundError({
            address: it.address,
            connector: nt
        });
    return createClient({
        account: it,
        chain: st,
        name: "Connector Client",
        transport: ot=>custom$1(at)({
            ...ot,
            retryCount: 0
        })
    })
}
function getUnit(_e) {
    return typeof _e == "number" ? _e : _e === "wei" ? 0 : Math.abs(weiUnits[_e])
}
function getAccount(_e) {
    const et = _e.state.current
      , tt = _e.state.connections.get(et)
      , rt = tt == null ? void 0 : tt.accounts
      , nt = rt == null ? void 0 : rt[0]
      , it = _e.chains.find(at=>at.id === (tt == null ? void 0 : tt.chainId))
      , st = _e.state.status;
    switch (st) {
    case "connected":
        return {
            address: nt,
            addresses: rt,
            chain: it,
            chainId: tt == null ? void 0 : tt.chainId,
            connector: tt == null ? void 0 : tt.connector,
            isConnected: !0,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !1,
            status: st
        };
    case "reconnecting":
        return {
            address: nt,
            addresses: rt,
            chain: it,
            chainId: tt == null ? void 0 : tt.chainId,
            connector: tt == null ? void 0 : tt.connector,
            isConnected: !!nt,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !0,
            status: st
        };
    case "connecting":
        return {
            address: nt,
            addresses: rt,
            chain: it,
            chainId: tt == null ? void 0 : tt.chainId,
            connector: tt == null ? void 0 : tt.connector,
            isConnected: !1,
            isConnecting: !0,
            isDisconnected: !1,
            isReconnecting: !1,
            status: st
        };
    case "disconnected":
        return {
            address: void 0,
            addresses: void 0,
            chain: void 0,
            chainId: void 0,
            connector: void 0,
            isConnected: !1,
            isConnecting: !1,
            isDisconnected: !0,
            isReconnecting: !1,
            status: st
        }
    }
}
async function multicall(_e, et) {
    const {allowFailure: tt=!0, chainId: rt, contracts: nt, ...it} = et
      , st = _e.getClient({
        chainId: rt
    });
    return getAction(st, multicall$1, "multicall")({
        allowFailure: tt,
        contracts: nt,
        ...it
    })
}
function readContract(_e, et) {
    const {chainId: tt, ...rt} = et
      , nt = _e.getClient({
        chainId: tt
    });
    return getAction(nt, readContract$1, "readContract")(rt)
}
async function readContracts(_e, et) {
    const {allowFailure: tt=!0, blockNumber: rt, blockTag: nt, ...it} = et
      , st = et.contracts;
    try {
        const at = st.reduce((ct,ut,ft)=>{
            const ht = ut.chainId ?? _e.state.chainId;
            return {
                ...ct,
                [ht]: [...ct[ht] || [], {
                    contract: ut,
                    index: ft
                }]
            }
        }
        , {})
          , ot = ()=>Object.entries(at).map(([ct,ut])=>multicall(_e, {
            ...it,
            allowFailure: tt,
            blockNumber: rt,
            blockTag: nt,
            chainId: parseInt(ct),
            contracts: ut.map(({contract: ft})=>ft)
        }))
          , lt = (await Promise.all(ot())).flat()
          , dt = Object.values(at).flatMap(ct=>ct.map(({index: ut})=>ut));
        return lt.reduce((ct,ut,ft)=>(ct && (ct[dt[ft]] = ut),
        ct), [])
    } catch (at) {
        if (at instanceof ContractFunctionExecutionError)
            throw at;
        const ot = ()=>st.map(lt=>readContract(_e, {
            ...lt,
            blockNumber: rt,
            blockTag: nt
        }));
        return tt ? (await Promise.allSettled(ot())).map(lt=>lt.status === "fulfilled" ? {
            result: lt.value,
            status: "success"
        } : {
            error: lt.reason,
            result: void 0,
            status: "failure"
        }) : await Promise.all(ot())
    }
}
async function getBalance(_e, et) {
    const {address: tt, blockNumber: rt, blockTag: nt, chainId: it, token: st, unit: at="ether"} = et;
    if (st)
        try {
            return getTokenBalance(_e, {
                balanceAddress: tt,
                chainId: it,
                symbolType: "string",
                tokenAddress: st
            })
        } catch (ut) {
            if (ut instanceof ContractFunctionExecutionError) {
                const ft = await getTokenBalance(_e, {
                    balanceAddress: tt,
                    chainId: it,
                    symbolType: "bytes32",
                    tokenAddress: st
                })
                  , ht = hexToString(trim(ft.symbol, {
                    dir: "right"
                }));
                return {
                    ...ft,
                    symbol: ht
                }
            }
            throw ut
        }
    const ot = _e.getClient({
        chainId: it
    })
      , dt = await getAction(ot, getBalance$1, "getBalance")(rt ? {
        address: tt,
        blockNumber: rt
    } : {
        address: tt,
        blockTag: nt
    })
      , ct = _e.chains.find(ut=>ut.id === it) ?? ot.chain;
    return {
        decimals: ct.nativeCurrency.decimals,
        formatted: formatUnits(dt, getUnit(at)),
        symbol: ct.nativeCurrency.symbol,
        value: dt
    }
}
async function getTokenBalance(_e, et) {
    const {balanceAddress: tt, chainId: rt, symbolType: nt, tokenAddress: it, unit: st} = et
      , at = {
        abi: [{
            type: "function",
            name: "balanceOf",
            stateMutability: "view",
            inputs: [{
                type: "address"
            }],
            outputs: [{
                type: "uint256"
            }]
        }, {
            type: "function",
            name: "decimals",
            stateMutability: "view",
            inputs: [],
            outputs: [{
                type: "uint8"
            }]
        }, {
            type: "function",
            name: "symbol",
            stateMutability: "view",
            inputs: [],
            outputs: [{
                type: nt
            }]
        }],
        address: it
    }
      , [ot,lt,dt] = await readContracts(_e, {
        allowFailure: !1,
        contracts: [{
            ...at,
            functionName: "balanceOf",
            args: [tt],
            chainId: rt
        }, {
            ...at,
            functionName: "decimals",
            chainId: rt
        }, {
            ...at,
            functionName: "symbol",
            chainId: rt
        }]
    })
      , ct = formatUnits(ot ?? "0", getUnit(st ?? lt));
    return {
        decimals: lt,
        formatted: ct,
        symbol: dt,
        value: ot
    }
}
function getChainId(_e) {
    return _e.state.chainId
}
function deepEqual$1(_e, et) {
    if (_e === et)
        return !0;
    if (_e && et && typeof _e == "object" && typeof et == "object") {
        if (_e.constructor !== et.constructor)
            return !1;
        let tt, rt;
        if (Array.isArray(_e) && Array.isArray(et)) {
            if (tt = _e.length,
            tt !== et.length)
                return !1;
            for (rt = tt; rt-- !== 0; )
                if (!deepEqual$1(_e[rt], et[rt]))
                    return !1;
            return !0
        }
        if (_e.valueOf !== Object.prototype.valueOf)
            return _e.valueOf() === et.valueOf();
        if (_e.toString !== Object.prototype.toString)
            return _e.toString() === et.toString();
        const nt = Object.keys(_e);
        if (tt = nt.length,
        tt !== Object.keys(et).length)
            return !1;
        for (rt = tt; rt-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(et, nt[rt]))
                return !1;
        for (rt = tt; rt-- !== 0; ) {
            const it = nt[rt];
            if (it && !deepEqual$1(_e[it], et[it]))
                return !1
        }
        return !0
    }
    return _e !== _e && et !== et
}
let previousChains = [];
function getChains(_e) {
    const et = _e.chains;
    return deepEqual$1(previousChains, et) ? previousChains : (previousChains = et,
    et)
}
function getEnsAvatar(_e, et) {
    const {chainId: tt, ...rt} = et
      , nt = _e.getClient({
        chainId: tt
    });
    return getAction(nt, getEnsAvatar$1, "getEnsAvatar")(rt)
}
function getEnsName(_e, et) {
    const {chainId: tt, ...rt} = et
      , nt = _e.getClient({
        chainId: tt
    });
    return getAction(nt, getEnsName$1, "getEnsName")(rt)
}
let isReconnecting = !1;
async function reconnect(_e, et={}) {
    var lt, dt;
    if (isReconnecting)
        return [];
    isReconnecting = !0,
    _e.setState(ct=>({
        ...ct,
        status: ct.current ? "reconnecting" : "connecting"
    }));
    const tt = [];
    if ((lt = et.connectors) != null && lt.length)
        for (const ct of et.connectors) {
            let ut;
            typeof ct == "function" ? ut = _e._internal.connectors.setup(ct) : ut = ct,
            tt.push(ut)
        }
    else
        tt.push(..._e.connectors);
    let rt;
    try {
        rt = await ((dt = _e.storage) == null ? void 0 : dt.getItem("recentConnectorId"))
    } catch {}
    const nt = {};
    for (const [,ct] of _e.state.connections)
        nt[ct.connector.id] = 1;
    rt && (nt[rt] = 0);
    const it = Object.keys(nt).length > 0 ? [...tt].sort((ct,ut)=>(nt[ct.id] ?? 10) - (nt[ut.id] ?? 10)) : tt;
    let st = !1;
    const at = []
      , ot = [];
    for (const ct of it) {
        const ut = await ct.getProvider();
        if (!ut || ot.some(gt=>gt === ut) || !await ct.isAuthorized())
            continue;
        const ht = await ct.connect({
            isReconnecting: !0
        }).catch(()=>null);
        ht && (ct.emitter.off("connect", _e._internal.events.connect),
        ct.emitter.on("change", _e._internal.events.change),
        ct.emitter.on("disconnect", _e._internal.events.disconnect),
        _e.setState(gt=>{
            const bt = new Map(st ? gt.connections : new Map).set(ct.uid, {
                accounts: ht.accounts,
                chainId: ht.chainId,
                connector: ct
            });
            return {
                ...gt,
                current: st ? gt.current : ct.uid,
                connections: bt
            }
        }
        ),
        at.push({
            accounts: ht.accounts,
            chainId: ht.chainId,
            connector: ct
        }),
        ot.push(ut),
        st = !0)
    }
    return st ? _e.setState(ct=>({
        ...ct,
        status: "connected"
    })) : _e.setState(ct=>({
        ...ct,
        connections: new Map,
        current: void 0,
        status: "disconnected"
    })),
    isReconnecting = !1,
    at
}
async function signMessage(_e, et) {
    const {account: tt, connector: rt, ...nt} = et;
    let it;
    return typeof tt == "object" && tt.type === "local" ? it = _e.getClient() : it = await getConnectorClient(_e, {
        account: tt,
        connector: rt
    }),
    getAction(it, signMessage$1, "signMessage")({
        ...nt,
        ...tt ? {
            account: tt
        } : {}
    })
}
async function simulateContract(_e, et) {
    const {abi: tt, chainId: rt, connector: nt, ...it} = et;
    let st;
    et.account ? st = et.account : st = (await getConnectorClient(_e, {
        chainId: rt,
        connector: nt
    })).account;
    const at = _e.getClient({
        chainId: rt
    })
      , ot = getAction(at, simulateContract$1, "simulateContract")
      , {result: lt, request: dt} = await ot({
        ...it,
        abi: tt,
        account: st
    });
    return {
        chainId: at.chain.id,
        result: lt,
        request: {
            __mode: "prepared",
            ...dt,
            chainId: rt
        }
    }
}
async function switchChain(_e, et) {
    var it;
    const {chainId: tt} = et
      , rt = _e.state.connections.get(((it = et.connector) == null ? void 0 : it.uid) ?? _e.state.current);
    if (rt) {
        const st = rt.connector;
        if (!st.switchChain)
            throw new SwitchChainNotSupportedError({
                connector: st
            });
        return await st.switchChain({
            chainId: tt
        })
    }
    const nt = _e.chains.find(st=>st.id === tt);
    if (!nt)
        throw new ChainNotConfiguredError;
    return _e.setState(st=>({
        ...st,
        chainId: tt
    })),
    nt
}
function watchAccount(_e, et) {
    const {onChange: tt} = et;
    return _e.subscribe(()=>getAccount(_e), tt, {
        equalityFn(rt, nt) {
            const {connector: it, ...st} = rt
              , {connector: at, ...ot} = nt;
            return deepEqual$1(st, ot) && (it == null ? void 0 : it.id) === (at == null ? void 0 : at.id) && (it == null ? void 0 : it.uid) === (at == null ? void 0 : at.uid)
        }
    })
}
function watchChainId(_e, et) {
    const {onChange: tt} = et;
    return _e.subscribe(rt=>rt.chainId, tt)
}
function watchConnectors(_e, et) {
    const {onChange: tt} = et;
    return _e._internal.connectors.subscribe((rt,nt)=>{
        tt(Object.values(rt), nt)
    }
    )
}
async function waitForTransactionReceipt(_e, et) {
    const {chainId: tt, timeout: rt=0, ...nt} = et
      , it = _e.getClient({
        chainId: tt
    })
      , at = await getAction(it, waitForTransactionReceipt$1, "waitForTransactionReceipt")({
        ...nt,
        timeout: rt
    });
    if (at.status === "reverted") {
        const lt = await getAction(it, getTransaction, "getTransaction")({
            hash: at.transactionHash
        })
          , ct = await getAction(it, call, "call")({
            ...lt,
            gasPrice: lt.type !== "eip1559" ? lt.gasPrice : void 0,
            maxFeePerGas: lt.type === "eip1559" ? lt.maxFeePerGas : void 0,
            maxPriorityFeePerGas: lt.type === "eip1559" ? lt.maxPriorityFeePerGas : void 0
        })
          , ut = hexToString(`0x${ct.substring(138)}`);
        throw new Error(ut)
    }
    return {
        ...at,
        chainId: it.chain.id
    }
}
async function writeContract(_e, et) {
    const {account: tt, chainId: rt, connector: nt, __mode: it, ...st} = et;
    let at;
    typeof tt == "object" && tt.type === "local" ? at = _e.getClient({
        chainId: rt
    }) : at = await getConnectorClient(_e, {
        account: tt,
        chainId: rt,
        connector: nt
    });
    let ot;
    if (it === "prepared")
        ot = st;
    else {
        const {request: ct} = await simulateContract(_e, {
            ...st,
            account: tt
        });
        ot = ct
    }
    return await getAction(at, writeContract$1, "writeContract")({
        ...ot,
        ...tt ? {
            account: tt
        } : {},
        chain: rt ? {
            id: rt
        } : null
    })
}
function hydrate(_e, et) {
    const {initialState: tt, reconnectOnMount: rt} = et;
    return tt && _e.setState({
        ...tt,
        connections: rt ? tt.connections : new Map,
        status: rt ? "reconnecting" : "disconnected"
    }),
    {
        async onMount() {
            var nt;
            if (_e._internal.ssr) {
                await _e._internal.store.persist.rehydrate();
                const it = (nt = _e._internal.mipd) == null ? void 0 : nt.getProviders().map(_e._internal.connectors.providerDetailToConnector).map(_e._internal.connectors.setup);
                _e._internal.connectors.setState(st=>[...st, ...it ?? []])
            }
            rt ? reconnect(_e) : _e.storage && _e.setState(it=>({
                ...it,
                connections: new Map
            }))
        }
    }
}
const bsc = defineChain({
    id: 97,
    name: "BNB Smart Chain",
    nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "BNB"
    },
    rpcUrls: {
        default: {
            http: ["https://chain-proxy.wallet.coinbase.com?targetName=bsc-testnet"]
        }
    },
    blockExplorers: {
        default: {
            name: "BscScan",
            url: "https://bscscan.com",
            apiUrl: "https://api.bscscan.com/api"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 15921452
        }
    }
})
  , mainnet = defineChain({
    id: 97,
    name: "BNB Smart Chain",
    nativeCurrency: {
        name: "BNB",
        symbol: "BNB",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: ["https://chain-proxy.wallet.coinbase.com?targetName=bsc-testnet"]
        }
    },
    blockExplorers: {
        default: {
            name: "BscScan",
            url: "https://bscscan.com",
            apiUrl: "https://api.bscscan.com/api"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0x8cab227b1162f03b8338331adaad7aadc83b895e",
            blockCreated: 18958930
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
})
  , t$9 = Symbol()
  , s$8 = Object.getPrototypeOf
  , c$8 = new WeakMap
  , l$5 = _e=>_e && (c$8.has(_e) ? c$8.get(_e) : s$8(_e) === Object.prototype || s$8(_e) === Array.prototype)
  , y$4 = _e=>l$5(_e) && _e[t$9] || null
  , h$b = (_e,et=!0)=>{
    c$8.set(_e, et)
}
;
var define_import_meta_env_default = {
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
const isObject$4 = _e=>typeof _e == "object" && _e !== null
  , proxyStateMap = new WeakMap
  , refSet = new WeakSet
  , buildProxyFunction = (_e=Object.is,et=(lt,dt)=>new Proxy(lt,dt),tt=lt=>isObject$4(lt) && !refSet.has(lt) && (Array.isArray(lt) || !(Symbol.iterator in lt)) && !(lt instanceof WeakMap) && !(lt instanceof WeakSet) && !(lt instanceof Error) && !(lt instanceof Number) && !(lt instanceof Date) && !(lt instanceof String) && !(lt instanceof RegExp) && !(lt instanceof ArrayBuffer),rt=lt=>{
    switch (lt.status) {
    case "fulfilled":
        return lt.value;
    case "rejected":
        throw lt.reason;
    default:
        throw lt
    }
}
,nt=new WeakMap,it=(lt,dt,ct=rt)=>{
    const ut = nt.get(lt);
    if ((ut == null ? void 0 : ut[0]) === dt)
        return ut[1];
    const ft = Array.isArray(lt) ? [] : Object.create(Object.getPrototypeOf(lt));
    return h$b(ft, !0),
    nt.set(lt, [dt, ft]),
    Reflect.ownKeys(lt).forEach(ht=>{
        if (Object.getOwnPropertyDescriptor(ft, ht))
            return;
        const gt = Reflect.get(lt, ht)
          , bt = {
            value: gt,
            enumerable: !0,
            configurable: !0
        };
        if (refSet.has(gt))
            h$b(gt, !1);
        else if (gt instanceof Promise)
            delete bt.value,
            bt.get = ()=>ct(gt);
        else if (proxyStateMap.has(gt)) {
            const [pt,mt] = proxyStateMap.get(gt);
            bt.value = it(pt, mt(), ct)
        }
        Object.defineProperty(ft, ht, bt)
    }
    ),
    Object.preventExtensions(ft)
}
,st=new WeakMap,at=[1, 1],ot=lt=>{
    if (!isObject$4(lt))
        throw new Error("object required");
    const dt = st.get(lt);
    if (dt)
        return dt;
    let ct = at[0];
    const ut = new Set
      , ft = (Ct,Tt=++at[0])=>{
        ct !== Tt && (ct = Tt,
        ut.forEach(It=>It(Ct, Tt)))
    }
    ;
    let ht = at[1];
    const gt = (Ct=++at[1])=>(ht !== Ct && !ut.size && (ht = Ct,
    pt.forEach(([Tt])=>{
        const It = Tt[1](Ct);
        It > ct && (ct = It)
    }
    )),
    ct)
      , bt = Ct=>(Tt,It)=>{
        const Nt = [...Tt];
        Nt[1] = [Ct, ...Nt[1]],
        ft(Nt, It)
    }
      , pt = new Map
      , mt = (Ct,Tt)=>{
        if ((define_import_meta_env_default ? "production" : void 0) !== "production" && pt.has(Ct))
            throw new Error("prop listener already exists");
        if (ut.size) {
            const It = Tt[3](bt(Ct));
            pt.set(Ct, [Tt, It])
        } else
            pt.set(Ct, [Tt])
    }
      , yt = Ct=>{
        var Tt;
        const It = pt.get(Ct);
        It && (pt.delete(Ct),
        (Tt = It[1]) == null || Tt.call(It))
    }
      , vt = Ct=>(ut.add(Ct),
    ut.size === 1 && pt.forEach(([It,Nt],Ft)=>{
        if ((define_import_meta_env_default ? "production" : void 0) !== "production" && Nt)
            throw new Error("remove already exists");
        const Lt = It[3](bt(Ft));
        pt.set(Ft, [It, Lt])
    }
    ),
    ()=>{
        ut.delete(Ct),
        ut.size === 0 && pt.forEach(([It,Nt],Ft)=>{
            Nt && (Nt(),
            pt.set(Ft, [It]))
        }
        )
    }
    )
      , wt = Array.isArray(lt) ? [] : Object.create(Object.getPrototypeOf(lt))
      , Et = et(wt, {
        deleteProperty(Ct, Tt) {
            const It = Reflect.get(Ct, Tt);
            yt(Tt);
            const Nt = Reflect.deleteProperty(Ct, Tt);
            return Nt && ft(["delete", [Tt], It]),
            Nt
        },
        set(Ct, Tt, It, Nt) {
            const Ft = Reflect.has(Ct, Tt)
              , Lt = Reflect.get(Ct, Tt, Nt);
            if (Ft && (_e(Lt, It) || st.has(It) && _e(Lt, st.get(It))))
                return !0;
            yt(Tt),
            isObject$4(It) && (It = y$4(It) || It);
            let Mt = It;
            if (It instanceof Promise)
                It.then($t=>{
                    It.status = "fulfilled",
                    It.value = $t,
                    ft(["resolve", [Tt], $t])
                }
                ).catch($t=>{
                    It.status = "rejected",
                    It.reason = $t,
                    ft(["reject", [Tt], $t])
                }
                );
            else {
                !proxyStateMap.has(It) && tt(It) && (Mt = ot(It));
                const $t = !refSet.has(Mt) && proxyStateMap.get(Mt);
                $t && mt(Tt, $t)
            }
            return Reflect.set(Ct, Tt, Mt, Nt),
            ft(["set", [Tt], It, Lt]),
            !0
        }
    });
    st.set(lt, Et);
    const xt = [wt, gt, it, vt];
    return proxyStateMap.set(Et, xt),
    Reflect.ownKeys(lt).forEach(Ct=>{
        const Tt = Object.getOwnPropertyDescriptor(lt, Ct);
        "value"in Tt && (Et[Ct] = lt[Ct],
        delete Tt.value,
        delete Tt.writable),
        Object.defineProperty(wt, Ct, Tt)
    }
    ),
    Et
}
)=>[ot, proxyStateMap, refSet, _e, et, tt, rt, nt, it, st, at]
  , [defaultProxyFunction] = buildProxyFunction();
function proxy(_e={}) {
    return defaultProxyFunction(_e)
}
function subscribe(_e, et, tt) {
    const rt = proxyStateMap.get(_e);
    (define_import_meta_env_default ? "production" : void 0) !== "production" && !rt && console.warn("Please use proxy object");
    let nt;
    const it = []
      , st = rt[3];
    let at = !1;
    const lt = st(dt=>{
        if (it.push(dt),
        tt) {
            et(it.splice(0));
            return
        }
        nt || (nt = Promise.resolve().then(()=>{
            nt = void 0,
            at && et(it.splice(0))
        }
        ))
    }
    );
    return at = !0,
    ()=>{
        at = !1,
        lt()
    }
}
function snapshot(_e, et) {
    const tt = proxyStateMap.get(_e);
    (define_import_meta_env_default ? "production" : void 0) !== "production" && !tt && console.warn("Please use proxy object");
    const [rt,nt,it] = tt;
    return it(rt, nt(), et)
}
function ref(_e) {
    return refSet.add(_e),
    _e
}
function subscribeKey(_e, et, tt, rt) {
    let nt = _e[et];
    return subscribe(_e, ()=>{
        const it = _e[et];
        Object.is(nt, it) || tt(nt = it)
    }
    , rt)
}
var shim = {
    exports: {}
}
  , useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$b = reactExports;
function h$a(_e, et) {
    return _e === et && (_e !== 0 || 1 / _e === 1 / et) || _e !== _e && et !== et
}
var k$2 = typeof Object.is == "function" ? Object.is : h$a
  , l$4 = e$b.useState
  , m$2 = e$b.useEffect
  , n$e = e$b.useLayoutEffect
  , p$6 = e$b.useDebugValue;
function q$2(_e, et) {
    var tt = et()
      , rt = l$4({
        inst: {
            value: tt,
            getSnapshot: et
        }
    })
      , nt = rt[0].inst
      , it = rt[1];
    return n$e(function() {
        nt.value = tt,
        nt.getSnapshot = et,
        r$g(nt) && it({
            inst: nt
        })
    }, [_e, tt, et]),
    m$2(function() {
        return r$g(nt) && it({
            inst: nt
        }),
        _e(function() {
            r$g(nt) && it({
                inst: nt
            })
        })
    }, [_e]),
    p$6(tt),
    tt
}
function r$g(_e) {
    var et = _e.getSnapshot;
    _e = _e.value;
    try {
        var tt = et();
        return !k$2(_e, tt)
    } catch {
        return !0
    }
}
function t$8(_e, et) {
    return et()
}
var u$6 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? t$8 : q$2;
useSyncExternalStoreShim_production_min.useSyncExternalStore = e$b.useSyncExternalStore !== void 0 ? e$b.useSyncExternalStore : u$6;
shim.exports = useSyncExternalStoreShim_production_min;
var shimExports = shim.exports;
const SECURE_SITE = "https://secure.walletconnect.com"
  , ONRAMP_PROVIDERS = [{
    label: "Coinbase",
    name: "coinbase",
    feeRange: "1-2%",
    url: ""
}]
  , ConstantsUtil$1 = {
    FOUR_MINUTES_MS: 24e4,
    TEN_SEC_MS: 1e4,
    ONE_SEC_MS: 1e3,
    SECURE_SITE,
    SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
    SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
    RESTRICTED_TIMEZONES: ["ASIA/SHANGHAI", "ASIA/URUMQI", "ASIA/CHONGQING", "ASIA/HARBIN", "ASIA/KASHGAR", "ASIA/MACAU", "ASIA/HONG_KONG", "ASIA/MACAO", "ASIA/BEIJING", "ASIA/HARBIN"],
    CONNECTOR_RDNS_MAP: {
        coinbaseWallet: "com.coinbase.wallet"
    },
    WC_COINBASE_PAY_SDK_CHAINS: ["ethereum", "arbitrum", "polygon", "avalanche-c-chain", "optimism", "celo"],
    WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
    WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
        Ethereum: "ethereum",
        "Arbitrum One": "arbitrum",
        Polygon: "polygon",
        Avalanche: "avalanche-c-chain",
        "OP Mainnet": "optimism",
        Celo: "celo"
    },
    WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e"
}
  , CoreHelperUtil = {
    isMobile() {
        return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1
    },
    isAndroid() {
        const _e = window.navigator.userAgent.toLowerCase();
        return CoreHelperUtil.isMobile() && _e.includes("android")
    },
    isIos() {
        const _e = window.navigator.userAgent.toLowerCase();
        return CoreHelperUtil.isMobile() && (_e.includes("iphone") || _e.includes("ipad"))
    },
    isClient() {
        return typeof window < "u"
    },
    isPairingExpired(_e) {
        return _e ? _e - Date.now() <= ConstantsUtil$1.TEN_SEC_MS : !0
    },
    isAllowedRetry(_e) {
        return Date.now() - _e >= ConstantsUtil$1.ONE_SEC_MS
    },
    copyToClopboard(_e) {
        navigator.clipboard.writeText(_e)
    },
    getPairingExpiry() {
        return Date.now() + ConstantsUtil$1.FOUR_MINUTES_MS
    },
    getPlainAddress(_e) {
        return _e.split(":")[2]
    },
    async wait(_e) {
        return new Promise(et=>{
            setTimeout(et, _e)
        }
        )
    },
    debounce(_e, et=500) {
        let tt;
        return (...rt)=>{
            function nt() {
                _e(...rt)
            }
            tt && clearTimeout(tt),
            tt = setTimeout(nt, et)
        }
    },
    isHttpUrl(_e) {
        return _e.startsWith("http://") || _e.startsWith("https://")
    },
    formatNativeUrl(_e, et) {
        if (CoreHelperUtil.isHttpUrl(_e))
            return this.formatUniversalUrl(_e, et);
        let tt = _e;
        tt.includes("://") || (tt = _e.replaceAll("/", "").replaceAll(":", ""),
        tt = `${tt}://`),
        tt.endsWith("/") || (tt = `${tt}/`);
        const rt = encodeURIComponent(et);
        return {
            redirect: `${tt}wc?uri=${rt}`,
            href: tt
        }
    },
    formatUniversalUrl(_e, et) {
        if (!CoreHelperUtil.isHttpUrl(_e))
            return this.formatNativeUrl(_e, et);
        let tt = _e;
        tt.endsWith("/") || (tt = `${tt}/`);
        const rt = encodeURIComponent(et);
        return {
            redirect: `${tt}wc?uri=${rt}`,
            href: tt
        }
    },
    openHref(_e, et, tt) {
        window.open(_e, et, tt || "noreferrer noopener")
    },
    async preloadImage(_e) {
        const et = new Promise((tt,rt)=>{
            const nt = new Image;
            nt.onload = tt,
            nt.onerror = rt,
            nt.crossOrigin = "anonymous",
            nt.src = _e
        }
        );
        return Promise.race([et, CoreHelperUtil.wait(2e3)])
    },
    formatBalance(_e, et) {
        var rt;
        let tt;
        if (_e === "0")
            tt = "0.000";
        else if (typeof _e == "string") {
            const nt = Number(_e);
            nt && (tt = (rt = nt.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : rt[0])
        }
        return tt ? `${tt} ${et ?? ""}` : `0.000 ${et ?? ""}`
    },
    formatBalance2(_e, et) {
        var rt;
        let tt;
        if (_e === "0")
            tt = "0";
        else if (typeof _e == "string") {
            const nt = Number(_e);
            nt && (tt = (rt = nt.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : rt[0])
        }
        return {
            value: tt ?? "0",
            rest: tt === "0" ? "000" : "",
            symbol: et
        }
    },
    isRestrictedRegion() {
        try {
            const {timeZone: _e} = new Intl.DateTimeFormat().resolvedOptions()
              , et = _e.toUpperCase();
            return ConstantsUtil$1.RESTRICTED_TIMEZONES.includes(et)
        } catch {
            return !1
        }
    },
    getApiUrl() {
        return CoreHelperUtil.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com"
    },
    getBlockchainApiUrl() {
        return CoreHelperUtil.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com"
    },
    getAnalyticsUrl() {
        return CoreHelperUtil.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com"
    },
    getUUID() {
        return crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, _e=>{
            const et = Math.random() * 16 | 0;
            return (_e === "x" ? et : et & 3 | 8).toString(16)
        }
        )
    },
    parseError(_e) {
        var et, tt;
        return typeof _e == "string" ? _e : typeof ((tt = (et = _e == null ? void 0 : _e.issues) == null ? void 0 : et[0]) == null ? void 0 : tt.message) == "string" ? _e.issues[0].message : _e instanceof Error ? _e.message : "Unknown error"
    },
    sortRequestedNetworks(_e, et=[]) {
        const tt = {};
        return et && _e && (_e.forEach((rt,nt)=>{
            tt[rt] = nt
        }
        ),
        et.sort((rt,nt)=>{
            const it = tt[rt.id]
              , st = tt[nt.id];
            return it !== void 0 && st !== void 0 ? it - st : it !== void 0 ? -1 : st !== void 0 ? 1 : 0
        }
        )),
        et
    }
}
  , state$f = proxy({
    isConnected: !1
})
  , AccountController = {
    state: state$f,
    subscribe(_e) {
        return subscribe(state$f, ()=>_e(state$f))
    },
    subscribeKey(_e, et) {
        return subscribeKey(state$f, _e, et)
    },
    setIsConnected(_e) {
        state$f.isConnected = _e
    },
    setCaipAddress(_e) {
        state$f.caipAddress = _e,
        state$f.address = _e ? CoreHelperUtil.getPlainAddress(_e) : void 0
    },
    setBalance(_e, et) {
        state$f.balance = _e,
        state$f.balanceSymbol = et
    },
    setProfileName(_e) {
        state$f.profileName = _e
    },
    setProfileImage(_e) {
        state$f.profileImage = _e
    },
    setAddressExplorerUrl(_e) {
        state$f.addressExplorerUrl = _e
    },
    resetAccount() {
        state$f.isConnected = !1,
        state$f.caipAddress = void 0,
        state$f.address = void 0,
        state$f.balance = void 0,
        state$f.balanceSymbol = void 0,
        state$f.profileName = void 0,
        state$f.profileImage = void 0,
        state$f.addressExplorerUrl = void 0
    }
};
class FetchUtil {
    constructor({baseUrl: et}) {
        this.baseUrl = et
    }
    async get({headers: et, signal: tt, ...rt}) {
        const nt = this.createUrl(rt);
        return (await fetch(nt, {
            method: "GET",
            headers: et,
            signal: tt,
            cache: "no-cache"
        })).json()
    }
    async getBlob({headers: et, signal: tt, ...rt}) {
        const nt = this.createUrl(rt);
        return (await fetch(nt, {
            method: "GET",
            headers: et,
            signal: tt
        })).blob()
    }
    async post({body: et, headers: tt, signal: rt, ...nt}) {
        const it = this.createUrl(nt);
        return (await fetch(it, {
            method: "POST",
            headers: tt,
            body: et ? JSON.stringify(et) : void 0,
            signal: rt
        })).json()
    }
    async put({body: et, headers: tt, signal: rt, ...nt}) {
        const it = this.createUrl(nt);
        return (await fetch(it, {
            method: "PUT",
            headers: tt,
            body: et ? JSON.stringify(et) : void 0,
            signal: rt
        })).json()
    }
    async delete({body: et, headers: tt, signal: rt, ...nt}) {
        const it = this.createUrl(nt);
        return (await fetch(it, {
            method: "DELETE",
            headers: tt,
            body: et ? JSON.stringify(et) : void 0,
            signal: rt
        })).json()
    }
    createUrl({path: et, params: tt}) {
        const rt = new URL(et,this.baseUrl);
        return tt && Object.entries(tt).forEach(([nt,it])=>{
            it && rt.searchParams.append(nt, it)
        }
        ),
        rt
    }
}
const WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE"
  , W3M_RECENT = "@w3m/recent"
  , W3M_CONNECTED_WALLET_IMAGE_URL = "@w3m/connected_wallet_image_url"
  , W3M_CONNECTED_CONNECTOR = "@w3m/connected_connector"
  , StorageUtil = {
    setWalletConnectDeepLink({href: _e, name: et}) {
        try {
            localStorage.setItem(WC_DEEPLINK, JSON.stringify({
                href: _e,
                name: et
            }))
        } catch {
            console.info("Unable to set WalletConnect deep link")
        }
    },
    getWalletConnectDeepLink() {
        try {
            const _e = localStorage.getItem(WC_DEEPLINK);
            if (_e)
                return JSON.parse(_e)
        } catch {
            console.info("Unable to get WalletConnect deep link")
        }
    },
    deleteWalletConnectDeepLink() {
        try {
            localStorage.removeItem(WC_DEEPLINK)
        } catch {
            console.info("Unable to delete WalletConnect deep link")
        }
    },
    setWeb3ModalRecent(_e) {
        try {
            const et = StorageUtil.getRecentWallets();
            et.find(rt=>rt.id === _e.id) || (et.unshift(_e),
            et.length > 2 && et.pop(),
            localStorage.setItem(W3M_RECENT, JSON.stringify(et)))
        } catch {
            console.info("Unable to set Web3Modal recent")
        }
    },
    getRecentWallets() {
        try {
            const _e = localStorage.getItem(W3M_RECENT);
            return _e ? JSON.parse(_e) : []
        } catch {
            console.info("Unable to get Web3Modal recent")
        }
        return []
    },
    setConnectedWalletImageUrl(_e) {
        try {
            localStorage.setItem(W3M_CONNECTED_WALLET_IMAGE_URL, _e)
        } catch {
            console.info("Unable to set Connected Wallet Image Url")
        }
    },
    getConnectedWalletImageUrl() {
        try {
            return localStorage.getItem(W3M_CONNECTED_WALLET_IMAGE_URL)
        } catch {
            console.info("Unable to set Connected Wallet Image Url")
        }
    },
    setConnectedConnector(_e) {
        try {
            localStorage.setItem(W3M_CONNECTED_CONNECTOR, _e)
        } catch {
            console.info("Unable to set Connected Connector")
        }
    },
    getConnectedConnector() {
        try {
            return localStorage.getItem(W3M_CONNECTED_CONNECTOR)
        } catch {
            console.info("Unable to get Connected Connector")
        }
    }
}
  , state$e = proxy({
    walletImages: {},
    networkImages: {},
    connectorImages: {},
    tokenImages: {},
    currencyImages: {}
})
  , AssetController = {
    state: state$e,
    subscribeNetworkImages(_e) {
        return subscribe(state$e.networkImages, ()=>_e(state$e.networkImages))
    },
    subscribeKey(_e, et) {
        return subscribeKey(state$e, _e, et)
    },
    subscribe(_e) {
        return subscribe(state$e, ()=>_e(state$e))
    },
    setWalletImage(_e, et) {
        state$e.walletImages[_e] = et
    },
    setNetworkImage(_e, et) {
        state$e.networkImages[_e] = et
    },
    setConnectorImage(_e, et) {
        state$e.connectorImages[_e] = et
    },
    setTokenImage(_e, et) {
        state$e.tokenImages[_e] = et
    },
    setCurrencyImage(_e, et) {
        state$e.currencyImages[_e] = et
    }
}
  , state$d = proxy({
    projectId: "",
    sdkType: "w3m",
    sdkVersion: "html-wagmi-undefined"
})
  , OptionsController = {
    state: state$d,
    subscribeKey(_e, et) {
        return subscribeKey(state$d, _e, et)
    },
    setProjectId(_e) {
        state$d.projectId = _e
    },
    setAllWallets(_e) {
        state$d.allWallets = _e
    },
    setIncludeWalletIds(_e) {
        state$d.includeWalletIds = _e
    },
    setExcludeWalletIds(_e) {
        state$d.excludeWalletIds = _e
    },
    setFeaturedWalletIds(_e) {
        state$d.featuredWalletIds = _e
    },
    setTokens(_e) {
        state$d.tokens = _e
    },
    setTermsConditionsUrl(_e) {
        state$d.termsConditionsUrl = _e
    },
    setPrivacyPolicyUrl(_e) {
        state$d.privacyPolicyUrl = _e
    },
    setCustomWallets(_e) {
        state$d.customWallets = _e
    },
    setEnableAnalytics(_e) {
        state$d.enableAnalytics = _e
    },
    setSdkVersion(_e) {
        state$d.sdkVersion = _e
    },
    setMetadata(_e) {
        state$d.metadata = _e
    },
    setOnrampEnabled(_e) {
        state$d.enableOnramp = _e
    }
}
  , state$c = proxy({
    themeMode: "dark",
    themeVariables: {}
})
  , ThemeController = {
    state: state$c,
    subscribe(_e) {
        return subscribe(state$c, ()=>_e(state$c))
    },
    setThemeMode(_e) {
        state$c.themeMode = _e;
        try {
            const et = ConnectorController.getEmailConnector();
            et && et.provider.syncTheme({
                themeMode: ThemeController.getSnapshot().themeMode
            })
        } catch {
            console.info("Unable to sync theme to email connector")
        }
    },
    setThemeVariables(_e) {
        state$c.themeVariables = {
            ...state$c.themeVariables,
            ..._e
        };
        try {
            const et = ConnectorController.getEmailConnector();
            et && et.provider.syncTheme({
                themeVariables: ThemeController.getSnapshot().themeVariables
            })
        } catch {
            console.info("Unable to sync theme to email connector")
        }
    },
    getSnapshot() {
        return snapshot(state$c)
    }
}
  , state$b = proxy({
    connectors: []
})
  , ConnectorController = {
    state: state$b,
    subscribeKey(_e, et) {
        return subscribeKey(state$b, _e, et)
    },
    setConnectors(_e) {
        state$b.connectors = _e.map(et=>ref(et))
    },
    addConnector(_e) {
        var et, tt;
        if (state$b.connectors.push(ref(_e)),
        _e.id === "w3mEmail") {
            const rt = _e
              , nt = snapshot(OptionsController.state);
            (tt = (et = rt == null ? void 0 : rt.provider) == null ? void 0 : et.syncDappData) == null || tt.call(et, {
                metadata: nt.metadata,
                sdkVersion: nt.sdkVersion,
                projectId: nt.projectId
            }),
            rt.provider.syncTheme({
                themeMode: ThemeController.getSnapshot().themeMode,
                themeVariables: ThemeController.getSnapshot().themeVariables
            })
        }
    },
    getEmailConnector() {
        return state$b.connectors.find(_e=>_e.type === "EMAIL")
    },
    getAnnouncedConnectorRdns() {
        return state$b.connectors.filter(_e=>_e.type === "ANNOUNCED").map(_e=>{
            var et;
            return (et = _e.info) == null ? void 0 : et.rdns
        }
        )
    },
    getConnectors() {
        return state$b.connectors
    }
}
  , state$a = proxy({
    open: !1,
    selectedNetworkId: void 0
})
  , PublicStateController = {
    state: state$a,
    subscribe(_e) {
        return subscribe(state$a, ()=>_e(state$a))
    },
    set(_e) {
        Object.assign(state$a, {
            ...state$a,
            ..._e
        })
    }
}
  , baseUrl$2 = CoreHelperUtil.getAnalyticsUrl()
  , api$2 = new FetchUtil({
    baseUrl: baseUrl$2
})
  , excluded = ["MODAL_CREATED"]
  , state$9 = proxy({
    timestamp: Date.now(),
    data: {
        type: "track",
        event: "MODAL_CREATED"
    }
})
  , EventsController = {
    state: state$9,
    subscribe(_e) {
        return subscribe(state$9, ()=>_e(state$9))
    },
    _getApiHeaders() {
        const {projectId: _e, sdkType: et, sdkVersion: tt} = OptionsController.state;
        return {
            "x-project-id": _e,
            "x-sdk-type": et,
            "x-sdk-version": tt
        }
    },
    async _sendAnalyticsEvent(_e) {
        try {
            if (excluded.includes(_e.data.event) || typeof window > "u")
                return;
            await api$2.post({
                path: "/e",
                headers: EventsController._getApiHeaders(),
                body: {
                    eventId: CoreHelperUtil.getUUID(),
                    url: window.location.href,
                    domain: window.location.hostname,
                    timestamp: _e.timestamp,
                    props: _e.data
                }
            })
        } catch {}
    },
    sendEvent(_e) {
        state$9.timestamp = Date.now(),
        state$9.data = _e,
        OptionsController.state.enableAnalytics && EventsController._sendAnalyticsEvent(state$9)
    }
}
  , state$8 = proxy({
    supportsAllNetworks: !0,
    isDefaultCaipNetwork: !1
})
  , NetworkController = {
    state: state$8,
    subscribeKey(_e, et) {
        return subscribeKey(state$8, _e, et)
    },
    _getClient() {
        if (!state$8._client)
            throw new Error("NetworkController client not set");
        return state$8._client
    },
    setClient(_e) {
        state$8._client = ref(_e)
    },
    setCaipNetwork(_e) {
        state$8.caipNetwork = _e,
        PublicStateController.set({
            selectedNetworkId: _e == null ? void 0 : _e.id
        }),
        this.checkIfSupportedNetwork()
    },
    setDefaultCaipNetwork(_e) {
        state$8.caipNetwork = _e,
        PublicStateController.set({
            selectedNetworkId: _e == null ? void 0 : _e.id
        }),
        state$8.isDefaultCaipNetwork = !0
    },
    setRequestedCaipNetworks(_e) {
        state$8.requestedCaipNetworks = _e
    },
    getRequestedCaipNetworks() {
        const {approvedCaipNetworkIds: _e, requestedCaipNetworks: et} = state$8
          , tt = _e
          , rt = et;
        return CoreHelperUtil.sortRequestedNetworks(tt, rt)
    },
    async getApprovedCaipNetworksData() {
        const _e = await this._getClient().getApprovedCaipNetworksData();
        state$8.supportsAllNetworks = _e.supportsAllNetworks,
        state$8.approvedCaipNetworkIds = _e.approvedCaipNetworkIds
    },
    async switchActiveNetwork(_e) {
        await this._getClient().switchCaipNetwork(_e),
        state$8.caipNetwork = _e,
        _e && EventsController.sendEvent({
            type: "track",
            event: "SWITCH_NETWORK",
            properties: {
                network: _e.id
            }
        })
    },
    checkIfSupportedNetwork() {
        var _e;
        state$8.isUnsupportedChain = !((_e = state$8.requestedCaipNetworks) != null && _e.some(et=>{
            var tt;
            return et.id === ((tt = state$8.caipNetwork) == null ? void 0 : tt.id)
        }
        )),
        state$8.isUnsupportedChain && this.showUnsupportedChainUI()
    },
    resetNetwork() {
        state$8.isDefaultCaipNetwork || (state$8.caipNetwork = void 0),
        state$8.approvedCaipNetworkIds = void 0,
        state$8.supportsAllNetworks = !0
    },
    showUnsupportedChainUI() {
        setTimeout(()=>{
            ModalController.open({
                view: "UnsupportedChain"
            })
        }
        , 300)
    }
}
  , baseUrl$1 = CoreHelperUtil.getApiUrl()
  , api$1 = new FetchUtil({
    baseUrl: baseUrl$1
})
  , entries = "40"
  , recommendedEntries = "4"
  , state$7 = proxy({
    page: 1,
    count: 0,
    featured: [],
    recommended: [],
    wallets: [],
    search: [],
    isAnalyticsEnabled: !1
})
  , ApiController = {
    state: state$7,
    subscribeKey(_e, et) {
        return subscribeKey(state$7, _e, et)
    },
    _getApiHeaders() {
        const {projectId: _e, sdkType: et, sdkVersion: tt} = OptionsController.state;
        return {
            "x-project-id": _e,
            "x-sdk-type": et,
            "x-sdk-version": tt
        }
    },
    async _fetchWalletImage(_e) {
        const et = `${api$1.baseUrl}/getWalletImage/${_e}`
          , tt = await api$1.getBlob({
            path: et,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setWalletImage(_e, URL.createObjectURL(tt))
    },
    async _fetchNetworkImage(_e) {
        const et = `${api$1.baseUrl}/public/getAssetImage/${_e}`
          , tt = await api$1.getBlob({
            path: et,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setNetworkImage(_e, URL.createObjectURL(tt))
    },
    async _fetchConnectorImage(_e) {
        const et = `${api$1.baseUrl}/public/getAssetImage/${_e}`
          , tt = await api$1.getBlob({
            path: et,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setConnectorImage(_e, URL.createObjectURL(tt))
    },
    async _fetchCurrencyImage(_e) {
        const et = `${api$1.baseUrl}/public/getCurrencyImage/${_e}`
          , tt = await api$1.getBlob({
            path: et,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setCurrencyImage(_e, URL.createObjectURL(tt))
    },
    async _fetchTokenImage(_e) {
        const et = `${api$1.baseUrl}/public/getTokenImage/${_e}`
          , tt = await api$1.getBlob({
            path: et,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setTokenImage(_e, URL.createObjectURL(tt))
    },
    async fetchNetworkImages() {
        const {requestedCaipNetworks: _e} = NetworkController.state
          , et = _e == null ? void 0 : _e.map(({imageId: tt})=>tt).filter(Boolean);
        et && await Promise.allSettled(et.map(tt=>ApiController._fetchNetworkImage(tt)))
    },
    async fetchConnectorImages() {
        const {connectors: _e} = ConnectorController.state
          , et = _e.map(({imageId: tt})=>tt).filter(Boolean);
        await Promise.allSettled(et.map(tt=>ApiController._fetchConnectorImage(tt)))
    },
    async fetchCurrencyImages(_e=[]) {
        await Promise.allSettled(_e.map(et=>ApiController._fetchCurrencyImage(et)))
    },
    async fetchTokenImages(_e=[]) {
        await Promise.allSettled(_e.map(et=>ApiController._fetchTokenImage(et)))
    },
    async fetchFeaturedWallets() {
        const {featuredWalletIds: _e} = OptionsController.state;
        if (_e != null && _e.length) {
            const {data: et} = await api$1.get({
                path: "/getWallets",
                headers: ApiController._getApiHeaders(),
                params: {
                    page: "1",
                    entries: _e != null && _e.length ? String(_e.length) : recommendedEntries,
                    include: _e == null ? void 0 : _e.join(",")
                }
            });
            et.sort((rt,nt)=>_e.indexOf(rt.id) - _e.indexOf(nt.id));
            const tt = et.map(rt=>rt.image_id).filter(Boolean);
            await Promise.allSettled(tt.map(rt=>ApiController._fetchWalletImage(rt))),
            state$7.featured = et
        }
    },
    async fetchRecommendedWallets() {
        const {includeWalletIds: _e, excludeWalletIds: et, featuredWalletIds: tt} = OptionsController.state
          , rt = [...et ?? [], ...tt ?? []].filter(Boolean)
          , {data: nt, count: it} = await api$1.get({
            path: "/getWallets",
            headers: ApiController._getApiHeaders(),
            params: {
                page: "1",
                entries: recommendedEntries,
                include: _e == null ? void 0 : _e.join(","),
                exclude: rt == null ? void 0 : rt.join(",")
            }
        })
          , st = StorageUtil.getRecentWallets()
          , at = nt.map(lt=>lt.image_id).filter(Boolean)
          , ot = st.map(lt=>lt.image_id).filter(Boolean);
        await Promise.allSettled([...at, ...ot].map(lt=>ApiController._fetchWalletImage(lt))),
        state$7.recommended = nt,
        state$7.count = it ?? 0
    },
    async fetchWallets({page: _e}) {
        const {includeWalletIds: et, excludeWalletIds: tt, featuredWalletIds: rt} = OptionsController.state
          , nt = [...state$7.recommended.map(({id: ot})=>ot), ...tt ?? [], ...rt ?? []].filter(Boolean)
          , {data: it, count: st} = await api$1.get({
            path: "/getWallets",
            headers: ApiController._getApiHeaders(),
            params: {
                page: String(_e),
                entries,
                include: et == null ? void 0 : et.join(","),
                exclude: nt.join(",")
            }
        })
          , at = it.map(ot=>ot.image_id).filter(Boolean);
        await Promise.allSettled([...at.map(ot=>ApiController._fetchWalletImage(ot)), CoreHelperUtil.wait(300)]),
        state$7.wallets = [...state$7.wallets, ...it],
        state$7.count = st > state$7.count ? st : state$7.count,
        state$7.page = _e
    },
    async searchWallet({search: _e}) {
        const {includeWalletIds: et, excludeWalletIds: tt} = OptionsController.state;
        state$7.search = [];
        const {data: rt} = await api$1.get({
            path: "/getWallets",
            headers: ApiController._getApiHeaders(),
            params: {
                page: "1",
                entries: "100",
                search: _e,
                include: et == null ? void 0 : et.join(","),
                exclude: tt == null ? void 0 : tt.join(",")
            }
        })
          , nt = rt.map(it=>it.image_id).filter(Boolean);
        await Promise.allSettled([...nt.map(it=>ApiController._fetchWalletImage(it)), CoreHelperUtil.wait(300)]),
        state$7.search = rt
    },
    prefetch() {
        const _e = [ApiController.fetchFeaturedWallets(), ApiController.fetchRecommendedWallets(), ApiController.fetchNetworkImages(), ApiController.fetchConnectorImages()];
        OptionsController.state.enableAnalytics === void 0 && _e.push(ApiController.fetchAnalyticsConfig()),
        state$7.prefetchPromise = Promise.race([Promise.allSettled(_e), CoreHelperUtil.wait(3e3)])
    },
    async fetchAnalyticsConfig() {
        const {isAnalyticsEnabled: _e} = await api$1.get({
            path: "/getAnalyticsConfig",
            headers: ApiController._getApiHeaders()
        });
        OptionsController.setEnableAnalytics(_e)
    }
}
  , state$6 = proxy({
    view: "Connect",
    history: ["Connect"]
})
  , RouterController = {
    state: state$6,
    subscribeKey(_e, et) {
        return subscribeKey(state$6, _e, et)
    },
    push(_e, et) {
        _e !== state$6.view && (state$6.view = _e,
        state$6.history.push(_e),
        state$6.data = et)
    },
    reset(_e) {
        state$6.view = _e,
        state$6.history = [_e]
    },
    replace(_e, et) {
        state$6.history.length > 1 && state$6.history.at(-1) !== _e && (state$6.view = _e,
        state$6.history[state$6.history.length - 1] = _e,
        state$6.data = et)
    },
    goBack() {
        if (state$6.history.length > 1) {
            state$6.history.pop();
            const [_e] = state$6.history.slice(-1);
            _e && (state$6.view = _e)
        }
    },
    goBackToIndex(_e) {
        if (state$6.history.length > 1) {
            state$6.history = state$6.history.slice(0, _e + 1);
            const [et] = state$6.history.slice(-1);
            et && (state$6.view = et)
        }
    }
}
  , state$5 = proxy({
    loading: !1,
    open: !1
})
  , ModalController = {
    state: state$5,
    subscribe(_e) {
        return subscribe(state$5, ()=>_e(state$5))
    },
    subscribeKey(_e, et) {
        return subscribeKey(state$5, _e, et)
    },
    async open(_e) {
        await ApiController.state.prefetchPromise;
        const et = AccountController.state.isConnected;
        _e != null && _e.view ? RouterController.reset(_e.view) : et ? RouterController.reset("Account") : RouterController.reset("Connect"),
        state$5.open = !0,
        PublicStateController.set({
            open: !0
        }),
        EventsController.sendEvent({
            type: "track",
            event: "MODAL_OPEN",
            properties: {
                connected: et
            }
        })
    },
    close() {
        const _e = AccountController.state.isConnected;
        state$5.open = !1,
        PublicStateController.set({
            open: !1
        }),
        EventsController.sendEvent({
            type: "track",
            event: "MODAL_CLOSE",
            properties: {
                connected: _e
            }
        })
    },
    setLoading(_e) {
        state$5.loading = _e
    }
}
  , DEFAULT_OPTIONS = {
    purchaseCurrencies: [{
        id: "2b92315d-eab7-5bef-84fa-089a131333f5",
        name: "USD Coin",
        symbol: "USDC",
        networks: [{
            name: "ethereum-mainnet",
            display_name: "Ethereum",
            chain_id: "1",
            contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        }, {
            name: "polygon-mainnet",
            display_name: "Polygon",
            chain_id: "137",
            contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }]
    }, {
        id: "2b92315d-eab7-5bef-84fa-089a131333f5",
        name: "Ether",
        symbol: "ETH",
        networks: [{
            name: "ethereum-mainnet",
            display_name: "Ethereum",
            chain_id: "1",
            contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        }, {
            name: "polygon-mainnet",
            display_name: "Polygon",
            chain_id: "137",
            contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }]
    }],
    paymentCurrencies: [{
        id: "USD",
        payment_method_limits: [{
            id: "card",
            min: "10.00",
            max: "7500.00"
        }, {
            id: "ach_bank_account",
            min: "10.00",
            max: "25000.00"
        }]
    }, {
        id: "EUR",
        payment_method_limits: [{
            id: "card",
            min: "10.00",
            max: "7500.00"
        }, {
            id: "ach_bank_account",
            min: "10.00",
            max: "25000.00"
        }]
    }]
}
  , baseUrl = CoreHelperUtil.getBlockchainApiUrl()
  , api = new FetchUtil({
    baseUrl
})
  , BlockchainApiController = {
    fetchIdentity({caipChainId: _e, address: et}) {
        return api.get({
            path: `/v1/identity/${et}`,
            params: {
                chainId: _e,
                projectId: OptionsController.state.projectId
            }
        })
    },
    fetchTransactions({account: _e, projectId: et, cursor: tt, onramp: rt, signal: nt}) {
        const it = tt ? {
            cursor: tt
        } : {};
        return api.get({
            path: `/v1/account/${_e}/history?projectId=${et}${rt ? `&onramp=${rt}` : ""}`,
            params: it,
            signal: nt
        })
    },
    async generateOnRampURL({destinationWallets: _e, partnerUserId: et, defaultNetwork: tt, purchaseAmount: rt, paymentAmount: nt}) {
        return (await api.post({
            path: `/v1/generators/onrampurl?projectId=${OptionsController.state.projectId}`,
            body: {
                destinationWallets: _e,
                defaultNetwork: tt,
                partnerUserId: et,
                defaultExperience: "buy",
                presetCryptoAmount: rt,
                presetFiatAmount: nt
            }
        })).url
    },
    async getOnrampOptions() {
        try {
            return await api.get({
                path: `/v1/onramp/options?projectId=${OptionsController.state.projectId}`
            })
        } catch {
            return DEFAULT_OPTIONS
        }
    },
    async getOnrampQuote({purchaseCurrency: _e, paymentCurrency: et, amount: tt, network: rt}) {
        try {
            return await api.post({
                path: `/v1/onramp/quote?projectId=${OptionsController.state.projectId}`,
                body: {
                    purchaseCurrency: _e,
                    paymentCurrency: et,
                    amount: tt,
                    network: rt
                }
            })
        } catch {
            return {
                coinbaseFee: {
                    amount: tt,
                    currency: et.id
                },
                networkFee: {
                    amount: tt,
                    currency: et.id
                },
                paymentSubtotal: {
                    amount: tt,
                    currency: et.id
                },
                paymentTotal: {
                    amount: tt,
                    currency: et.id
                },
                purchaseAmount: {
                    amount: tt,
                    currency: et.id
                },
                quoteId: "mocked-quote-id"
            }
        }
    }
}
  , USDC_CURRENCY_DEFAULT = {
    id: "2b92315d-eab7-5bef-84fa-089a131333f5",
    name: "USD Coin",
    symbol: "USDC",
    networks: [{
        name: "ethereum-mainnet",
        display_name: "Ethereum",
        chain_id: "1",
        contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    }, {
        name: "polygon-mainnet",
        display_name: "Polygon",
        chain_id: "137",
        contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }]
}
  , USD_CURRENCY_DEFAULT = {
    id: "USD",
    payment_method_limits: [{
        id: "card",
        min: "10.00",
        max: "7500.00"
    }, {
        id: "ach_bank_account",
        min: "10.00",
        max: "25000.00"
    }]
}
  , state$4 = proxy({
    providers: ONRAMP_PROVIDERS,
    selectedProvider: null,
    error: null,
    purchaseCurrency: USDC_CURRENCY_DEFAULT,
    paymentCurrency: USD_CURRENCY_DEFAULT,
    purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
    paymentCurrencies: [],
    quotesLoading: !1
})
  , OnRampController = {
    state: state$4,
    subscribe(_e) {
        return subscribe(state$4, ()=>_e(state$4))
    },
    subscribeKey(_e, et) {
        return subscribeKey(state$4, _e, et)
    },
    setSelectedProvider(_e) {
        state$4.selectedProvider = _e
    },
    setPurchaseCurrency(_e) {
        state$4.purchaseCurrency = _e
    },
    setPaymentCurrency(_e) {
        state$4.paymentCurrency = _e
    },
    setPurchaseAmount(_e) {
        this.state.purchaseAmount = _e
    },
    setPaymentAmount(_e) {
        this.state.paymentAmount = _e
    },
    async getAvailableCurrencies() {
        const _e = await BlockchainApiController.getOnrampOptions();
        state$4.purchaseCurrencies = _e.purchaseCurrencies,
        state$4.paymentCurrencies = _e.paymentCurrencies,
        state$4.paymentCurrency = _e.paymentCurrencies[0] || USD_CURRENCY_DEFAULT,
        state$4.purchaseCurrency = _e.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT,
        await ApiController.fetchCurrencyImages(_e.paymentCurrencies.map(et=>et.id)),
        await ApiController.fetchTokenImages(_e.purchaseCurrencies.map(et=>et.symbol))
    },
    async getQuote() {
        var et, tt;
        state$4.quotesLoading = !0;
        const _e = await BlockchainApiController.getOnrampQuote({
            purchaseCurrency: state$4.purchaseCurrency,
            paymentCurrency: state$4.paymentCurrency,
            amount: ((et = state$4.paymentAmount) == null ? void 0 : et.toString()) || "0",
            network: (tt = state$4.purchaseCurrency) == null ? void 0 : tt.name
        });
        return state$4.quotesLoading = !1,
        state$4.purchaseAmount = Number(_e.purchaseAmount.amount),
        _e
    }
}
  , state$3 = proxy({
    message: "",
    variant: "success",
    open: !1
})
  , SnackController = {
    state: state$3,
    subscribeKey(_e, et) {
        return subscribeKey(state$3, _e, et)
    },
    showSuccess(_e) {
        state$3.message = _e,
        state$3.variant = "success",
        state$3.open = !0
    },
    showError(_e) {
        const et = CoreHelperUtil.parseError(_e);
        state$3.message = et,
        state$3.variant = "error",
        state$3.open = !0
    },
    hide() {
        state$3.open = !1
    }
}
  , state$2 = proxy({
    transactions: [],
    coinbaseTransactions: [],
    transactionsByYear: {},
    loading: !1,
    empty: !1,
    next: void 0
})
  , TransactionsController = {
    state: state$2,
    subscribe(_e) {
        return subscribe(state$2, ()=>_e(state$2))
    },
    async fetchTransactions(_e, et) {
        const {projectId: tt} = OptionsController.state;
        if (!tt || !_e)
            throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
        state$2.loading = !0;
        try {
            const rt = await BlockchainApiController.fetchTransactions({
                account: _e,
                projectId: tt,
                cursor: state$2.next,
                onramp: et
            })
              , nt = this.filterSpamTransactions(rt.data)
              , it = [...state$2.transactions, ...nt];
            state$2.loading = !1,
            et === "coinbase" ? state$2.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state$2.coinbaseTransactions, rt.data) : (state$2.transactions = it,
            state$2.transactionsByYear = this.groupTransactionsByYearAndMonth(state$2.transactionsByYear, nt)),
            state$2.empty = it.length === 0,
            state$2.next = rt.next ? rt.next : void 0
        } catch {
            EventsController.sendEvent({
                type: "track",
                event: "ERROR_FETCH_TRANSACTIONS",
                properties: {
                    address: _e,
                    projectId: tt,
                    cursor: state$2.next
                }
            }),
            SnackController.showError("Failed to fetch transactions"),
            state$2.loading = !1,
            state$2.empty = !0
        }
    },
    groupTransactionsByYearAndMonth(_e={}, et=[]) {
        const tt = _e;
        return et.forEach(rt=>{
            const nt = new Date(rt.metadata.minedAt).getFullYear()
              , it = new Date(rt.metadata.minedAt).getMonth()
              , st = tt[nt] ?? {}
              , at = st[it] ?? [];
            at.find(ot=>ot.metadata.hash === rt.metadata.hash && ot.metadata.status === rt.metadata.status) || (tt[nt] = {
                ...st,
                [it]: [...at, rt].sort((ot,lt)=>new Date(lt.metadata.minedAt).getTime() - new Date(ot.metadata.minedAt).getTime())
            })
        }
        ),
        tt
    },
    filterSpamTransactions(_e) {
        return _e.filter(et=>!et.transfers.every(rt=>{
            var nt;
            return ((nt = rt.nft_info) == null ? void 0 : nt.flags.is_spam) === !0
        }
        ))
    },
    resetTransactions() {
        state$2.transactions = [],
        state$2.transactionsByYear = {},
        state$2.loading = !1,
        state$2.empty = !1,
        state$2.next = void 0
    }
}
  , state$1 = proxy({
    wcError: !1,
    buffering: !1
})
  , ConnectionController = {
    state: state$1,
    subscribeKey(_e, et) {
        return subscribeKey(state$1, _e, et)
    },
    _getClient() {
        if (!state$1._client)
            throw new Error("ConnectionController client not set");
        return state$1._client
    },
    setClient(_e) {
        state$1._client = ref(_e)
    },
    connectWalletConnect() {
        state$1.wcPromise = this._getClient().connectWalletConnect(_e=>{
            state$1.wcUri = _e,
            state$1.wcPairingExpiry = CoreHelperUtil.getPairingExpiry()
        }
        )
    },
    async connectExternal(_e) {
        var et, tt;
        await ((tt = (et = this._getClient()).connectExternal) == null ? void 0 : tt.call(et, _e)),
        StorageUtil.setConnectedConnector(_e.type)
    },
    async signMessage(_e) {
        return this._getClient().signMessage(_e)
    },
    checkInstalled(_e) {
        var et, tt;
        return (tt = (et = this._getClient()).checkInstalled) == null ? void 0 : tt.call(et, _e)
    },
    resetWcConnection() {
        state$1.wcUri = void 0,
        state$1.wcPairingExpiry = void 0,
        state$1.wcPromise = void 0,
        state$1.wcLinking = void 0,
        state$1.recentWallet = void 0,
        TransactionsController.resetTransactions(),
        StorageUtil.deleteWalletConnectDeepLink()
    },
    setWcLinking(_e) {
        state$1.wcLinking = _e
    },
    setWcError(_e) {
        state$1.wcError = _e,
        state$1.buffering = !1
    },
    setRecentWallet(_e) {
        state$1.recentWallet = _e
    },
    setBuffering(_e) {
        state$1.buffering = _e
    },
    async disconnect() {
        await this._getClient().disconnect(),
        this.resetWcConnection()
    }
}
  , state = proxy({
    status: "uninitialized",
    isSiweEnabled: !1
})
  , SIWEController = {
    state,
    subscribeKey(_e, et) {
        return subscribeKey(state, _e, et)
    },
    subscribe(_e) {
        return subscribe(state, ()=>_e(state))
    },
    _getClient() {
        if (!state._client)
            throw new Error("SIWEController client not set");
        return state._client
    },
    async getNonce() {
        const et = await this._getClient().getNonce();
        return this.setNonce(et),
        et
    },
    async getSession() {
        const et = await this._getClient().getSession();
        return et && (this.setSession(et),
        this.setStatus("success")),
        et
    },
    createMessage(_e) {
        const tt = this._getClient().createMessage(_e);
        return this.setMessage(tt),
        tt
    },
    async verifyMessage(_e) {
        return await this._getClient().verifyMessage(_e)
    },
    async signIn() {
        return await this._getClient().signIn()
    },
    async signOut() {
        var et;
        const _e = this._getClient();
        await _e.signOut(),
        this.setStatus("ready"),
        (et = _e.onSignOut) == null || et.call(_e)
    },
    onSignIn(_e) {
        var tt;
        const et = this._getClient();
        (tt = et.onSignIn) == null || tt.call(et, _e)
    },
    onSignOut() {
        var et;
        const _e = this._getClient();
        (et = _e.onSignOut) == null || et.call(_e)
    },
    setSIWEClient(_e) {
        state._client = ref(_e),
        state.status = "ready",
        state.isSiweEnabled = _e.options.enabled
    },
    setNonce(_e) {
        state.nonce = _e
    },
    setStatus(_e) {
        state.status = _e
    },
    setMessage(_e) {
        state.message = _e
    },
    setSession(_e) {
        state.session = _e
    }
}
  , AssetUtil = {
    getWalletImage(_e) {
        if (_e != null && _e.image_url)
            return _e == null ? void 0 : _e.image_url;
        if (_e != null && _e.image_id)
            return AssetController.state.walletImages[_e.image_id]
    },
    getNetworkImage(_e) {
        if (_e != null && _e.imageUrl)
            return _e == null ? void 0 : _e.imageUrl;
        if (_e != null && _e.imageId)
            return AssetController.state.networkImages[_e.imageId]
    },
    getConnectorImage(_e) {
        if (_e != null && _e.imageUrl)
            return _e.imageUrl;
        if (_e != null && _e.imageId)
            return AssetController.state.connectorImages[_e.imageId]
    }
}
  , RouterUtil = {
    goBackOrCloseModal() {
        RouterController.state.history.length > 1 ? RouterController.goBack() : ModalController.close()
    },
    navigateAfterNetworkSwitch() {
        const {history: _e} = RouterController.state
          , et = _e.findIndex(tt=>tt === "Networks");
        et >= 1 ? RouterController.goBackToIndex(et - 1) : ModalController.close()
    }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$7 = globalThis
  , e$a = t$7.ShadowRoot && (t$7.ShadyCSS === void 0 || t$7.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
  , s$7 = Symbol()
  , o$d = new WeakMap;
let n$d = class {
    constructor(et, tt, rt) {
        if (this._$cssResult$ = !0,
        rt !== s$7)
            throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = et,
        this.t = tt
    }
    get styleSheet() {
        let et = this.o;
        const tt = this.t;
        if (e$a && et === void 0) {
            const rt = tt !== void 0 && tt.length === 1;
            rt && (et = o$d.get(tt)),
            et === void 0 && ((this.o = et = new CSSStyleSheet).replaceSync(this.cssText),
            rt && o$d.set(tt, et))
        }
        return et
    }
    toString() {
        return this.cssText
    }
}
;
const r$f = _e=>new n$d(typeof _e == "string" ? _e : _e + "",void 0,s$7)
  , i$8 = (_e,...et)=>{
    const tt = _e.length === 1 ? _e[0] : et.reduce((rt,nt,it)=>rt + (st=>{
        if (st._$cssResult$ === !0)
            return st.cssText;
        if (typeof st == "number")
            return st;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + st + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
    }
    )(nt) + _e[it + 1], _e[0]);
    return new n$d(tt,_e,s$7)
}
  , S$3 = (_e,et)=>{
    if (e$a)
        _e.adoptedStyleSheets = et.map(tt=>tt instanceof CSSStyleSheet ? tt : tt.styleSheet);
    else
        for (const tt of et) {
            const rt = document.createElement("style")
              , nt = t$7.litNonce;
            nt !== void 0 && rt.setAttribute("nonce", nt),
            rt.textContent = tt.cssText,
            _e.appendChild(rt)
        }
}
  , c$7 = e$a ? _e=>_e : _e=>_e instanceof CSSStyleSheet ? (et=>{
    let tt = "";
    for (const rt of et.cssRules)
        tt += rt.cssText;
    return r$f(tt)
}
)(_e) : _e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const {is: i$7, defineProperty: e$9, getOwnPropertyDescriptor: r$e, getOwnPropertyNames: h$9, getOwnPropertySymbols: o$c, getPrototypeOf: n$c} = Object
  , a$3 = globalThis
  , c$6 = a$3.trustedTypes
  , l$3 = c$6 ? c$6.emptyScript : ""
  , p$5 = a$3.reactiveElementPolyfillSupport
  , d$3 = (_e,et)=>_e
  , u$5 = {
    toAttribute(_e, et) {
        switch (et) {
        case Boolean:
            _e = _e ? l$3 : null;
            break;
        case Object:
        case Array:
            _e = _e == null ? _e : JSON.stringify(_e)
        }
        return _e
    },
    fromAttribute(_e, et) {
        let tt = _e;
        switch (et) {
        case Boolean:
            tt = _e !== null;
            break;
        case Number:
            tt = _e === null ? null : Number(_e);
            break;
        case Object:
        case Array:
            try {
                tt = JSON.parse(_e)
            } catch {
                tt = null
            }
        }
        return tt
    }
}
  , f$7 = (_e,et)=>!i$7(_e, et)
  , y$3 = {
    attribute: !0,
    type: String,
    converter: u$5,
    reflect: !1,
    hasChanged: f$7
};
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")),
a$3.litPropertyMetadata ?? (a$3.litPropertyMetadata = new WeakMap);
let b$2 = class extends HTMLElement {
    static addInitializer(et) {
        this._$Ei(),
        (this.l ?? (this.l = [])).push(et)
    }
    static get observedAttributes() {
        return this.finalize(),
        this._$Eh && [...this._$Eh.keys()]
    }
    static createProperty(et, tt=y$3) {
        if (tt.state && (tt.attribute = !1),
        this._$Ei(),
        this.elementProperties.set(et, tt),
        !tt.noAccessor) {
            const rt = Symbol()
              , nt = this.getPropertyDescriptor(et, rt, tt);
            nt !== void 0 && e$9(this.prototype, et, nt)
        }
    }
    static getPropertyDescriptor(et, tt, rt) {
        const {get: nt, set: it} = r$e(this.prototype, et) ?? {
            get() {
                return this[tt]
            },
            set(st) {
                this[tt] = st
            }
        };
        return {
            get() {
                return nt == null ? void 0 : nt.call(this)
            },
            set(st) {
                const at = nt == null ? void 0 : nt.call(this);
                it.call(this, st),
                this.requestUpdate(et, at, rt)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(et) {
        return this.elementProperties.get(et) ?? y$3
    }
    static _$Ei() {
        if (this.hasOwnProperty(d$3("elementProperties")))
            return;
        const et = n$c(this);
        et.finalize(),
        et.l !== void 0 && (this.l = [...et.l]),
        this.elementProperties = new Map(et.elementProperties)
    }
    static finalize() {
        if (this.hasOwnProperty(d$3("finalized")))
            return;
        if (this.finalized = !0,
        this._$Ei(),
        this.hasOwnProperty(d$3("properties"))) {
            const tt = this.properties
              , rt = [...h$9(tt), ...o$c(tt)];
            for (const nt of rt)
                this.createProperty(nt, tt[nt])
        }
        const et = this[Symbol.metadata];
        if (et !== null) {
            const tt = litPropertyMetadata.get(et);
            if (tt !== void 0)
                for (const [rt,nt] of tt)
                    this.elementProperties.set(rt, nt)
        }
        this._$Eh = new Map;
        for (const [tt,rt] of this.elementProperties) {
            const nt = this._$Eu(tt, rt);
            nt !== void 0 && this._$Eh.set(nt, tt)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
    }
    static finalizeStyles(et) {
        const tt = [];
        if (Array.isArray(et)) {
            const rt = new Set(et.flat(1 / 0).reverse());
            for (const nt of rt)
                tt.unshift(c$7(nt))
        } else
            et !== void 0 && tt.push(c$7(et));
        return tt
    }
    static _$Eu(et, tt) {
        const rt = tt.attribute;
        return rt === !1 ? void 0 : typeof rt == "string" ? rt : typeof et == "string" ? et.toLowerCase() : void 0
    }
    constructor() {
        super(),
        this._$Ep = void 0,
        this.isUpdatePending = !1,
        this.hasUpdated = !1,
        this._$Em = null,
        this._$Ev()
    }
    _$Ev() {
        var et;
        this._$ES = new Promise(tt=>this.enableUpdating = tt),
        this._$AL = new Map,
        this._$E_(),
        this.requestUpdate(),
        (et = this.constructor.l) == null || et.forEach(tt=>tt(this))
    }
    addController(et) {
        var tt;
        (this._$EO ?? (this._$EO = new Set)).add(et),
        this.renderRoot !== void 0 && this.isConnected && ((tt = et.hostConnected) == null || tt.call(et))
    }
    removeController(et) {
        var tt;
        (tt = this._$EO) == null || tt.delete(et)
    }
    _$E_() {
        const et = new Map
          , tt = this.constructor.elementProperties;
        for (const rt of tt.keys())
            this.hasOwnProperty(rt) && (et.set(rt, this[rt]),
            delete this[rt]);
        et.size > 0 && (this._$Ep = et)
    }
    createRenderRoot() {
        const et = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S$3(et, this.constructor.elementStyles),
        et
    }
    connectedCallback() {
        var et;
        this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
        this.enableUpdating(!0),
        (et = this._$EO) == null || et.forEach(tt=>{
            var rt;
            return (rt = tt.hostConnected) == null ? void 0 : rt.call(tt)
        }
        )
    }
    enableUpdating(et) {}
    disconnectedCallback() {
        var et;
        (et = this._$EO) == null || et.forEach(tt=>{
            var rt;
            return (rt = tt.hostDisconnected) == null ? void 0 : rt.call(tt)
        }
        )
    }
    attributeChangedCallback(et, tt, rt) {
        this._$AK(et, rt)
    }
    _$EC(et, tt) {
        var it;
        const rt = this.constructor.elementProperties.get(et)
          , nt = this.constructor._$Eu(et, rt);
        if (nt !== void 0 && rt.reflect === !0) {
            const st = (((it = rt.converter) == null ? void 0 : it.toAttribute) !== void 0 ? rt.converter : u$5).toAttribute(tt, rt.type);
            this._$Em = et,
            st == null ? this.removeAttribute(nt) : this.setAttribute(nt, st),
            this._$Em = null
        }
    }
    _$AK(et, tt) {
        var it;
        const rt = this.constructor
          , nt = rt._$Eh.get(et);
        if (nt !== void 0 && this._$Em !== nt) {
            const st = rt.getPropertyOptions(nt)
              , at = typeof st.converter == "function" ? {
                fromAttribute: st.converter
            } : ((it = st.converter) == null ? void 0 : it.fromAttribute) !== void 0 ? st.converter : u$5;
            this._$Em = nt,
            this[nt] = at.fromAttribute(tt, st.type),
            this._$Em = null
        }
    }
    requestUpdate(et, tt, rt) {
        if (et !== void 0) {
            if (rt ?? (rt = this.constructor.getPropertyOptions(et)),
            !(rt.hasChanged ?? f$7)(this[et], tt))
                return;
            this.P(et, tt, rt)
        }
        this.isUpdatePending === !1 && (this._$ES = this._$ET())
    }
    P(et, tt, rt) {
        this._$AL.has(et) || this._$AL.set(et, tt),
        rt.reflect === !0 && this._$Em !== et && (this._$Ej ?? (this._$Ej = new Set)).add(et)
    }
    async _$ET() {
        this.isUpdatePending = !0;
        try {
            await this._$ES
        } catch (tt) {
            Promise.reject(tt)
        }
        const et = this.scheduleUpdate();
        return et != null && await et,
        !this.isUpdatePending
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        var rt;
        if (!this.isUpdatePending)
            return;
        if (!this.hasUpdated) {
            if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
            this._$Ep) {
                for (const [it,st] of this._$Ep)
                    this[it] = st;
                this._$Ep = void 0
            }
            const nt = this.constructor.elementProperties;
            if (nt.size > 0)
                for (const [it,st] of nt)
                    st.wrapped !== !0 || this._$AL.has(it) || this[it] === void 0 || this.P(it, this[it], st)
        }
        let et = !1;
        const tt = this._$AL;
        try {
            et = this.shouldUpdate(tt),
            et ? (this.willUpdate(tt),
            (rt = this._$EO) == null || rt.forEach(nt=>{
                var it;
                return (it = nt.hostUpdate) == null ? void 0 : it.call(nt)
            }
            ),
            this.update(tt)) : this._$EU()
        } catch (nt) {
            throw et = !1,
            this._$EU(),
            nt
        }
        et && this._$AE(tt)
    }
    willUpdate(et) {}
    _$AE(et) {
        var tt;
        (tt = this._$EO) == null || tt.forEach(rt=>{
            var nt;
            return (nt = rt.hostUpdated) == null ? void 0 : nt.call(rt)
        }
        ),
        this.hasUpdated || (this.hasUpdated = !0,
        this.firstUpdated(et)),
        this.updated(et)
    }
    _$EU() {
        this._$AL = new Map,
        this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$ES
    }
    shouldUpdate(et) {
        return !0
    }
    update(et) {
        this._$Ej && (this._$Ej = this._$Ej.forEach(tt=>this._$EC(tt, this[tt]))),
        this._$EU()
    }
    updated(et) {}
    firstUpdated(et) {}
}
;
b$2.elementStyles = [],
b$2.shadowRootOptions = {
    mode: "open"
},
b$2[d$3("elementProperties")] = new Map,
b$2[d$3("finalized")] = new Map,
p$5 == null || p$5({
    ReactiveElement: b$2
}),
(a$3.reactiveElementVersions ?? (a$3.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$6 = globalThis
  , i$6 = t$6.trustedTypes
  , s$6 = i$6 ? i$6.createPolicy("lit-html", {
    createHTML: _e=>_e
}) : void 0
  , e$8 = "$lit$"
  , h$8 = `lit$${(Math.random() + "").slice(9)}$`
  , o$b = "?" + h$8
  , n$b = `<${o$b}>`
  , r$d = document
  , l$2 = ()=>r$d.createComment("")
  , c$5 = _e=>_e === null || typeof _e != "object" && typeof _e != "function"
  , a$2 = Array.isArray
  , u$4 = _e=>a$2(_e) || typeof (_e == null ? void 0 : _e[Symbol.iterator]) == "function"
  , d$2 = `[ 	
\f\r]`
  , f$6 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
  , v$4 = /-->/g
  , _$1 = />/g
  , m$1 = RegExp(`>|${d$2}(?:([^\\s"'>=/]+)(${d$2}*=${d$2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g")
  , p$4 = /'/g
  , g$2 = /"/g
  , $$1 = /^(?:script|style|textarea|title)$/i
  , y$2 = _e=>(et,...tt)=>({
    _$litType$: _e,
    strings: et,
    values: tt
})
  , x$1 = y$2(1)
  , b$1 = y$2(2)
  , w$3 = Symbol.for("lit-noChange")
  , T$1 = Symbol.for("lit-nothing")
  , A$1 = new WeakMap
  , E$1 = r$d.createTreeWalker(r$d, 129);
function C$1(_e, et) {
    if (!Array.isArray(_e) || !_e.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
    return s$6 !== void 0 ? s$6.createHTML(et) : et
}
const P$1 = (_e,et)=>{
    const tt = _e.length - 1
      , rt = [];
    let nt, it = et === 2 ? "<svg>" : "", st = f$6;
    for (let at = 0; at < tt; at++) {
        const ot = _e[at];
        let lt, dt, ct = -1, ut = 0;
        for (; ut < ot.length && (st.lastIndex = ut,
        dt = st.exec(ot),
        dt !== null); )
            ut = st.lastIndex,
            st === f$6 ? dt[1] === "!--" ? st = v$4 : dt[1] !== void 0 ? st = _$1 : dt[2] !== void 0 ? ($$1.test(dt[2]) && (nt = RegExp("</" + dt[2], "g")),
            st = m$1) : dt[3] !== void 0 && (st = m$1) : st === m$1 ? dt[0] === ">" ? (st = nt ?? f$6,
            ct = -1) : dt[1] === void 0 ? ct = -2 : (ct = st.lastIndex - dt[2].length,
            lt = dt[1],
            st = dt[3] === void 0 ? m$1 : dt[3] === '"' ? g$2 : p$4) : st === g$2 || st === p$4 ? st = m$1 : st === v$4 || st === _$1 ? st = f$6 : (st = m$1,
            nt = void 0);
        const ft = st === m$1 && _e[at + 1].startsWith("/>") ? " " : "";
        it += st === f$6 ? ot + n$b : ct >= 0 ? (rt.push(lt),
        ot.slice(0, ct) + e$8 + ot.slice(ct) + h$8 + ft) : ot + h$8 + (ct === -2 ? at : ft)
    }
    return [C$1(_e, it + (_e[tt] || "<?>") + (et === 2 ? "</svg>" : "")), rt]
}
;
let V$1 = class Pl {
    constructor({strings: et, _$litType$: tt}, rt) {
        let nt;
        this.parts = [];
        let it = 0
          , st = 0;
        const at = et.length - 1
          , ot = this.parts
          , [lt,dt] = P$1(et, tt);
        if (this.el = Pl.createElement(lt, rt),
        E$1.currentNode = this.el.content,
        tt === 2) {
            const ct = this.el.content.firstChild;
            ct.replaceWith(...ct.childNodes)
        }
        for (; (nt = E$1.nextNode()) !== null && ot.length < at; ) {
            if (nt.nodeType === 1) {
                if (nt.hasAttributes())
                    for (const ct of nt.getAttributeNames())
                        if (ct.endsWith(e$8)) {
                            const ut = dt[st++]
                              , ft = nt.getAttribute(ct).split(h$8)
                              , ht = /([.?@])?(.*)/.exec(ut);
                            ot.push({
                                type: 1,
                                index: it,
                                name: ht[2],
                                strings: ft,
                                ctor: ht[1] === "." ? k$1 : ht[1] === "?" ? H$1 : ht[1] === "@" ? I$1 : R$1
                            }),
                            nt.removeAttribute(ct)
                        } else
                            ct.startsWith(h$8) && (ot.push({
                                type: 6,
                                index: it
                            }),
                            nt.removeAttribute(ct));
                if ($$1.test(nt.tagName)) {
                    const ct = nt.textContent.split(h$8)
                      , ut = ct.length - 1;
                    if (ut > 0) {
                        nt.textContent = i$6 ? i$6.emptyScript : "";
                        for (let ft = 0; ft < ut; ft++)
                            nt.append(ct[ft], l$2()),
                            E$1.nextNode(),
                            ot.push({
                                type: 2,
                                index: ++it
                            });
                        nt.append(ct[ut], l$2())
                    }
                }
            } else if (nt.nodeType === 8)
                if (nt.data === o$b)
                    ot.push({
                        type: 2,
                        index: it
                    });
                else {
                    let ct = -1;
                    for (; (ct = nt.data.indexOf(h$8, ct + 1)) !== -1; )
                        ot.push({
                            type: 7,
                            index: it
                        }),
                        ct += h$8.length - 1
                }
            it++
        }
    }
    static createElement(et, tt) {
        const rt = r$d.createElement("template");
        return rt.innerHTML = et,
        rt
    }
}
;
function N$1(_e, et, tt=_e, rt) {
    var st, at;
    if (et === w$3)
        return et;
    let nt = rt !== void 0 ? (st = tt._$Co) == null ? void 0 : st[rt] : tt._$Cl;
    const it = c$5(et) ? void 0 : et._$litDirective$;
    return (nt == null ? void 0 : nt.constructor) !== it && ((at = nt == null ? void 0 : nt._$AO) == null || at.call(nt, !1),
    it === void 0 ? nt = void 0 : (nt = new it(_e),
    nt._$AT(_e, tt, rt)),
    rt !== void 0 ? (tt._$Co ?? (tt._$Co = []))[rt] = nt : tt._$Cl = nt),
    nt !== void 0 && (et = N$1(_e, nt._$AS(_e, et.values), nt, rt)),
    et
}
let S$2 = class {
    constructor(et, tt) {
        this._$AV = [],
        this._$AN = void 0,
        this._$AD = et,
        this._$AM = tt
    }
    get parentNode() {
        return this._$AM.parentNode
    }
    get _$AU() {
        return this._$AM._$AU
    }
    u(et) {
        const {el: {content: tt}, parts: rt} = this._$AD
          , nt = ((et == null ? void 0 : et.creationScope) ?? r$d).importNode(tt, !0);
        E$1.currentNode = nt;
        let it = E$1.nextNode()
          , st = 0
          , at = 0
          , ot = rt[0];
        for (; ot !== void 0; ) {
            if (st === ot.index) {
                let lt;
                ot.type === 2 ? lt = new M$1(it,it.nextSibling,this,et) : ot.type === 1 ? lt = new ot.ctor(it,ot.name,ot.strings,this,et) : ot.type === 6 && (lt = new L$1(it,this,et)),
                this._$AV.push(lt),
                ot = rt[++at]
            }
            st !== (ot == null ? void 0 : ot.index) && (it = E$1.nextNode(),
            st++)
        }
        return E$1.currentNode = r$d,
        nt
    }
    p(et) {
        let tt = 0;
        for (const rt of this._$AV)
            rt !== void 0 && (rt.strings !== void 0 ? (rt._$AI(et, rt, tt),
            tt += rt.strings.length - 2) : rt._$AI(et[tt])),
            tt++
    }
}
  , M$1 = class Rl {
    get _$AU() {
        var et;
        return ((et = this._$AM) == null ? void 0 : et._$AU) ?? this._$Cv
    }
    constructor(et, tt, rt, nt) {
        this.type = 2,
        this._$AH = T$1,
        this._$AN = void 0,
        this._$AA = et,
        this._$AB = tt,
        this._$AM = rt,
        this.options = nt,
        this._$Cv = (nt == null ? void 0 : nt.isConnected) ?? !0
    }
    get parentNode() {
        let et = this._$AA.parentNode;
        const tt = this._$AM;
        return tt !== void 0 && (et == null ? void 0 : et.nodeType) === 11 && (et = tt.parentNode),
        et
    }
    get startNode() {
        return this._$AA
    }
    get endNode() {
        return this._$AB
    }
    _$AI(et, tt=this) {
        et = N$1(this, et, tt),
        c$5(et) ? et === T$1 || et == null || et === "" ? (this._$AH !== T$1 && this._$AR(),
        this._$AH = T$1) : et !== this._$AH && et !== w$3 && this._(et) : et._$litType$ !== void 0 ? this.$(et) : et.nodeType !== void 0 ? this.T(et) : u$4(et) ? this.k(et) : this._(et)
    }
    S(et) {
        return this._$AA.parentNode.insertBefore(et, this._$AB)
    }
    T(et) {
        this._$AH !== et && (this._$AR(),
        this._$AH = this.S(et))
    }
    _(et) {
        this._$AH !== T$1 && c$5(this._$AH) ? this._$AA.nextSibling.data = et : this.T(r$d.createTextNode(et)),
        this._$AH = et
    }
    $(et) {
        var it;
        const {values: tt, _$litType$: rt} = et
          , nt = typeof rt == "number" ? this._$AC(et) : (rt.el === void 0 && (rt.el = V$1.createElement(C$1(rt.h, rt.h[0]), this.options)),
        rt);
        if (((it = this._$AH) == null ? void 0 : it._$AD) === nt)
            this._$AH.p(tt);
        else {
            const st = new S$2(nt,this)
              , at = st.u(this.options);
            st.p(tt),
            this.T(at),
            this._$AH = st
        }
    }
    _$AC(et) {
        let tt = A$1.get(et.strings);
        return tt === void 0 && A$1.set(et.strings, tt = new V$1(et)),
        tt
    }
    k(et) {
        a$2(this._$AH) || (this._$AH = [],
        this._$AR());
        const tt = this._$AH;
        let rt, nt = 0;
        for (const it of et)
            nt === tt.length ? tt.push(rt = new Rl(this.S(l$2()),this.S(l$2()),this,this.options)) : rt = tt[nt],
            rt._$AI(it),
            nt++;
        nt < tt.length && (this._$AR(rt && rt._$AB.nextSibling, nt),
        tt.length = nt)
    }
    _$AR(et=this._$AA.nextSibling, tt) {
        var rt;
        for ((rt = this._$AP) == null ? void 0 : rt.call(this, !1, !0, tt); et && et !== this._$AB; ) {
            const nt = et.nextSibling;
            et.remove(),
            et = nt
        }
    }
    setConnected(et) {
        var tt;
        this._$AM === void 0 && (this._$Cv = et,
        (tt = this._$AP) == null || tt.call(this, et))
    }
}
  , R$1 = class {
    get tagName() {
        return this.element.tagName
    }
    get _$AU() {
        return this._$AM._$AU
    }
    constructor(et, tt, rt, nt, it) {
        this.type = 1,
        this._$AH = T$1,
        this._$AN = void 0,
        this.element = et,
        this.name = tt,
        this._$AM = nt,
        this.options = it,
        rt.length > 2 || rt[0] !== "" || rt[1] !== "" ? (this._$AH = Array(rt.length - 1).fill(new String),
        this.strings = rt) : this._$AH = T$1
    }
    _$AI(et, tt=this, rt, nt) {
        const it = this.strings;
        let st = !1;
        if (it === void 0)
            et = N$1(this, et, tt, 0),
            st = !c$5(et) || et !== this._$AH && et !== w$3,
            st && (this._$AH = et);
        else {
            const at = et;
            let ot, lt;
            for (et = it[0],
            ot = 0; ot < it.length - 1; ot++)
                lt = N$1(this, at[rt + ot], tt, ot),
                lt === w$3 && (lt = this._$AH[ot]),
                st || (st = !c$5(lt) || lt !== this._$AH[ot]),
                lt === T$1 ? et = T$1 : et !== T$1 && (et += (lt ?? "") + it[ot + 1]),
                this._$AH[ot] = lt
        }
        st && !nt && this.j(et)
    }
    j(et) {
        et === T$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, et ?? "")
    }
}
  , k$1 = class extends R$1 {
    constructor() {
        super(...arguments),
        this.type = 3
    }
    j(et) {
        this.element[this.name] = et === T$1 ? void 0 : et
    }
}
  , H$1 = class extends R$1 {
    constructor() {
        super(...arguments),
        this.type = 4
    }
    j(et) {
        this.element.toggleAttribute(this.name, !!et && et !== T$1)
    }
}
  , I$1 = class extends R$1 {
    constructor(et, tt, rt, nt, it) {
        super(et, tt, rt, nt, it),
        this.type = 5
    }
    _$AI(et, tt=this) {
        if ((et = N$1(this, et, tt, 0) ?? T$1) === w$3)
            return;
        const rt = this._$AH
          , nt = et === T$1 && rt !== T$1 || et.capture !== rt.capture || et.once !== rt.once || et.passive !== rt.passive
          , it = et !== T$1 && (rt === T$1 || nt);
        nt && this.element.removeEventListener(this.name, this, rt),
        it && this.element.addEventListener(this.name, this, et),
        this._$AH = et
    }
    handleEvent(et) {
        var tt;
        typeof this._$AH == "function" ? this._$AH.call(((tt = this.options) == null ? void 0 : tt.host) ?? this.element, et) : this._$AH.handleEvent(et)
    }
}
  , L$1 = class {
    constructor(et, tt, rt) {
        this.element = et,
        this.type = 6,
        this._$AN = void 0,
        this._$AM = tt,
        this.options = rt
    }
    get _$AU() {
        return this._$AM._$AU
    }
    _$AI(et) {
        N$1(this, et)
    }
}
;
const Z$1 = t$6.litHtmlPolyfillSupport;
Z$1 == null || Z$1(V$1, M$1),
(t$6.litHtmlVersions ?? (t$6.litHtmlVersions = [])).push("3.1.2");
const j$1 = (_e,et,tt)=>{
    const rt = (tt == null ? void 0 : tt.renderBefore) ?? et;
    let nt = rt._$litPart$;
    if (nt === void 0) {
        const it = (tt == null ? void 0 : tt.renderBefore) ?? null;
        rt._$litPart$ = nt = new M$1(et.insertBefore(l$2(), it),it,void 0,tt ?? {})
    }
    return nt._$AI(_e),
    nt
}
;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$5 = class extends b$2 {
    constructor() {
        super(...arguments),
        this.renderOptions = {
            host: this
        },
        this._$Do = void 0
    }
    createRenderRoot() {
        var tt;
        const et = super.createRenderRoot();
        return (tt = this.renderOptions).renderBefore ?? (tt.renderBefore = et.firstChild),
        et
    }
    update(et) {
        const tt = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
        super.update(et),
        this._$Do = j$1(tt, this.renderRoot, this.renderOptions)
    }
    connectedCallback() {
        var et;
        super.connectedCallback(),
        (et = this._$Do) == null || et.setConnected(!0)
    }
    disconnectedCallback() {
        var et;
        super.disconnectedCallback(),
        (et = this._$Do) == null || et.setConnected(!1)
    }
    render() {
        return w$3
    }
}
;
var Yo;
s$5._$litElement$ = !0,
s$5.finalized = !0,
(Yo = globalThis.litElementHydrateSupport) == null || Yo.call(globalThis, {
    LitElement: s$5
});
const r$c = globalThis.litElementPolyfillSupport;
r$c == null || r$c({
    LitElement: s$5
});
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.4");
let themeTag, darkModeTag, lightModeTag;
function initializeTheming(_e, et) {
    themeTag = document.createElement("style"),
    darkModeTag = document.createElement("style"),
    lightModeTag = document.createElement("style"),
    themeTag.textContent = createRootStyles(_e).core.cssText,
    darkModeTag.textContent = createRootStyles(_e).dark.cssText,
    lightModeTag.textContent = createRootStyles(_e).light.cssText,
    document.head.appendChild(themeTag),
    document.head.appendChild(darkModeTag),
    document.head.appendChild(lightModeTag),
    setColorTheme(et)
}
function setColorTheme(_e) {
    darkModeTag && lightModeTag && (_e === "light" ? (darkModeTag.removeAttribute("media"),
    lightModeTag.media = "enabled") : (lightModeTag.removeAttribute("media"),
    darkModeTag.media = "enabled"))
}
function setThemeVariables(_e) {
    themeTag && darkModeTag && lightModeTag && (themeTag.textContent = createRootStyles(_e).core.cssText,
    darkModeTag.textContent = createRootStyles(_e).dark.cssText,
    lightModeTag.textContent = createRootStyles(_e).light.cssText)
}
function createRootStyles(_e) {
    return {
        core: i$8`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      :root {
        --w3m-color-mix-strength: ${r$f(_e != null && _e["--w3m-color-mix-strength"] ? `${_e["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r$f((_e == null ? void 0 : _e["--w3m-font-family"]) || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${r$f((_e == null ? void 0 : _e["--w3m-font-size-master"]) || "10px")};
        --w3m-border-radius-master: ${r$f((_e == null ? void 0 : _e["--w3m-border-radius-master"]) || "4px")};
        --w3m-z-index: ${r$f((_e == null ? void 0 : _e["--w3m-z-index"]) || 100)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-blue-100: var(--wui-color-blue-base-100);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-accent-glass-090: var(--wui-accent-glass-base-090);
        --wui-accent-glass-080: var(--wui-accent-glass-base-080);
        --wui-accent-glass-020: var(--wui-accent-glass-base-020);
        --wui-accent-glass-015: var(--wui-accent-glass-base-015);
        --wui-accent-glass-010: var(--wui-accent-glass-base-010);
        --wui-accent-glass-005: var(--wui-accent-glass-base-005);
        --wui-accent-glass-002: var(--wui-accent-glass-base-002);

        --wui-color-fg-100: var(--wui-color-fg-base-100);
        --wui-color-fg-125: var(--wui-color-fg-base-125);
        --wui-color-fg-150: var(--wui-color-fg-base-150);
        --wui-color-fg-175: var(--wui-color-fg-base-175);
        --wui-color-fg-200: var(--wui-color-fg-base-200);
        --wui-color-fg-225: var(--wui-color-fg-base-225);
        --wui-color-fg-250: var(--wui-color-fg-base-250);
        --wui-color-fg-275: var(--wui-color-fg-base-275);
        --wui-color-fg-300: var(--wui-color-fg-base-300);

        --wui-color-bg-100: var(--wui-color-bg-base-100);
        --wui-color-bg-125: var(--wui-color-bg-base-125);
        --wui-color-bg-150: var(--wui-color-bg-base-150);
        --wui-color-bg-175: var(--wui-color-bg-base-175);
        --wui-color-bg-200: var(--wui-color-bg-base-200);
        --wui-color-bg-225: var(--wui-color-bg-base-225);
        --wui-color-bg-250: var(--wui-color-bg-base-250);
        --wui-color-bg-275: var(--wui-color-bg-base-275);
        --wui-color-bg-300: var(--wui-color-bg-base-300);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            var(--w3m-default)
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            var(--w3m-default)
          );

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );

          --wui-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-base-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
        light: i$8`
      :root {
        --w3m-color-mix: ${r$f((_e == null ? void 0 : _e["--w3m-color-mix"]) || "#fff")};
        --w3m-accent: ${r$f((_e == null ? void 0 : _e["--w3m-accent"]) || "#47a1ff")};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: #191a1a;

        --wui-color-blue-base-100: #47a1ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #59aaff;
        --wui-color-accent-base-080: #6cb4ff;

        --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
        --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
        --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
        --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
        --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
        --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
        --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

        --wui-color-fg-base-100: #e4e7e7;
        --wui-color-fg-base-125: #d0d5d5;
        --wui-color-fg-base-150: #a8b1b1;
        --wui-color-fg-base-175: #a8b0b0;
        --wui-color-fg-base-200: #949e9e;
        --wui-color-fg-base-225: #868f8f;
        --wui-color-fg-base-250: #788080;
        --wui-color-fg-base-275: #788181;
        --wui-color-fg-base-300: #6e7777;

        --wui-color-bg-base-100: #141414;
        --wui-color-bg-base-125: #191a1a;
        --wui-color-bg-base-150: #1e1f1f;
        --wui-color-bg-base-175: #222525;
        --wui-color-bg-base-200: #272a2a;
        --wui-color-bg-base-225: #2c3030;
        --wui-color-bg-base-250: #313535;
        --wui-color-bg-base-275: #363b3b;
        --wui-color-bg-base-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-base-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
      }
    `,
        dark: i$8`
      :root {
        --w3m-color-mix: ${r$f((_e == null ? void 0 : _e["--w3m-color-mix"]) || "#000")};
        --w3m-accent: ${r$f((_e == null ? void 0 : _e["--w3m-accent"]) || "#3396ff")};
        --w3m-default: #000;

        --wui-color-modal-bg-base: #fff;

        --wui-color-blue-base-100: #3396ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #2d7dd2;
        --wui-color-accent-base-080: #2978cc;

        --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
        --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
        --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
        --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
        --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
        --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
        --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

        --wui-color-fg-base-100: #141414;
        --wui-color-fg-base-125: #2d3131;
        --wui-color-fg-base-150: #474d4d;
        --wui-color-fg-base-175: #636d6d;
        --wui-color-fg-base-200: #798686;
        --wui-color-fg-base-225: #828f8f;
        --wui-color-fg-base-250: #8b9797;
        --wui-color-fg-base-275: #95a0a0;
        --wui-color-fg-base-300: #9ea9a9;

        --wui-color-bg-base-100: #ffffff;
        --wui-color-bg-base-125: #f5fafa;
        --wui-color-bg-base-150: #f3f8f8;
        --wui-color-bg-base-175: #eef4f4;
        --wui-color-bg-base-200: #eaf1f1;
        --wui-color-bg-base-225: #e5eded;
        --wui-color-bg-base-250: #e1e9e9;
        --wui-color-bg-base-275: #dce7e7;
        --wui-color-bg-base-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-base-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
      }
    `
    }
}
const resetStyles = i$8`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`
  , elementStyles = i$8`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    outline: none;
    border: 1px solid transparent;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-005);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-010);
    }

    button[data-variant='fill']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='accentBg']:hover:enabled {
      background: var(--wui-accent-glass-015);
    }

    button[data-variant='accentBg']:active:enabled {
      background: var(--wui-accent-glass-020);
    }
  }

  button:disabled {
    cursor: not-allowed;
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='shade']:disabled,
  button[data-variant='accent']:disabled,
  button[data-variant='accentBg']:disabled {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-gray-glass-015);
    filter: grayscale(1);
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  button:focus-visible,
  a:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='fill']:disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='fill']:disabled > wui-icon {
    color: var(--wui-gray-glass-015);
  }

  button[data-variant='shade'] {
    color: var(--wui-color-fg-200);
  }

  button[data-variant='accent'],
  button[data-variant='accentBg'] {
    color: var(--wui-color-accent-100);
  }

  button[data-variant='accentBg'] {
    background: var(--wui-accent-glass-010);
    border: 1px solid var(--wui-accent-glass-010);
  }

  button[data-variant='fullWidth'] {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    height: 56px;
    border: none;
    background-color: var(--wui-gray-glass-002);
    color: var(--wui-color-fg-200);
    gap: var(--wui-spacing-xs);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:active:enabled {
    background-color: var(--wui-color-accent-080);
    border: 1px solid var(--wui-gray-glass-010);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`
  , colorStyles = i$8`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;
function standardCustomElement(_e, et) {
    const {kind: tt, elements: rt} = et;
    return {
        kind: tt,
        elements: rt,
        finisher(nt) {
            customElements.get(_e) || customElements.define(_e, nt)
        }
    }
}
function legacyCustomElement(_e, et) {
    return customElements.get(_e) || customElements.define(_e, et),
    et
}
function customElement(_e) {
    return function(tt) {
        return typeof tt == "function" ? legacyCustomElement(_e, tt) : standardCustomElement(_e, tt)
    }
}
const styles$1k = i$8`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    box-shadow: 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var __decorate$1H = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiCard = class extends s$5 {
    render() {
        return x$1`<slot></slot>`
    }
}
;
WuiCard.styles = [resetStyles, styles$1k];
WuiCard = __decorate$1H([customElement("wui-card")], WuiCard);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$a = {
    attribute: !0,
    type: String,
    converter: u$5,
    reflect: !1,
    hasChanged: f$7
}
  , r$b = (_e=o$a,et,tt)=>{
    const {kind: rt, metadata: nt} = tt;
    let it = globalThis.litPropertyMetadata.get(nt);
    if (it === void 0 && globalThis.litPropertyMetadata.set(nt, it = new Map),
    it.set(tt.name, _e),
    rt === "accessor") {
        const {name: st} = tt;
        return {
            set(at) {
                const ot = et.get.call(this);
                et.set.call(this, at),
                this.requestUpdate(st, ot, _e)
            },
            init(at) {
                return at !== void 0 && this.P(st, void 0, _e),
                at
            }
        }
    }
    if (rt === "setter") {
        const {name: st} = tt;
        return function(at) {
            const ot = this[st];
            et.call(this, at),
            this.requestUpdate(st, ot, _e)
        }
    }
    throw Error("Unsupported decorator location: " + rt)
}
;
function n$a(_e) {
    return (et,tt)=>typeof tt == "object" ? r$b(_e, et, tt) : ((rt,nt,it)=>{
        const st = nt.hasOwnProperty(it);
        return nt.constructor.createProperty(it, st ? {
            ...rt,
            wrapped: !0
        } : rt),
        st ? Object.getOwnPropertyDescriptor(nt, it) : void 0
    }
    )(_e, et, tt)
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$a(_e) {
    return n$a({
        ..._e,
        state: !0,
        attribute: !1
    })
}
const styles$1j = i$8`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`
  , allWalletsSvg = b$1`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`
  , arrowBottomCircleSvg = b$1`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10.5 2.42908C6.31875 2.42908 2.92859 5.81989 2.92859 10.0034C2.92859 14.1869 6.31875 17.5777 10.5 17.5777C14.6813 17.5777 18.0714 14.1869 18.0714 10.0034C18.0714 5.81989 14.6813 2.42908 10.5 2.42908ZM0.928589 10.0034C0.928589 4.71596 5.21355 0.429077 10.5 0.429077C15.7865 0.429077 20.0714 4.71596 20.0714 10.0034C20.0714 15.2908 15.7865 19.5777 10.5 19.5777C5.21355 19.5777 0.928589 15.2908 0.928589 10.0034ZM10.5 5.75003C11.0523 5.75003 11.5 6.19774 11.5 6.75003L11.5 10.8343L12.7929 9.54137C13.1834 9.15085 13.8166 9.15085 14.2071 9.54137C14.5976 9.9319 14.5976 10.5651 14.2071 10.9556L11.2071 13.9556C10.8166 14.3461 10.1834 14.3461 9.79291 13.9556L6.79291 10.9556C6.40239 10.5651 6.40239 9.9319 6.79291 9.54137C7.18343 9.15085 7.8166 9.15085 8.20712 9.54137L9.50002 10.8343L9.50002 6.75003C9.50002 6.19774 9.94773 5.75003 10.5 5.75003Z"
    clip-rule="evenodd"
  /></svg
>`
  , appStoreSvg = b$1`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`
  , appleSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , arrowBottomSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , arrowLeftSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`
  , arrowRightSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , arrowTopSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`
  , browserSvg$1 = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , checkmarkSvg = b$1`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="12"
  viewBox="0 0 12 12"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M10.537 2.34245C10.8997 2.64654 10.9471 3.187 10.6429 3.54959L5.61072 9.54757C5.45645 9.73144 5.23212 9.84222 4.99229 9.85295C4.75247 9.86368 4.51914 9.77337 4.34906 9.60401L1.40881 6.6761C1.07343 6.34213 1.07238 5.7996 1.40647 5.46433C1.74055 5.12906 2.28326 5.12801 2.61865 5.46198L4.89731 7.73108L9.32942 2.44834C9.63362 2.08576 10.1743 2.03835 10.537 2.34245Z"
    fill="currentColor"
  /></svg
>`
  , chevronBottomSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`
  , chevronLeftSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , chevronRightSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , chevronTopSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`
  , chromeStoreSvg = b$1`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`
  , clockSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , closeSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`
  , coinPlaceholderSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`
  , compassSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`
  , copySvg = b$1`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.21498 1.28565H10.5944C11.1458 1.28562 11.6246 1.2856 12.0182 1.32093C12.4353 1.35836 12.853 1.44155 13.2486 1.66724C13.7005 1.92498 14.0749 2.29935 14.3326 2.75122C14.5583 3.14689 14.6415 3.56456 14.6789 3.9817C14.7143 4.37531 14.7142 4.85403 14.7142 5.40545V6.78489C14.7142 7.33631 14.7143 7.81503 14.6789 8.20865C14.6415 8.62578 14.5583 9.04345 14.3326 9.43912C14.0749 9.89099 13.7005 10.2654 13.2486 10.5231C12.853 10.7488 12.4353 10.832 12.0182 10.8694C11.7003 10.8979 11.3269 10.9034 10.9045 10.9045C10.9034 11.3269 10.8979 11.7003 10.8694 12.0182C10.832 12.4353 10.7488 12.853 10.5231 13.2486C10.2654 13.7005 9.89099 14.0749 9.43912 14.3326C9.04345 14.5583 8.62578 14.6415 8.20865 14.6789C7.81503 14.7143 7.33631 14.7142 6.78489 14.7142H5.40545C4.85403 14.7142 4.37531 14.7143 3.9817 14.6789C3.56456 14.6415 3.14689 14.5583 2.75122 14.3326C2.29935 14.0749 1.92498 13.7005 1.66724 13.2486C1.44155 12.853 1.35836 12.4353 1.32093 12.0182C1.2856 11.6246 1.28562 11.1458 1.28565 10.5944V9.21498C1.28562 8.66356 1.2856 8.18484 1.32093 7.79122C1.35836 7.37409 1.44155 6.95642 1.66724 6.56074C1.92498 6.10887 2.29935 5.73451 2.75122 5.47677C3.14689 5.25108 3.56456 5.16789 3.9817 5.13045C4.2996 5.10192 4.67301 5.09645 5.09541 5.09541C5.09645 4.67302 5.10192 4.2996 5.13045 3.9817C5.16789 3.56456 5.25108 3.14689 5.47676 2.75122C5.73451 2.29935 6.10887 1.92498 6.56074 1.66724C6.95642 1.44155 7.37409 1.35836 7.79122 1.32093C8.18484 1.2856 8.66356 1.28562 9.21498 1.28565ZM5.09541 7.09552C4.68397 7.09667 4.39263 7.10161 4.16046 7.12245C3.88053 7.14757 3.78516 7.18949 3.74214 7.21403C3.60139 7.29431 3.48478 7.41091 3.4045 7.55166C3.37997 7.59468 3.33804 7.69005 3.31292 7.96999C3.28659 8.26345 3.28565 8.65147 3.28565 9.25708V10.5523C3.28565 11.1579 3.28659 11.5459 3.31292 11.8394C3.33804 12.1193 3.37997 12.2147 3.4045 12.2577C3.48478 12.3985 3.60139 12.5151 3.74214 12.5954C3.78516 12.6199 3.88053 12.6618 4.16046 12.6869C4.45393 12.7133 4.84195 12.7142 5.44755 12.7142H6.74279C7.3484 12.7142 7.73641 12.7133 8.02988 12.6869C8.30981 12.6618 8.40518 12.6199 8.44821 12.5954C8.58895 12.5151 8.70556 12.3985 8.78584 12.2577C8.81038 12.2147 8.8523 12.1193 8.87742 11.8394C8.89825 11.6072 8.90319 11.3159 8.90435 10.9045C8.48219 10.9034 8.10898 10.8979 7.79122 10.8694C7.37409 10.832 6.95641 10.7488 6.56074 10.5231C6.10887 10.2654 5.73451 9.89099 5.47676 9.43912C5.25108 9.04345 5.16789 8.62578 5.13045 8.20865C5.10194 7.89089 5.09645 7.51767 5.09541 7.09552ZM7.96999 3.31292C7.69005 3.33804 7.59468 3.37997 7.55166 3.4045C7.41091 3.48478 7.29431 3.60139 7.21403 3.74214C7.18949 3.78516 7.14757 3.88053 7.12245 4.16046C7.09611 4.45393 7.09517 4.84195 7.09517 5.44755V6.74279C7.09517 7.3484 7.09611 7.73641 7.12245 8.02988C7.14757 8.30981 7.18949 8.40518 7.21403 8.4482C7.29431 8.58895 7.41091 8.70556 7.55166 8.78584C7.59468 8.81038 7.69005 8.8523 7.96999 8.87742C8.26345 8.90376 8.65147 8.9047 9.25708 8.9047H10.5523C11.1579 8.9047 11.5459 8.90376 11.8394 8.87742C12.1193 8.8523 12.2147 8.81038 12.2577 8.78584C12.3985 8.70556 12.5151 8.58895 12.5954 8.4482C12.6199 8.40518 12.6618 8.30981 12.6869 8.02988C12.7133 7.73641 12.7142 7.3484 12.7142 6.74279V5.44755C12.7142 4.84195 12.7133 4.45393 12.6869 4.16046C12.6618 3.88053 12.6199 3.78516 12.5954 3.74214C12.5151 3.60139 12.3985 3.48478 12.2577 3.4045C12.2147 3.37997 12.1193 3.33804 11.8394 3.31292C11.5459 3.28659 11.1579 3.28565 10.5523 3.28565H9.25708C8.65147 3.28565 8.26345 3.28659 7.96999 3.31292Z"
    fill="#788181"
  /></svg
>`
  , addSvg = b$1`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.0023 0.875C7.48571 0.875 7.8776 1.26675 7.8776 1.75V6.125H12.2541C12.7375 6.125 13.1294 6.51675 13.1294 7C13.1294 7.48325 12.7375 7.875 12.2541 7.875H7.8776V12.25C7.8776 12.7332 7.48571 13.125 7.0023 13.125C6.51889 13.125 6.12701 12.7332 6.12701 12.25V7.875H1.75054C1.26713 7.875 0.875244 7.48325 0.875244 7C0.875244 6.51675 1.26713 6.125 1.75054 6.125H6.12701V1.75C6.12701 1.26675 6.51889 0.875 7.0023 0.875Z"
    fill="#47A1FF"
  /></svg
>`
  , cursorSvg = b$1` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`
  , desktopSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`
  , disconnectSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`
  , discordSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`
  , etherscanSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`
  , extensionSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`
  , externalLinkSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , facebookSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , filtersSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , githubSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , googleSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
      <g clip-path="url(#c)">
        <path
          fill="#4285F4"
          d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
        />
        <path
          fill="#34A853"
          d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
        />
        <path
          fill="#FBBC05"
          d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
        />
        <path
          fill="#EA4335"
          d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , helpCircleSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`
  , infoCircleSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , mailSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`
  , mobileSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`
  , networkPlaceholderSvg = b$1`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`
  , nftPlaceholderSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , offSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`
  , playStoreSvg = b$1` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`
  , qrCodeIcon = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`
  , refreshSvg = b$1`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`
  , searchSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`
  , sendSvg = b$1`<svg fill="none" viewBox="0 0 21 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.3808 4.34812C13.72 4.47798 12.8501 4.7587 11.5748 5.17296L9.00869 6.00646C6.90631 6.68935 5.40679 7.17779 4.38121 7.63178C3.87166 7.85734 3.5351 8.05091 3.32022 8.22035C3.11183 8.38466 3.07011 8.48486 3.05969 8.51817C2.98058 8.77103 2.98009 9.04195 3.05831 9.29509C3.06861 9.32844 3.10998 9.42878 3.31777 9.59384C3.53205 9.76404 3.86792 9.95881 4.37667 10.1862C5.29287 10.5957 6.58844 11.0341 8.35529 11.6164L10.8876 8.59854C11.2426 8.17547 11.8733 8.12028 12.2964 8.47528C12.7195 8.83029 12.7746 9.46104 12.4196 9.88412L9.88738 12.9019C10.7676 14.5408 11.4244 15.7406 11.9867 16.5718C12.299 17.0333 12.5491 17.3303 12.7539 17.5117C12.9526 17.6877 13.0586 17.711 13.0932 17.7154C13.3561 17.7484 13.6228 17.7009 13.8581 17.5791C13.8891 17.563 13.9805 17.5046 14.1061 17.2708C14.2357 17.0298 14.3679 16.6647 14.5015 16.1237C14.7705 15.0349 14.9912 13.4733 15.2986 11.2843L15.6738 8.61249C15.8603 7.28456 15.9857 6.37917 15.9989 5.7059C16.012 5.03702 15.9047 4.8056 15.8145 4.69183C15.7044 4.55297 15.5673 4.43792 15.4114 4.35365C15.2837 4.28459 15.0372 4.2191 14.3808 4.34812ZM7.99373 13.603C6.11919 12.9864 4.6304 12.4902 3.5606 12.0121C2.98683 11.7557 2.4778 11.4808 2.07383 11.1599C1.66337 10.8339 1.31312 10.4217 1.14744 9.88551C0.949667 9.24541 0.950886 8.56035 1.15094 7.92096C1.31852 7.38534 1.67024 6.97442 2.08185 6.64985C2.48697 6.33041 2.99697 6.05734 3.57166 5.80295C4.70309 5.3021 6.30179 4.78283 8.32903 4.12437L11.0196 3.25042C12.2166 2.86159 13.2017 2.54158 13.9951 2.38566C14.8065 2.22618 15.6202 2.19289 16.3627 2.59437C16.7568 2.80747 17.1035 3.09839 17.3818 3.4495C17.9062 4.111 18.0147 4.91815 17.9985 5.74496C17.9827 6.55332 17.8386 7.57903 17.6636 8.82534L17.2701 11.6268C16.9737 13.7376 16.7399 15.4022 16.4432 16.6034C16.2924 17.2135 16.1121 17.7632 15.8678 18.2176C15.6197 18.6794 15.2761 19.0971 14.7777 19.3551C14.1827 19.6632 13.5083 19.7833 12.8436 19.6997C12.2867 19.6297 11.82 19.3563 11.4277 19.0087C11.0415 18.6666 10.6824 18.213 10.3302 17.6925C9.67361 16.722 8.92648 15.342 7.99373 13.603Z"
    clip-rule="evenodd"
  />
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="21"
    height="20"
    viewBox="0 0 21 20"
    fill="none"
  ></svg></svg
>`
  , swapHorizontalSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`
  , swapHorizontalBoldSvg = b$1`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`
  , swapHorizontalMediumSvg = b$1`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.7306 3.24213C14.0725 3.58384 14.0725 4.13786 13.7306 4.47957L10.7418 7.46737C10.4 7.80908 9.84581 7.80908 9.50399 7.46737C9.16216 7.12567 9.16216 6.57165 9.50399 6.22994L10.9986 4.73585H5.34082C4.85741 4.73585 4.46553 4.3441 4.46553 3.86085C4.46553 3.3776 4.85741 2.98585 5.34082 2.98585L10.9986 2.98585L9.50399 1.49177C9.16216 1.15006 9.16216 0.596037 9.50399 0.254328C9.84581 -0.0873803 10.4 -0.0873803 10.7418 0.254328L13.7306 3.24213ZM9.52515 10.1352C9.52515 10.6185 9.13327 11.0102 8.64986 11.0102L2.9921 11.0102L4.48669 12.5043C4.82852 12.846 4.82852 13.4001 4.48669 13.7418C4.14487 14.0835 3.59066 14.0835 3.24884 13.7418L0.26003 10.754C0.0958806 10.5899 0.0036621 10.3673 0.00366211 10.1352C0.00366212 9.90318 0.0958806 9.68062 0.26003 9.51652L3.24884 6.52872C3.59066 6.18701 4.14487 6.18701 4.48669 6.52872C4.82851 6.87043 4.82851 7.42445 4.48669 7.76616L2.9921 9.26024L8.64986 9.26024C9.13327 9.26024 9.52515 9.65199 9.52515 10.1352Z"
    fill="currentColor"
  />
</svg>

`
  , swapVerticalSvg = b$1`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , telegramSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg> `
  , twitchSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , twitterSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
      <path
        fill="#fff"
        d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`
  , twitterIconSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`
  , verifySvg = b$1`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`
  , verifyFilledSvg = b$1`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`
  , walletPlaceholderSvg = b$1`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`
  , walletSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`
  , walletConnectSvg = b$1`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`
  , warningCircleSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , recycleHorizontalSvg = b$1`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    d="M8.8071 0.292893C9.19763 0.683417 9.19763 1.31658 8.8071 1.70711L6.91421 3.6H11.8404C14.3368 3.6 16.5533 5.1975 17.3427 7.56588L17.4487 7.88377C17.6233 8.40772 17.3402 8.97404 16.8162 9.14868C16.2923 9.32333 15.726 9.04017 15.5513 8.51623L15.4453 8.19834C14.9281 6.64664 13.476 5.6 11.8404 5.6H6.91421L8.8071 7.49289C9.19763 7.88342 9.19763 8.51658 8.8071 8.90711C8.41658 9.29763 7.78341 9.29763 7.39289 8.90711L3.79289 5.30711C3.40236 4.91658 3.40236 4.28342 3.79289 3.89289L7.39289 0.292893C7.78341 -0.0976311 8.41658 -0.0976311 8.8071 0.292893ZM4.18377 10.8513C4.70771 10.6767 5.27403 10.9598 5.44868 11.4838L5.55464 11.8017C6.07188 13.3534 7.52401 14.4 9.15964 14.4L14.0858 14.4L12.1929 12.5071C11.8024 12.1166 11.8024 11.4834 12.1929 11.0929C12.5834 10.7024 13.2166 10.7024 13.6071 11.0929L17.2071 14.6929C17.5976 15.0834 17.5976 15.7166 17.2071 16.1071L13.6071 19.7071C13.2166 20.0976 12.5834 20.0976 12.1929 19.7071C11.8024 19.3166 11.8024 18.6834 12.1929 18.2929L14.0858 16.4L9.15964 16.4C6.66314 16.4 4.44674 14.8025 3.65728 12.4341L3.55131 12.1162C3.37667 11.5923 3.65983 11.026 4.18377 10.8513Z"
  /></svg
>`
  , bankSvg = b$1`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.61391 1.57124C5.85142 1.42873 6.14813 1.42873 6.38564 1.57124L11.0793 4.38749C11.9179 4.89067 11.5612 6.17864 10.5832 6.17864H9.96398V10.0358H10.2854C10.6996 10.0358 11.0354 10.3716 11.0354 10.7858C11.0354 11.2 10.6996 11.5358 10.2854 11.5358H1.71416C1.29995 11.5358 0.964172 11.2 0.964172 10.7858C0.964172 10.3716 1.29995 10.0358 1.71416 10.0358H2.03558L2.03558 6.17864H1.41637C0.438389 6.17864 0.0816547 4.89066 0.920263 4.38749L5.61391 1.57124ZM3.53554 6.17864V10.0358H5.24979V6.17864H3.53554ZM6.74976 6.17864V10.0358H8.46401V6.17864H6.74976ZM8.64913 4.67864H3.35043L5.99978 3.089L8.64913 4.67864Z"
    fill="currentColor"
  /></svg
>`
  , cardSvg = b$1`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.16072 2C4.17367 2 4.18665 2 4.19968 2L7.83857 2C8.36772 1.99998 8.82398 1.99996 9.19518 2.04018C9.5895 2.0829 9.97577 2.17811 10.3221 2.42971C10.5131 2.56849 10.6811 2.73647 10.8198 2.92749C11.0714 3.27379 11.1666 3.66007 11.2094 4.0544C11.2496 4.42561 11.2496 4.88188 11.2495 5.41105V7.58896C11.2496 8.11812 11.2496 8.57439 11.2094 8.94561C11.1666 9.33994 11.0714 9.72621 10.8198 10.0725C10.6811 10.2635 10.5131 10.4315 10.3221 10.5703C9.97577 10.8219 9.5895 10.9171 9.19518 10.9598C8.82398 11 8.36772 11 7.83856 11H4.16073C3.63157 11 3.17531 11 2.80411 10.9598C2.40979 10.9171 2.02352 10.8219 1.67722 10.5703C1.48621 10.4315 1.31824 10.2635 1.17946 10.0725C0.927858 9.72621 0.832652 9.33994 0.78993 8.94561C0.749713 8.5744 0.749733 8.11813 0.749757 7.58896L0.749758 5.45C0.749758 5.43697 0.749758 5.42399 0.749757 5.41104C0.749733 4.88188 0.749713 4.42561 0.78993 4.0544C0.832652 3.66007 0.927858 3.27379 1.17946 2.92749C1.31824 2.73647 1.48621 2.56849 1.67722 2.42971C2.02352 2.17811 2.40979 2.0829 2.80411 2.04018C3.17531 1.99996 3.63157 1.99998 4.16072 2ZM2.96567 3.53145C2.69897 3.56034 2.60687 3.60837 2.55888 3.64324C2.49521 3.6895 2.43922 3.74549 2.39296 3.80916C2.35809 3.85715 2.31007 3.94926 2.28117 4.21597C2.26629 4.35335 2.25844 4.51311 2.25431 4.70832H9.74498C9.74085 4.51311 9.733 4.35335 9.71812 4.21597C9.68922 3.94926 9.6412 3.85715 9.60633 3.80916C9.56007 3.74549 9.50408 3.6895 9.44041 3.64324C9.39242 3.60837 9.30031 3.56034 9.03362 3.53145C8.75288 3.50103 8.37876 3.5 7.79961 3.5H4.19968C3.62053 3.5 3.24641 3.50103 2.96567 3.53145ZM9.74956 6.20832H2.24973V7.55C2.24973 8.12917 2.25076 8.5033 2.28117 8.78404C2.31007 9.05074 2.35809 9.14285 2.39296 9.19084C2.43922 9.25451 2.49521 9.31051 2.55888 9.35677C2.60687 9.39163 2.69897 9.43966 2.96567 9.46856C3.24641 9.49897 3.62053 9.5 4.19968 9.5H7.79961C8.37876 9.5 8.75288 9.49897 9.03362 9.46856C9.30032 9.43966 9.39242 9.39163 9.44041 9.35677C9.50408 9.31051 9.56007 9.25451 9.60633 9.19084C9.6412 9.14285 9.68922 9.05075 9.71812 8.78404C9.74854 8.5033 9.74956 8.12917 9.74956 7.55V6.20832ZM6.74963 8C6.74963 7.58579 7.08541 7.25 7.49961 7.25H8.2496C8.6638 7.25 8.99958 7.58579 8.99958 8C8.99958 8.41422 8.6638 8.75 8.2496 8.75H7.49961C7.08541 8.75 6.74963 8.41422 6.74963 8Z"
    fill="currentColor"
  /></svg
>`
  , plusSvg = b$1`<svg
  width="13"
  height="12"
  viewBox="0 0 13 12"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.794373 5.99982C0.794373 5.52643 1.17812 5.14268 1.6515 5.14268H5.643V1.15109C5.643 0.677701 6.02675 0.293946 6.50012 0.293945C6.9735 0.293946 7.35725 0.677701 7.35725 1.15109V5.14268H11.3488C11.8221 5.14268 12.2059 5.52643 12.2059 5.99982C12.2059 6.47321 11.8221 6.85696 11.3488 6.85696H7.35725V10.8486C7.35725 11.3219 6.9735 11.7057 6.50012 11.7057C6.02675 11.7057 5.643 11.3219 5.643 10.8486V6.85696H1.6515C1.17812 6.85696 0.794373 6.47321 0.794373 5.99982Z"
  /></svg
>`;
var __decorate$1G = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const svgOptions$1 = {
    add: addSvg,
    allWallets: allWalletsSvg,
    arrowBottomCircle: arrowBottomCircleSvg,
    appStore: appStoreSvg,
    apple: appleSvg,
    arrowBottom: arrowBottomSvg,
    arrowLeft: arrowLeftSvg,
    arrowRight: arrowRightSvg,
    arrowTop: arrowTopSvg,
    bank: bankSvg,
    browser: browserSvg$1,
    card: cardSvg,
    checkmark: checkmarkSvg,
    chevronBottom: chevronBottomSvg,
    chevronLeft: chevronLeftSvg,
    chevronRight: chevronRightSvg,
    chevronTop: chevronTopSvg,
    chromeStore: chromeStoreSvg,
    clock: clockSvg,
    close: closeSvg,
    compass: compassSvg,
    coinPlaceholder: coinPlaceholderSvg,
    copy: copySvg,
    cursor: cursorSvg,
    desktop: desktopSvg,
    disconnect: disconnectSvg,
    discord: discordSvg,
    etherscan: etherscanSvg,
    extension: extensionSvg,
    externalLink: externalLinkSvg,
    facebook: facebookSvg,
    filters: filtersSvg,
    github: githubSvg,
    google: googleSvg,
    helpCircle: helpCircleSvg,
    infoCircle: infoCircleSvg,
    mail: mailSvg,
    mobile: mobileSvg,
    networkPlaceholder: networkPlaceholderSvg,
    nftPlaceholder: nftPlaceholderSvg,
    off: offSvg,
    playStore: playStoreSvg,
    plus: plusSvg,
    qrCode: qrCodeIcon,
    recycleHorizontal: recycleHorizontalSvg,
    refresh: refreshSvg,
    search: searchSvg,
    send: sendSvg,
    swapHorizontal: swapHorizontalSvg,
    swapHorizontalMedium: swapHorizontalMediumSvg,
    swapHorizontalBold: swapHorizontalBoldSvg,
    swapVertical: swapVerticalSvg,
    telegram: telegramSvg,
    twitch: twitchSvg,
    twitter: twitterSvg,
    twitterIcon: twitterIconSvg,
    verify: verifySvg,
    verifyFilled: verifyFilledSvg,
    wallet: walletSvg,
    walletConnect: walletConnectSvg,
    walletPlaceholder: walletPlaceholderSvg,
    warningCircle: warningCircleSvg
};
let WuiIcon = class extends s$5 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.name = "copy",
        this.color = "fg-300"
    }
    render() {
        return this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `,
        x$1`${svgOptions$1[this.name]}`
    }
}
;
WuiIcon.styles = [resetStyles, colorStyles, styles$1j];
__decorate$1G([n$a()], WuiIcon.prototype, "size", void 0);
__decorate$1G([n$a()], WuiIcon.prototype, "name", void 0);
__decorate$1G([n$a()], WuiIcon.prototype, "color", void 0);
WuiIcon = __decorate$1G([customElement("wui-icon")], WuiIcon);
const styles$1i = i$8`
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var __decorate$1F = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiImage = class extends s$5 {
    constructor() {
        super(...arguments),
        this.src = "./path/to/image.jpg",
        this.alt = "Image"
    }
    render() {
        return x$1`<img src=${this.src} alt=${this.alt} />`
    }
}
;
WuiImage.styles = [resetStyles, colorStyles, styles$1i];
__decorate$1F([n$a()], WuiImage.prototype, "src", void 0);
__decorate$1F([n$a()], WuiImage.prototype, "alt", void 0);
WuiImage = __decorate$1F([customElement("wui-image")], WuiImage);
const styles$1h = i$8`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1E = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiLoadingHexagon = class extends s$5 {
    render() {
        return x$1`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `
    }
}
;
WuiLoadingHexagon.styles = [resetStyles, styles$1h];
WuiLoadingHexagon = __decorate$1E([customElement("wui-loading-hexagon")], WuiLoadingHexagon);
const styles$1g = i$8`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var __decorate$1D = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiLoadingSpinner = class extends s$5 {
    constructor() {
        super(...arguments),
        this.color = "accent-100",
        this.size = "lg"
    }
    render() {
        return this.style.cssText = `--local-color: var(--wui-color-${this.color});`,
        this.dataset.size = this.size,
        x$1`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`
    }
}
;
WuiLoadingSpinner.styles = [resetStyles, styles$1g];
__decorate$1D([n$a()], WuiLoadingSpinner.prototype, "color", void 0);
__decorate$1D([n$a()], WuiLoadingSpinner.prototype, "size", void 0);
WuiLoadingSpinner = __decorate$1D([customElement("wui-loading-spinner")], WuiLoadingSpinner);
const styles$1f = i$8`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1C = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiLoadingThumbnail = class extends s$5 {
    constructor() {
        super(...arguments),
        this.radius = 36
    }
    render() {
        return this.svgLoaderTemplate()
    }
    svgLoaderTemplate() {
        const et = this.radius > 50 ? 50 : this.radius
          , rt = 36 - et
          , nt = 116 + rt
          , it = 245 + rt
          , st = 360 + rt * 1.75;
        return x$1`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${et}
          stroke-dasharray="${nt} ${it}"
          stroke-dashoffset=${st}
        />
      </svg>
    `
    }
}
;
WuiLoadingThumbnail.styles = [resetStyles, styles$1f];
__decorate$1C([n$a({
    type: Number
})], WuiLoadingThumbnail.prototype, "radius", void 0);
WuiLoadingThumbnail = __decorate$1C([customElement("wui-loading-thumbnail")], WuiLoadingThumbnail);
const styles$1e = i$8`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var __decorate$1B = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiShimmer = class extends s$5 {
    constructor() {
        super(...arguments),
        this.width = "",
        this.height = "",
        this.borderRadius = "m"
    }
    render() {
        return this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `,
        x$1`<slot></slot>`
    }
}
;
WuiShimmer.styles = [styles$1e];
__decorate$1B([n$a()], WuiShimmer.prototype, "width", void 0);
__decorate$1B([n$a()], WuiShimmer.prototype, "height", void 0);
__decorate$1B([n$a()], WuiShimmer.prototype, "borderRadius", void 0);
WuiShimmer = __decorate$1B([customElement("wui-shimmer")], WuiShimmer);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$5 = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
}
  , e$7 = _e=>(...et)=>({
    _$litDirective$: _e,
    values: et
});
let i$5 = class {
    constructor(et) {}
    get _$AU() {
        return this._$AM._$AU
    }
    _$AT(et, tt, rt) {
        this._$Ct = et,
        this._$AM = tt,
        this._$Ci = rt
    }
    _$AS(et, tt) {
        return this.update(et, tt)
    }
    update(et, tt) {
        return this.render(...tt)
    }
}
;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$6 = e$7(class extends i$5 {
    constructor(_e) {
        var et;
        if (super(_e),
        _e.type !== t$5.ATTRIBUTE || _e.name !== "class" || ((et = _e.strings) == null ? void 0 : et.length) > 2)
            throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")
    }
    render(_e) {
        return " " + Object.keys(_e).filter(et=>_e[et]).join(" ") + " "
    }
    update(_e, [et]) {
        var rt, nt;
        if (this.st === void 0) {
            this.st = new Set,
            _e.strings !== void 0 && (this.nt = new Set(_e.strings.join(" ").split(/\s/).filter(it=>it !== "")));
            for (const it in et)
                et[it] && !((rt = this.nt) != null && rt.has(it)) && this.st.add(it);
            return this.render(et)
        }
        const tt = _e.element.classList;
        for (const it of this.st)
            it in et || (tt.remove(it),
            this.st.delete(it));
        for (const it in et) {
            const st = !!et[it];
            st === this.st.has(it) || (nt = this.nt) != null && nt.has(it) || (st ? (tt.add(it),
            this.st.add(it)) : (tt.remove(it),
            this.st.delete(it)))
        }
        return w$3
    }
}
)
  , styles$1d = i$8`
  :host {
    display: inline-flex !important;
  }

  slot {
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-font-medium-title-600 {
    font-size: var(--wui-font-size-medium-title);
    letter-spacing: var(--wui-letter-spacing-medium-title);
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-2xl-500,
  .wui-font-2xl-600,
  .wui-font-2xl-700 {
    font-size: var(--wui-font-size-2xl);
    letter-spacing: var(--wui-letter-spacing-2xl);
  }

  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-400,
  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-tiny-400,
  .wui-font-small-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-medium-title-600,
  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;
var __decorate$1A = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiText = class extends s$5 {
    constructor() {
        super(...arguments),
        this.variant = "paragraph-500",
        this.color = "fg-300",
        this.align = "left"
    }
    render() {
        const et = {
            [`wui-font-${this.variant}`]: !0,
            [`wui-color-${this.color}`]: !0
        };
        return this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `,
        x$1`<slot class=${e$6(et)}></slot>`
    }
}
;
WuiText.styles = [resetStyles, styles$1d];
__decorate$1A([n$a()], WuiText.prototype, "variant", void 0);
__decorate$1A([n$a()], WuiText.prototype, "color", void 0);
__decorate$1A([n$a()], WuiText.prototype, "align", void 0);
WuiText = __decorate$1A([customElement("wui-text")], WuiText);
const browserSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `
  , daoSvg = b$1`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `
  , defiSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`
  , defiAltSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `
  , ethSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `
  , layersSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
  , lockSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
  , loginSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `
  , networkSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`
  , nftSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `
  , nounSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
  , profileSvg = b$1`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `
  , systemSvg = b$1`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `
  , coinbaseSvg = b$1`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40" fill="none">
  <g clip-path="url(#clip0_187_29)">
    <path d="M1.18187e-05 15.8055C1.18187e-05 9.8015 -5.19442e-07 6.91338 1.69991e-08 0C4.5 3.72236e-05 9.62249 0 16.5 0L23.5 4.31399e-05C29.9349 4.31399e-05 35.5 0.000206332 40 3.73468e-05C40 2.77754 40 9.36708 40 15.8055V22.8364C40 29.2647 40 33.7962 40 40C31.5 40 29.8337 40 23.4 40H16.6C10.5092 40 6.50004 40 4.04289e-05 40C3.05176e-05 32.2453 1.18187e-05 29.6382 1.18187e-05 22.8364V15.8055Z" fill="#0052FF"/>
    <path d="M20.0236 26.5C16.4342 26.5 13.5236 23.5931 13.5236 20C13.5236 16.4069 16.4342 13.5 20.0236 13.5C23.2411 13.5 25.9134 15.8472 26.4261 18.9167H32.9731C32.4206 12.2433 26.8342 7 20.02 7C12.8411 7 7.02002 12.8211 7.02002 20C7.02002 27.1789 12.8411 33 20.02 33C26.8342 33 32.4206 27.7567 32.9731 21.0833H26.4225C25.9061 24.1528 23.2411 26.5 20.0236 26.5Z" fill="white"/>
  </g>
  <defs>
    <clipPath id="clip0_187_29">
      <rect width="40" height="40" fill="white"/>
    </clipPath>
  </defs>
</svg>`
  , moonpaySvg = b$1`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#7D00FF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M28.306 15.381a3.69 3.69 0 1 0 0-7.381 3.69 3.69 0 0 0 0 7.381ZM16.987 32a8.991 8.991 0 1 1 .016-17.983A8.991 8.991 0 0 1 16.988 32Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`
  , stripeSvg = b$1`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#635BFF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M18.299 15.147c0-1.028.844-1.424 2.242-1.424 2.004 0 4.536.607 6.54 1.688V9.213C24.892 8.343 22.73 8 20.541 8c-5.354 0-8.915 2.796-8.915 7.464 0 7.279 10.022 6.118 10.022 9.257 0 1.213-1.055 1.609-2.531 1.609-2.19 0-4.985-.897-7.2-2.11v6.277a18.283 18.283 0 0 0 7.2 1.503c5.485 0 9.257-2.716 9.257-7.437-.027-7.86-10.075-6.462-10.075-9.416Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`
  , paypalSvg = b$1`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#fff"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M18.606 12.642a.781.781 0 0 0-.771.66l-1.281 8.125a.78.78 0 0 1 .77-.66h3.755a7.668 7.668 0 0 0 7.57-6.49 6.26 6.26 0 0 0 .075-.843c-.96-.504-2.089-.792-3.325-.792h-6.793Z"
        fill="#001C64"
      />
      <path
        d="M28.724 13.434c-.006.282-.03.564-.075.843a7.668 7.668 0 0 1-7.57 6.491h-3.754a.78.78 0 0 0-.771.66l-1.916 12.15a.634.634 0 0 0 .626.734h4.075a.781.781 0 0 0 .77-.66l1.074-6.807a.781.781 0 0 1 .772-.66h2.4a7.668 7.668 0 0 0 7.57-6.491c.415-2.651-.92-5.064-3.201-6.26Z"
        fill="#0070E0"
      />
      <path
        d="M13.977 7.226a.78.78 0 0 0-.771.658l-3.198 20.277a.634.634 0 0 0 .626.733h4.742l1.178-7.467 1.281-8.125a.782.782 0 0 1 .771-.66H25.4c1.237 0 2.364.289 3.325.792.065-3.4-2.74-6.208-6.599-6.208h-8.148Z"
        fill="#003087"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`
  , onrampCardSvg = b$1`<svg width="60" height="60" viewBox="0 0 60 60" fill="none">
<g clip-path="url(#clip0_13859_31161)">
  <path d="M0 24.8995C0 15.6481 0 11.0223 1.97053 7.56763C3.3015 5.2342 5.23468 3.30101 7.56812 1.97004C11.0228 -0.000488281 15.6485 -0.000488281 24.9 -0.000488281H35.1C44.3514 -0.000488281 48.9772 -0.000488281 52.4319 1.97004C54.7653 3.30101 56.6985 5.2342 58.0295 7.56763C60 11.0223 60 15.6481 60 24.8995V35.0995C60 44.351 60 48.9767 58.0295 52.4314C56.6985 54.7648 54.7653 56.698 52.4319 58.029C48.9772 59.9995 44.3514 59.9995 35.1 59.9995H24.9C15.6485 59.9995 11.0228 59.9995 7.56812 58.029C5.23468 56.698 3.3015 54.7648 1.97053 52.4314C0 48.9767 0 44.351 0 35.0995V24.8995Z" fill="#EB8B47"/>
  <path d="M0.5 24.8995C0.5 20.2647 0.50047 16.8216 0.744315 14.1045C0.987552 11.3941 1.46987 9.45455 2.40484 7.81536C3.69145 5.55971 5.56019 3.69096 7.81585 2.40435C9.45504 1.46938 11.3946 0.987064 14.105 0.743826C16.8221 0.499981 20.2652 0.499512 24.9 0.499512H35.1C39.7348 0.499512 43.1779 0.499981 45.895 0.743826C48.6054 0.987064 50.545 1.46938 52.1841 2.40435C54.4398 3.69096 56.3086 5.55971 57.5952 7.81536C58.5301 9.45455 59.0124 11.3941 59.2557 14.1045C59.4995 16.8216 59.5 20.2647 59.5 24.8995V35.0995C59.5 39.7343 59.4995 43.1774 59.2557 45.8945C59.0124 48.6049 58.5301 50.5445 57.5952 52.1837C56.3086 54.4393 54.4398 56.3081 52.1841 57.5947C50.545 58.5296 48.6054 59.012 45.895 59.2552C43.1779 59.499 39.7348 59.4995 35.1 59.4995H24.9C20.2652 59.4995 16.8221 59.499 14.105 59.2552C11.3946 59.012 9.45504 58.5296 7.81585 57.5947C5.56019 56.3081 3.69145 54.4393 2.40484 52.1837C1.46987 50.5445 0.987552 48.6049 0.744315 45.8945C0.50047 43.1774 0.5 39.7343 0.5 35.0995V24.8995Z" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M13 26.0335C13 21.7838 13 19.659 14.0822 18.1694C14.4318 17.6883 14.8548 17.2653 15.3359 16.9157C16.8255 15.8335 18.9503 15.8335 23.2 15.8335H36.8C41.0497 15.8335 43.1745 15.8335 44.6641 16.9157C45.1452 17.2653 45.5682 17.6883 45.9178 18.1694C47 19.659 47 21.7838 47 26.0335V33.9668C47 38.2165 47 40.3414 45.9178 41.831C45.5682 42.312 45.1452 42.7351 44.6641 43.0846C43.1745 44.1668 41.0497 44.1668 36.8 44.1668H23.2C18.9503 44.1668 16.8255 44.1668 15.3359 43.0846C14.8548 42.7351 14.4318 42.312 14.0822 41.831C13 40.3414 13 38.2165 13 33.9668V26.0335Z" fill="#FF974C" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M39.5 36.667H36.6666" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M45.2 23.0645H14.8C14.0501 23.0645 13.6751 23.0645 13.4122 23.2554C13.3273 23.3171 13.2527 23.3918 13.191 23.4767C13 23.7395 13 24.1145 13 24.8645V27.2645C13 28.0144 13 28.3894 13.191 28.6522C13.2527 28.7371 13.3273 28.8118 13.4122 28.8735C13.6751 29.0645 14.0501 29.0645 14.8 29.0645H45.2C45.9499 29.0645 46.3249 29.0645 46.5878 28.8735C46.6727 28.8118 46.7473 28.7371 46.809 28.6522C47 28.3894 47 28.0144 47 27.2645V24.8645C47 24.1145 47 23.7395 46.809 23.4767C46.7473 23.3918 46.6727 23.3171 46.5878 23.2554C46.3249 23.0645 45.9499 23.0645 45.2 23.0645Z" fill="white" fill-opacity="0.4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
<defs>
  <clipPath id="clip0_13859_31161">
    <rect width="60" height="60" fill="white"/>
  </clipPath>
</defs>
</svg>`
  , styles$1c = i$8`
  :host {
    display: block;
    width: var(--local-size);
    height: var(--local-size);
  }

  :host svg {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$1z = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const svgOptions = {
    browser: browserSvg,
    dao: daoSvg,
    defi: defiSvg,
    defiAlt: defiAltSvg,
    eth: ethSvg,
    layers: layersSvg,
    lock: lockSvg,
    login: loginSvg,
    network: networkSvg,
    nft: nftSvg,
    noun: nounSvg,
    profile: profileSvg,
    system: systemSvg,
    coinbase: coinbaseSvg,
    onrampCard: onrampCardSvg,
    moonpay: moonpaySvg,
    stripe: stripeSvg,
    paypal: paypalSvg
};
let WuiVisual = class extends s$5 {
    constructor() {
        super(...arguments),
        this.name = "browser",
        this.size = "md"
    }
    render() {
        return this.style.cssText = `
       --local-size: var(--wui-visual-size-${this.size});
   `,
        x$1`${svgOptions[this.name]}`
    }
}
;
WuiVisual.styles = [resetStyles, styles$1c];
__decorate$1z([n$a()], WuiVisual.prototype, "name", void 0);
__decorate$1z([n$a()], WuiVisual.prototype, "size", void 0);
WuiVisual = __decorate$1z([customElement("wui-visual")], WuiVisual);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$9 = _e=>_e ?? T$1
  , UiHelperUtil = {
    getSpacingStyles(_e, et) {
        if (Array.isArray(_e))
            return _e[et] ? `var(--wui-spacing-${_e[et]})` : void 0;
        if (typeof _e == "string")
            return `var(--wui-spacing-${_e})`
    },
    getFormattedDate(_e) {
        return new Intl.DateTimeFormat("en-US",{
            month: "short",
            day: "numeric"
        }).format(_e)
    },
    getHostName(_e) {
        return new URL(_e).hostname
    },
    getTruncateString({string: _e, charsStart: et, charsEnd: tt, truncate: rt}) {
        return _e.length <= et + tt ? _e : rt === "end" ? `${_e.substring(0, et)}...` : rt === "start" ? `...${_e.substring(_e.length - tt)}` : `${_e.substring(0, Math.floor(et))}...${_e.substring(_e.length - Math.floor(tt))}`
    },
    generateAvatarColors(_e) {
        const tt = _e.toLowerCase().replace(/^0x/iu, "").substring(0, 6)
          , rt = this.hexToRgb(tt)
          , nt = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master")
          , st = 100 - 3 * Number(nt == null ? void 0 : nt.replace("px", ""))
          , at = `${st}% ${st}% at 65% 40%`
          , ot = [];
        for (let lt = 0; lt < 5; lt += 1) {
            const dt = this.tintColor(rt, .15 * lt);
            ot.push(`rgb(${dt[0]}, ${dt[1]}, ${dt[2]})`)
        }
        return `
    --local-color-1: ${ot[0]};
    --local-color-2: ${ot[1]};
    --local-color-3: ${ot[2]};
    --local-color-4: ${ot[3]};
    --local-color-5: ${ot[4]};
    --local-radial-circle: ${at}
   `
    },
    hexToRgb(_e) {
        const et = parseInt(_e, 16)
          , tt = et >> 16 & 255
          , rt = et >> 8 & 255
          , nt = et & 255;
        return [tt, rt, nt]
    },
    tintColor(_e, et) {
        const [tt,rt,nt] = _e
          , it = Math.round(tt + (255 - tt) * et)
          , st = Math.round(rt + (255 - rt) * et)
          , at = Math.round(nt + (255 - nt) * et);
        return [it, st, at]
    },
    isNumber(_e) {
        return {
            number: /^[0-9]+$/u
        }.number.test(_e)
    },
    getColorTheme(_e) {
        return _e || (typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : "dark")
    }
}
  , styles$1b = i$8`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$1y = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiFlex = class extends s$5 {
    render() {
        return this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `,
        x$1`<slot></slot>`
    }
}
;
WuiFlex.styles = [resetStyles, styles$1b];
__decorate$1y([n$a()], WuiFlex.prototype, "flexDirection", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "flexWrap", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "flexBasis", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "flexGrow", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "flexShrink", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "alignItems", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "justifyContent", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "columnGap", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "rowGap", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "gap", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "padding", void 0);
__decorate$1y([n$a()], WuiFlex.prototype, "margin", void 0);
WuiFlex = __decorate$1y([customElement("wui-flex")], WuiFlex);
const styles$1a = i$8`
  :host {
    display: block;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var __decorate$1x = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiAvatar = class extends s$5 {
    constructor() {
        super(...arguments),
        this.imageSrc = void 0,
        this.alt = void 0,
        this.address = void 0
    }
    render() {
        return x$1`${this.visualTemplate()}`
    }
    visualTemplate() {
        if (this.imageSrc)
            return this.dataset.variant = "image",
            x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
        if (this.address) {
            this.dataset.variant = "generated";
            const et = UiHelperUtil.generateAvatarColors(this.address);
            return this.style.cssText = et,
            null
        }
        return this.dataset.variant = "default",
        null
    }
}
;
WuiAvatar.styles = [resetStyles, styles$1a];
__decorate$1x([n$a()], WuiAvatar.prototype, "imageSrc", void 0);
__decorate$1x([n$a()], WuiAvatar.prototype, "alt", void 0);
__decorate$1x([n$a()], WuiAvatar.prototype, "address", void 0);
WuiAvatar = __decorate$1x([customElement("wui-avatar")], WuiAvatar);
const styles$19 = i$8`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-gray-glass-020);
    border-radius: var(--local-border-radius);
    border: var(--local-border);
    box-sizing: content-box;
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var __decorate$1w = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiIconBox = class extends s$5 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.backgroundColor = "accent-100",
        this.iconColor = "accent-100",
        this.background = "transparent",
        this.border = !1,
        this.borderColor = "wui-color-bg-125",
        this.icon = "copy"
    }
    render() {
        const et = this.iconSize || this.size
          , tt = this.size === "lg"
          , rt = this.size === "xl"
          , nt = tt ? "12%" : "16%"
          , it = tt ? "xxs" : rt ? "s" : "3xl"
          , st = this.background === "gray"
          , at = this.background === "opaque"
          , ot = this.backgroundColor === "accent-100" && at || this.backgroundColor === "success-100" && at || this.backgroundColor === "error-100" && at || this.backgroundColor === "inverse-100" && at;
        let lt = `var(--wui-color-${this.backgroundColor})`;
        return ot ? lt = `var(--wui-icon-box-bg-${this.backgroundColor})` : st && (lt = `var(--wui-gray-${this.backgroundColor})`),
        this.style.cssText = `
       --local-bg-value: ${lt};
       --local-bg-mix: ${ot || st ? "100%" : nt};
       --local-border-radius: var(--wui-border-radius-${it});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? "2px" : "1px"} solid ${this.border ? `var(--${this.borderColor})` : "transparent"}
   `,
        x$1` <wui-icon color=${this.iconColor} size=${et} name=${this.icon}></wui-icon> `
    }
}
;
WuiIconBox.styles = [resetStyles, elementStyles, styles$19];
__decorate$1w([n$a()], WuiIconBox.prototype, "size", void 0);
__decorate$1w([n$a()], WuiIconBox.prototype, "backgroundColor", void 0);
__decorate$1w([n$a()], WuiIconBox.prototype, "iconColor", void 0);
__decorate$1w([n$a()], WuiIconBox.prototype, "iconSize", void 0);
__decorate$1w([n$a()], WuiIconBox.prototype, "background", void 0);
__decorate$1w([n$a({
    type: Boolean
})], WuiIconBox.prototype, "border", void 0);
__decorate$1w([n$a()], WuiIconBox.prototype, "borderColor", void 0);
__decorate$1w([n$a()], WuiIconBox.prototype, "icon", void 0);
WuiIconBox = __decorate$1w([customElement("wui-icon-box")], WuiIconBox);
const styles$18 = i$8`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var __decorate$1v = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiAccountButton = class extends s$5 {
    constructor() {
        super(...arguments),
        this.networkSrc = void 0,
        this.avatarSrc = void 0,
        this.balance = void 0,
        this.isUnsupportedChain = void 0,
        this.disabled = !1,
        this.isProfileName = !1,
        this.address = "",
        this.charsStart = 4,
        this.charsEnd = 6
    }
    render() {
        return x$1`
      <button
        ?disabled=${this.disabled}
        class=${o$9(this.balance ? void 0 : "local-no-balance")}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${UiHelperUtil.getTruncateString({
            string: this.address,
            charsStart: this.isProfileName ? 18 : this.charsStart,
            charsEnd: this.isProfileName ? 0 : this.charsEnd,
            truncate: this.isProfileName ? "end" : "middle"
        })}
          </wui-text>
        </wui-flex>
      </button>
    `
    }
    balanceTemplate() {
        if (this.isUnsupportedChain)
            return x$1` <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
        <wui-text variant="paragraph-600" color="inherit"> Switch Network</wui-text>`;
        if (this.balance) {
            const et = this.networkSrc ? x$1`<wui-image src=${this.networkSrc}></wui-image>` : x$1`
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
            return x$1`
        ${et}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance} </wui-text>
      `
        }
        return null
    }
}
;
WuiAccountButton.styles = [resetStyles, elementStyles, styles$18];
__decorate$1v([n$a()], WuiAccountButton.prototype, "networkSrc", void 0);
__decorate$1v([n$a()], WuiAccountButton.prototype, "avatarSrc", void 0);
__decorate$1v([n$a()], WuiAccountButton.prototype, "balance", void 0);
__decorate$1v([n$a({
    type: Boolean
})], WuiAccountButton.prototype, "isUnsupportedChain", void 0);
__decorate$1v([n$a({
    type: Boolean
})], WuiAccountButton.prototype, "disabled", void 0);
__decorate$1v([n$a({
    type: Boolean
})], WuiAccountButton.prototype, "isProfileName", void 0);
__decorate$1v([n$a()], WuiAccountButton.prototype, "address", void 0);
__decorate$1v([n$a()], WuiAccountButton.prototype, "charsStart", void 0);
__decorate$1v([n$a()], WuiAccountButton.prototype, "charsEnd", void 0);
WuiAccountButton = __decorate$1v([customElement("wui-account-button")], WuiAccountButton);
const styles$17 = i$8`
  :host {
    position: relative;
    background-color: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-base-150, #1e1f1f);
    padding: 1px;
  }
`;
var __decorate$1u = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiWalletImage = class extends s$5 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.name = "",
        this.installed = !1,
        this.badgeSize = "xs"
    }
    render() {
        let et = "xxs";
        return this.size === "lg" ? et = "m" : this.size === "md" ? et = "xs" : et = "xxs",
        this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${et});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `,
        this.walletIcon && (this.dataset.walletIcon = this.walletIcon),
        x$1`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : this.walletIcon ? x$1`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>` : x$1`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`
    }
}
;
WuiWalletImage.styles = [resetStyles, styles$17];
__decorate$1u([n$a()], WuiWalletImage.prototype, "size", void 0);
__decorate$1u([n$a()], WuiWalletImage.prototype, "name", void 0);
__decorate$1u([n$a()], WuiWalletImage.prototype, "imageSrc", void 0);
__decorate$1u([n$a()], WuiWalletImage.prototype, "walletIcon", void 0);
__decorate$1u([n$a({
    type: Boolean
})], WuiWalletImage.prototype, "installed", void 0);
__decorate$1u([n$a()], WuiWalletImage.prototype, "badgeSize", void 0);
WuiWalletImage = __decorate$1u([customElement("wui-wallet-image")], WuiWalletImage);
const styles$16 = i$8`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var __decorate$1t = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const TOTAL_IMAGES = 4;
let WuiAllWalletsImage = class extends s$5 {
    constructor() {
        super(...arguments),
        this.walletImages = []
    }
    render() {
        const et = this.walletImages.length < TOTAL_IMAGES;
        return x$1`${this.walletImages.slice(0, TOTAL_IMAGES).map(({src: tt, walletName: rt})=>x$1`
            <wui-wallet-image
              size="inherit"
              imageSrc=${tt}
              name=${o$9(rt)}
            ></wui-wallet-image>
          `)}
      ${et ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(()=>x$1` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`
    }
}
;
WuiAllWalletsImage.styles = [resetStyles, styles$16];
__decorate$1t([n$a({
    type: Array
})], WuiAllWalletsImage.prototype, "walletImages", void 0);
WuiAllWalletsImage = __decorate$1t([customElement("wui-all-wallets-image")], WuiAllWalletsImage);
const styles$15 = i$8`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--local-border-radius);
    width: var(--local-width);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-010);
  }

  /* xs settings */
  button[data-size='xs'] {
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs);
  }

  button[data-size='xs'][data-icon-left='true'][data-icon-right='false'] {
    padding-left: var(--wui-spacing-xxs);
  }

  button[data-size='xs'][data-icon-right='true'][data-icon-left='false'] {
    padding-right: var(--wui-spacing-xxs);
  }

  /* sm settings */
  button[data-size='sm'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s);
  }

  button[data-size='sm'][data-icon-left='true'][data-icon-right='false'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  button[data-size='sm'][data-icon-right='true'][data-icon-left='false'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-xs) var(--wui-spacing-xxs)
      var(--wui-spacing-s);
  }

  /* md settings */
  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'][data-icon-left='true'][data-icon-right='false'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'][data-icon-left='false'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  /* lg settings */
  button[data-size='lg'] {
    padding: var(--wui-spacing-m) var(--wui-spacing-2l);
  }

  button[data-size='lg'][data-icon-left='true'][data-icon-right='false'] {
    padding-left: var(--wui-spacing-m);
  }

  button[data-size='lg'][data-icon-right='true'][data-icon-left='false'] {
    padding-right: var(--wui-spacing-m);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transition: all 200ms ease-in-out;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var __decorate$1s = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const TEXT_VARIANT_BY_SIZE = {
    xs: "small-600",
    sm: "paragraph-600",
    md: "small-600",
    mdl: "small-600",
    lg: "paragraph-600"
};
let WuiButton = class extends s$5 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.disabled = !1,
        this.fullWidth = !1,
        this.loading = !1,
        this.variant = "fill",
        this.hasIconLeft = !1,
        this.hasIconRight = !1,
        this.borderRadius = "m"
    }
    render() {
        this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};
    --local-border-radius: var(--wui-border-radius-${this.borderRadius});
    `;
        const et = this.textVariant ?? TEXT_VARIANT_BY_SIZE[this.size];
        return x$1`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled || this.loading}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${()=>this.handleSlotLeftChange()}></slot>
        <wui-text variant=${et} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${()=>this.handleSlotRightChange()}></slot>
      </button>
    `
    }
    handleSlotLeftChange() {
        this.hasIconLeft = !0
    }
    handleSlotRightChange() {
        this.hasIconRight = !0
    }
    loadingTemplate() {
        return this.loading ? x$1`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : x$1``
    }
}
;
WuiButton.styles = [resetStyles, elementStyles, styles$15];
__decorate$1s([n$a()], WuiButton.prototype, "size", void 0);
__decorate$1s([n$a({
    type: Boolean
})], WuiButton.prototype, "disabled", void 0);
__decorate$1s([n$a({
    type: Boolean
})], WuiButton.prototype, "fullWidth", void 0);
__decorate$1s([n$a({
    type: Boolean
})], WuiButton.prototype, "loading", void 0);
__decorate$1s([n$a()], WuiButton.prototype, "variant", void 0);
__decorate$1s([n$a({
    type: Boolean
})], WuiButton.prototype, "hasIconLeft", void 0);
__decorate$1s([n$a({
    type: Boolean
})], WuiButton.prototype, "hasIconRight", void 0);
__decorate$1s([n$a()], WuiButton.prototype, "borderRadius", void 0);
__decorate$1s([n$a()], WuiButton.prototype, "textVariant", void 0);
WuiButton = __decorate$1s([customElement("wui-button")], WuiButton);
const networkSvgMd = b$1`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`
  , styles$14 = i$8`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-gray-glass-010);
    stroke-width: 1px;
  }
`;
var __decorate$1r = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiCardSelectLoader = class extends s$5 {
    constructor() {
        super(...arguments),
        this.type = "wallet"
    }
    render() {
        return x$1`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `
    }
    shimmerTemplate() {
        return this.type === "network" ? x$1` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvgMd}` : x$1`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`
    }
}
;
WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$14];
__decorate$1r([n$a()], WuiCardSelectLoader.prototype, "type", void 0);
WuiCardSelectLoader = __decorate$1r([customElement("wui-card-select-loader")], WuiCardSelectLoader);
const networkSvgSm = b$1`
  <svg fill="none" viewBox="0 0 36 40">
    <path
      d="M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z"
    />
  </svg>
`
  , networkSvgLg = b$1`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`
  , styles$13 = i$8`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
    transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var __decorate$1q = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiNetworkImage = class extends s$5 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.name = "uknown",
        this.selected = !1
    }
    render() {
        const et = {
            sm: networkSvgSm,
            md: networkSvgMd,
            lg: networkSvgLg
        };
        return this.style.cssText = `
      --local-stroke: ${this.selected ? "var(--wui-color-accent-100)" : "var(--wui-gray-glass-010)"};
      --local-path: var(--wui-path-network-${this.size});
      --local-width:  var(--wui-width-network-${this.size});
      --local-height:  var(--wui-height-network-${this.size});
      --local-icon-size:  var(--wui-icon-size-network-${this.size});
    `,
        x$1`${this.templateVisual()} ${et[this.size]}`
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : x$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
    }
}
;
WuiNetworkImage.styles = [resetStyles, styles$13];
__decorate$1q([n$a()], WuiNetworkImage.prototype, "size", void 0);
__decorate$1q([n$a()], WuiNetworkImage.prototype, "name", void 0);
__decorate$1q([n$a()], WuiNetworkImage.prototype, "imageSrc", void 0);
__decorate$1q([n$a({
    type: Boolean
})], WuiNetworkImage.prototype, "selected", void 0);
WuiNetworkImage = __decorate$1q([customElement("wui-network-image")], WuiNetworkImage);
const styles$12 = i$8`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-accent-glass-010);
  }
`;
var __decorate$1p = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiCardSelect = class extends s$5 {
    constructor() {
        super(...arguments),
        this.name = "Unknown",
        this.type = "wallet",
        this.imageSrc = void 0,
        this.disabled = !1,
        this.selected = !1,
        this.installed = !1
    }
    render() {
        return x$1`
      <button data-selected=${o$9(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `
    }
    imageTemplate() {
        return this.type === "network" ? x$1`
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${o$9(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      ` : x$1`
      <wui-wallet-image
        size="md"
        imageSrc=${o$9(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `
    }
}
;
WuiCardSelect.styles = [resetStyles, elementStyles, styles$12];
__decorate$1p([n$a()], WuiCardSelect.prototype, "name", void 0);
__decorate$1p([n$a()], WuiCardSelect.prototype, "type", void 0);
__decorate$1p([n$a()], WuiCardSelect.prototype, "imageSrc", void 0);
__decorate$1p([n$a({
    type: Boolean
})], WuiCardSelect.prototype, "disabled", void 0);
__decorate$1p([n$a({
    type: Boolean
})], WuiCardSelect.prototype, "selected", void 0);
__decorate$1p([n$a({
    type: Boolean
})], WuiCardSelect.prototype, "installed", void 0);
WuiCardSelect = __decorate$1p([customElement("wui-card-select")], WuiCardSelect);
const styles$11 = i$8`
  a {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-success-glass-010);
    background-color: var(--wui-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-success-glass-015);
  }

  a.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-success-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-success-glass-020);
  }
`;
var __decorate$1o = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiChip = class extends s$5 {
    constructor() {
        super(...arguments),
        this.variant = "fill",
        this.imageSrc = void 0,
        this.disabled = !1,
        this.icon = "externalLink",
        this.href = "",
        this.text = void 0
    }
    render() {
        const tt = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall" ? "small-600" : "paragraph-600";
        return x$1`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${tt} color="inherit">
          ${this.title ? this.title : UiHelperUtil.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `
    }
    imageTemplate() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc}></wui-image>` : null
    }
}
;
WuiChip.styles = [resetStyles, elementStyles, styles$11];
__decorate$1o([n$a()], WuiChip.prototype, "variant", void 0);
__decorate$1o([n$a()], WuiChip.prototype, "imageSrc", void 0);
__decorate$1o([n$a({
    type: Boolean
})], WuiChip.prototype, "disabled", void 0);
__decorate$1o([n$a()], WuiChip.prototype, "icon", void 0);
__decorate$1o([n$a()], WuiChip.prototype, "href", void 0);
__decorate$1o([n$a()], WuiChip.prototype, "text", void 0);
WuiChip = __decorate$1o([customElement("wui-chip")], WuiChip);
const styles$10 = i$8`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var __decorate$1n = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiConnectButton = class extends s$5 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.loading = !1
    }
    render() {
        const et = this.size === "md" ? "paragraph-600" : "small-600";
        return x$1`
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${et} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `
    }
    loadingTemplate() {
        return this.loading ? x$1`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>` : null
    }
}
;
WuiConnectButton.styles = [resetStyles, elementStyles, styles$10];
__decorate$1n([n$a()], WuiConnectButton.prototype, "size", void 0);
__decorate$1n([n$a({
    type: Boolean
})], WuiConnectButton.prototype, "loading", void 0);
WuiConnectButton = __decorate$1n([customElement("wui-connect-button")], WuiConnectButton);
const styles$$ = i$8`
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$1m = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiCtaButton = class extends s$5 {
    constructor() {
        super(...arguments),
        this.disabled = !1,
        this.label = "",
        this.buttonLabel = ""
    }
    render() {
        return x$1`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-button size="sm" variant="accent">
          ${this.buttonLabel}
          <wui-icon size="xs" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `
    }
}
;
WuiCtaButton.styles = [resetStyles, elementStyles, styles$$];
__decorate$1m([n$a({
    type: Boolean
})], WuiCtaButton.prototype, "disabled", void 0);
__decorate$1m([n$a()], WuiCtaButton.prototype, "label", void 0);
__decorate$1m([n$a()], WuiCtaButton.prototype, "buttonLabel", void 0);
WuiCtaButton = __decorate$1m([customElement("wui-cta-button")], WuiCtaButton);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f$5 = _e=>_e.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$4 = (_e,et)=>{
    var rt;
    const tt = _e._$AN;
    if (tt === void 0)
        return !1;
    for (const nt of tt)
        (rt = nt._$AO) == null || rt.call(nt, et, !1),
        s$4(nt, et);
    return !0
}
  , o$8 = _e=>{
    let et, tt;
    do {
        if ((et = _e._$AM) === void 0)
            break;
        tt = et._$AN,
        tt.delete(_e),
        _e = et
    } while ((tt == null ? void 0 : tt.size) === 0)
}
  , r$9 = _e=>{
    for (let et; et = _e._$AM; _e = et) {
        let tt = et._$AN;
        if (tt === void 0)
            et._$AN = tt = new Set;
        else if (tt.has(_e))
            break;
        tt.add(_e),
        c$4(et)
    }
}
;
function h$7(_e) {
    this._$AN !== void 0 ? (o$8(this),
    this._$AM = _e,
    r$9(this)) : this._$AM = _e
}
function n$9(_e, et=!1, tt=0) {
    const rt = this._$AH
      , nt = this._$AN;
    if (nt !== void 0 && nt.size !== 0)
        if (et)
            if (Array.isArray(rt))
                for (let it = tt; it < rt.length; it++)
                    s$4(rt[it], !1),
                    o$8(rt[it]);
            else
                rt != null && (s$4(rt, !1),
                o$8(rt));
        else
            s$4(this, _e)
}
const c$4 = _e=>{
    _e.type == t$5.CHILD && (_e._$AP ?? (_e._$AP = n$9),
    _e._$AQ ?? (_e._$AQ = h$7))
}
;
let f$4 = class extends i$5 {
    constructor() {
        super(...arguments),
        this._$AN = void 0
    }
    _$AT(et, tt, rt) {
        super._$AT(et, tt, rt),
        r$9(this),
        this.isConnected = et._$AU
    }
    _$AO(et, tt=!0) {
        var rt, nt;
        et !== this.isConnected && (this.isConnected = et,
        et ? (rt = this.reconnected) == null || rt.call(this) : (nt = this.disconnected) == null || nt.call(this)),
        tt && (s$4(this, et),
        o$8(this))
    }
    setValue(et) {
        if (f$5(this._$Ct))
            this._$Ct._$AI(et, this);
        else {
            const tt = [...this._$Ct._$AH];
            tt[this._$Ci] = et,
            this._$Ct._$AI(tt, this, 0)
        }
    }
    disconnected() {}
    reconnected() {}
}
;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$5 = ()=>new h$6;
let h$6 = class {
}
;
const o$7 = new WeakMap
  , n$8 = e$7(class extends f$4 {
    render(_e) {
        return T$1
    }
    update(_e, [et]) {
        var rt;
        const tt = et !== this.Y;
        return tt && this.Y !== void 0 && this.rt(void 0),
        (tt || this.lt !== this.ct) && (this.Y = et,
        this.ht = (rt = _e.options) == null ? void 0 : rt.host,
        this.rt(this.ct = _e.element)),
        T$1
    }
    rt(_e) {
        if (typeof this.Y == "function") {
            const et = this.ht ?? globalThis;
            let tt = o$7.get(et);
            tt === void 0 && (tt = new WeakMap,
            o$7.set(et, tt)),
            tt.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0),
            tt.set(this.Y, _e),
            _e !== void 0 && this.Y.call(this.ht, _e)
        } else
            this.Y.value = _e
    }
    get lt() {
        var _e, et;
        return typeof this.Y == "function" ? (_e = o$7.get(this.ht ?? globalThis)) == null ? void 0 : _e.get(this.Y) : (et = this.Y) == null ? void 0 : et.value
    }
    disconnected() {
        this.lt === this.ct && this.rt(void 0)
    }
    reconnected() {
        this.rt(this.ct)
    }
}
)
  , styles$_ = i$8`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    font-size: var(--wui-font-size-paragraph);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px 40px;
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-lg {
    padding: var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-l);
    letter-spacing: var(--wui-letter-spacing-medium-title);
    font-size: var(--wui-font-size-medium-title);
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    color: var(--wui-color-fg-100);
    height: 64px;
  }

  wui-icon + .wui-size-lg,
  wui-loading-spinner + .wui-size-lg {
    padding-left: 50px;
  }

  wui-icon[data-input='lg'] {
    left: var(--wui-spacing-l);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var __decorate$1l = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiInputText = class extends s$5 {
    constructor() {
        super(...arguments),
        this.inputElementRef = e$5(),
        this.size = "md",
        this.disabled = !1,
        this.placeholder = "",
        this.type = "text"
    }
    render() {
        const et = `wui-size-${this.size}`;
        return x$1` ${this.templateIcon()}
      <input
        ${n$8(this.inputElementRef)}
        class=${et}
        type=${this.type}
        enterkeyhint=${o$9(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        value=${o$9(this.value)}
        .value=${this.value || ""}
      />
      <slot></slot>`
    }
    templateIcon() {
        return this.icon ? x$1`<wui-icon
        data-input=${this.size}
        size=${this.size}
        color="inherit"
        name=${this.icon}
      ></wui-icon>` : null
    }
    dispatchInputChangeEvent() {
        var et;
        this.dispatchEvent(new CustomEvent("inputChange",{
            detail: (et = this.inputElementRef.value) == null ? void 0 : et.value,
            bubbles: !0,
            composed: !0
        }))
    }
}
;
WuiInputText.styles = [resetStyles, elementStyles, styles$_];
__decorate$1l([n$a()], WuiInputText.prototype, "size", void 0);
__decorate$1l([n$a()], WuiInputText.prototype, "icon", void 0);
__decorate$1l([n$a({
    type: Boolean
})], WuiInputText.prototype, "disabled", void 0);
__decorate$1l([n$a()], WuiInputText.prototype, "placeholder", void 0);
__decorate$1l([n$a()], WuiInputText.prototype, "type", void 0);
__decorate$1l([n$a()], WuiInputText.prototype, "keyHint", void 0);
__decorate$1l([n$a()], WuiInputText.prototype, "value", void 0);
WuiInputText = __decorate$1l([customElement("wui-input-text")], WuiInputText);
const styles$Z = i$8`
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$1k = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiEmailInput = class extends s$5 {
    constructor() {
        super(...arguments),
        this.disabled = !1
    }
    render() {
        return x$1`
      <wui-input-text
        placeholder="Email"
        icon="mail"
        size="md"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `
    }
    templateError() {
        return this.errorMessage ? x$1`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>` : null
    }
}
;
WuiEmailInput.styles = [resetStyles, styles$Z];
__decorate$1k([n$a()], WuiEmailInput.prototype, "errorMessage", void 0);
__decorate$1k([n$a({
    type: Boolean
})], WuiEmailInput.prototype, "disabled", void 0);
__decorate$1k([n$a()], WuiEmailInput.prototype, "value", void 0);
WuiEmailInput = __decorate$1k([customElement("wui-email-input")], WuiEmailInput);
const styles$Y = i$8`
  button {
    border-radius: var(--local-border-radius);
    color: var(--wui-color-fg-100);
    padding: var(--local-padding);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var __decorate$1j = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiIconLink = class extends s$5 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.disabled = !1,
        this.icon = "copy",
        this.iconColor = "inherit"
    }
    render() {
        const et = this.size === "lg" ? "--wui-border-radius-xs" : "--wui-border-radius-xxs"
          , tt = this.size === "lg" ? "--wui-spacing-1xs" : "--wui-spacing-2xs";
        return this.style.cssText = `
    --local-border-radius: var(${et});
    --local-padding: var(${tt});
`,
        x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `
    }
}
;
WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$Y];
__decorate$1j([n$a()], WuiIconLink.prototype, "size", void 0);
__decorate$1j([n$a({
    type: Boolean
})], WuiIconLink.prototype, "disabled", void 0);
__decorate$1j([n$a()], WuiIconLink.prototype, "icon", void 0);
__decorate$1j([n$a()], WuiIconLink.prototype, "iconColor", void 0);
WuiIconLink = __decorate$1j([customElement("wui-icon-link")], WuiIconLink);
const styles$X = i$8`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;
var __decorate$1i = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiInputElement = class extends s$5 {
    constructor() {
        super(...arguments),
        this.icon = "copy"
    }
    render() {
        return x$1`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `
    }
}
;
WuiInputElement.styles = [resetStyles, elementStyles, styles$X];
__decorate$1i([n$a()], WuiInputElement.prototype, "icon", void 0);
WuiInputElement = __decorate$1i([customElement("wui-input-element")], WuiInputElement);
const styles$W = i$8`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-005);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }
  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }
`;
var __decorate$1h = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiInputNumeric = class extends s$5 {
    constructor() {
        super(...arguments),
        this.disabled = !1,
        this.value = ""
    }
    render() {
        return x$1`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `
    }
}
;
WuiInputNumeric.styles = [resetStyles, elementStyles, styles$W];
__decorate$1h([n$a({
    type: Boolean
})], WuiInputNumeric.prototype, "disabled", void 0);
__decorate$1h([n$a({
    type: String
})], WuiInputNumeric.prototype, "value", void 0);
WuiInputNumeric = __decorate$1h([customElement("wui-input-numeric")], WuiInputNumeric);
const styles$V = i$8`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-gray-glass-015);
  }
`;
var __decorate$1g = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiLink = class extends s$5 {
    constructor() {
        super(...arguments),
        this.disabled = !1,
        this.color = "inherit"
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `
    }
}
;
WuiLink.styles = [resetStyles, elementStyles, styles$V];
__decorate$1g([n$a({
    type: Boolean
})], WuiLink.prototype, "disabled", void 0);
__decorate$1g([n$a()], WuiLink.prototype, "color", void 0);
WuiLink = __decorate$1g([customElement("wui-link")], WuiLink);
const styles$U = i$8`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    transition: opacity 200ms ease-in-out;
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var __decorate$1f = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiListItem = class extends s$5 {
    constructor() {
        super(...arguments),
        this.variant = "icon",
        this.disabled = !1,
        this.imageSrc = void 0,
        this.alt = void 0,
        this.chevron = !1,
        this.loading = !1
    }
    render() {
        return x$1`
      <button
        ?disabled=${this.loading ? !0 : !!this.disabled}
        data-loading=${this.loading}
        data-iconvariant=${o$9(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `
    }
    visualTemplate() {
        if (this.variant === "image" && this.imageSrc)
            return x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
        if (this.iconVariant === "square" && this.icon && this.variant === "icon")
            return x$1`<wui-icon name=${this.icon}></wui-icon>`;
        if (this.variant === "icon" && this.icon && this.iconVariant) {
            const et = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200"
              , tt = this.iconVariant === "square-blue" ? "mdl" : "md"
              , rt = this.iconSize ? this.iconSize : tt;
            return x$1`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${rt}
          background="transparent"
          iconColor=${et}
          backgroundColor=${et}
          size=${tt}
        ></wui-icon-box>
      `
        }
        return null
    }
    loadingTemplate() {
        return this.loading ? x$1`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : x$1``
    }
    chevronTemplate() {
        return this.chevron ? x$1`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>` : null
    }
}
;
WuiListItem.styles = [resetStyles, elementStyles, styles$U];
__decorate$1f([n$a()], WuiListItem.prototype, "icon", void 0);
__decorate$1f([n$a()], WuiListItem.prototype, "iconSize", void 0);
__decorate$1f([n$a()], WuiListItem.prototype, "variant", void 0);
__decorate$1f([n$a()], WuiListItem.prototype, "iconVariant", void 0);
__decorate$1f([n$a({
    type: Boolean
})], WuiListItem.prototype, "disabled", void 0);
__decorate$1f([n$a()], WuiListItem.prototype, "imageSrc", void 0);
__decorate$1f([n$a()], WuiListItem.prototype, "alt", void 0);
__decorate$1f([n$a({
    type: Boolean
})], WuiListItem.prototype, "chevron", void 0);
__decorate$1f([n$a({
    type: Boolean
})], WuiListItem.prototype, "loading", void 0);
WuiListItem = __decorate$1f([customElement("wui-list-item")], WuiListItem);
var TransactionTypePastTense;
(function(_e) {
    _e.approve = "approved",
    _e.bought = "bought",
    _e.borrow = "borrowed",
    _e.burn = "burnt",
    _e.cancel = "canceled",
    _e.claim = "claimed",
    _e.deploy = "deployed",
    _e.deposit = "deposited",
    _e.execute = "executed",
    _e.mint = "minted",
    _e.receive = "received",
    _e.repay = "repaid",
    _e.send = "sent",
    _e.sell = "sold",
    _e.stake = "staked",
    _e.trade = "swapped",
    _e.unstake = "unstaked",
    _e.withdraw = "withdrawn"
}
)(TransactionTypePastTense || (TransactionTypePastTense = {}));
const styles$T = i$8`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var __decorate$1e = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiTransactionVisual = class extends s$5 {
    constructor() {
        super(...arguments),
        this.images = [],
        this.secondImage = {
            type: void 0,
            url: ""
        }
    }
    render() {
        const [et,tt] = this.images
          , rt = (et == null ? void 0 : et.type) === "NFT"
          , nt = tt != null && tt.url ? tt.type === "NFT" : rt
          , it = rt ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)"
          , st = nt ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
        return this.style.cssText = `
    --local-left-border-radius: ${it};
    --local-right-border-radius: ${st};
    `,
        x$1`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`
    }
    templateVisual() {
        const [et,tt] = this.images
          , rt = et == null ? void 0 : et.type;
        return this.images.length === 2 && (et != null && et.url || tt != null && tt.url) ? x$1`<div class="swap-images-container">
        ${et != null && et.url ? x$1`<wui-image src=${et.url} alt="Transaction image"></wui-image>` : null}
        ${tt != null && tt.url ? x$1`<wui-image src=${tt.url} alt="Transaction image"></wui-image>` : null}
      </div>` : et != null && et.url ? x$1`<wui-image src=${et.url} alt="Transaction image"></wui-image>` : rt === "NFT" ? x$1`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>` : x$1`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`
    }
    templateIcon() {
        let et = "accent-100", tt;
        return tt = this.getIcon(),
        this.status && (et = this.getStatusColor()),
        tt ? x$1`
      <wui-icon-box
        size="xxs"
        iconColor=${et}
        backgroundColor=${et}
        background="opaque"
        icon=${tt}
        ?border=${!0}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    ` : null
    }
    getDirectionIcon() {
        switch (this.direction) {
        case "in":
            return "arrowBottom";
        case "out":
            return "arrowTop";
        default:
            return
        }
    }
    getIcon() {
        return this.onlyDirectionIcon ? this.getDirectionIcon() : this.type === "trade" ? "swapHorizontalBold" : this.type === "approve" ? "checkmark" : this.type === "cancel" ? "close" : this.getDirectionIcon()
    }
    getStatusColor() {
        switch (this.status) {
        case "confirmed":
            return "success-100";
        case "failed":
            return "error-100";
        case "pending":
            return "inverse-100";
        default:
            return "accent-100"
        }
    }
}
;
WuiTransactionVisual.styles = [styles$T];
__decorate$1e([n$a()], WuiTransactionVisual.prototype, "type", void 0);
__decorate$1e([n$a()], WuiTransactionVisual.prototype, "status", void 0);
__decorate$1e([n$a()], WuiTransactionVisual.prototype, "direction", void 0);
__decorate$1e([n$a({
    type: Boolean
})], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0);
__decorate$1e([n$a({
    type: Array
})], WuiTransactionVisual.prototype, "images", void 0);
__decorate$1e([n$a({
    type: Object
})], WuiTransactionVisual.prototype, "secondImage", void 0);
WuiTransactionVisual = __decorate$1e([customElement("wui-transaction-visual")], WuiTransactionVisual);
const styles$S = i$8`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-xs) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var __decorate$1d = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiTransactionListItem = class extends s$5 {
    constructor() {
        super(...arguments),
        this.type = "approve",
        this.onlyDirectionIcon = !1,
        this.images = [],
        this.price = [],
        this.amount = [],
        this.symbol = []
    }
    render() {
        return x$1`
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${o$9(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${o$9(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type] || this.type}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `
    }
    templateDescription() {
        var tt;
        const et = (tt = this.descriptions) == null ? void 0 : tt[0];
        return et ? x$1`
          <wui-text variant="small-500" color="fg-200">
            <span>${et}</span>
          </wui-text>
        ` : null
    }
    templateSecondDescription() {
        var tt;
        const et = (tt = this.descriptions) == null ? void 0 : tt[1];
        return et ? x$1`
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${et}</span>
          </wui-text>
        ` : null
    }
}
;
WuiTransactionListItem.styles = [resetStyles, styles$S];
__decorate$1d([n$a()], WuiTransactionListItem.prototype, "type", void 0);
__decorate$1d([n$a({
    type: Array
})], WuiTransactionListItem.prototype, "descriptions", void 0);
__decorate$1d([n$a()], WuiTransactionListItem.prototype, "date", void 0);
__decorate$1d([n$a({
    type: Boolean
})], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0);
__decorate$1d([n$a()], WuiTransactionListItem.prototype, "status", void 0);
__decorate$1d([n$a()], WuiTransactionListItem.prototype, "direction", void 0);
__decorate$1d([n$a({
    type: Array
})], WuiTransactionListItem.prototype, "images", void 0);
__decorate$1d([n$a({
    type: Array
})], WuiTransactionListItem.prototype, "price", void 0);
__decorate$1d([n$a({
    type: Array
})], WuiTransactionListItem.prototype, "amount", void 0);
__decorate$1d([n$a({
    type: Array
})], WuiTransactionListItem.prototype, "symbol", void 0);
WuiTransactionListItem = __decorate$1d([customElement("wui-transaction-list-item")], WuiTransactionListItem);
const styles$R = i$8`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var __decorate$1c = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiTransactionListItemLoader = class extends s$5 {
    render() {
        return x$1`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `
    }
}
;
WuiTransactionListItemLoader.styles = [resetStyles, styles$R];
WuiTransactionListItemLoader = __decorate$1c([customElement("wui-transaction-list-item-loader")], WuiTransactionListItemLoader);
const styles$Q = i$8`
  :host {
    display: block;
    padding: 3.5px 5px !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }
`;
var __decorate$1b = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiTag = class extends s$5 {
    constructor() {
        super(...arguments),
        this.variant = "main"
    }
    render() {
        return this.dataset.variant = this.variant,
        x$1`
      <wui-text data-variant=${this.variant} variant="micro-700" color="inherit">
        <slot></slot>
      </wui-text>
    `
    }
}
;
WuiTag.styles = [resetStyles, styles$Q];
__decorate$1b([n$a()], WuiTag.prototype, "variant", void 0);
WuiTag = __decorate$1b([customElement("wui-tag")], WuiTag);
const styles$P = i$8`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$1a = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiListWallet = class extends s$5 {
    constructor() {
        super(...arguments),
        this.walletImages = [],
        this.imageSrc = "",
        this.name = "",
        this.installed = !1,
        this.disabled = !1,
        this.showAllWallets = !1
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `
    }
    templateAllWallets() {
        return this.showAllWallets && this.imageSrc ? x$1` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> ` : this.showAllWallets && this.walletIcon ? x$1` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> ` : null
    }
    templateWalletImage() {
        return !this.showAllWallets && this.imageSrc ? x$1`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>` : !this.showAllWallets && !this.imageSrc ? x$1`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>` : null
    }
    templateStatus() {
        return this.tagLabel && this.tagVariant ? x$1`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>` : this.icon ? x$1`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>` : null
    }
}
;
WuiListWallet.styles = [resetStyles, elementStyles, styles$P];
__decorate$1a([n$a({
    type: Array
})], WuiListWallet.prototype, "walletImages", void 0);
__decorate$1a([n$a()], WuiListWallet.prototype, "imageSrc", void 0);
__decorate$1a([n$a()], WuiListWallet.prototype, "name", void 0);
__decorate$1a([n$a()], WuiListWallet.prototype, "tagLabel", void 0);
__decorate$1a([n$a()], WuiListWallet.prototype, "tagVariant", void 0);
__decorate$1a([n$a()], WuiListWallet.prototype, "icon", void 0);
__decorate$1a([n$a()], WuiListWallet.prototype, "walletIcon", void 0);
__decorate$1a([n$a({
    type: Boolean
})], WuiListWallet.prototype, "installed", void 0);
__decorate$1a([n$a({
    type: Boolean
})], WuiListWallet.prototype, "disabled", void 0);
__decorate$1a([n$a({
    type: Boolean
})], WuiListWallet.prototype, "showAllWallets", void 0);
WuiListWallet = __decorate$1a([customElement("wui-list-wallet")], WuiListWallet);
const styles$O = i$8`
  :host {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-010);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$19 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiLogo = class extends s$5 {
    constructor() {
        super(...arguments),
        this.logo = "google"
    }
    render() {
        return x$1`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `
    }
}
;
WuiLogo.styles = [resetStyles, styles$O];
__decorate$19([n$a()], WuiLogo.prototype, "logo", void 0);
WuiLogo = __decorate$19([customElement("wui-logo")], WuiLogo);
const styles$N = i$8`
  :host {
    display: block;
  }

  button {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$18 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiLogoSelect = class extends s$5 {
    constructor() {
        super(...arguments),
        this.logo = "google",
        this.disabled = !1
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `
    }
}
;
WuiLogoSelect.styles = [resetStyles, elementStyles, styles$N];
__decorate$18([n$a()], WuiLogoSelect.prototype, "logo", void 0);
__decorate$18([n$a({
    type: Boolean
})], WuiLogoSelect.prototype, "disabled", void 0);
WuiLogoSelect = __decorate$18([customElement("wui-logo-select")], WuiLogoSelect);
const styles$M = i$8`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }
`;
var __decorate$17 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiNetworkButton = class extends s$5 {
    constructor() {
        super(...arguments),
        this.imageSrc = void 0,
        this.isUnsupportedChain = void 0,
        this.disabled = !1
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `
    }
    visualTemplate() {
        return this.isUnsupportedChain ? x$1`
        <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
      ` : this.imageSrc ? x$1`<wui-image src=${this.imageSrc}></wui-image>` : x$1`
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `
    }
}
;
WuiNetworkButton.styles = [resetStyles, elementStyles, styles$M];
__decorate$17([n$a()], WuiNetworkButton.prototype, "imageSrc", void 0);
__decorate$17([n$a({
    type: Boolean
})], WuiNetworkButton.prototype, "isUnsupportedChain", void 0);
__decorate$17([n$a({
    type: Boolean
})], WuiNetworkButton.prototype, "disabled", void 0);
WuiNetworkButton = __decorate$17([customElement("wui-network-button")], WuiNetworkButton);
const styles$L = i$8`
  :host {
    position: relative;
    display: block;
  }
`;
var __decorate$16 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiOtp = class extends s$5 {
    constructor() {
        super(...arguments),
        this.length = 6,
        this.otp = "",
        this.values = Array.from({
            length: this.length
        }).map(()=>""),
        this.numerics = [],
        this.shouldInputBeEnabled = et=>this.values.slice(0, et).every(rt=>rt !== ""),
        this.handleKeyDown = (et,tt)=>{
            const rt = et.target
              , nt = this.getInputElement(rt)
              , it = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
            if (!nt)
                return;
            it.includes(et.key) && et.preventDefault();
            const st = nt.selectionStart;
            switch (et.key) {
            case "ArrowLeft":
                st && nt.setSelectionRange(st + 1, st + 1),
                this.focusInputField("prev", tt);
                break;
            case "ArrowRight":
                this.focusInputField("next", tt);
                break;
            case "Shift":
                this.focusInputField("next", tt);
                break;
            case "Delete":
                nt.value === "" ? this.focusInputField("prev", tt) : this.updateInput(nt, tt, "");
                break;
            case "Backspace":
                nt.value === "" ? this.focusInputField("prev", tt) : this.updateInput(nt, tt, "");
                break
            }
        }
        ,
        this.focusInputField = (et,tt)=>{
            if (et === "next") {
                const rt = tt + 1;
                if (!this.shouldInputBeEnabled(rt))
                    return;
                const nt = this.numerics[rt < this.length ? rt : tt]
                  , it = nt ? this.getInputElement(nt) : void 0;
                it && (it.disabled = !1,
                it.focus())
            }
            if (et === "prev") {
                const rt = tt - 1
                  , nt = this.numerics[rt > -1 ? rt : tt]
                  , it = nt ? this.getInputElement(nt) : void 0;
                it && it.focus()
            }
        }
    }
    firstUpdated() {
        var tt, rt;
        this.otp && (this.values = this.otp.split(""));
        const et = (tt = this.shadowRoot) == null ? void 0 : tt.querySelectorAll("wui-input-numeric");
        et && (this.numerics = Array.from(et)),
        (rt = this.numerics[0]) == null || rt.focus()
    }
    render() {
        return x$1`
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({
            length: this.length
        }).map((et,tt)=>x$1`
            <wui-input-numeric
              @input=${rt=>this.handleInput(rt, tt)}
              @keydown=${rt=>this.handleKeyDown(rt, tt)}
              .disabled=${!this.shouldInputBeEnabled(tt)}
              .value=${this.values[tt] || ""}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `
    }
    updateInput(et, tt, rt) {
        const nt = this.numerics[tt]
          , it = et || (nt ? this.getInputElement(nt) : void 0);
        it && (it.value = rt,
        this.values = this.values.map((st,at)=>at === tt ? rt : st))
    }
    handleInput(et, tt) {
        const rt = et.target
          , nt = this.getInputElement(rt);
        if (nt) {
            const it = nt.value;
            et.inputType === "insertFromPaste" ? this.handlePaste(nt, it, tt) : UiHelperUtil.isNumber(it) && et.data ? (this.updateInput(nt, tt, et.data),
            this.focusInputField("next", tt)) : this.updateInput(nt, tt, "")
        }
        this.dispatchInputChangeEvent()
    }
    handlePaste(et, tt, rt) {
        const nt = tt[0];
        if (nt && UiHelperUtil.isNumber(nt)) {
            this.updateInput(et, rt, nt);
            const st = tt.substring(1);
            if (rt + 1 < this.length && st.length) {
                const at = this.numerics[rt + 1]
                  , ot = at ? this.getInputElement(at) : void 0;
                ot && this.handlePaste(ot, st, rt + 1)
            } else
                this.focusInputField("next", rt)
        } else
            this.updateInput(et, rt, "")
    }
    getInputElement(et) {
        var tt;
        return (tt = et.shadowRoot) != null && tt.querySelector("input") ? et.shadowRoot.querySelector("input") : null
    }
    dispatchInputChangeEvent() {
        const et = this.values.join("");
        this.dispatchEvent(new CustomEvent("inputChange",{
            detail: et,
            bubbles: !0,
            composed: !0
        }))
    }
}
;
WuiOtp.styles = [resetStyles, styles$L];
__decorate$16([n$a({
    type: Number
})], WuiOtp.prototype, "length", void 0);
__decorate$16([n$a({
    type: String
})], WuiOtp.prototype, "otp", void 0);
__decorate$16([r$a()], WuiOtp.prototype, "values", void 0);
WuiOtp = __decorate$16([customElement("wui-otp")], WuiOtp);
var browser$1 = {}
  , canPromise$1 = function() {
    return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
}
  , qrcode = {}
  , utils$3 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
utils$3.getSymbolSize = function(et) {
    if (!et)
        throw new Error('"version" cannot be null or undefined');
    if (et < 1 || et > 40)
        throw new Error('"version" should be in range from 1 to 40');
    return et * 4 + 17
}
;
utils$3.getSymbolTotalCodewords = function(et) {
    return CODEWORDS_COUNT[et]
}
;
utils$3.getBCHDigit = function(_e) {
    let et = 0;
    for (; _e !== 0; )
        et++,
        _e >>>= 1;
    return et
}
;
utils$3.setToSJISFunction = function(et) {
    if (typeof et != "function")
        throw new Error('"toSJISFunc" is not a valid function.');
    toSJISFunction = et
}
;
utils$3.isKanjiModeEnabled = function() {
    return typeof toSJISFunction < "u"
}
;
utils$3.toSJIS = function(et) {
    return toSJISFunction(et)
}
;
var errorCorrectionLevel = {};
(function(_e) {
    _e.L = {
        bit: 1
    },
    _e.M = {
        bit: 0
    },
    _e.Q = {
        bit: 3
    },
    _e.H = {
        bit: 2
    };
    function et(tt) {
        if (typeof tt != "string")
            throw new Error("Param is not a string");
        switch (tt.toLowerCase()) {
        case "l":
        case "low":
            return _e.L;
        case "m":
        case "medium":
            return _e.M;
        case "q":
        case "quartile":
            return _e.Q;
        case "h":
        case "high":
            return _e.H;
        default:
            throw new Error("Unknown EC Level: " + tt)
        }
    }
    _e.isValid = function(rt) {
        return rt && typeof rt.bit < "u" && rt.bit >= 0 && rt.bit < 4
    }
    ,
    _e.from = function(rt, nt) {
        if (_e.isValid(rt))
            return rt;
        try {
            return et(rt)
        } catch {
            return nt
        }
    }
}
)(errorCorrectionLevel);
function BitBuffer$1() {
    this.buffer = [],
    this.length = 0
}
BitBuffer$1.prototype = {
    get: function(_e) {
        const et = Math.floor(_e / 8);
        return (this.buffer[et] >>> 7 - _e % 8 & 1) === 1
    },
    put: function(_e, et) {
        for (let tt = 0; tt < et; tt++)
            this.putBit((_e >>> et - tt - 1 & 1) === 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(_e) {
        const et = Math.floor(this.length / 8);
        this.buffer.length <= et && this.buffer.push(0),
        _e && (this.buffer[et] |= 128 >>> this.length % 8),
        this.length++
    }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(_e) {
    if (!_e || _e < 1)
        throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = _e,
    this.data = new Uint8Array(_e * _e),
    this.reservedBit = new Uint8Array(_e * _e)
}
BitMatrix$1.prototype.set = function(_e, et, tt, rt) {
    const nt = _e * this.size + et;
    this.data[nt] = tt,
    rt && (this.reservedBit[nt] = !0)
}
;
BitMatrix$1.prototype.get = function(_e, et) {
    return this.data[_e * this.size + et]
}
;
BitMatrix$1.prototype.xor = function(_e, et, tt) {
    this.data[_e * this.size + et] ^= tt
}
;
BitMatrix$1.prototype.isReserved = function(_e, et) {
    return this.reservedBit[_e * this.size + et]
}
;
var bitMatrix = BitMatrix$1
  , alignmentPattern = {};
(function(_e) {
    const et = utils$3.getSymbolSize;
    _e.getRowColCoords = function(rt) {
        if (rt === 1)
            return [];
        const nt = Math.floor(rt / 7) + 2
          , it = et(rt)
          , st = it === 145 ? 26 : Math.ceil((it - 13) / (2 * nt - 2)) * 2
          , at = [it - 7];
        for (let ot = 1; ot < nt - 1; ot++)
            at[ot] = at[ot - 1] - st;
        return at.push(6),
        at.reverse()
    }
    ,
    _e.getPositions = function(rt) {
        const nt = []
          , it = _e.getRowColCoords(rt)
          , st = it.length;
        for (let at = 0; at < st; at++)
            for (let ot = 0; ot < st; ot++)
                at === 0 && ot === 0 || at === 0 && ot === st - 1 || at === st - 1 && ot === 0 || nt.push([it[at], it[ot]]);
        return nt
    }
}
)(alignmentPattern);
var finderPattern = {};
const getSymbolSize = utils$3.getSymbolSize
  , FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function(et) {
    const tt = getSymbolSize(et);
    return [[0, 0], [tt - FINDER_PATTERN_SIZE, 0], [0, tt - FINDER_PATTERN_SIZE]]
}
;
var maskPattern = {};
(function(_e) {
    _e.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    };
    const et = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
    };
    _e.isValid = function(nt) {
        return nt != null && nt !== "" && !isNaN(nt) && nt >= 0 && nt <= 7
    }
    ,
    _e.from = function(nt) {
        return _e.isValid(nt) ? parseInt(nt, 10) : void 0
    }
    ,
    _e.getPenaltyN1 = function(nt) {
        const it = nt.size;
        let st = 0
          , at = 0
          , ot = 0
          , lt = null
          , dt = null;
        for (let ct = 0; ct < it; ct++) {
            at = ot = 0,
            lt = dt = null;
            for (let ut = 0; ut < it; ut++) {
                let ft = nt.get(ct, ut);
                ft === lt ? at++ : (at >= 5 && (st += et.N1 + (at - 5)),
                lt = ft,
                at = 1),
                ft = nt.get(ut, ct),
                ft === dt ? ot++ : (ot >= 5 && (st += et.N1 + (ot - 5)),
                dt = ft,
                ot = 1)
            }
            at >= 5 && (st += et.N1 + (at - 5)),
            ot >= 5 && (st += et.N1 + (ot - 5))
        }
        return st
    }
    ,
    _e.getPenaltyN2 = function(nt) {
        const it = nt.size;
        let st = 0;
        for (let at = 0; at < it - 1; at++)
            for (let ot = 0; ot < it - 1; ot++) {
                const lt = nt.get(at, ot) + nt.get(at, ot + 1) + nt.get(at + 1, ot) + nt.get(at + 1, ot + 1);
                (lt === 4 || lt === 0) && st++
            }
        return st * et.N2
    }
    ,
    _e.getPenaltyN3 = function(nt) {
        const it = nt.size;
        let st = 0
          , at = 0
          , ot = 0;
        for (let lt = 0; lt < it; lt++) {
            at = ot = 0;
            for (let dt = 0; dt < it; dt++)
                at = at << 1 & 2047 | nt.get(lt, dt),
                dt >= 10 && (at === 1488 || at === 93) && st++,
                ot = ot << 1 & 2047 | nt.get(dt, lt),
                dt >= 10 && (ot === 1488 || ot === 93) && st++
        }
        return st * et.N3
    }
    ,
    _e.getPenaltyN4 = function(nt) {
        let it = 0;
        const st = nt.data.length;
        for (let ot = 0; ot < st; ot++)
            it += nt.data[ot];
        return Math.abs(Math.ceil(it * 100 / st / 5) - 10) * et.N4
    }
    ;
    function tt(rt, nt, it) {
        switch (rt) {
        case _e.Patterns.PATTERN000:
            return (nt + it) % 2 === 0;
        case _e.Patterns.PATTERN001:
            return nt % 2 === 0;
        case _e.Patterns.PATTERN010:
            return it % 3 === 0;
        case _e.Patterns.PATTERN011:
            return (nt + it) % 3 === 0;
        case _e.Patterns.PATTERN100:
            return (Math.floor(nt / 2) + Math.floor(it / 3)) % 2 === 0;
        case _e.Patterns.PATTERN101:
            return nt * it % 2 + nt * it % 3 === 0;
        case _e.Patterns.PATTERN110:
            return (nt * it % 2 + nt * it % 3) % 2 === 0;
        case _e.Patterns.PATTERN111:
            return (nt * it % 3 + (nt + it) % 2) % 2 === 0;
        default:
            throw new Error("bad maskPattern:" + rt)
        }
    }
    _e.applyMask = function(nt, it) {
        const st = it.size;
        for (let at = 0; at < st; at++)
            for (let ot = 0; ot < st; ot++)
                it.isReserved(ot, at) || it.xor(ot, at, tt(nt, ot, at))
    }
    ,
    _e.getBestMask = function(nt, it) {
        const st = Object.keys(_e.Patterns).length;
        let at = 0
          , ot = 1 / 0;
        for (let lt = 0; lt < st; lt++) {
            it(lt),
            _e.applyMask(lt, nt);
            const dt = _e.getPenaltyN1(nt) + _e.getPenaltyN2(nt) + _e.getPenaltyN3(nt) + _e.getPenaltyN4(nt);
            _e.applyMask(lt, nt),
            dt < ot && (ot = dt,
            at = lt)
        }
        return at
    }
}
)(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel
  , EC_BLOCKS_TABLE = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]
  , EC_CODEWORDS_TABLE = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
errorCorrectionCode.getBlocksCount = function(et, tt) {
    switch (tt) {
    case ECLevel$1.L:
        return EC_BLOCKS_TABLE[(et - 1) * 4 + 0];
    case ECLevel$1.M:
        return EC_BLOCKS_TABLE[(et - 1) * 4 + 1];
    case ECLevel$1.Q:
        return EC_BLOCKS_TABLE[(et - 1) * 4 + 2];
    case ECLevel$1.H:
        return EC_BLOCKS_TABLE[(et - 1) * 4 + 3];
    default:
        return
    }
}
;
errorCorrectionCode.getTotalCodewordsCount = function(et, tt) {
    switch (tt) {
    case ECLevel$1.L:
        return EC_CODEWORDS_TABLE[(et - 1) * 4 + 0];
    case ECLevel$1.M:
        return EC_CODEWORDS_TABLE[(et - 1) * 4 + 1];
    case ECLevel$1.Q:
        return EC_CODEWORDS_TABLE[(et - 1) * 4 + 2];
    case ECLevel$1.H:
        return EC_CODEWORDS_TABLE[(et - 1) * 4 + 3];
    default:
        return
    }
}
;
var polynomial = {}
  , galoisField = {};
const EXP_TABLE = new Uint8Array(512)
  , LOG_TABLE = new Uint8Array(256);
(function() {
    let et = 1;
    for (let tt = 0; tt < 255; tt++)
        EXP_TABLE[tt] = et,
        LOG_TABLE[et] = tt,
        et <<= 1,
        et & 256 && (et ^= 285);
    for (let tt = 255; tt < 512; tt++)
        EXP_TABLE[tt] = EXP_TABLE[tt - 255]
}
)();
galoisField.log = function(et) {
    if (et < 1)
        throw new Error("log(" + et + ")");
    return LOG_TABLE[et]
}
;
galoisField.exp = function(et) {
    return EXP_TABLE[et]
}
;
galoisField.mul = function(et, tt) {
    return et === 0 || tt === 0 ? 0 : EXP_TABLE[LOG_TABLE[et] + LOG_TABLE[tt]]
}
;
(function(_e) {
    const et = galoisField;
    _e.mul = function(rt, nt) {
        const it = new Uint8Array(rt.length + nt.length - 1);
        for (let st = 0; st < rt.length; st++)
            for (let at = 0; at < nt.length; at++)
                it[st + at] ^= et.mul(rt[st], nt[at]);
        return it
    }
    ,
    _e.mod = function(rt, nt) {
        let it = new Uint8Array(rt);
        for (; it.length - nt.length >= 0; ) {
            const st = it[0];
            for (let ot = 0; ot < nt.length; ot++)
                it[ot] ^= et.mul(nt[ot], st);
            let at = 0;
            for (; at < it.length && it[at] === 0; )
                at++;
            it = it.slice(at)
        }
        return it
    }
    ,
    _e.generateECPolynomial = function(rt) {
        let nt = new Uint8Array([1]);
        for (let it = 0; it < rt; it++)
            nt = _e.mul(nt, new Uint8Array([1, et.exp(it)]));
        return nt
    }
}
)(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(_e) {
    this.genPoly = void 0,
    this.degree = _e,
    this.degree && this.initialize(this.degree)
}
ReedSolomonEncoder$1.prototype.initialize = function(et) {
    this.degree = et,
    this.genPoly = Polynomial.generateECPolynomial(this.degree)
}
;
ReedSolomonEncoder$1.prototype.encode = function(et) {
    if (!this.genPoly)
        throw new Error("Encoder not initialized");
    const tt = new Uint8Array(et.length + this.degree);
    tt.set(et);
    const rt = Polynomial.mod(tt, this.genPoly)
      , nt = this.degree - rt.length;
    if (nt > 0) {
        const it = new Uint8Array(this.degree);
        return it.set(rt, nt),
        it
    }
    return rt
}
;
var reedSolomonEncoder = ReedSolomonEncoder$1
  , version$1 = {}
  , mode = {}
  , versionCheck = {};
versionCheck.isValid = function(et) {
    return !isNaN(et) && et >= 1 && et <= 40
}
;
var regex = {};
const numeric = "[0-9]+"
  , alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + `)(?:.|[\r
]))+`;
regex.KANJI = new RegExp(kanji,"g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+","g");
regex.BYTE = new RegExp(byte,"g");
regex.NUMERIC = new RegExp(numeric,"g");
regex.ALPHANUMERIC = new RegExp(alphanumeric,"g");
const TEST_KANJI = new RegExp("^" + kanji + "$")
  , TEST_NUMERIC = new RegExp("^" + numeric + "$")
  , TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function(et) {
    return TEST_KANJI.test(et)
}
;
regex.testNumeric = function(et) {
    return TEST_NUMERIC.test(et)
}
;
regex.testAlphanumeric = function(et) {
    return TEST_ALPHANUMERIC.test(et)
}
;
(function(_e) {
    const et = versionCheck
      , tt = regex;
    _e.NUMERIC = {
        id: "Numeric",
        bit: 1,
        ccBits: [10, 12, 14]
    },
    _e.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
    },
    _e.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
    },
    _e.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
    },
    _e.MIXED = {
        bit: -1
    },
    _e.getCharCountIndicator = function(it, st) {
        if (!it.ccBits)
            throw new Error("Invalid mode: " + it);
        if (!et.isValid(st))
            throw new Error("Invalid version: " + st);
        return st >= 1 && st < 10 ? it.ccBits[0] : st < 27 ? it.ccBits[1] : it.ccBits[2]
    }
    ,
    _e.getBestModeForData = function(it) {
        return tt.testNumeric(it) ? _e.NUMERIC : tt.testAlphanumeric(it) ? _e.ALPHANUMERIC : tt.testKanji(it) ? _e.KANJI : _e.BYTE
    }
    ,
    _e.toString = function(it) {
        if (it && it.id)
            return it.id;
        throw new Error("Invalid mode")
    }
    ,
    _e.isValid = function(it) {
        return it && it.bit && it.ccBits
    }
    ;
    function rt(nt) {
        if (typeof nt != "string")
            throw new Error("Param is not a string");
        switch (nt.toLowerCase()) {
        case "numeric":
            return _e.NUMERIC;
        case "alphanumeric":
            return _e.ALPHANUMERIC;
        case "kanji":
            return _e.KANJI;
        case "byte":
            return _e.BYTE;
        default:
            throw new Error("Unknown mode: " + nt)
        }
    }
    _e.from = function(it, st) {
        if (_e.isValid(it))
            return it;
        try {
            return rt(it)
        } catch {
            return st
        }
    }
}
)(mode);
(function(_e) {
    const et = utils$3
      , tt = errorCorrectionCode
      , rt = errorCorrectionLevel
      , nt = mode
      , it = versionCheck
      , st = 7973
      , at = et.getBCHDigit(st);
    function ot(ut, ft, ht) {
        for (let gt = 1; gt <= 40; gt++)
            if (ft <= _e.getCapacity(gt, ht, ut))
                return gt
    }
    function lt(ut, ft) {
        return nt.getCharCountIndicator(ut, ft) + 4
    }
    function dt(ut, ft) {
        let ht = 0;
        return ut.forEach(function(gt) {
            const bt = lt(gt.mode, ft);
            ht += bt + gt.getBitsLength()
        }),
        ht
    }
    function ct(ut, ft) {
        for (let ht = 1; ht <= 40; ht++)
            if (dt(ut, ht) <= _e.getCapacity(ht, ft, nt.MIXED))
                return ht
    }
    _e.from = function(ft, ht) {
        return it.isValid(ft) ? parseInt(ft, 10) : ht
    }
    ,
    _e.getCapacity = function(ft, ht, gt) {
        if (!it.isValid(ft))
            throw new Error("Invalid QR Code version");
        typeof gt > "u" && (gt = nt.BYTE);
        const bt = et.getSymbolTotalCodewords(ft)
          , pt = tt.getTotalCodewordsCount(ft, ht)
          , mt = (bt - pt) * 8;
        if (gt === nt.MIXED)
            return mt;
        const yt = mt - lt(gt, ft);
        switch (gt) {
        case nt.NUMERIC:
            return Math.floor(yt / 10 * 3);
        case nt.ALPHANUMERIC:
            return Math.floor(yt / 11 * 2);
        case nt.KANJI:
            return Math.floor(yt / 13);
        case nt.BYTE:
        default:
            return Math.floor(yt / 8)
        }
    }
    ,
    _e.getBestVersionForData = function(ft, ht) {
        let gt;
        const bt = rt.from(ht, rt.M);
        if (Array.isArray(ft)) {
            if (ft.length > 1)
                return ct(ft, bt);
            if (ft.length === 0)
                return 1;
            gt = ft[0]
        } else
            gt = ft;
        return ot(gt.mode, gt.getLength(), bt)
    }
    ,
    _e.getEncodedBits = function(ft) {
        if (!it.isValid(ft) || ft < 7)
            throw new Error("Invalid QR Code version");
        let ht = ft << 12;
        for (; et.getBCHDigit(ht) - at >= 0; )
            ht ^= st << et.getBCHDigit(ht) - at;
        return ft << 12 | ht
    }
}
)(version$1);
var formatInfo = {};
const Utils$3 = utils$3
  , G15 = 1335
  , G15_MASK = 21522
  , G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function(et, tt) {
    const rt = et.bit << 3 | tt;
    let nt = rt << 10;
    for (; Utils$3.getBCHDigit(nt) - G15_BCH >= 0; )
        nt ^= G15 << Utils$3.getBCHDigit(nt) - G15_BCH;
    return (rt << 10 | nt) ^ G15_MASK
}
;
var segments = {};
const Mode$4 = mode;
function NumericData(_e) {
    this.mode = Mode$4.NUMERIC,
    this.data = _e.toString()
}
NumericData.getBitsLength = function(et) {
    return 10 * Math.floor(et / 3) + (et % 3 ? et % 3 * 3 + 1 : 0)
}
;
NumericData.prototype.getLength = function() {
    return this.data.length
}
;
NumericData.prototype.getBitsLength = function() {
    return NumericData.getBitsLength(this.data.length)
}
;
NumericData.prototype.write = function(et) {
    let tt, rt, nt;
    for (tt = 0; tt + 3 <= this.data.length; tt += 3)
        rt = this.data.substr(tt, 3),
        nt = parseInt(rt, 10),
        et.put(nt, 10);
    const it = this.data.length - tt;
    it > 0 && (rt = this.data.substr(tt),
    nt = parseInt(rt, 10),
    et.put(nt, it * 3 + 1))
}
;
var numericData = NumericData;
const Mode$3 = mode
  , ALPHA_NUM_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function AlphanumericData(_e) {
    this.mode = Mode$3.ALPHANUMERIC,
    this.data = _e
}
AlphanumericData.getBitsLength = function(et) {
    return 11 * Math.floor(et / 2) + 6 * (et % 2)
}
;
AlphanumericData.prototype.getLength = function() {
    return this.data.length
}
;
AlphanumericData.prototype.getBitsLength = function() {
    return AlphanumericData.getBitsLength(this.data.length)
}
;
AlphanumericData.prototype.write = function(et) {
    let tt;
    for (tt = 0; tt + 2 <= this.data.length; tt += 2) {
        let rt = ALPHA_NUM_CHARS.indexOf(this.data[tt]) * 45;
        rt += ALPHA_NUM_CHARS.indexOf(this.data[tt + 1]),
        et.put(rt, 11)
    }
    this.data.length % 2 && et.put(ALPHA_NUM_CHARS.indexOf(this.data[tt]), 6)
}
;
var alphanumericData = AlphanumericData
  , encodeUtf8$1 = function(et) {
    for (var tt = [], rt = et.length, nt = 0; nt < rt; nt++) {
        var it = et.charCodeAt(nt);
        if (it >= 55296 && it <= 56319 && rt > nt + 1) {
            var st = et.charCodeAt(nt + 1);
            st >= 56320 && st <= 57343 && (it = (it - 55296) * 1024 + st - 56320 + 65536,
            nt += 1)
        }
        if (it < 128) {
            tt.push(it);
            continue
        }
        if (it < 2048) {
            tt.push(it >> 6 | 192),
            tt.push(it & 63 | 128);
            continue
        }
        if (it < 55296 || it >= 57344 && it < 65536) {
            tt.push(it >> 12 | 224),
            tt.push(it >> 6 & 63 | 128),
            tt.push(it & 63 | 128);
            continue
        }
        if (it >= 65536 && it <= 1114111) {
            tt.push(it >> 18 | 240),
            tt.push(it >> 12 & 63 | 128),
            tt.push(it >> 6 & 63 | 128),
            tt.push(it & 63 | 128);
            continue
        }
        tt.push(239, 191, 189)
    }
    return new Uint8Array(tt).buffer
};
const encodeUtf8 = encodeUtf8$1
  , Mode$2 = mode;
function ByteData(_e) {
    this.mode = Mode$2.BYTE,
    typeof _e == "string" && (_e = encodeUtf8(_e)),
    this.data = new Uint8Array(_e)
}
ByteData.getBitsLength = function(et) {
    return et * 8
}
;
ByteData.prototype.getLength = function() {
    return this.data.length
}
;
ByteData.prototype.getBitsLength = function() {
    return ByteData.getBitsLength(this.data.length)
}
;
ByteData.prototype.write = function(_e) {
    for (let et = 0, tt = this.data.length; et < tt; et++)
        _e.put(this.data[et], 8)
}
;
var byteData = ByteData;
const Mode$1 = mode
  , Utils$2 = utils$3;
function KanjiData(_e) {
    this.mode = Mode$1.KANJI,
    this.data = _e
}
KanjiData.getBitsLength = function(et) {
    return et * 13
}
;
KanjiData.prototype.getLength = function() {
    return this.data.length
}
;
KanjiData.prototype.getBitsLength = function() {
    return KanjiData.getBitsLength(this.data.length)
}
;
KanjiData.prototype.write = function(_e) {
    let et;
    for (et = 0; et < this.data.length; et++) {
        let tt = Utils$2.toSJIS(this.data[et]);
        if (tt >= 33088 && tt <= 40956)
            tt -= 33088;
        else if (tt >= 57408 && tt <= 60351)
            tt -= 49472;
        else
            throw new Error("Invalid SJIS character: " + this.data[et] + `
Make sure your charset is UTF-8`);
        tt = (tt >>> 8 & 255) * 192 + (tt & 255),
        _e.put(tt, 13)
    }
}
;
var kanjiData = KanjiData
  , dijkstra = {
    exports: {}
};
(function(_e) {
    var et = {
        single_source_shortest_paths: function(tt, rt, nt) {
            var it = {}
              , st = {};
            st[rt] = 0;
            var at = et.PriorityQueue.make();
            at.push(rt, 0);
            for (var ot, lt, dt, ct, ut, ft, ht, gt, bt; !at.empty(); ) {
                ot = at.pop(),
                lt = ot.value,
                ct = ot.cost,
                ut = tt[lt] || {};
                for (dt in ut)
                    ut.hasOwnProperty(dt) && (ft = ut[dt],
                    ht = ct + ft,
                    gt = st[dt],
                    bt = typeof st[dt] > "u",
                    (bt || gt > ht) && (st[dt] = ht,
                    at.push(dt, ht),
                    it[dt] = lt))
            }
            if (typeof nt < "u" && typeof st[nt] > "u") {
                var pt = ["Could not find a path from ", rt, " to ", nt, "."].join("");
                throw new Error(pt)
            }
            return it
        },
        extract_shortest_path_from_predecessor_list: function(tt, rt) {
            for (var nt = [], it = rt; it; )
                nt.push(it),
                tt[it],
                it = tt[it];
            return nt.reverse(),
            nt
        },
        find_path: function(tt, rt, nt) {
            var it = et.single_source_shortest_paths(tt, rt, nt);
            return et.extract_shortest_path_from_predecessor_list(it, nt)
        },
        PriorityQueue: {
            make: function(tt) {
                var rt = et.PriorityQueue, nt = {}, it;
                tt = tt || {};
                for (it in rt)
                    rt.hasOwnProperty(it) && (nt[it] = rt[it]);
                return nt.queue = [],
                nt.sorter = tt.sorter || rt.default_sorter,
                nt
            },
            default_sorter: function(tt, rt) {
                return tt.cost - rt.cost
            },
            push: function(tt, rt) {
                var nt = {
                    value: tt,
                    cost: rt
                };
                this.queue.push(nt),
                this.queue.sort(this.sorter)
            },
            pop: function() {
                return this.queue.shift()
            },
            empty: function() {
                return this.queue.length === 0
            }
        }
    };
    _e.exports = et
}
)(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(_e) {
    const et = mode
      , tt = numericData
      , rt = alphanumericData
      , nt = byteData
      , it = kanjiData
      , st = regex
      , at = utils$3
      , ot = dijkstraExports;
    function lt(pt) {
        return unescape(encodeURIComponent(pt)).length
    }
    function dt(pt, mt, yt) {
        const vt = [];
        let wt;
        for (; (wt = pt.exec(yt)) !== null; )
            vt.push({
                data: wt[0],
                index: wt.index,
                mode: mt,
                length: wt[0].length
            });
        return vt
    }
    function ct(pt) {
        const mt = dt(st.NUMERIC, et.NUMERIC, pt)
          , yt = dt(st.ALPHANUMERIC, et.ALPHANUMERIC, pt);
        let vt, wt;
        return at.isKanjiModeEnabled() ? (vt = dt(st.BYTE, et.BYTE, pt),
        wt = dt(st.KANJI, et.KANJI, pt)) : (vt = dt(st.BYTE_KANJI, et.BYTE, pt),
        wt = []),
        mt.concat(yt, vt, wt).sort(function(Et, xt) {
            return Et.index - xt.index
        }).map(function(Et) {
            return {
                data: Et.data,
                mode: Et.mode,
                length: Et.length
            }
        })
    }
    function ut(pt, mt) {
        switch (mt) {
        case et.NUMERIC:
            return tt.getBitsLength(pt);
        case et.ALPHANUMERIC:
            return rt.getBitsLength(pt);
        case et.KANJI:
            return it.getBitsLength(pt);
        case et.BYTE:
            return nt.getBitsLength(pt)
        }
    }
    function ft(pt) {
        return pt.reduce(function(mt, yt) {
            const vt = mt.length - 1 >= 0 ? mt[mt.length - 1] : null;
            return vt && vt.mode === yt.mode ? (mt[mt.length - 1].data += yt.data,
            mt) : (mt.push(yt),
            mt)
        }, [])
    }
    function ht(pt) {
        const mt = [];
        for (let yt = 0; yt < pt.length; yt++) {
            const vt = pt[yt];
            switch (vt.mode) {
            case et.NUMERIC:
                mt.push([vt, {
                    data: vt.data,
                    mode: et.ALPHANUMERIC,
                    length: vt.length
                }, {
                    data: vt.data,
                    mode: et.BYTE,
                    length: vt.length
                }]);
                break;
            case et.ALPHANUMERIC:
                mt.push([vt, {
                    data: vt.data,
                    mode: et.BYTE,
                    length: vt.length
                }]);
                break;
            case et.KANJI:
                mt.push([vt, {
                    data: vt.data,
                    mode: et.BYTE,
                    length: lt(vt.data)
                }]);
                break;
            case et.BYTE:
                mt.push([{
                    data: vt.data,
                    mode: et.BYTE,
                    length: lt(vt.data)
                }])
            }
        }
        return mt
    }
    function gt(pt, mt) {
        const yt = {}
          , vt = {
            start: {}
        };
        let wt = ["start"];
        for (let _t = 0; _t < pt.length; _t++) {
            const Et = pt[_t]
              , xt = [];
            for (let Ct = 0; Ct < Et.length; Ct++) {
                const Tt = Et[Ct]
                  , It = "" + _t + Ct;
                xt.push(It),
                yt[It] = {
                    node: Tt,
                    lastCount: 0
                },
                vt[It] = {};
                for (let Nt = 0; Nt < wt.length; Nt++) {
                    const Ft = wt[Nt];
                    yt[Ft] && yt[Ft].node.mode === Tt.mode ? (vt[Ft][It] = ut(yt[Ft].lastCount + Tt.length, Tt.mode) - ut(yt[Ft].lastCount, Tt.mode),
                    yt[Ft].lastCount += Tt.length) : (yt[Ft] && (yt[Ft].lastCount = Tt.length),
                    vt[Ft][It] = ut(Tt.length, Tt.mode) + 4 + et.getCharCountIndicator(Tt.mode, mt))
                }
            }
            wt = xt
        }
        for (let _t = 0; _t < wt.length; _t++)
            vt[wt[_t]].end = 0;
        return {
            map: vt,
            table: yt
        }
    }
    function bt(pt, mt) {
        let yt;
        const vt = et.getBestModeForData(pt);
        if (yt = et.from(mt, vt),
        yt !== et.BYTE && yt.bit < vt.bit)
            throw new Error('"' + pt + '" cannot be encoded with mode ' + et.toString(yt) + `.
 Suggested mode is: ` + et.toString(vt));
        switch (yt === et.KANJI && !at.isKanjiModeEnabled() && (yt = et.BYTE),
        yt) {
        case et.NUMERIC:
            return new tt(pt);
        case et.ALPHANUMERIC:
            return new rt(pt);
        case et.KANJI:
            return new it(pt);
        case et.BYTE:
            return new nt(pt)
        }
    }
    _e.fromArray = function(mt) {
        return mt.reduce(function(yt, vt) {
            return typeof vt == "string" ? yt.push(bt(vt, null)) : vt.data && yt.push(bt(vt.data, vt.mode)),
            yt
        }, [])
    }
    ,
    _e.fromString = function(mt, yt) {
        const vt = ct(mt, at.isKanjiModeEnabled())
          , wt = ht(vt)
          , _t = gt(wt, yt)
          , Et = ot.find_path(_t.map, "start", "end")
          , xt = [];
        for (let Ct = 1; Ct < Et.length - 1; Ct++)
            xt.push(_t.table[Et[Ct]].node);
        return _e.fromArray(ft(xt))
    }
    ,
    _e.rawSplit = function(mt) {
        return _e.fromArray(ct(mt, at.isKanjiModeEnabled()))
    }
}
)(segments);
const Utils$1 = utils$3
  , ECLevel = errorCorrectionLevel
  , BitBuffer = bitBuffer
  , BitMatrix = bitMatrix
  , AlignmentPattern = alignmentPattern
  , FinderPattern = finderPattern
  , MaskPattern = maskPattern
  , ECCode = errorCorrectionCode
  , ReedSolomonEncoder = reedSolomonEncoder
  , Version = version$1
  , FormatInfo = formatInfo
  , Mode = mode
  , Segments = segments;
function setupFinderPattern(_e, et) {
    const tt = _e.size
      , rt = FinderPattern.getPositions(et);
    for (let nt = 0; nt < rt.length; nt++) {
        const it = rt[nt][0]
          , st = rt[nt][1];
        for (let at = -1; at <= 7; at++)
            if (!(it + at <= -1 || tt <= it + at))
                for (let ot = -1; ot <= 7; ot++)
                    st + ot <= -1 || tt <= st + ot || (at >= 0 && at <= 6 && (ot === 0 || ot === 6) || ot >= 0 && ot <= 6 && (at === 0 || at === 6) || at >= 2 && at <= 4 && ot >= 2 && ot <= 4 ? _e.set(it + at, st + ot, !0, !0) : _e.set(it + at, st + ot, !1, !0))
    }
}
function setupTimingPattern(_e) {
    const et = _e.size;
    for (let tt = 8; tt < et - 8; tt++) {
        const rt = tt % 2 === 0;
        _e.set(tt, 6, rt, !0),
        _e.set(6, tt, rt, !0)
    }
}
function setupAlignmentPattern(_e, et) {
    const tt = AlignmentPattern.getPositions(et);
    for (let rt = 0; rt < tt.length; rt++) {
        const nt = tt[rt][0]
          , it = tt[rt][1];
        for (let st = -2; st <= 2; st++)
            for (let at = -2; at <= 2; at++)
                st === -2 || st === 2 || at === -2 || at === 2 || st === 0 && at === 0 ? _e.set(nt + st, it + at, !0, !0) : _e.set(nt + st, it + at, !1, !0)
    }
}
function setupVersionInfo(_e, et) {
    const tt = _e.size
      , rt = Version.getEncodedBits(et);
    let nt, it, st;
    for (let at = 0; at < 18; at++)
        nt = Math.floor(at / 3),
        it = at % 3 + tt - 8 - 3,
        st = (rt >> at & 1) === 1,
        _e.set(nt, it, st, !0),
        _e.set(it, nt, st, !0)
}
function setupFormatInfo(_e, et, tt) {
    const rt = _e.size
      , nt = FormatInfo.getEncodedBits(et, tt);
    let it, st;
    for (it = 0; it < 15; it++)
        st = (nt >> it & 1) === 1,
        it < 6 ? _e.set(it, 8, st, !0) : it < 8 ? _e.set(it + 1, 8, st, !0) : _e.set(rt - 15 + it, 8, st, !0),
        it < 8 ? _e.set(8, rt - it - 1, st, !0) : it < 9 ? _e.set(8, 15 - it - 1 + 1, st, !0) : _e.set(8, 15 - it - 1, st, !0);
    _e.set(rt - 8, 8, 1, !0)
}
function setupData(_e, et) {
    const tt = _e.size;
    let rt = -1
      , nt = tt - 1
      , it = 7
      , st = 0;
    for (let at = tt - 1; at > 0; at -= 2)
        for (at === 6 && at--; ; ) {
            for (let ot = 0; ot < 2; ot++)
                if (!_e.isReserved(nt, at - ot)) {
                    let lt = !1;
                    st < et.length && (lt = (et[st] >>> it & 1) === 1),
                    _e.set(nt, at - ot, lt),
                    it--,
                    it === -1 && (st++,
                    it = 7)
                }
            if (nt += rt,
            nt < 0 || tt <= nt) {
                nt -= rt,
                rt = -rt;
                break
            }
        }
}
function createData(_e, et, tt) {
    const rt = new BitBuffer;
    tt.forEach(function(ot) {
        rt.put(ot.mode.bit, 4),
        rt.put(ot.getLength(), Mode.getCharCountIndicator(ot.mode, _e)),
        ot.write(rt)
    });
    const nt = Utils$1.getSymbolTotalCodewords(_e)
      , it = ECCode.getTotalCodewordsCount(_e, et)
      , st = (nt - it) * 8;
    for (rt.getLengthInBits() + 4 <= st && rt.put(0, 4); rt.getLengthInBits() % 8 !== 0; )
        rt.putBit(0);
    const at = (st - rt.getLengthInBits()) / 8;
    for (let ot = 0; ot < at; ot++)
        rt.put(ot % 2 ? 17 : 236, 8);
    return createCodewords(rt, _e, et)
}
function createCodewords(_e, et, tt) {
    const rt = Utils$1.getSymbolTotalCodewords(et)
      , nt = ECCode.getTotalCodewordsCount(et, tt)
      , it = rt - nt
      , st = ECCode.getBlocksCount(et, tt)
      , at = rt % st
      , ot = st - at
      , lt = Math.floor(rt / st)
      , dt = Math.floor(it / st)
      , ct = dt + 1
      , ut = lt - dt
      , ft = new ReedSolomonEncoder(ut);
    let ht = 0;
    const gt = new Array(st)
      , bt = new Array(st);
    let pt = 0;
    const mt = new Uint8Array(_e.buffer);
    for (let Et = 0; Et < st; Et++) {
        const xt = Et < ot ? dt : ct;
        gt[Et] = mt.slice(ht, ht + xt),
        bt[Et] = ft.encode(gt[Et]),
        ht += xt,
        pt = Math.max(pt, xt)
    }
    const yt = new Uint8Array(rt);
    let vt = 0, wt, _t;
    for (wt = 0; wt < pt; wt++)
        for (_t = 0; _t < st; _t++)
            wt < gt[_t].length && (yt[vt++] = gt[_t][wt]);
    for (wt = 0; wt < ut; wt++)
        for (_t = 0; _t < st; _t++)
            yt[vt++] = bt[_t][wt];
    return yt
}
function createSymbol(_e, et, tt, rt) {
    let nt;
    if (Array.isArray(_e))
        nt = Segments.fromArray(_e);
    else if (typeof _e == "string") {
        let lt = et;
        if (!lt) {
            const dt = Segments.rawSplit(_e);
            lt = Version.getBestVersionForData(dt, tt)
        }
        nt = Segments.fromString(_e, lt || 40)
    } else
        throw new Error("Invalid data");
    const it = Version.getBestVersionForData(nt, tt);
    if (!it)
        throw new Error("The amount of data is too big to be stored in a QR Code");
    if (!et)
        et = it;
    else if (et < it)
        throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + it + `.
`);
    const st = createData(et, tt, nt)
      , at = Utils$1.getSymbolSize(et)
      , ot = new BitMatrix(at);
    return setupFinderPattern(ot, et),
    setupTimingPattern(ot),
    setupAlignmentPattern(ot, et),
    setupFormatInfo(ot, tt, 0),
    et >= 7 && setupVersionInfo(ot, et),
    setupData(ot, st),
    isNaN(rt) && (rt = MaskPattern.getBestMask(ot, setupFormatInfo.bind(null, ot, tt))),
    MaskPattern.applyMask(rt, ot),
    setupFormatInfo(ot, tt, rt),
    {
        modules: ot,
        version: et,
        errorCorrectionLevel: tt,
        maskPattern: rt,
        segments: nt
    }
}
qrcode.create = function(et, tt) {
    if (typeof et > "u" || et === "")
        throw new Error("No input text");
    let rt = ECLevel.M, nt, it;
    return typeof tt < "u" && (rt = ECLevel.from(tt.errorCorrectionLevel, ECLevel.M),
    nt = Version.from(tt.version),
    it = MaskPattern.from(tt.maskPattern),
    tt.toSJISFunc && Utils$1.setToSJISFunction(tt.toSJISFunc)),
    createSymbol(et, nt, rt, it)
}
;
var canvas = {}
  , utils$2 = {};
(function(_e) {
    function et(tt) {
        if (typeof tt == "number" && (tt = tt.toString()),
        typeof tt != "string")
            throw new Error("Color should be defined as hex string");
        let rt = tt.slice().replace("#", "").split("");
        if (rt.length < 3 || rt.length === 5 || rt.length > 8)
            throw new Error("Invalid hex color: " + tt);
        (rt.length === 3 || rt.length === 4) && (rt = Array.prototype.concat.apply([], rt.map(function(it) {
            return [it, it]
        }))),
        rt.length === 6 && rt.push("F", "F");
        const nt = parseInt(rt.join(""), 16);
        return {
            r: nt >> 24 & 255,
            g: nt >> 16 & 255,
            b: nt >> 8 & 255,
            a: nt & 255,
            hex: "#" + rt.slice(0, 6).join("")
        }
    }
    _e.getOptions = function(rt) {
        rt || (rt = {}),
        rt.color || (rt.color = {});
        const nt = typeof rt.margin > "u" || rt.margin === null || rt.margin < 0 ? 4 : rt.margin
          , it = rt.width && rt.width >= 21 ? rt.width : void 0
          , st = rt.scale || 4;
        return {
            width: it,
            scale: it ? 4 : st,
            margin: nt,
            color: {
                dark: et(rt.color.dark || "#000000ff"),
                light: et(rt.color.light || "#ffffffff")
            },
            type: rt.type,
            rendererOpts: rt.rendererOpts || {}
        }
    }
    ,
    _e.getScale = function(rt, nt) {
        return nt.width && nt.width >= rt + nt.margin * 2 ? nt.width / (rt + nt.margin * 2) : nt.scale
    }
    ,
    _e.getImageWidth = function(rt, nt) {
        const it = _e.getScale(rt, nt);
        return Math.floor((rt + nt.margin * 2) * it)
    }
    ,
    _e.qrToImageData = function(rt, nt, it) {
        const st = nt.modules.size
          , at = nt.modules.data
          , ot = _e.getScale(st, it)
          , lt = Math.floor((st + it.margin * 2) * ot)
          , dt = it.margin * ot
          , ct = [it.color.light, it.color.dark];
        for (let ut = 0; ut < lt; ut++)
            for (let ft = 0; ft < lt; ft++) {
                let ht = (ut * lt + ft) * 4
                  , gt = it.color.light;
                if (ut >= dt && ft >= dt && ut < lt - dt && ft < lt - dt) {
                    const bt = Math.floor((ut - dt) / ot)
                      , pt = Math.floor((ft - dt) / ot);
                    gt = ct[at[bt * st + pt] ? 1 : 0]
                }
                rt[ht++] = gt.r,
                rt[ht++] = gt.g,
                rt[ht++] = gt.b,
                rt[ht] = gt.a
            }
    }
}
)(utils$2);
(function(_e) {
    const et = utils$2;
    function tt(nt, it, st) {
        nt.clearRect(0, 0, it.width, it.height),
        it.style || (it.style = {}),
        it.height = st,
        it.width = st,
        it.style.height = st + "px",
        it.style.width = st + "px"
    }
    function rt() {
        try {
            return document.createElement("canvas")
        } catch {
            throw new Error("You need to specify a canvas element")
        }
    }
    _e.render = function(it, st, at) {
        let ot = at
          , lt = st;
        typeof ot > "u" && (!st || !st.getContext) && (ot = st,
        st = void 0),
        st || (lt = rt()),
        ot = et.getOptions(ot);
        const dt = et.getImageWidth(it.modules.size, ot)
          , ct = lt.getContext("2d")
          , ut = ct.createImageData(dt, dt);
        return et.qrToImageData(ut.data, it, ot),
        tt(ct, lt, dt),
        ct.putImageData(ut, 0, 0),
        lt
    }
    ,
    _e.renderToDataURL = function(it, st, at) {
        let ot = at;
        typeof ot > "u" && (!st || !st.getContext) && (ot = st,
        st = void 0),
        ot || (ot = {});
        const lt = _e.render(it, st, ot)
          , dt = ot.type || "image/png"
          , ct = ot.rendererOpts || {};
        return lt.toDataURL(dt, ct.quality)
    }
}
)(canvas);
var svgTag = {};
const Utils = utils$2;
function getColorAttrib(_e, et) {
    const tt = _e.a / 255
      , rt = et + '="' + _e.hex + '"';
    return tt < 1 ? rt + " " + et + '-opacity="' + tt.toFixed(2).slice(1) + '"' : rt
}
function svgCmd(_e, et, tt) {
    let rt = _e + et;
    return typeof tt < "u" && (rt += " " + tt),
    rt
}
function qrToPath(_e, et, tt) {
    let rt = ""
      , nt = 0
      , it = !1
      , st = 0;
    for (let at = 0; at < _e.length; at++) {
        const ot = Math.floor(at % et)
          , lt = Math.floor(at / et);
        !ot && !it && (it = !0),
        _e[at] ? (st++,
        at > 0 && ot > 0 && _e[at - 1] || (rt += it ? svgCmd("M", ot + tt, .5 + lt + tt) : svgCmd("m", nt, 0),
        nt = 0,
        it = !1),
        ot + 1 < et && _e[at + 1] || (rt += svgCmd("h", st),
        st = 0)) : nt++
    }
    return rt
}
svgTag.render = function(et, tt, rt) {
    const nt = Utils.getOptions(tt)
      , it = et.modules.size
      , st = et.modules.data
      , at = it + nt.margin * 2
      , ot = nt.color.light.a ? "<path " + getColorAttrib(nt.color.light, "fill") + ' d="M0 0h' + at + "v" + at + 'H0z"/>' : ""
      , lt = "<path " + getColorAttrib(nt.color.dark, "stroke") + ' d="' + qrToPath(st, it, nt.margin) + '"/>'
      , dt = 'viewBox="0 0 ' + at + " " + at + '"'
      , ut = '<svg xmlns="http://www.w3.org/2000/svg" ' + (nt.width ? 'width="' + nt.width + '" height="' + nt.width + '" ' : "") + dt + ' shape-rendering="crispEdges">' + ot + lt + `</svg>
`;
    return typeof rt == "function" && rt(null, ut),
    ut
}
;
const canPromise = canPromise$1
  , QRCode = qrcode
  , CanvasRenderer = canvas
  , SvgRenderer = svgTag;
function renderCanvas(_e, et, tt, rt, nt) {
    const it = [].slice.call(arguments, 1)
      , st = it.length
      , at = typeof it[st - 1] == "function";
    if (!at && !canPromise())
        throw new Error("Callback required as last argument");
    if (at) {
        if (st < 2)
            throw new Error("Too few arguments provided");
        st === 2 ? (nt = tt,
        tt = et,
        et = rt = void 0) : st === 3 && (et.getContext && typeof nt > "u" ? (nt = rt,
        rt = void 0) : (nt = rt,
        rt = tt,
        tt = et,
        et = void 0))
    } else {
        if (st < 1)
            throw new Error("Too few arguments provided");
        return st === 1 ? (tt = et,
        et = rt = void 0) : st === 2 && !et.getContext && (rt = tt,
        tt = et,
        et = void 0),
        new Promise(function(ot, lt) {
            try {
                const dt = QRCode.create(tt, rt);
                ot(_e(dt, et, rt))
            } catch (dt) {
                lt(dt)
            }
        }
        )
    }
    try {
        const ot = QRCode.create(tt, rt);
        nt(null, _e(ot, et, rt))
    } catch (ot) {
        nt(ot)
    }
}
browser$1.create = QRCode.create;
browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser$1.toString = renderCanvas.bind(null, function(_e, et, tt) {
    return SvgRenderer.render(_e, tt)
});
const CONNECTING_ERROR_MARGIN = .1
  , CIRCLE_SIZE_MODIFIER = 2.5
  , QRCODE_MATRIX_MARGIN = 7;
function isAdjecentDots(_e, et, tt) {
    return _e === et ? !1 : (_e - et < 0 ? et - _e : _e - et) <= tt + CONNECTING_ERROR_MARGIN
}
function getMatrix(_e, et) {
    const tt = Array.prototype.slice.call(browser$1.create(_e, {
        errorCorrectionLevel: et
    }).modules.data, 0)
      , rt = Math.sqrt(tt.length);
    return tt.reduce((nt,it,st)=>(st % rt === 0 ? nt.push([it]) : nt[nt.length - 1].push(it)) && nt, [])
}
const QrCodeUtil = {
    generate(_e, et, tt) {
        const rt = "#141414"
          , nt = "transparent"
          , st = []
          , at = getMatrix(_e, "Q")
          , ot = et / at.length
          , lt = [{
            x: 0,
            y: 0
        }, {
            x: 1,
            y: 0
        }, {
            x: 0,
            y: 1
        }];
        lt.forEach(({x: gt, y: bt})=>{
            const pt = (at.length - QRCODE_MATRIX_MARGIN) * ot * gt
              , mt = (at.length - QRCODE_MATRIX_MARGIN) * ot * bt
              , yt = .45;
            for (let vt = 0; vt < lt.length; vt += 1) {
                const wt = ot * (QRCODE_MATRIX_MARGIN - vt * 2);
                st.push(b$1`
            <rect
              fill=${vt === 2 ? rt : nt}
              width=${vt === 0 ? wt - 5 : wt}
              rx= ${vt === 0 ? (wt - 5) * yt : wt * yt}
              ry= ${vt === 0 ? (wt - 5) * yt : wt * yt}
              stroke=${rt}
              stroke-width=${vt === 0 ? 5 : 0}
              height=${vt === 0 ? wt - 5 : wt}
              x= ${vt === 0 ? mt + ot * vt + 5 / 2 : mt + ot * vt}
              y= ${vt === 0 ? pt + ot * vt + 5 / 2 : pt + ot * vt}
            />
          `)
            }
        }
        );
        const dt = Math.floor((tt + 25) / ot)
          , ct = at.length / 2 - dt / 2
          , ut = at.length / 2 + dt / 2 - 1
          , ft = [];
        at.forEach((gt,bt)=>{
            gt.forEach((pt,mt)=>{
                if (at[bt][mt] && !(bt < QRCODE_MATRIX_MARGIN && mt < QRCODE_MATRIX_MARGIN || bt > at.length - (QRCODE_MATRIX_MARGIN + 1) && mt < QRCODE_MATRIX_MARGIN || bt < QRCODE_MATRIX_MARGIN && mt > at.length - (QRCODE_MATRIX_MARGIN + 1)) && !(bt > ct && bt < ut && mt > ct && mt < ut)) {
                    const yt = bt * ot + ot / 2
                      , vt = mt * ot + ot / 2;
                    ft.push([yt, vt])
                }
            }
            )
        }
        );
        const ht = {};
        return ft.forEach(([gt,bt])=>{
            var pt;
            ht[gt] ? (pt = ht[gt]) == null || pt.push(bt) : ht[gt] = [bt]
        }
        ),
        Object.entries(ht).map(([gt,bt])=>{
            const pt = bt.filter(mt=>bt.every(yt=>!isAdjecentDots(mt, yt, ot)));
            return [Number(gt), pt]
        }
        ).forEach(([gt,bt])=>{
            bt.forEach(pt=>{
                st.push(b$1`<circle cx=${gt} cy=${pt} fill=${rt} r=${ot / CIRCLE_SIZE_MODIFIER} />`)
            }
            )
        }
        ),
        Object.entries(ht).filter(([gt,bt])=>bt.length > 1).map(([gt,bt])=>{
            const pt = bt.filter(mt=>bt.some(yt=>isAdjecentDots(mt, yt, ot)));
            return [Number(gt), pt]
        }
        ).map(([gt,bt])=>{
            bt.sort((mt,yt)=>mt < yt ? -1 : 1);
            const pt = [];
            for (const mt of bt) {
                const yt = pt.find(vt=>vt.some(wt=>isAdjecentDots(mt, wt, ot)));
                yt ? yt.push(mt) : pt.push([mt])
            }
            return [gt, pt.map(mt=>[mt[0], mt[mt.length - 1]])]
        }
        ).forEach(([gt,bt])=>{
            bt.forEach(([pt,mt])=>{
                st.push(b$1`
              <line
                x1=${gt}
                x2=${gt}
                y1=${pt}
                y2=${mt}
                stroke=${rt}
                stroke-width=${ot / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `)
            }
            )
        }
        ),
        st
    }
}
  , styles$K = i$8`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var __decorate$15 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiQrCode = class extends s$5 {
    constructor() {
        super(...arguments),
        this.uri = "",
        this.size = 0,
        this.theme = "dark",
        this.imageSrc = void 0,
        this.alt = void 0
    }
    render() {
        return this.dataset.theme = this.theme,
        this.style.cssText = `--local-size: ${this.size}px`,
        x$1`${this.templateVisual()} ${this.templateSvg()}`
    }
    templateSvg() {
        const et = this.theme === "light" ? this.size : this.size - 32;
        return b$1`
      <svg height=${et} width=${et}>
        ${QrCodeUtil.generate(this.uri, et, et / 4)}
      </svg>
    `
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>` : x$1`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`
    }
}
;
WuiQrCode.styles = [resetStyles, styles$K];
__decorate$15([n$a()], WuiQrCode.prototype, "uri", void 0);
__decorate$15([n$a({
    type: Number
})], WuiQrCode.prototype, "size", void 0);
__decorate$15([n$a()], WuiQrCode.prototype, "theme", void 0);
__decorate$15([n$a()], WuiQrCode.prototype, "imageSrc", void 0);
__decorate$15([n$a()], WuiQrCode.prototype, "alt", void 0);
WuiQrCode = __decorate$15([customElement("wui-qr-code")], WuiQrCode);
const styles$J = i$8`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var __decorate$14 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiSearchBar = class extends s$5 {
    constructor() {
        super(...arguments),
        this.inputComponentRef = e$5()
    }
    render() {
        return x$1`
      <wui-input-text
        ${n$8(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `
    }
    clearValue() {
        const et = this.inputComponentRef.value
          , tt = et == null ? void 0 : et.inputElementRef.value;
        tt && (tt.value = "",
        tt.focus(),
        tt.dispatchEvent(new Event("input")))
    }
}
;
WuiSearchBar.styles = [resetStyles, styles$J];
WuiSearchBar = __decorate$14([customElement("wui-search-bar")], WuiSearchBar);
const styles$I = i$8`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    box-sizing: border-box;
    max-height: 40px;
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }
`;
var __decorate$13 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiSnackbar = class extends s$5 {
    constructor() {
        super(...arguments),
        this.backgroundColor = "accent-100",
        this.iconColor = "accent-100",
        this.icon = "checkmark",
        this.message = ""
    }
    render() {
        return x$1`
      <wui-icon-box
        size="sm"
        iconSize="xs"
        iconColor=${this.iconColor}
        backgroundColor=${this.backgroundColor}
        icon=${this.icon}
        background="opaque"
      ></wui-icon-box>
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `
    }
}
;
WuiSnackbar.styles = [resetStyles, styles$I];
__decorate$13([n$a()], WuiSnackbar.prototype, "backgroundColor", void 0);
__decorate$13([n$a()], WuiSnackbar.prototype, "iconColor", void 0);
__decorate$13([n$a()], WuiSnackbar.prototype, "icon", void 0);
__decorate$13([n$a()], WuiSnackbar.prototype, "message", void 0);
WuiSnackbar = __decorate$13([customElement("wui-snackbar")], WuiSnackbar);
const styles$H = i$8`
  :host {
    display: inline-flex;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  button {
    width: var(--local-tab-width);
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$12 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiTabs = class extends s$5 {
    constructor() {
        super(...arguments),
        this.tabs = [],
        this.onTabChange = ()=>null,
        this.buttons = [],
        this.disabled = !1,
        this.activeTab = 0,
        this.localTabWidth = "100px",
        this.isDense = !1
    }
    render() {
        return this.isDense = this.tabs.length > 3,
        this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `,
        this.dataset.type = this.isDense ? "flex" : "block",
        this.tabs.map((et,tt)=>{
            const rt = tt === this.activeTab;
            return x$1`
        <button
          ?disabled=${this.disabled}
          @click=${()=>this.onTabClick(tt)}
          data-active=${rt}
        >
          <wui-icon size="xs" color="inherit" name=${et.icon}></wui-icon>
          <wui-text variant="small-600" color="inherit"> ${et.label} </wui-text>
        </button>
      `
        }
        )
    }
    firstUpdated() {
        this.shadowRoot && this.isDense && (this.buttons = [...this.shadowRoot.querySelectorAll("button")],
        setTimeout(()=>{
            this.animateTabs(0, !0)
        }
        , 0))
    }
    onTabClick(et) {
        this.buttons && this.animateTabs(et, !1),
        this.activeTab = et,
        this.onTabChange(et)
    }
    animateTabs(et, tt) {
        const rt = this.buttons[this.activeTab]
          , nt = this.buttons[et]
          , it = rt == null ? void 0 : rt.querySelector("wui-text")
          , st = nt == null ? void 0 : nt.querySelector("wui-text")
          , at = nt == null ? void 0 : nt.getBoundingClientRect()
          , ot = st == null ? void 0 : st.getBoundingClientRect();
        rt && it && !tt && et !== this.activeTab && (it.animate([{
            opacity: 0
        }], {
            duration: 50,
            easing: "ease",
            fill: "forwards"
        }),
        rt.animate([{
            width: "34px"
        }], {
            duration: 500,
            easing: "ease",
            fill: "forwards"
        })),
        nt && at && ot && st && (et !== this.activeTab || tt) && (this.localTabWidth = `${Math.round(at.width + ot.width) + 6}px`,
        nt.animate([{
            width: `${at.width + ot.width}px`
        }], {
            duration: tt ? 0 : 500,
            fill: "forwards",
            easing: "ease"
        }),
        st.animate([{
            opacity: 1
        }], {
            duration: tt ? 0 : 125,
            delay: tt ? 0 : 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
}
;
WuiTabs.styles = [resetStyles, elementStyles, styles$H];
__decorate$12([n$a({
    type: Array
})], WuiTabs.prototype, "tabs", void 0);
__decorate$12([n$a()], WuiTabs.prototype, "onTabChange", void 0);
__decorate$12([n$a({
    type: Array
})], WuiTabs.prototype, "buttons", void 0);
__decorate$12([n$a({
    type: Boolean
})], WuiTabs.prototype, "disabled", void 0);
__decorate$12([r$a()], WuiTabs.prototype, "activeTab", void 0);
__decorate$12([r$a()], WuiTabs.prototype, "localTabWidth", void 0);
__decorate$12([r$a()], WuiTabs.prototype, "isDense", void 0);
WuiTabs = __decorate$12([customElement("wui-tabs")], WuiTabs);
const styles$G = i$8`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    background-color: var(--wui-color-fg-100);
    color: var(--wui-color-bg-100);
    position: relative;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$11 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiTooltip = class extends s$5 {
    constructor() {
        super(...arguments),
        this.placement = "top",
        this.message = ""
    }
    render() {
        return x$1`<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name="cursor"
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`
    }
}
;
WuiTooltip.styles = [resetStyles, elementStyles, styles$G];
__decorate$11([n$a()], WuiTooltip.prototype, "placement", void 0);
__decorate$11([n$a()], WuiTooltip.prototype, "message", void 0);
WuiTooltip = __decorate$11([customElement("wui-tooltip")], WuiTooltip);
const styles$F = i$8`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var __decorate$10 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiVisualThumbnail = class extends s$5 {
    render() {
        return this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"};`,
        x$1`${this.templateVisual()}`
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>` : x$1`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`
    }
}
;
WuiVisualThumbnail.styles = [resetStyles, styles$F];
__decorate$10([n$a()], WuiVisualThumbnail.prototype, "imageSrc", void 0);
__decorate$10([n$a()], WuiVisualThumbnail.prototype, "alt", void 0);
__decorate$10([n$a({
    type: Boolean
})], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0);
WuiVisualThumbnail = __decorate$10([customElement("wui-visual-thumbnail")], WuiVisualThumbnail);
const styles$E = i$8`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-accent-glass-015);
  }

  button:hover {
    background-color: var(--wui-accent-glass-010) !important;
  }

  button:active {
    background-color: var(--wui-accent-glass-020) !important;
  }
`;
var __decorate$$ = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiNoticeCard = class extends s$5 {
    constructor() {
        super(...arguments),
        this.label = "",
        this.description = "",
        this.icon = "wallet"
    }
    render() {
        return x$1`
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `
    }
}
;
WuiNoticeCard.styles = [resetStyles, elementStyles, styles$E];
__decorate$$([n$a()], WuiNoticeCard.prototype, "label", void 0);
__decorate$$([n$a()], WuiNoticeCard.prototype, "description", void 0);
__decorate$$([n$a()], WuiNoticeCard.prototype, "icon", void 0);
WuiNoticeCard = __decorate$$([customElement("wui-notice-card")], WuiNoticeCard);
const styles$D = i$8`
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-200), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var __decorate$_ = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const MAX_HEIGHT = 100;
let WuiListAccordion = class extends s$5 {
    constructor() {
        super(...arguments),
        this.textTitle = "",
        this.overflowedContent = "",
        this.toggled = !1,
        this.enableAccordion = !1,
        this.scrollElement = void 0,
        this.scrollHeightElement = 0
    }
    firstUpdated() {
        setTimeout(()=>{
            var tt;
            const et = (tt = this.shadowRoot) == null ? void 0 : tt.querySelector(".heightContent");
            if (et) {
                this.scrollElement = et;
                const rt = et == null ? void 0 : et.scrollHeight;
                rt && rt > MAX_HEIGHT && (this.enableAccordion = !0,
                this.scrollHeightElement = rt,
                this.requestUpdate())
            }
        }
        , 0)
    }
    render() {
        return x$1`
      <button ontouchstart @click=${()=>this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion ? !!this.toggled : !0}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `
    }
    onClick() {
        var tt;
        const et = (tt = this.shadowRoot) == null ? void 0 : tt.querySelector("wui-icon");
        this.enableAccordion && (this.toggled = !this.toggled,
        this.requestUpdate(),
        this.scrollElement && this.scrollElement.animate([{
            maxHeight: this.toggled ? `${MAX_HEIGHT}px` : `${this.scrollHeightElement}px`
        }, {
            maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${MAX_HEIGHT}px`
        }], {
            duration: 300,
            fill: "forwards",
            easing: "ease"
        }),
        et && et.animate([{
            transform: this.toggled ? "rotate(0deg)" : "rotate(180deg)"
        }, {
            transform: this.toggled ? "rotate(180deg)" : "rotate(0deg)"
        }], {
            duration: 300,
            fill: "forwards",
            easing: "ease"
        }))
    }
    chevronTemplate() {
        return this.enableAccordion ? x$1` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>` : null
    }
}
;
WuiListAccordion.styles = [resetStyles, elementStyles, styles$D];
__decorate$_([n$a()], WuiListAccordion.prototype, "textTitle", void 0);
__decorate$_([n$a()], WuiListAccordion.prototype, "overflowedContent", void 0);
WuiListAccordion = __decorate$_([customElement("wui-list-accordion")], WuiListAccordion);
const styles$C = i$8`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$Z = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiListContent = class extends s$5 {
    constructor() {
        super(...arguments),
        this.imageSrc = void 0,
        this.textTitle = "",
        this.textValue = void 0
    }
    render() {
        return x$1`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `
    }
    templateContent() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>` : this.textValue ? x$1` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>` : x$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
    }
}
;
WuiListContent.styles = [resetStyles, elementStyles, styles$C];
__decorate$Z([n$a()], WuiListContent.prototype, "imageSrc", void 0);
__decorate$Z([n$a()], WuiListContent.prototype, "textTitle", void 0);
__decorate$Z([n$a()], WuiListContent.prototype, "textValue", void 0);
WuiListContent = __decorate$Z([customElement("wui-list-content")], WuiListContent);
const styles$B = i$8`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$Y = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiListNetwork = class extends s$5 {
    constructor() {
        super(...arguments),
        this.imageSrc = "",
        this.name = "",
        this.disabled = !1
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateNetworkImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
      </button>
    `
    }
    templateNetworkImage() {
        return this.imageSrc ? x$1`<wui-network-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
      ></wui-network-image>` : this.imageSrc ? null : x$1`<wui-network-image size="sm" name=${this.name}></wui-network-image>`
    }
}
;
WuiListNetwork.styles = [resetStyles, elementStyles, styles$B];
__decorate$Y([n$a()], WuiListNetwork.prototype, "imageSrc", void 0);
__decorate$Y([n$a()], WuiListNetwork.prototype, "name", void 0);
__decorate$Y([n$a({
    type: Boolean
})], WuiListNetwork.prototype, "disabled", void 0);
WuiListNetwork = __decorate$Y([customElement("wui-list-network")], WuiListNetwork);
const styles$A = i$8`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$X = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiListWalletTransaction = class extends s$5 {
    constructor() {
        super(...arguments),
        this.amount = "",
        this.networkCurreny = "",
        this.networkImageUrl = "",
        this.receiverAddress = "",
        this.addressExplorerUrl = ""
    }
    render() {
        return x$1`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.addressExplorerUrl}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `
    }
    templateNetworkVisual() {
        return this.networkImageUrl ? x$1`<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>` : x$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
    }
}
;
WuiListWalletTransaction.styles = [resetStyles, elementStyles, styles$A];
__decorate$X([n$a()], WuiListWalletTransaction.prototype, "amount", void 0);
__decorate$X([n$a()], WuiListWalletTransaction.prototype, "networkCurreny", void 0);
__decorate$X([n$a()], WuiListWalletTransaction.prototype, "networkImageUrl", void 0);
__decorate$X([n$a()], WuiListWalletTransaction.prototype, "receiverAddress", void 0);
__decorate$X([n$a()], WuiListWalletTransaction.prototype, "addressExplorerUrl", void 0);
WuiListWalletTransaction = __decorate$X([customElement("wui-list-wallet-transaction")], WuiListWalletTransaction);
const styles$z = i$8`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    width: 100%;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
  }

  :host > wui-flex:hover {
    background-color: var(--wui-gray-glass-002);
  }

  .purchase-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: var(--wui-icon-box-size-lg);
    height: var(--wui-icon-box-size-lg);
  }

  .purchase-image-container wui-image {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
  }

  .purchase-image-container wui-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  }

  .purchase-image-container wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }
`;
var __decorate$W = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiOnRampActivityItem = class extends s$5 {
    constructor() {
        super(...arguments),
        this.disabled = !1,
        this.color = "inherit",
        this.label = "Bought",
        this.purchaseValue = "",
        this.purchaseCurrency = "",
        this.date = "",
        this.completed = !1,
        this.inProgress = !1,
        this.failed = !1,
        this.onClick = null,
        this.symbol = ""
    }
    firstUpdated() {
        this.icon || this.fetchTokenImage()
    }
    render() {
        return x$1`
      <wui-flex>
        ${this.imageTemplate()}
        <wui-flex flexDirection="column" gap="4xs" flexGrow="1">
          <wui-flex gap="xxs" alignItems="center" justifyContent="flex-start">
            ${this.statusIconTemplate()}
            <wui-text variant="paragraph-500" color="fg-100"> ${this.label}</wui-text>
          </wui-flex>
          <wui-text variant="small-400" color="fg-200">
            + ${this.purchaseValue} ${this.purchaseCurrency}
          </wui-text>
        </wui-flex>
        ${this.inProgress ? x$1`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : x$1`<wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>`}
      </wui-flex>
    `
    }
    async fetchTokenImage() {
        await ApiController._fetchTokenImage(this.purchaseCurrency)
    }
    statusIconTemplate() {
        return this.inProgress ? null : this.completed ? this.boughtIconTemplate() : this.errorIconTemplate()
    }
    errorIconTemplate() {
        return x$1`<wui-icon-box
      size="xxs"
      iconColor="error-100"
      backgroundColor="error-100"
      background="opaque"
      icon="close"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`
    }
    imageTemplate() {
        const et = this.icon || `https://avatar.vercel.sh/andrew.svg?size=50&text=${this.symbol}`;
        return x$1`<wui-flex class="purchase-image-container">
      <wui-image src=${et}></wui-image>
    </wui-flex>`
    }
    boughtIconTemplate() {
        return x$1`<wui-icon-box
      size="xxs"
      iconColor="success-100"
      backgroundColor="success-100"
      background="opaque"
      icon="arrowBottom"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`
    }
}
;
WuiOnRampActivityItem.styles = [resetStyles, elementStyles, styles$z];
__decorate$W([n$a({
    type: Boolean
})], WuiOnRampActivityItem.prototype, "disabled", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "color", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "label", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "purchaseValue", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "purchaseCurrency", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "date", void 0);
__decorate$W([n$a({
    type: Boolean
})], WuiOnRampActivityItem.prototype, "completed", void 0);
__decorate$W([n$a({
    type: Boolean
})], WuiOnRampActivityItem.prototype, "inProgress", void 0);
__decorate$W([n$a({
    type: Boolean
})], WuiOnRampActivityItem.prototype, "failed", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "onClick", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "symbol", void 0);
__decorate$W([n$a()], WuiOnRampActivityItem.prototype, "icon", void 0);
WuiOnRampActivityItem = __decorate$W([customElement("wui-onramp-activity-item")], WuiOnRampActivityItem);
const styles$y = i$8`
  button {
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-gray-glass-002);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
    transition: background-color 0.2s linear;
  }

  button:hover {
    background-color: var(--wui-gray-glass-005);
  }

  .provider-image {
    width: var(--wui-spacing-3xl);
    min-width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    position: relative;
    overflow: hidden;
  }

  .provider-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  }

  .network-icon {
    width: var(--wui-spacing-m);
    height: var(--wui-spacing-m);
    border-radius: calc(var(--wui-spacing-m) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
    transition: box-shadow 0.2s linear;
  }

  button:hover .network-icon {
    box-shadow:
      0 0 0 3px var(--wui-gray-glass-005),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;
var __decorate$V = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiOnRampProviderItem = class extends s$5 {
    constructor() {
        super(...arguments),
        this.disabled = !1,
        this.color = "inherit",
        this.label = "",
        this.feeRange = "",
        this.loading = !1,
        this.onClick = null
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-visual name=${o$9(this.name)} class="provider-image"></wui-visual>
        <wui-flex flexDirection="column" gap="4xs">
          <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
          <wui-flex alignItems="center" justifyContent="flex-start" gap="l">
            <wui-text variant="tiny-500" color="fg-100">
              <wui-text variant="tiny-400" color="fg-200">Fees</wui-text>
              ${this.feeRange}
            </wui-text>
            <wui-flex gap="xxs">
              <wui-icon name="bank" size="xs" color="fg-150"></wui-icon>
              <wui-icon name="card" size="xs" color="fg-150"></wui-icon>
            </wui-flex>
            ${this.networksTemplate()}
          </wui-flex>
        </wui-flex>
        ${this.loading ? x$1`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : x$1`<wui-icon name="chevronRight" color="fg-200" size="sm"></wui-icon>`}
      </button>
    `
    }
    networksTemplate() {
        const et = NetworkController.getRequestedCaipNetworks()
          , tt = et == null ? void 0 : et.slice(0, 5);
        return x$1`
      <wui-flex class="networks">
        ${tt == null ? void 0 : tt.map(rt=>x$1`
            <wui-flex class="network-icon">
              <wui-image src=${o$9(AssetUtil.getNetworkImage(rt))}></wui-image>
            </wui-flex>
          `)}
      </wui-flex>
    `
    }
}
;
WuiOnRampProviderItem.styles = [resetStyles, elementStyles, styles$y];
__decorate$V([n$a({
    type: Boolean
})], WuiOnRampProviderItem.prototype, "disabled", void 0);
__decorate$V([n$a()], WuiOnRampProviderItem.prototype, "color", void 0);
__decorate$V([n$a()], WuiOnRampProviderItem.prototype, "name", void 0);
__decorate$V([n$a()], WuiOnRampProviderItem.prototype, "label", void 0);
__decorate$V([n$a()], WuiOnRampProviderItem.prototype, "feeRange", void 0);
__decorate$V([n$a({
    type: Boolean
})], WuiOnRampProviderItem.prototype, "loading", void 0);
__decorate$V([n$a()], WuiOnRampProviderItem.prototype, "onClick", void 0);
WuiOnRampProviderItem = __decorate$V([customElement("wui-onramp-provider-item")], WuiOnRampProviderItem);
const styles$x = i$8`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$U = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiGrid = class extends s$5 {
    render() {
        return this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `,
        x$1`<slot></slot>`
    }
}
;
WuiGrid.styles = [resetStyles, styles$x];
__decorate$U([n$a()], WuiGrid.prototype, "gridTemplateRows", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "gridTemplateColumns", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "justifyItems", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "alignItems", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "justifyContent", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "alignContent", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "columnGap", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "rowGap", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "gap", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "padding", void 0);
__decorate$U([n$a()], WuiGrid.prototype, "margin", void 0);
WuiGrid = __decorate$U([customElement("wui-grid")], WuiGrid);
const styles$w = i$8`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;
var __decorate$T = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let WuiSeparator = class extends s$5 {
    constructor() {
        super(...arguments),
        this.text = ""
    }
    render() {
        return x$1`${this.template()}`
    }
    template() {
        return this.text ? x$1`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>` : null
    }
}
;
WuiSeparator.styles = [resetStyles, styles$w];
__decorate$T([n$a()], WuiSeparator.prototype, "text", void 0);
WuiSeparator = __decorate$T([customElement("wui-separator")], WuiSeparator);
var dayjs_min = {
    exports: {}
};
(function(_e, et) {
    (function(tt, rt) {
        _e.exports = rt()
    }
    )(commonjsGlobal, function() {
        var tt = 1e3
          , rt = 6e4
          , nt = 36e5
          , it = "millisecond"
          , st = "second"
          , at = "minute"
          , ot = "hour"
          , lt = "day"
          , dt = "week"
          , ct = "month"
          , ut = "quarter"
          , ft = "year"
          , ht = "date"
          , gt = "Invalid Date"
          , bt = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
          , pt = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
          , mt = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(Lt) {
                var Mt = ["th", "st", "nd", "rd"]
                  , $t = Lt % 100;
                return "[" + Lt + (Mt[($t - 20) % 10] || Mt[$t] || Mt[0]) + "]"
            }
        }
          , yt = function(Lt, Mt, $t) {
            var kt = String(Lt);
            return !kt || kt.length >= Mt ? Lt : "" + Array(Mt + 1 - kt.length).join($t) + Lt
        }
          , vt = {
            s: yt,
            z: function(Lt) {
                var Mt = -Lt.utcOffset()
                  , $t = Math.abs(Mt)
                  , kt = Math.floor($t / 60)
                  , At = $t % 60;
                return (Mt <= 0 ? "+" : "-") + yt(kt, 2, "0") + ":" + yt(At, 2, "0")
            },
            m: function Lt(Mt, $t) {
                if (Mt.date() < $t.date())
                    return -Lt($t, Mt);
                var kt = 12 * ($t.year() - Mt.year()) + ($t.month() - Mt.month())
                  , At = Mt.clone().add(kt, ct)
                  , Pt = $t - At < 0
                  , Dt = Mt.clone().add(kt + (Pt ? -1 : 1), ct);
                return +(-(kt + ($t - At) / (Pt ? At - Dt : Dt - At)) || 0)
            },
            a: function(Lt) {
                return Lt < 0 ? Math.ceil(Lt) || 0 : Math.floor(Lt)
            },
            p: function(Lt) {
                return {
                    M: ct,
                    y: ft,
                    w: dt,
                    d: lt,
                    D: ht,
                    h: ot,
                    m: at,
                    s: st,
                    ms: it,
                    Q: ut
                }[Lt] || String(Lt || "").toLowerCase().replace(/s$/, "")
            },
            u: function(Lt) {
                return Lt === void 0
            }
        }
          , wt = "en"
          , _t = {};
        _t[wt] = mt;
        var Et = "$isDayjsObject"
          , xt = function(Lt) {
            return Lt instanceof Nt || !(!Lt || !Lt[Et])
        }
          , Ct = function Lt(Mt, $t, kt) {
            var At;
            if (!Mt)
                return wt;
            if (typeof Mt == "string") {
                var Pt = Mt.toLowerCase();
                _t[Pt] && (At = Pt),
                $t && (_t[Pt] = $t,
                At = Pt);
                var Dt = Mt.split("-");
                if (!At && Dt.length > 1)
                    return Lt(Dt[0])
            } else {
                var Bt = Mt.name;
                _t[Bt] = Mt,
                At = Bt
            }
            return !kt && At && (wt = At),
            At || !kt && wt
        }
          , Tt = function(Lt, Mt) {
            if (xt(Lt))
                return Lt.clone();
            var $t = typeof Mt == "object" ? Mt : {};
            return $t.date = Lt,
            $t.args = arguments,
            new Nt($t)
        }
          , It = vt;
        It.l = Ct,
        It.i = xt,
        It.w = function(Lt, Mt) {
            return Tt(Lt, {
                locale: Mt.$L,
                utc: Mt.$u,
                x: Mt.$x,
                $offset: Mt.$offset
            })
        }
        ;
        var Nt = function() {
            function Lt($t) {
                this.$L = Ct($t.locale, null, !0),
                this.parse($t),
                this.$x = this.$x || $t.x || {},
                this[Et] = !0
            }
            var Mt = Lt.prototype;
            return Mt.parse = function($t) {
                this.$d = function(kt) {
                    var At = kt.date
                      , Pt = kt.utc;
                    if (At === null)
                        return new Date(NaN);
                    if (It.u(At))
                        return new Date;
                    if (At instanceof Date)
                        return new Date(At);
                    if (typeof At == "string" && !/Z$/i.test(At)) {
                        var Dt = At.match(bt);
                        if (Dt) {
                            var Bt = Dt[2] - 1 || 0
                              , zt = (Dt[7] || "0").substring(0, 3);
                            return Pt ? new Date(Date.UTC(Dt[1], Bt, Dt[3] || 1, Dt[4] || 0, Dt[5] || 0, Dt[6] || 0, zt)) : new Date(Dt[1],Bt,Dt[3] || 1,Dt[4] || 0,Dt[5] || 0,Dt[6] || 0,zt)
                        }
                    }
                    return new Date(At)
                }($t),
                this.init()
            }
            ,
            Mt.init = function() {
                var $t = this.$d;
                this.$y = $t.getFullYear(),
                this.$M = $t.getMonth(),
                this.$D = $t.getDate(),
                this.$W = $t.getDay(),
                this.$H = $t.getHours(),
                this.$m = $t.getMinutes(),
                this.$s = $t.getSeconds(),
                this.$ms = $t.getMilliseconds()
            }
            ,
            Mt.$utils = function() {
                return It
            }
            ,
            Mt.isValid = function() {
                return this.$d.toString() !== gt
            }
            ,
            Mt.isSame = function($t, kt) {
                var At = Tt($t);
                return this.startOf(kt) <= At && At <= this.endOf(kt)
            }
            ,
            Mt.isAfter = function($t, kt) {
                return Tt($t) < this.startOf(kt)
            }
            ,
            Mt.isBefore = function($t, kt) {
                return this.endOf(kt) < Tt($t)
            }
            ,
            Mt.$g = function($t, kt, At) {
                return It.u($t) ? this[kt] : this.set(At, $t)
            }
            ,
            Mt.unix = function() {
                return Math.floor(this.valueOf() / 1e3)
            }
            ,
            Mt.valueOf = function() {
                return this.$d.getTime()
            }
            ,
            Mt.startOf = function($t, kt) {
                var At = this
                  , Pt = !!It.u(kt) || kt
                  , Dt = It.p($t)
                  , Bt = function(Sr, br) {
                    var Pr = It.w(At.$u ? Date.UTC(At.$y, br, Sr) : new Date(At.$y,br,Sr), At);
                    return Pt ? Pr : Pr.endOf(lt)
                }
                  , zt = function(Sr, br) {
                    return It.w(At.toDate()[Sr].apply(At.toDate("s"), (Pt ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(br)), At)
                }
                  , Yt = this.$W
                  , rr = this.$M
                  , ar = this.$D
                  , or = "set" + (this.$u ? "UTC" : "");
                switch (Dt) {
                case ft:
                    return Pt ? Bt(1, 0) : Bt(31, 11);
                case ct:
                    return Pt ? Bt(1, rr) : Bt(0, rr + 1);
                case dt:
                    var pr = this.$locale().weekStart || 0
                      , gr = (Yt < pr ? Yt + 7 : Yt) - pr;
                    return Bt(Pt ? ar - gr : ar + (6 - gr), rr);
                case lt:
                case ht:
                    return zt(or + "Hours", 0);
                case ot:
                    return zt(or + "Minutes", 1);
                case at:
                    return zt(or + "Seconds", 2);
                case st:
                    return zt(or + "Milliseconds", 3);
                default:
                    return this.clone()
                }
            }
            ,
            Mt.endOf = function($t) {
                return this.startOf($t, !1)
            }
            ,
            Mt.$set = function($t, kt) {
                var At, Pt = It.p($t), Dt = "set" + (this.$u ? "UTC" : ""), Bt = (At = {},
                At[lt] = Dt + "Date",
                At[ht] = Dt + "Date",
                At[ct] = Dt + "Month",
                At[ft] = Dt + "FullYear",
                At[ot] = Dt + "Hours",
                At[at] = Dt + "Minutes",
                At[st] = Dt + "Seconds",
                At[it] = Dt + "Milliseconds",
                At)[Pt], zt = Pt === lt ? this.$D + (kt - this.$W) : kt;
                if (Pt === ct || Pt === ft) {
                    var Yt = this.clone().set(ht, 1);
                    Yt.$d[Bt](zt),
                    Yt.init(),
                    this.$d = Yt.set(ht, Math.min(this.$D, Yt.daysInMonth())).$d
                } else
                    Bt && this.$d[Bt](zt);
                return this.init(),
                this
            }
            ,
            Mt.set = function($t, kt) {
                return this.clone().$set($t, kt)
            }
            ,
            Mt.get = function($t) {
                return this[It.p($t)]()
            }
            ,
            Mt.add = function($t, kt) {
                var At, Pt = this;
                $t = Number($t);
                var Dt = It.p(kt)
                  , Bt = function(rr) {
                    var ar = Tt(Pt);
                    return It.w(ar.date(ar.date() + Math.round(rr * $t)), Pt)
                };
                if (Dt === ct)
                    return this.set(ct, this.$M + $t);
                if (Dt === ft)
                    return this.set(ft, this.$y + $t);
                if (Dt === lt)
                    return Bt(1);
                if (Dt === dt)
                    return Bt(7);
                var zt = (At = {},
                At[at] = rt,
                At[ot] = nt,
                At[st] = tt,
                At)[Dt] || 1
                  , Yt = this.$d.getTime() + $t * zt;
                return It.w(Yt, this)
            }
            ,
            Mt.subtract = function($t, kt) {
                return this.add(-1 * $t, kt)
            }
            ,
            Mt.format = function($t) {
                var kt = this
                  , At = this.$locale();
                if (!this.isValid())
                    return At.invalidDate || gt;
                var Pt = $t || "YYYY-MM-DDTHH:mm:ssZ"
                  , Dt = It.z(this)
                  , Bt = this.$H
                  , zt = this.$m
                  , Yt = this.$M
                  , rr = At.weekdays
                  , ar = At.months
                  , or = At.meridiem
                  , pr = function(br, Pr, Wr, _r) {
                    return br && (br[Pr] || br(kt, Pt)) || Wr[Pr].slice(0, _r)
                }
                  , gr = function(br) {
                    return It.s(Bt % 12 || 12, br, "0")
                }
                  , Sr = or || function(br, Pr, Wr) {
                    var _r = br < 12 ? "AM" : "PM";
                    return Wr ? _r.toLowerCase() : _r
                }
                ;
                return Pt.replace(pt, function(br, Pr) {
                    return Pr || function(Wr) {
                        switch (Wr) {
                        case "YY":
                            return String(kt.$y).slice(-2);
                        case "YYYY":
                            return It.s(kt.$y, 4, "0");
                        case "M":
                            return Yt + 1;
                        case "MM":
                            return It.s(Yt + 1, 2, "0");
                        case "MMM":
                            return pr(At.monthsShort, Yt, ar, 3);
                        case "MMMM":
                            return pr(ar, Yt);
                        case "D":
                            return kt.$D;
                        case "DD":
                            return It.s(kt.$D, 2, "0");
                        case "d":
                            return String(kt.$W);
                        case "dd":
                            return pr(At.weekdaysMin, kt.$W, rr, 2);
                        case "ddd":
                            return pr(At.weekdaysShort, kt.$W, rr, 3);
                        case "dddd":
                            return rr[kt.$W];
                        case "H":
                            return String(Bt);
                        case "HH":
                            return It.s(Bt, 2, "0");
                        case "h":
                            return gr(1);
                        case "hh":
                            return gr(2);
                        case "a":
                            return Sr(Bt, zt, !0);
                        case "A":
                            return Sr(Bt, zt, !1);
                        case "m":
                            return String(zt);
                        case "mm":
                            return It.s(zt, 2, "0");
                        case "s":
                            return String(kt.$s);
                        case "ss":
                            return It.s(kt.$s, 2, "0");
                        case "SSS":
                            return It.s(kt.$ms, 3, "0");
                        case "Z":
                            return Dt
                        }
                        return null
                    }(br) || Dt.replace(":", "")
                })
            }
            ,
            Mt.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
            }
            ,
            Mt.diff = function($t, kt, At) {
                var Pt, Dt = this, Bt = It.p(kt), zt = Tt($t), Yt = (zt.utcOffset() - this.utcOffset()) * rt, rr = this - zt, ar = function() {
                    return It.m(Dt, zt)
                };
                switch (Bt) {
                case ft:
                    Pt = ar() / 12;
                    break;
                case ct:
                    Pt = ar();
                    break;
                case ut:
                    Pt = ar() / 3;
                    break;
                case dt:
                    Pt = (rr - Yt) / 6048e5;
                    break;
                case lt:
                    Pt = (rr - Yt) / 864e5;
                    break;
                case ot:
                    Pt = rr / nt;
                    break;
                case at:
                    Pt = rr / rt;
                    break;
                case st:
                    Pt = rr / tt;
                    break;
                default:
                    Pt = rr
                }
                return At ? Pt : It.a(Pt)
            }
            ,
            Mt.daysInMonth = function() {
                return this.endOf(ct).$D
            }
            ,
            Mt.$locale = function() {
                return _t[this.$L]
            }
            ,
            Mt.locale = function($t, kt) {
                if (!$t)
                    return this.$L;
                var At = this.clone()
                  , Pt = Ct($t, kt, !0);
                return Pt && (At.$L = Pt),
                At
            }
            ,
            Mt.clone = function() {
                return It.w(this.$d, this)
            }
            ,
            Mt.toDate = function() {
                return new Date(this.valueOf())
            }
            ,
            Mt.toJSON = function() {
                return this.isValid() ? this.toISOString() : null
            }
            ,
            Mt.toISOString = function() {
                return this.$d.toISOString()
            }
            ,
            Mt.toString = function() {
                return this.$d.toUTCString()
            }
            ,
            Lt
        }()
          , Ft = Nt.prototype;
        return Tt.prototype = Ft,
        [["$ms", it], ["$s", st], ["$m", at], ["$H", ot], ["$W", lt], ["$M", ct], ["$y", ft], ["$D", ht]].forEach(function(Lt) {
            Ft[Lt[1]] = function(Mt) {
                return this.$g(Mt, Lt[0], Lt[1])
            }
        }),
        Tt.extend = function(Lt, Mt) {
            return Lt.$i || (Lt(Mt, Nt, Tt),
            Lt.$i = !0),
            Tt
        }
        ,
        Tt.locale = Ct,
        Tt.isDayjs = xt,
        Tt.unix = function(Lt) {
            return Tt(1e3 * Lt)
        }
        ,
        Tt.en = _t[wt],
        Tt.Ls = _t,
        Tt.p = {},
        Tt
    })
}
)(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = getDefaultExportFromCjs(dayjs_minExports);
var updateLocale$1 = {
    exports: {}
};
(function(_e, et) {
    (function(tt, rt) {
        _e.exports = rt()
    }
    )(commonjsGlobal, function() {
        return function(tt, rt, nt) {
            nt.updateLocale = function(it, st) {
                var at = nt.Ls[it];
                if (at)
                    return (st ? Object.keys(st) : []).forEach(function(ot) {
                        at[ot] = st[ot]
                    }),
                    at
            }
        }
    })
}
)(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = getDefaultExportFromCjs(updateLocaleExports);
var relativeTime$1 = {
    exports: {}
};
(function(_e, et) {
    (function(tt, rt) {
        _e.exports = rt()
    }
    )(commonjsGlobal, function() {
        return function(tt, rt, nt) {
            tt = tt || {};
            var it = rt.prototype
              , st = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            };
            function at(lt, dt, ct, ut) {
                return it.fromToBase(lt, dt, ct, ut)
            }
            nt.en.relativeTime = st,
            it.fromToBase = function(lt, dt, ct, ut, ft) {
                for (var ht, gt, bt, pt = ct.$locale().relativeTime || st, mt = tt.thresholds || [{
                    l: "s",
                    r: 44,
                    d: "second"
                }, {
                    l: "m",
                    r: 89
                }, {
                    l: "mm",
                    r: 44,
                    d: "minute"
                }, {
                    l: "h",
                    r: 89
                }, {
                    l: "hh",
                    r: 21,
                    d: "hour"
                }, {
                    l: "d",
                    r: 35
                }, {
                    l: "dd",
                    r: 25,
                    d: "day"
                }, {
                    l: "M",
                    r: 45
                }, {
                    l: "MM",
                    r: 10,
                    d: "month"
                }, {
                    l: "y",
                    r: 17
                }, {
                    l: "yy",
                    d: "year"
                }], yt = mt.length, vt = 0; vt < yt; vt += 1) {
                    var wt = mt[vt];
                    wt.d && (ht = ut ? nt(lt).diff(ct, wt.d, !0) : ct.diff(lt, wt.d, !0));
                    var _t = (tt.rounding || Math.round)(Math.abs(ht));
                    if (bt = ht > 0,
                    _t <= wt.r || !wt.r) {
                        _t <= 1 && vt > 0 && (wt = mt[vt - 1]);
                        var Et = pt[wt.l];
                        ft && (_t = ft("" + _t)),
                        gt = typeof Et == "string" ? Et.replace("%d", _t) : Et(_t, dt, wt.l, bt);
                        break
                    }
                }
                if (dt)
                    return gt;
                var xt = bt ? pt.future : pt.past;
                return typeof xt == "function" ? xt(gt) : xt.replace("%s", gt)
            }
            ,
            it.to = function(lt, dt) {
                return at(lt, dt, this, !0)
            }
            ,
            it.from = function(lt, dt) {
                return at(lt, dt, this)
            }
            ;
            var ot = function(lt) {
                return lt.$u ? nt.utc() : nt()
            };
            it.toNow = function(lt) {
                return this.to(ot(this), lt)
            }
            ,
            it.fromNow = function(lt) {
                return this.from(ot(this), lt)
            }
        }
    })
}
)(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = getDefaultExportFromCjs(relativeTimeExports);
dayjs.extend(relativeTime);
dayjs.extend(updateLocale);
dayjs.updateLocale("en", {
    relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "%s sec",
        m: "1 min",
        mm: "%d min",
        h: "1 hr",
        hh: "%d hrs",
        d: "1 d",
        dd: "%d d",
        M: "1 mo",
        MM: "%d mo",
        y: "1 yr",
        yy: "%d yr"
    }
});
const DateUtil = {
    getYear(_e=new Date().toISOString()) {
        return dayjs(_e).year()
    },
    getRelativeDateFromNow(_e) {
        return dayjs(_e).fromNow(!0)
    },
    formatDate(_e, et="DD MMM") {
        return dayjs(_e).format(et)
    }
}
  , FLOAT_FIXED_VALUE = 3
  , plusTypes = ["receive", "deposit", "borrow", "claim"]
  , minusTypes = ["withdraw", "repay", "burn"]
  , TransactionUtil = {
    getMonthName(_e) {
        const et = new Date;
        return et.setMonth(_e),
        et.toLocaleString("en-US", {
            month: "long"
        })
    },
    getTransactionGroupTitle(_e, et) {
        const tt = DateUtil.getYear()
          , rt = this.getMonthName(et);
        return _e === tt ? rt : `${rt} ${_e}`
    },
    getTransactionImages(_e) {
        const [et,tt] = _e
          , rt = !!et && (_e == null ? void 0 : _e.every(st=>!!st.nft_info))
          , nt = (_e == null ? void 0 : _e.length) > 1;
        return (_e == null ? void 0 : _e.length) === 2 && !rt ? [this.getTransactionImage(et), this.getTransactionImage(tt)] : nt ? _e.map(st=>this.getTransactionImage(st)) : [this.getTransactionImage(et)]
    },
    getTransactionImage(_e) {
        return {
            type: TransactionUtil.getTransactionTransferTokenType(_e),
            url: TransactionUtil.getTransactionImageURL(_e)
        }
    },
    getTransactionImageURL(_e) {
        var nt, it, st, at, ot;
        let et;
        const tt = !!(_e != null && _e.nft_info)
          , rt = !!(_e != null && _e.fungible_info);
        return _e && tt ? et = (st = (it = (nt = _e == null ? void 0 : _e.nft_info) == null ? void 0 : nt.content) == null ? void 0 : it.preview) == null ? void 0 : st.url : _e && rt && (et = (ot = (at = _e == null ? void 0 : _e.fungible_info) == null ? void 0 : at.icon) == null ? void 0 : ot.url),
        et
    },
    getTransactionTransferTokenType(_e) {
        if (_e != null && _e.fungible_info)
            return "FUNGIBLE";
        if (_e != null && _e.nft_info)
            return "NFT"
    },
    getTransactionDescriptions(_e) {
        var ct, ut, ft;
        const et = (ct = _e == null ? void 0 : _e.metadata) == null ? void 0 : ct.operationType
          , tt = _e == null ? void 0 : _e.transfers
          , rt = ((ut = _e == null ? void 0 : _e.transfers) == null ? void 0 : ut.length) > 0
          , nt = ((ft = _e == null ? void 0 : _e.transfers) == null ? void 0 : ft.length) > 1
          , it = rt && (tt == null ? void 0 : tt.every(ht=>!!(ht != null && ht.fungible_info)))
          , [st,at] = tt;
        let ot = this.getTransferDescription(st)
          , lt = this.getTransferDescription(at);
        if (!rt)
            return (et === "send" || et === "receive") && it ? (ot = UiHelperUtil.getTruncateString({
                string: _e == null ? void 0 : _e.metadata.sentFrom,
                charsStart: 4,
                charsEnd: 6,
                truncate: "middle"
            }),
            lt = UiHelperUtil.getTruncateString({
                string: _e == null ? void 0 : _e.metadata.sentTo,
                charsStart: 4,
                charsEnd: 6,
                truncate: "middle"
            }),
            [ot, lt]) : [_e.metadata.status];
        if (nt)
            return tt.map(ht=>this.getTransferDescription(ht));
        let dt = "";
        return plusTypes.includes(et) ? dt = "+" : minusTypes.includes(et) && (dt = "-"),
        ot = dt.concat(ot),
        [ot]
    },
    getTransferDescription(_e) {
        var tt;
        let et = "";
        return _e && (_e != null && _e.nft_info ? et = ((tt = _e == null ? void 0 : _e.nft_info) == null ? void 0 : tt.name) || "-" : _e != null && _e.fungible_info && (et = this.getFungibleTransferDescription(_e) || "-")),
        et
    },
    getFungibleTransferDescription(_e) {
        var rt;
        return _e ? [this.getQuantityFixedValue(_e == null ? void 0 : _e.quantity.numeric), (rt = _e == null ? void 0 : _e.fungible_info) == null ? void 0 : rt.symbol].join(" ").trim() : null
    },
    getQuantityFixedValue(_e) {
        return _e ? parseFloat(_e).toFixed(FLOAT_FIXED_VALUE) : null
    }
}
  , index$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    TransactionUtil,
    UiHelperUtil,
    get WuiAccountButton() {
        return WuiAccountButton
    },
    get WuiAllWalletsImage() {
        return WuiAllWalletsImage
    },
    get WuiAvatar() {
        return WuiAvatar
    },
    get WuiButton() {
        return WuiButton
    },
    get WuiCard() {
        return WuiCard
    },
    get WuiCardSelect() {
        return WuiCardSelect
    },
    get WuiCardSelectLoader() {
        return WuiCardSelectLoader
    },
    get WuiChip() {
        return WuiChip
    },
    get WuiConnectButton() {
        return WuiConnectButton
    },
    get WuiCtaButton() {
        return WuiCtaButton
    },
    get WuiEmailInput() {
        return WuiEmailInput
    },
    get WuiFlex() {
        return WuiFlex
    },
    get WuiGrid() {
        return WuiGrid
    },
    get WuiIcon() {
        return WuiIcon
    },
    get WuiIconBox() {
        return WuiIconBox
    },
    get WuiIconLink() {
        return WuiIconLink
    },
    get WuiImage() {
        return WuiImage
    },
    get WuiInputElement() {
        return WuiInputElement
    },
    get WuiInputNumeric() {
        return WuiInputNumeric
    },
    get WuiInputText() {
        return WuiInputText
    },
    get WuiLink() {
        return WuiLink
    },
    get WuiListAccordion() {
        return WuiListAccordion
    },
    get WuiListContent() {
        return WuiListContent
    },
    get WuiListItem() {
        return WuiListItem
    },
    get WuiListNetwork() {
        return WuiListNetwork
    },
    get WuiListWallet() {
        return WuiListWallet
    },
    get WuiListWalletTransaction() {
        return WuiListWalletTransaction
    },
    get WuiLoadingHexagon() {
        return WuiLoadingHexagon
    },
    get WuiLoadingSpinner() {
        return WuiLoadingSpinner
    },
    get WuiLoadingThumbnail() {
        return WuiLoadingThumbnail
    },
    get WuiLogo() {
        return WuiLogo
    },
    get WuiLogoSelect() {
        return WuiLogoSelect
    },
    get WuiNetworkButton() {
        return WuiNetworkButton
    },
    get WuiNetworkImage() {
        return WuiNetworkImage
    },
    get WuiNoticeCard() {
        return WuiNoticeCard
    },
    get WuiOnRampActivityItem() {
        return WuiOnRampActivityItem
    },
    get WuiOnRampProviderItem() {
        return WuiOnRampProviderItem
    },
    get WuiOtp() {
        return WuiOtp
    },
    get WuiQrCode() {
        return WuiQrCode
    },
    get WuiSearchBar() {
        return WuiSearchBar
    },
    get WuiSeparator() {
        return WuiSeparator
    },
    get WuiShimmer() {
        return WuiShimmer
    },
    get WuiSnackbar() {
        return WuiSnackbar
    },
    get WuiTabs() {
        return WuiTabs
    },
    get WuiTag() {
        return WuiTag
    },
    get WuiText() {
        return WuiText
    },
    get WuiTooltip() {
        return WuiTooltip
    },
    get WuiTransactionListItem() {
        return WuiTransactionListItem
    },
    get WuiTransactionListItemLoader() {
        return WuiTransactionListItemLoader
    },
    get WuiTransactionVisual() {
        return WuiTransactionVisual
    },
    get WuiVisual() {
        return WuiVisual
    },
    get WuiVisualThumbnail() {
        return WuiVisualThumbnail
    },
    get WuiWalletImage() {
        return WuiWalletImage
    },
    customElement,
    initializeTheming,
    setColorTheme,
    setThemeVariables
}, Symbol.toStringTag, {
    value: "Module"
}));
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$4 = globalThis
  , e$4 = t$4.ShadowRoot && (t$4.ShadyCSS === void 0 || t$4.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
  , s$3 = Symbol()
  , o$6 = new WeakMap;
let n$7 = class {
    constructor(et, tt, rt) {
        if (this._$cssResult$ = !0,
        rt !== s$3)
            throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = et,
        this.t = tt
    }
    get styleSheet() {
        let et = this.o;
        const tt = this.t;
        if (e$4 && et === void 0) {
            const rt = tt !== void 0 && tt.length === 1;
            rt && (et = o$6.get(tt)),
            et === void 0 && ((this.o = et = new CSSStyleSheet).replaceSync(this.cssText),
            rt && o$6.set(tt, et))
        }
        return et
    }
    toString() {
        return this.cssText
    }
}
;
const r$8 = _e=>new n$7(typeof _e == "string" ? _e : _e + "",void 0,s$3)
  , i$4 = (_e,...et)=>{
    const tt = _e.length === 1 ? _e[0] : et.reduce((rt,nt,it)=>rt + (st=>{
        if (st._$cssResult$ === !0)
            return st.cssText;
        if (typeof st == "number")
            return st;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + st + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
    }
    )(nt) + _e[it + 1], _e[0]);
    return new n$7(tt,_e,s$3)
}
  , S$1 = (_e,et)=>{
    if (e$4)
        _e.adoptedStyleSheets = et.map(tt=>tt instanceof CSSStyleSheet ? tt : tt.styleSheet);
    else
        for (const tt of et) {
            const rt = document.createElement("style")
              , nt = t$4.litNonce;
            nt !== void 0 && rt.setAttribute("nonce", nt),
            rt.textContent = tt.cssText,
            _e.appendChild(rt)
        }
}
  , c$3 = e$4 ? _e=>_e : _e=>_e instanceof CSSStyleSheet ? (et=>{
    let tt = "";
    for (const rt of et.cssRules)
        tt += rt.cssText;
    return r$8(tt)
}
)(_e) : _e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const {is: i$3, defineProperty: e$3, getOwnPropertyDescriptor: r$7, getOwnPropertyNames: h$5, getOwnPropertySymbols: o$5, getPrototypeOf: n$6} = Object
  , a$1 = globalThis
  , c$2 = a$1.trustedTypes
  , l$1 = c$2 ? c$2.emptyScript : ""
  , p$3 = a$1.reactiveElementPolyfillSupport
  , d$1 = (_e,et)=>_e
  , u$3 = {
    toAttribute(_e, et) {
        switch (et) {
        case Boolean:
            _e = _e ? l$1 : null;
            break;
        case Object:
        case Array:
            _e = _e == null ? _e : JSON.stringify(_e)
        }
        return _e
    },
    fromAttribute(_e, et) {
        let tt = _e;
        switch (et) {
        case Boolean:
            tt = _e !== null;
            break;
        case Number:
            tt = _e === null ? null : Number(_e);
            break;
        case Object:
        case Array:
            try {
                tt = JSON.parse(_e)
            } catch {
                tt = null
            }
        }
        return tt
    }
}
  , f$3 = (_e,et)=>!i$3(_e, et)
  , y$1 = {
    attribute: !0,
    type: String,
    converter: u$3,
    reflect: !1,
    hasChanged: f$3
};
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")),
a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = new WeakMap);
class b extends HTMLElement {
    static addInitializer(et) {
        this._$Ei(),
        (this.l ?? (this.l = [])).push(et)
    }
    static get observedAttributes() {
        return this.finalize(),
        this._$Eh && [...this._$Eh.keys()]
    }
    static createProperty(et, tt=y$1) {
        if (tt.state && (tt.attribute = !1),
        this._$Ei(),
        this.elementProperties.set(et, tt),
        !tt.noAccessor) {
            const rt = Symbol()
              , nt = this.getPropertyDescriptor(et, rt, tt);
            nt !== void 0 && e$3(this.prototype, et, nt)
        }
    }
    static getPropertyDescriptor(et, tt, rt) {
        const {get: nt, set: it} = r$7(this.prototype, et) ?? {
            get() {
                return this[tt]
            },
            set(st) {
                this[tt] = st
            }
        };
        return {
            get() {
                return nt == null ? void 0 : nt.call(this)
            },
            set(st) {
                const at = nt == null ? void 0 : nt.call(this);
                it.call(this, st),
                this.requestUpdate(et, at, rt)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(et) {
        return this.elementProperties.get(et) ?? y$1
    }
    static _$Ei() {
        if (this.hasOwnProperty(d$1("elementProperties")))
            return;
        const et = n$6(this);
        et.finalize(),
        et.l !== void 0 && (this.l = [...et.l]),
        this.elementProperties = new Map(et.elementProperties)
    }
    static finalize() {
        if (this.hasOwnProperty(d$1("finalized")))
            return;
        if (this.finalized = !0,
        this._$Ei(),
        this.hasOwnProperty(d$1("properties"))) {
            const tt = this.properties
              , rt = [...h$5(tt), ...o$5(tt)];
            for (const nt of rt)
                this.createProperty(nt, tt[nt])
        }
        const et = this[Symbol.metadata];
        if (et !== null) {
            const tt = litPropertyMetadata.get(et);
            if (tt !== void 0)
                for (const [rt,nt] of tt)
                    this.elementProperties.set(rt, nt)
        }
        this._$Eh = new Map;
        for (const [tt,rt] of this.elementProperties) {
            const nt = this._$Eu(tt, rt);
            nt !== void 0 && this._$Eh.set(nt, tt)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
    }
    static finalizeStyles(et) {
        const tt = [];
        if (Array.isArray(et)) {
            const rt = new Set(et.flat(1 / 0).reverse());
            for (const nt of rt)
                tt.unshift(c$3(nt))
        } else
            et !== void 0 && tt.push(c$3(et));
        return tt
    }
    static _$Eu(et, tt) {
        const rt = tt.attribute;
        return rt === !1 ? void 0 : typeof rt == "string" ? rt : typeof et == "string" ? et.toLowerCase() : void 0
    }
    constructor() {
        super(),
        this._$Ep = void 0,
        this.isUpdatePending = !1,
        this.hasUpdated = !1,
        this._$Em = null,
        this._$Ev()
    }
    _$Ev() {
        var et;
        this._$ES = new Promise(tt=>this.enableUpdating = tt),
        this._$AL = new Map,
        this._$E_(),
        this.requestUpdate(),
        (et = this.constructor.l) == null || et.forEach(tt=>tt(this))
    }
    addController(et) {
        var tt;
        (this._$EO ?? (this._$EO = new Set)).add(et),
        this.renderRoot !== void 0 && this.isConnected && ((tt = et.hostConnected) == null || tt.call(et))
    }
    removeController(et) {
        var tt;
        (tt = this._$EO) == null || tt.delete(et)
    }
    _$E_() {
        const et = new Map
          , tt = this.constructor.elementProperties;
        for (const rt of tt.keys())
            this.hasOwnProperty(rt) && (et.set(rt, this[rt]),
            delete this[rt]);
        et.size > 0 && (this._$Ep = et)
    }
    createRenderRoot() {
        const et = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S$1(et, this.constructor.elementStyles),
        et
    }
    connectedCallback() {
        var et;
        this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
        this.enableUpdating(!0),
        (et = this._$EO) == null || et.forEach(tt=>{
            var rt;
            return (rt = tt.hostConnected) == null ? void 0 : rt.call(tt)
        }
        )
    }
    enableUpdating(et) {}
    disconnectedCallback() {
        var et;
        (et = this._$EO) == null || et.forEach(tt=>{
            var rt;
            return (rt = tt.hostDisconnected) == null ? void 0 : rt.call(tt)
        }
        )
    }
    attributeChangedCallback(et, tt, rt) {
        this._$AK(et, rt)
    }
    _$EC(et, tt) {
        var it;
        const rt = this.constructor.elementProperties.get(et)
          , nt = this.constructor._$Eu(et, rt);
        if (nt !== void 0 && rt.reflect === !0) {
            const st = (((it = rt.converter) == null ? void 0 : it.toAttribute) !== void 0 ? rt.converter : u$3).toAttribute(tt, rt.type);
            this._$Em = et,
            st == null ? this.removeAttribute(nt) : this.setAttribute(nt, st),
            this._$Em = null
        }
    }
    _$AK(et, tt) {
        var it;
        const rt = this.constructor
          , nt = rt._$Eh.get(et);
        if (nt !== void 0 && this._$Em !== nt) {
            const st = rt.getPropertyOptions(nt)
              , at = typeof st.converter == "function" ? {
                fromAttribute: st.converter
            } : ((it = st.converter) == null ? void 0 : it.fromAttribute) !== void 0 ? st.converter : u$3;
            this._$Em = nt,
            this[nt] = at.fromAttribute(tt, st.type),
            this._$Em = null
        }
    }
    requestUpdate(et, tt, rt) {
        if (et !== void 0) {
            if (rt ?? (rt = this.constructor.getPropertyOptions(et)),
            !(rt.hasChanged ?? f$3)(this[et], tt))
                return;
            this.P(et, tt, rt)
        }
        this.isUpdatePending === !1 && (this._$ES = this._$ET())
    }
    P(et, tt, rt) {
        this._$AL.has(et) || this._$AL.set(et, tt),
        rt.reflect === !0 && this._$Em !== et && (this._$Ej ?? (this._$Ej = new Set)).add(et)
    }
    async _$ET() {
        this.isUpdatePending = !0;
        try {
            await this._$ES
        } catch (tt) {
            Promise.reject(tt)
        }
        const et = this.scheduleUpdate();
        return et != null && await et,
        !this.isUpdatePending
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        var rt;
        if (!this.isUpdatePending)
            return;
        if (!this.hasUpdated) {
            if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
            this._$Ep) {
                for (const [it,st] of this._$Ep)
                    this[it] = st;
                this._$Ep = void 0
            }
            const nt = this.constructor.elementProperties;
            if (nt.size > 0)
                for (const [it,st] of nt)
                    st.wrapped !== !0 || this._$AL.has(it) || this[it] === void 0 || this.P(it, this[it], st)
        }
        let et = !1;
        const tt = this._$AL;
        try {
            et = this.shouldUpdate(tt),
            et ? (this.willUpdate(tt),
            (rt = this._$EO) == null || rt.forEach(nt=>{
                var it;
                return (it = nt.hostUpdate) == null ? void 0 : it.call(nt)
            }
            ),
            this.update(tt)) : this._$EU()
        } catch (nt) {
            throw et = !1,
            this._$EU(),
            nt
        }
        et && this._$AE(tt)
    }
    willUpdate(et) {}
    _$AE(et) {
        var tt;
        (tt = this._$EO) == null || tt.forEach(rt=>{
            var nt;
            return (nt = rt.hostUpdated) == null ? void 0 : nt.call(rt)
        }
        ),
        this.hasUpdated || (this.hasUpdated = !0,
        this.firstUpdated(et)),
        this.updated(et)
    }
    _$EU() {
        this._$AL = new Map,
        this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$ES
    }
    shouldUpdate(et) {
        return !0
    }
    update(et) {
        this._$Ej && (this._$Ej = this._$Ej.forEach(tt=>this._$EC(tt, this[tt]))),
        this._$EU()
    }
    updated(et) {}
    firstUpdated(et) {}
}
b.elementStyles = [],
b.shadowRootOptions = {
    mode: "open"
},
b[d$1("elementProperties")] = new Map,
b[d$1("finalized")] = new Map,
p$3 == null || p$3({
    ReactiveElement: b
}),
(a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3 = globalThis
  , i$2 = t$3.trustedTypes
  , s$2 = i$2 ? i$2.createPolicy("lit-html", {
    createHTML: _e=>_e
}) : void 0
  , e$2 = "$lit$"
  , h$4 = `lit$${(Math.random() + "").slice(9)}$`
  , o$4 = "?" + h$4
  , n$5 = `<${o$4}>`
  , r$6 = document
  , l = ()=>r$6.createComment("")
  , c$1 = _e=>_e === null || typeof _e != "object" && typeof _e != "function"
  , a = Array.isArray
  , u$2 = _e=>a(_e) || typeof (_e == null ? void 0 : _e[Symbol.iterator]) == "function"
  , d = `[ 	
\f\r]`
  , f$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
  , v$3 = /-->/g
  , _ = />/g
  , m = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g")
  , p$2 = /'/g
  , g$1 = /"/g
  , $ = /^(?:script|style|textarea|title)$/i
  , y = _e=>(et,...tt)=>({
    _$litType$: _e,
    strings: et,
    values: tt
})
  , x = y(1)
  , w$2 = Symbol.for("lit-noChange")
  , T = Symbol.for("lit-nothing")
  , A = new WeakMap
  , E = r$6.createTreeWalker(r$6, 129);
function C(_e, et) {
    if (!Array.isArray(_e) || !_e.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
    return s$2 !== void 0 ? s$2.createHTML(et) : et
}
const P = (_e,et)=>{
    const tt = _e.length - 1
      , rt = [];
    let nt, it = et === 2 ? "<svg>" : "", st = f$2;
    for (let at = 0; at < tt; at++) {
        const ot = _e[at];
        let lt, dt, ct = -1, ut = 0;
        for (; ut < ot.length && (st.lastIndex = ut,
        dt = st.exec(ot),
        dt !== null); )
            ut = st.lastIndex,
            st === f$2 ? dt[1] === "!--" ? st = v$3 : dt[1] !== void 0 ? st = _ : dt[2] !== void 0 ? ($.test(dt[2]) && (nt = RegExp("</" + dt[2], "g")),
            st = m) : dt[3] !== void 0 && (st = m) : st === m ? dt[0] === ">" ? (st = nt ?? f$2,
            ct = -1) : dt[1] === void 0 ? ct = -2 : (ct = st.lastIndex - dt[2].length,
            lt = dt[1],
            st = dt[3] === void 0 ? m : dt[3] === '"' ? g$1 : p$2) : st === g$1 || st === p$2 ? st = m : st === v$3 || st === _ ? st = f$2 : (st = m,
            nt = void 0);
        const ft = st === m && _e[at + 1].startsWith("/>") ? " " : "";
        it += st === f$2 ? ot + n$5 : ct >= 0 ? (rt.push(lt),
        ot.slice(0, ct) + e$2 + ot.slice(ct) + h$4 + ft) : ot + h$4 + (ct === -2 ? at : ft)
    }
    return [C(_e, it + (_e[tt] || "<?>") + (et === 2 ? "</svg>" : "")), rt]
}
;
class V {
    constructor({strings: et, _$litType$: tt}, rt) {
        let nt;
        this.parts = [];
        let it = 0
          , st = 0;
        const at = et.length - 1
          , ot = this.parts
          , [lt,dt] = P(et, tt);
        if (this.el = V.createElement(lt, rt),
        E.currentNode = this.el.content,
        tt === 2) {
            const ct = this.el.content.firstChild;
            ct.replaceWith(...ct.childNodes)
        }
        for (; (nt = E.nextNode()) !== null && ot.length < at; ) {
            if (nt.nodeType === 1) {
                if (nt.hasAttributes())
                    for (const ct of nt.getAttributeNames())
                        if (ct.endsWith(e$2)) {
                            const ut = dt[st++]
                              , ft = nt.getAttribute(ct).split(h$4)
                              , ht = /([.?@])?(.*)/.exec(ut);
                            ot.push({
                                type: 1,
                                index: it,
                                name: ht[2],
                                strings: ft,
                                ctor: ht[1] === "." ? k : ht[1] === "?" ? H : ht[1] === "@" ? I : R
                            }),
                            nt.removeAttribute(ct)
                        } else
                            ct.startsWith(h$4) && (ot.push({
                                type: 6,
                                index: it
                            }),
                            nt.removeAttribute(ct));
                if ($.test(nt.tagName)) {
                    const ct = nt.textContent.split(h$4)
                      , ut = ct.length - 1;
                    if (ut > 0) {
                        nt.textContent = i$2 ? i$2.emptyScript : "";
                        for (let ft = 0; ft < ut; ft++)
                            nt.append(ct[ft], l()),
                            E.nextNode(),
                            ot.push({
                                type: 2,
                                index: ++it
                            });
                        nt.append(ct[ut], l())
                    }
                }
            } else if (nt.nodeType === 8)
                if (nt.data === o$4)
                    ot.push({
                        type: 2,
                        index: it
                    });
                else {
                    let ct = -1;
                    for (; (ct = nt.data.indexOf(h$4, ct + 1)) !== -1; )
                        ot.push({
                            type: 7,
                            index: it
                        }),
                        ct += h$4.length - 1
                }
            it++
        }
    }
    static createElement(et, tt) {
        const rt = r$6.createElement("template");
        return rt.innerHTML = et,
        rt
    }
}
function N(_e, et, tt=_e, rt) {
    var st, at;
    if (et === w$2)
        return et;
    let nt = rt !== void 0 ? (st = tt._$Co) == null ? void 0 : st[rt] : tt._$Cl;
    const it = c$1(et) ? void 0 : et._$litDirective$;
    return (nt == null ? void 0 : nt.constructor) !== it && ((at = nt == null ? void 0 : nt._$AO) == null || at.call(nt, !1),
    it === void 0 ? nt = void 0 : (nt = new it(_e),
    nt._$AT(_e, tt, rt)),
    rt !== void 0 ? (tt._$Co ?? (tt._$Co = []))[rt] = nt : tt._$Cl = nt),
    nt !== void 0 && (et = N(_e, nt._$AS(_e, et.values), nt, rt)),
    et
}
class S {
    constructor(et, tt) {
        this._$AV = [],
        this._$AN = void 0,
        this._$AD = et,
        this._$AM = tt
    }
    get parentNode() {
        return this._$AM.parentNode
    }
    get _$AU() {
        return this._$AM._$AU
    }
    u(et) {
        const {el: {content: tt}, parts: rt} = this._$AD
          , nt = ((et == null ? void 0 : et.creationScope) ?? r$6).importNode(tt, !0);
        E.currentNode = nt;
        let it = E.nextNode()
          , st = 0
          , at = 0
          , ot = rt[0];
        for (; ot !== void 0; ) {
            if (st === ot.index) {
                let lt;
                ot.type === 2 ? lt = new M(it,it.nextSibling,this,et) : ot.type === 1 ? lt = new ot.ctor(it,ot.name,ot.strings,this,et) : ot.type === 6 && (lt = new L(it,this,et)),
                this._$AV.push(lt),
                ot = rt[++at]
            }
            st !== (ot == null ? void 0 : ot.index) && (it = E.nextNode(),
            st++)
        }
        return E.currentNode = r$6,
        nt
    }
    p(et) {
        let tt = 0;
        for (const rt of this._$AV)
            rt !== void 0 && (rt.strings !== void 0 ? (rt._$AI(et, rt, tt),
            tt += rt.strings.length - 2) : rt._$AI(et[tt])),
            tt++
    }
}
class M {
    get _$AU() {
        var et;
        return ((et = this._$AM) == null ? void 0 : et._$AU) ?? this._$Cv
    }
    constructor(et, tt, rt, nt) {
        this.type = 2,
        this._$AH = T,
        this._$AN = void 0,
        this._$AA = et,
        this._$AB = tt,
        this._$AM = rt,
        this.options = nt,
        this._$Cv = (nt == null ? void 0 : nt.isConnected) ?? !0
    }
    get parentNode() {
        let et = this._$AA.parentNode;
        const tt = this._$AM;
        return tt !== void 0 && (et == null ? void 0 : et.nodeType) === 11 && (et = tt.parentNode),
        et
    }
    get startNode() {
        return this._$AA
    }
    get endNode() {
        return this._$AB
    }
    _$AI(et, tt=this) {
        et = N(this, et, tt),
        c$1(et) ? et === T || et == null || et === "" ? (this._$AH !== T && this._$AR(),
        this._$AH = T) : et !== this._$AH && et !== w$2 && this._(et) : et._$litType$ !== void 0 ? this.$(et) : et.nodeType !== void 0 ? this.T(et) : u$2(et) ? this.k(et) : this._(et)
    }
    S(et) {
        return this._$AA.parentNode.insertBefore(et, this._$AB)
    }
    T(et) {
        this._$AH !== et && (this._$AR(),
        this._$AH = this.S(et))
    }
    _(et) {
        this._$AH !== T && c$1(this._$AH) ? this._$AA.nextSibling.data = et : this.T(r$6.createTextNode(et)),
        this._$AH = et
    }
    $(et) {
        var it;
        const {values: tt, _$litType$: rt} = et
          , nt = typeof rt == "number" ? this._$AC(et) : (rt.el === void 0 && (rt.el = V.createElement(C(rt.h, rt.h[0]), this.options)),
        rt);
        if (((it = this._$AH) == null ? void 0 : it._$AD) === nt)
            this._$AH.p(tt);
        else {
            const st = new S(nt,this)
              , at = st.u(this.options);
            st.p(tt),
            this.T(at),
            this._$AH = st
        }
    }
    _$AC(et) {
        let tt = A.get(et.strings);
        return tt === void 0 && A.set(et.strings, tt = new V(et)),
        tt
    }
    k(et) {
        a(this._$AH) || (this._$AH = [],
        this._$AR());
        const tt = this._$AH;
        let rt, nt = 0;
        for (const it of et)
            nt === tt.length ? tt.push(rt = new M(this.S(l()),this.S(l()),this,this.options)) : rt = tt[nt],
            rt._$AI(it),
            nt++;
        nt < tt.length && (this._$AR(rt && rt._$AB.nextSibling, nt),
        tt.length = nt)
    }
    _$AR(et=this._$AA.nextSibling, tt) {
        var rt;
        for ((rt = this._$AP) == null ? void 0 : rt.call(this, !1, !0, tt); et && et !== this._$AB; ) {
            const nt = et.nextSibling;
            et.remove(),
            et = nt
        }
    }
    setConnected(et) {
        var tt;
        this._$AM === void 0 && (this._$Cv = et,
        (tt = this._$AP) == null || tt.call(this, et))
    }
}
class R {
    get tagName() {
        return this.element.tagName
    }
    get _$AU() {
        return this._$AM._$AU
    }
    constructor(et, tt, rt, nt, it) {
        this.type = 1,
        this._$AH = T,
        this._$AN = void 0,
        this.element = et,
        this.name = tt,
        this._$AM = nt,
        this.options = it,
        rt.length > 2 || rt[0] !== "" || rt[1] !== "" ? (this._$AH = Array(rt.length - 1).fill(new String),
        this.strings = rt) : this._$AH = T
    }
    _$AI(et, tt=this, rt, nt) {
        const it = this.strings;
        let st = !1;
        if (it === void 0)
            et = N(this, et, tt, 0),
            st = !c$1(et) || et !== this._$AH && et !== w$2,
            st && (this._$AH = et);
        else {
            const at = et;
            let ot, lt;
            for (et = it[0],
            ot = 0; ot < it.length - 1; ot++)
                lt = N(this, at[rt + ot], tt, ot),
                lt === w$2 && (lt = this._$AH[ot]),
                st || (st = !c$1(lt) || lt !== this._$AH[ot]),
                lt === T ? et = T : et !== T && (et += (lt ?? "") + it[ot + 1]),
                this._$AH[ot] = lt
        }
        st && !nt && this.j(et)
    }
    j(et) {
        et === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, et ?? "")
    }
}
class k extends R {
    constructor() {
        super(...arguments),
        this.type = 3
    }
    j(et) {
        this.element[this.name] = et === T ? void 0 : et
    }
}
class H extends R {
    constructor() {
        super(...arguments),
        this.type = 4
    }
    j(et) {
        this.element.toggleAttribute(this.name, !!et && et !== T)
    }
}
class I extends R {
    constructor(et, tt, rt, nt, it) {
        super(et, tt, rt, nt, it),
        this.type = 5
    }
    _$AI(et, tt=this) {
        if ((et = N(this, et, tt, 0) ?? T) === w$2)
            return;
        const rt = this._$AH
          , nt = et === T && rt !== T || et.capture !== rt.capture || et.once !== rt.once || et.passive !== rt.passive
          , it = et !== T && (rt === T || nt);
        nt && this.element.removeEventListener(this.name, this, rt),
        it && this.element.addEventListener(this.name, this, et),
        this._$AH = et
    }
    handleEvent(et) {
        var tt;
        typeof this._$AH == "function" ? this._$AH.call(((tt = this.options) == null ? void 0 : tt.host) ?? this.element, et) : this._$AH.handleEvent(et)
    }
}
class L {
    constructor(et, tt, rt) {
        this.element = et,
        this.type = 6,
        this._$AN = void 0,
        this._$AM = tt,
        this.options = rt
    }
    get _$AU() {
        return this._$AM._$AU
    }
    _$AI(et) {
        N(this, et)
    }
}
const Z = t$3.litHtmlPolyfillSupport;
Z == null || Z(V, M),
(t$3.litHtmlVersions ?? (t$3.litHtmlVersions = [])).push("3.1.2");
const j = (_e,et,tt)=>{
    const rt = (tt == null ? void 0 : tt.renderBefore) ?? et;
    let nt = rt._$litPart$;
    if (nt === void 0) {
        const it = (tt == null ? void 0 : tt.renderBefore) ?? null;
        rt._$litPart$ = nt = new M(et.insertBefore(l(), it),it,void 0,tt ?? {})
    }
    return nt._$AI(_e),
    nt
}
;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$1 = class extends b {
    constructor() {
        super(...arguments),
        this.renderOptions = {
            host: this
        },
        this._$Do = void 0
    }
    createRenderRoot() {
        var tt;
        const et = super.createRenderRoot();
        return (tt = this.renderOptions).renderBefore ?? (tt.renderBefore = et.firstChild),
        et
    }
    update(et) {
        const tt = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
        super.update(et),
        this._$Do = j(tt, this.renderRoot, this.renderOptions)
    }
    connectedCallback() {
        var et;
        super.connectedCallback(),
        (et = this._$Do) == null || et.setConnected(!0)
    }
    disconnectedCallback() {
        var et;
        super.disconnectedCallback(),
        (et = this._$Do) == null || et.setConnected(!1)
    }
    render() {
        return w$2
    }
}
;
var Qo;
s$1._$litElement$ = !0,
s$1.finalized = !0,
(Qo = globalThis.litElementHydrateSupport) == null || Qo.call(globalThis, {
    LitElement: s$1
});
const r$5 = globalThis.litElementPolyfillSupport;
r$5 == null || r$5({
    LitElement: s$1
});
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$3 = {
    attribute: !0,
    type: String,
    converter: u$3,
    reflect: !1,
    hasChanged: f$3
}
  , r$4 = (_e=o$3,et,tt)=>{
    const {kind: rt, metadata: nt} = tt;
    let it = globalThis.litPropertyMetadata.get(nt);
    if (it === void 0 && globalThis.litPropertyMetadata.set(nt, it = new Map),
    it.set(tt.name, _e),
    rt === "accessor") {
        const {name: st} = tt;
        return {
            set(at) {
                const ot = et.get.call(this);
                et.set.call(this, at),
                this.requestUpdate(st, ot, _e)
            },
            init(at) {
                return at !== void 0 && this.P(st, void 0, _e),
                at
            }
        }
    }
    if (rt === "setter") {
        const {name: st} = tt;
        return function(at) {
            const ot = this[st];
            et.call(this, at),
            this.requestUpdate(st, ot, _e)
        }
    }
    throw Error("Unsupported decorator location: " + rt)
}
;
function n$4(_e) {
    return (et,tt)=>typeof tt == "object" ? r$4(_e, et, tt) : ((rt,nt,it)=>{
        const st = nt.hasOwnProperty(it);
        return nt.constructor.createProperty(it, st ? {
            ...rt,
            wrapped: !0
        } : rt),
        st ? Object.getOwnPropertyDescriptor(nt, it) : void 0
    }
    )(_e, et, tt)
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$3(_e) {
    return n$4({
        ..._e,
        state: !0,
        attribute: !1
    })
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$2 = _e=>_e ?? T;
var __decorate$S = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mAccountButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.disabled = !1,
        this.balance = "show",
        this.charsStart = 4,
        this.charsEnd = 6,
        this.address = AccountController.state.address,
        this.balanceVal = AccountController.state.balance,
        this.balanceSymbol = AccountController.state.balanceSymbol,
        this.profileName = AccountController.state.profileName,
        this.profileImage = AccountController.state.profileImage,
        this.network = NetworkController.state.caipNetwork,
        this.isUnsupportedChain = NetworkController.state.isUnsupportedChain,
        this.unsubscribe.push(AccountController.subscribe(et=>{
            et.isConnected ? (this.address = et.address,
            this.balanceVal = et.balance,
            this.profileName = et.profileName,
            this.profileImage = et.profileImage,
            this.balanceSymbol = et.balanceSymbol) : (this.address = "",
            this.balanceVal = "",
            this.profileName = "",
            this.profileImage = "",
            this.balanceSymbol = "")
        }
        ), NetworkController.subscribeKey("caipNetwork", et=>this.network = et), NetworkController.subscribeKey("isUnsupportedChain", et=>this.isUnsupportedChain = et))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        const et = AssetUtil.getNetworkImage(this.network)
          , tt = this.balance === "show";
        return x`
      <wui-account-button
        .disabled=${!!this.disabled}
        .isUnsupportedChain=${this.isUnsupportedChain}
        address=${o$2(this.profileName ?? this.address)}
        ?isProfileName=${!!this.profileName}
        networkSrc=${o$2(et)}
        avatarSrc=${o$2(this.profileImage)}
        balance=${tt ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `
    }
    onClick() {
        this.isUnsupportedChain ? ModalController.open({
            view: "UnsupportedChain"
        }) : ModalController.open()
    }
}
;
__decorate$S([n$4({
    type: Boolean
})], W3mAccountButton.prototype, "disabled", void 0);
__decorate$S([n$4()], W3mAccountButton.prototype, "balance", void 0);
__decorate$S([n$4()], W3mAccountButton.prototype, "charsStart", void 0);
__decorate$S([n$4()], W3mAccountButton.prototype, "charsEnd", void 0);
__decorate$S([r$3()], W3mAccountButton.prototype, "address", void 0);
__decorate$S([r$3()], W3mAccountButton.prototype, "balanceVal", void 0);
__decorate$S([r$3()], W3mAccountButton.prototype, "balanceSymbol", void 0);
__decorate$S([r$3()], W3mAccountButton.prototype, "profileName", void 0);
__decorate$S([r$3()], W3mAccountButton.prototype, "profileImage", void 0);
__decorate$S([r$3()], W3mAccountButton.prototype, "network", void 0);
__decorate$S([r$3()], W3mAccountButton.prototype, "isUnsupportedChain", void 0);
W3mAccountButton = __decorate$S([customElement("w3m-account-button")], W3mAccountButton);
const styles$v = i$4`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$R = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.disabled = !1,
        this.balance = void 0,
        this.size = void 0,
        this.label = void 0,
        this.loadingLabel = void 0,
        this.charsStart = 4,
        this.charsEnd = 6,
        this.isAccount = AccountController.state.isConnected,
        this.unsubscribe.push(AccountController.subscribeKey("isConnected", et=>{
            this.isAccount = et
        }
        ))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return this.isAccount ? x`
          <w3m-account-button
            .disabled=${!!this.disabled}
            balance=${o$2(this.balance)}
            .charsStart=${o$2(this.charsStart)}
            .charsEnd=${o$2(this.charsEnd)}
          >
          </w3m-account-button>
        ` : x`
          <w3m-connect-button
            size=${o$2(this.size)}
            label=${o$2(this.label)}
            loadingLabel=${o$2(this.loadingLabel)}
          ></w3m-connect-button>
        `
    }
}
;
W3mButton.styles = styles$v;
__decorate$R([n$4({
    type: Boolean
})], W3mButton.prototype, "disabled", void 0);
__decorate$R([n$4()], W3mButton.prototype, "balance", void 0);
__decorate$R([n$4()], W3mButton.prototype, "size", void 0);
__decorate$R([n$4()], W3mButton.prototype, "label", void 0);
__decorate$R([n$4()], W3mButton.prototype, "loadingLabel", void 0);
__decorate$R([n$4()], W3mButton.prototype, "charsStart", void 0);
__decorate$R([n$4()], W3mButton.prototype, "charsEnd", void 0);
__decorate$R([r$3()], W3mButton.prototype, "isAccount", void 0);
W3mButton = __decorate$R([customElement("w3m-button")], W3mButton);
var __decorate$Q = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.size = "md",
        this.label = "Connect Wallet",
        this.loadingLabel = "Connecting...",
        this.open = ModalController.state.open,
        this.loading = ModalController.state.loading,
        this.unsubscribe.push(ModalController.subscribe(et=>{
            this.open = et.open,
            this.loading = et.loading
        }
        ))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        const et = this.loading || this.open;
        return x`
      <wui-connect-button
        size=${o$2(this.size)}
        .loading=${et}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${et ? this.loadingLabel : this.label}
      </wui-connect-button>
    `
    }
    onClick() {
        this.open ? ModalController.close() : this.loading || ModalController.open()
    }
}
;
__decorate$Q([n$4()], W3mConnectButton.prototype, "size", void 0);
__decorate$Q([n$4()], W3mConnectButton.prototype, "label", void 0);
__decorate$Q([n$4()], W3mConnectButton.prototype, "loadingLabel", void 0);
__decorate$Q([r$3()], W3mConnectButton.prototype, "open", void 0);
__decorate$Q([r$3()], W3mConnectButton.prototype, "loading", void 0);
W3mConnectButton = __decorate$Q([customElement("w3m-connect-button")], W3mConnectButton);
const styles$u = i$4`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;
var __decorate$P = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const SCROLL_LOCK = "scroll-lock";
let W3mModal = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.abortController = void 0,
        this.open = ModalController.state.open,
        this.caipAddress = AccountController.state.caipAddress,
        this.isSiweEnabled = SIWEController.state.isSiweEnabled,
        this.initializeTheming(),
        ApiController.prefetch(),
        this.unsubscribe.push(ModalController.subscribeKey("open", et=>et ? this.onOpen() : this.onClose()), SIWEController.subscribeKey("isSiweEnabled", et=>{
            this.isSiweEnabled = et
        }
        ), AccountController.subscribe(et=>this.onNewAccountState(et))),
        EventsController.sendEvent({
            type: "track",
            event: "MODAL_LOADED"
        })
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et()),
        this.onRemoveKeyboardListener()
    }
    render() {
        return this.open ? x`
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        ` : null
    }
    async onOverlayClick(et) {
        et.target === et.currentTarget && await this.handleClose()
    }
    async handleClose() {
        this.isSiweEnabled && SIWEController.state.status !== "success" && await ConnectionController.disconnect(),
        ModalController.close()
    }
    initializeTheming() {
        const {themeVariables: et, themeMode: tt} = ThemeController.state
          , rt = UiHelperUtil.getColorTheme(tt);
        initializeTheming(et, rt)
    }
    async onClose() {
        this.onScrollUnlock(),
        await this.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards"
        }).finished,
        SnackController.hide(),
        this.open = !1,
        this.onRemoveKeyboardListener()
    }
    async onOpen() {
        this.onScrollLock(),
        this.open = !0,
        await this.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards",
            delay: 300
        }).finished,
        this.onAddKeyboardListener()
    }
    onScrollLock() {
        const et = document.createElement("style");
        et.dataset.w3m = SCROLL_LOCK,
        et.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `,
        document.head.appendChild(et)
    }
    onScrollUnlock() {
        const et = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
        et && et.remove()
    }
    onAddKeyboardListener() {
        var tt;
        this.abortController = new AbortController;
        const et = (tt = this.shadowRoot) == null ? void 0 : tt.querySelector("wui-card");
        et == null || et.focus(),
        window.addEventListener("keydown", rt=>{
            if (rt.key === "Escape")
                this.handleClose();
            else if (rt.key === "Tab") {
                const {tagName: nt} = rt.target;
                nt && !nt.includes("W3M-") && !nt.includes("WUI-") && (et == null || et.focus())
            }
        }
        , this.abortController)
    }
    onRemoveKeyboardListener() {
        var et;
        (et = this.abortController) == null || et.abort(),
        this.abortController = void 0
    }
    async onNewAccountState(et) {
        const {isConnected: tt, caipAddress: rt} = et;
        if (this.isSiweEnabled) {
            tt && !this.caipAddress && (this.caipAddress = rt),
            tt && rt && this.caipAddress !== rt && (await SIWEController.signOut(),
            this.onSiweNavigation(),
            this.caipAddress = rt);
            try {
                const nt = await SIWEController.getSession();
                nt && !tt ? await SIWEController.signOut() : tt && !nt && this.onSiweNavigation()
            } catch {
                tt && this.onSiweNavigation()
            }
        }
    }
    onSiweNavigation() {
        this.open ? RouterController.push("ConnectingSiwe") : ModalController.open({
            view: "ConnectingSiwe"
        })
    }
}
;
W3mModal.styles = styles$u;
__decorate$P([r$3()], W3mModal.prototype, "open", void 0);
__decorate$P([r$3()], W3mModal.prototype, "caipAddress", void 0);
__decorate$P([r$3()], W3mModal.prototype, "isSiweEnabled", void 0);
W3mModal = __decorate$P([customElement("w3m-modal")], W3mModal);
const index = Object.freeze(Object.defineProperty({
    __proto__: null,
    get W3mModal() {
        return W3mModal
    }
}, Symbol.toStringTag, {
    value: "Module"
}))
  , styles$t = i$4`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$O = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mNetworkButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.disabled = !1,
        this.network = NetworkController.state.caipNetwork,
        this.connected = AccountController.state.isConnected,
        this.loading = ModalController.state.loading,
        this.isUnsupportedChain = NetworkController.state.isUnsupportedChain,
        this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", et=>this.network = et), AccountController.subscribeKey("isConnected", et=>this.connected = et), ModalController.subscribeKey("loading", et=>this.loading = et), NetworkController.subscribeKey("isUnsupportedChain", et=>this.isUnsupportedChain = et))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        var et;
        return x`
      <wui-network-button
        .disabled=${!!(this.disabled || this.loading)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        imageSrc=${o$2(AssetUtil.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${this.isUnsupportedChain ? "Switch Network" : ((et = this.network) == null ? void 0 : et.name) ?? (this.connected ? "Unknown Network" : "Select Network")}
      </wui-network-button>
    `
    }
    onClick() {
        this.loading || (EventsController.sendEvent({
            type: "track",
            event: "CLICK_NETWORKS"
        }),
        ModalController.open({
            view: "Networks"
        }))
    }
}
;
W3mNetworkButton.styles = styles$t;
__decorate$O([n$4({
    type: Boolean
})], W3mNetworkButton.prototype, "disabled", void 0);
__decorate$O([r$3()], W3mNetworkButton.prototype, "network", void 0);
__decorate$O([r$3()], W3mNetworkButton.prototype, "connected", void 0);
__decorate$O([r$3()], W3mNetworkButton.prototype, "loading", void 0);
__decorate$O([r$3()], W3mNetworkButton.prototype, "isUnsupportedChain", void 0);
W3mNetworkButton = __decorate$O([customElement("w3m-network-button")], W3mNetworkButton);
const styles$s = i$4`
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;
var __decorate$N = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mRouter = class extends s$1 {
    constructor() {
        super(),
        this.resizeObserver = void 0,
        this.prevHeight = "0px",
        this.prevHistoryLength = 1,
        this.unsubscribe = [],
        this.view = RouterController.state.view,
        this.unsubscribe.push(RouterController.subscribeKey("view", et=>this.onViewChange(et)))
    }
    firstUpdated() {
        this.resizeObserver = new ResizeObserver(async([et])=>{
            const tt = `${et == null ? void 0 : et.contentRect.height}px`;
            this.prevHeight !== "0px" && (await this.animate([{
                height: this.prevHeight
            }, {
                height: tt
            }], {
                duration: 150,
                easing: "ease",
                fill: "forwards"
            }).finished,
            this.style.height = "auto"),
            this.prevHeight = tt
        }
        ),
        this.resizeObserver.observe(this.getWrapper())
    }
    disconnectedCallback() {
        var et;
        (et = this.resizeObserver) == null || et.unobserve(this.getWrapper()),
        this.unsubscribe.forEach(tt=>tt())
    }
    render() {
        return x`<div>${this.viewTemplate()}</div>`
    }
    viewTemplate() {
        switch (this.view) {
        case "Connect":
            return x`<w3m-connect-view></w3m-connect-view>`;
        case "ConnectingWalletConnect":
            return x`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
        case "ConnectingExternal":
            return x`<w3m-connecting-external-view></w3m-connecting-external-view>`;
        case "ConnectingSiwe":
            return x`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
        case "AllWallets":
            return x`<w3m-all-wallets-view></w3m-all-wallets-view>`;
        case "Networks":
            return x`<w3m-networks-view></w3m-networks-view>`;
        case "SwitchNetwork":
            return x`<w3m-network-switch-view></w3m-network-switch-view>`;
        case "Account":
            return x`<w3m-account-view></w3m-account-view>`;
        case "AccountSettings":
            return x`<w3m-account-settings-view></w3m-account-settings-view>`;
        case "WhatIsAWallet":
            return x`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
        case "WhatIsANetwork":
            return x`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
        case "GetWallet":
            return x`<w3m-get-wallet-view></w3m-get-wallet-view>`;
        case "Downloads":
            return x`<w3m-downloads-view></w3m-downloads-view>`;
        case "EmailVerifyOtp":
            return x`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
        case "EmailVerifyDevice":
            return x`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
        case "ApproveTransaction":
            return x`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
        case "Transactions":
            return x`<w3m-transactions-view></w3m-transactions-view>`;
        case "UpgradeEmailWallet":
            return x`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
        case "UpdateEmailWallet":
            return x`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
        case "UpdateEmailPrimaryOtp":
            return x`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
        case "UpdateEmailSecondaryOtp":
            return x`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
        case "UnsupportedChain":
            return x`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
        case "OnRampProviders":
            return x`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
        case "OnRampActivity":
            return x`<w3m-onramp-activity-view></w3m-onramp-activity-view>`;
        case "OnRampTokenSelect":
            return x`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
        case "OnRampFiatSelect":
            return x`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
        case "WhatIsABuy":
            return x`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
        case "BuyInProgress":
            return x`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
        default:
            return x`<w3m-connect-view></w3m-connect-view>`
        }
    }
    async onViewChange(et) {
        const {history: tt} = RouterController.state;
        let rt = -10
          , nt = 10;
        tt.length < this.prevHistoryLength && (rt = 10,
        nt = -10),
        this.prevHistoryLength = tt.length,
        await this.animate([{
            opacity: 1,
            transform: "translateX(0px)"
        }, {
            opacity: 0,
            transform: `translateX(${rt}px)`
        }], {
            duration: 150,
            easing: "ease",
            fill: "forwards"
        }).finished,
        this.view = et,
        await this.animate([{
            opacity: 0,
            transform: `translateX(${nt}px)`
        }, {
            opacity: 1,
            transform: "translateX(0px)"
        }], {
            duration: 150,
            easing: "ease",
            fill: "forwards",
            delay: 50
        }).finished
    }
    getWrapper() {
        var et;
        return (et = this.shadowRoot) == null ? void 0 : et.querySelector("div")
    }
}
;
W3mRouter.styles = styles$s;
__decorate$N([r$3()], W3mRouter.prototype, "view", void 0);
W3mRouter = __decorate$N([customElement("w3m-router")], W3mRouter);
const styles$r = i$4`
  :host > wui-flex {
    width: 100%;
    max-width: 360px;
  }

  :host > wui-flex > wui-flex {
    border-radius: var(--wui-border-radius-l);
    width: 100%;
  }

  .amounts-container {
    width: 100%;
  }
`;
var __decorate$M = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const PAYMENT_CURRENCY_SYMBOLS = {
    USD: "$",
    EUR: "€",
    GBP: "£"
}
  , BUY_PRESET_AMOUNTS = [100, 250, 500, 1e3];
let W3mOnrampWidget = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.disabled = !1,
        this.connected = AccountController.state.isConnected,
        this.loading = ModalController.state.loading,
        this.paymentCurrency = OnRampController.state.paymentCurrency,
        this.paymentAmount = OnRampController.state.paymentAmount,
        this.purchaseAmount = OnRampController.state.purchaseAmount,
        this.quoteLoading = OnRampController.state.quotesLoading,
        this.unsubscribe.push(AccountController.subscribeKey("isConnected", et=>{
            this.connected = et
        }
        ), ModalController.subscribeKey("loading", et=>{
            this.loading = et
        }
        ), OnRampController.subscribe(et=>{
            this.paymentCurrency = et.paymentCurrency,
            this.paymentAmount = et.paymentAmount,
            this.purchaseAmount = et.purchaseAmount,
            this.quoteLoading = et.quotesLoading
        }
        ))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return x`
      <wui-flex flexDirection="column" justifyContent="center" alignItems="center">
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <w3m-swap-input
            type="Fiat"
            @inputChange=${this.onPaymentAmountChange.bind(this)}
            .value=${this.paymentAmount || 0}
          ></w3m-swap-input>
          <w3m-swap-input
            type="Token"
            .value=${this.purchaseAmount || 0}
            .loading=${this.quoteLoading}
          ></w3m-swap-input>
          <wui-flex justifyContent="space-evenly" class="amounts-container" gap="xs">
            ${BUY_PRESET_AMOUNTS.map(et=>{
            var tt;
            return x`<wui-button
                  variant=${this.paymentAmount === et ? "accentBg" : "shade"}
                  size="xs"
                  textVariant="paragraph-600"
                  fullWidth
                  @click=${()=>this.selectPresetAmount(et)}
                  >${`${PAYMENT_CURRENCY_SYMBOLS[((tt = this.paymentCurrency) == null ? void 0 : tt.id) || "USD"]} ${et}`}</wui-button
                >`
        }
        )}
          </wui-flex>
          ${this.templateButton()}
        </wui-flex>
      </wui-flex>
    `
    }
    templateButton() {
        return this.connected ? x`<wui-button
          @click=${this.getQuotes.bind(this)}
          variant="fill"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Get quotes
        </wui-button>` : x`<wui-button
          @click=${this.openModal.bind(this)}
          variant="accentBg"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Connect wallet
        </wui-button>`
    }
    getQuotes() {
        this.loading || ModalController.open({
            view: "OnRampProviders"
        })
    }
    openModal() {
        ModalController.open({
            view: "Connect"
        })
    }
    async onPaymentAmountChange(et) {
        OnRampController.setPaymentAmount(Number(et.detail)),
        await OnRampController.getQuote()
    }
    async selectPresetAmount(et) {
        OnRampController.setPaymentAmount(et),
        await OnRampController.getQuote()
    }
}
;
W3mOnrampWidget.styles = styles$r;
__decorate$M([n$4({
    type: Boolean
})], W3mOnrampWidget.prototype, "disabled", void 0);
__decorate$M([r$3()], W3mOnrampWidget.prototype, "connected", void 0);
__decorate$M([r$3()], W3mOnrampWidget.prototype, "loading", void 0);
__decorate$M([r$3()], W3mOnrampWidget.prototype, "paymentCurrency", void 0);
__decorate$M([r$3()], W3mOnrampWidget.prototype, "paymentAmount", void 0);
__decorate$M([r$3()], W3mOnrampWidget.prototype, "purchaseAmount", void 0);
__decorate$M([r$3()], W3mOnrampWidget.prototype, "quoteLoading", void 0);
W3mOnrampWidget = __decorate$M([customElement("w3m-onramp-widget")], W3mOnrampWidget);
const styles$q = i$4`
  wui-flex {
    width: 100%;
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background 0.2s linear;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }
`;
var __decorate$L = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mAccountSettingsView = class extends s$1 {
    constructor() {
        super(),
        this.usubscribe = [],
        this.networkImages = AssetController.state.networkImages,
        this.address = AccountController.state.address,
        this.profileImage = AccountController.state.profileImage,
        this.profileName = AccountController.state.profileName,
        this.balance = AccountController.state.balance,
        this.balanceSymbol = AccountController.state.balanceSymbol,
        this.network = NetworkController.state.caipNetwork,
        this.disconnecting = !1,
        this.usubscribe.push(AccountController.subscribe(et=>{
            et.address ? (this.address = et.address,
            this.profileImage = et.profileImage,
            this.profileName = et.profileName,
            this.balance = et.balance,
            this.balanceSymbol = et.balanceSymbol) : ModalController.close()
        }
        ), NetworkController.subscribeKey("caipNetwork", et=>{
            et != null && et.id && (this.network = et)
        }
        ))
    }
    disconnectedCallback() {
        this.usubscribe.forEach(et=>et())
    }
    render() {
        var tt, rt;
        if (!this.address)
            throw new Error("w3m-account-settings-view: No account provided");
        const et = this.networkImages[((tt = this.network) == null ? void 0 : tt.imageId) ?? ""];
        return x`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$2(this.profileImage)}
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName ? UiHelperUtil.getTruncateString({
            string: this.profileName,
            charsStart: 20,
            charsEnd: 0,
            truncate: "end"
        }) : UiHelperUtil.getTruncateString({
            string: this.address,
            charsStart: 4,
            charsEnd: 6,
            truncate: "middle"
        })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-flex gap="s" flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-200">
              ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
            </wui-text>
            ${this.explorerBtnTemplate()}
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="m">
        <wui-flex flexDirection="column" gap="xs" .padding=${["0", "xl", "xl", "xl"]}>
          <wui-list-item
            .variant=${et ? "image" : "icon"}
            iconVariant="overlay"
            icon="networkPlaceholder"
            imageSrc=${o$2(et)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            @click=${this.onNetworks.bind(this)}
          >
            <wui-text variant="paragraph-500" color="fg-100">
              ${((rt = this.network) == null ? void 0 : rt.name) ?? "Unknown"}
            </wui-text>
          </wui-list-item>

          <wui-list-item
            iconVariant="blue"
            icon="swapHorizontalBold"
            iconSize="sm"
            ?chevron=${!0}
            @click=${this.onTransactions.bind(this)}
          >
            <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
          </wui-list-item>
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${!1}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `
    }
    onTransactions() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_TRANSACTIONS"
        }),
        RouterController.push("Transactions")
    }
    explorerBtnTemplate() {
        const {addressExplorerUrl: et} = AccountController.state;
        return et ? x`
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    ` : null
    }
    isAllowedNetworkSwitch() {
        const {requestedCaipNetworks: et} = NetworkController.state
          , tt = et ? et.length > 1 : !1
          , rt = et == null ? void 0 : et.find(({id: nt})=>{
            var it;
            return nt === ((it = this.network) == null ? void 0 : it.id)
        }
        );
        return tt || !rt
    }
    onCopyAddress() {
        try {
            this.address && (CoreHelperUtil.copyToClopboard(this.address),
            SnackController.showSuccess("Address copied"))
        } catch {
            SnackController.showError("Failed to copy")
        }
    }
    onNetworks() {
        this.isAllowedNetworkSwitch() && RouterController.push("Networks")
    }
    async onDisconnect() {
        try {
            this.disconnecting = !0,
            await ConnectionController.disconnect(),
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_SUCCESS"
            }),
            ModalController.close()
        } catch {
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_ERROR"
            }),
            SnackController.showError("Failed to disconnect")
        } finally {
            this.disconnecting = !1
        }
    }
    onExplorer() {
        const {addressExplorerUrl: et} = AccountController.state;
        et && CoreHelperUtil.openHref(et, "_blank")
    }
}
;
W3mAccountSettingsView.styles = styles$q;
__decorate$L([r$3()], W3mAccountSettingsView.prototype, "address", void 0);
__decorate$L([r$3()], W3mAccountSettingsView.prototype, "profileImage", void 0);
__decorate$L([r$3()], W3mAccountSettingsView.prototype, "profileName", void 0);
__decorate$L([r$3()], W3mAccountSettingsView.prototype, "balance", void 0);
__decorate$L([r$3()], W3mAccountSettingsView.prototype, "balanceSymbol", void 0);
__decorate$L([r$3()], W3mAccountSettingsView.prototype, "network", void 0);
__decorate$L([r$3()], W3mAccountSettingsView.prototype, "disconnecting", void 0);
W3mAccountSettingsView = __decorate$L([customElement("w3m-account-settings-view")], W3mAccountSettingsView);
const styles$p = i$4`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }

  w3m-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-s);
    height: 48px;
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-s);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    background-color: var(--wui-gray-glass-002);
    border-radius: 24px;
    transaction: background-color 0.2s linear;
  }

  .account-button:hover {
    background-color: var(--wui-gray-glass-005);
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background 0.2s linear;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }
`;
var __decorate$K = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mAccountView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.address = AccountController.state.address,
        this.profileImage = AccountController.state.profileImage,
        this.profileName = AccountController.state.profileName,
        this.network = NetworkController.state.caipNetwork,
        this.disconnecting = !1,
        this.balance = AccountController.state.balance,
        this.balanceSymbol = AccountController.state.balanceSymbol,
        this.unsubscribe.push(AccountController.subscribe(et=>{
            et.address ? (this.address = et.address,
            this.profileImage = et.profileImage,
            this.profileName = et.profileName,
            this.balance = et.balance,
            this.balanceSymbol = et.balanceSymbol) : ModalController.close()
        }
        ), NetworkController.subscribeKey("caipNetwork", et=>{
            et != null && et.id && (this.network = et)
        }
        ))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        var tt;
        if (!this.address)
            throw new Error("w3m-account-view: No account provided");
        const et = AssetUtil.getNetworkImage(this.network);
        return x`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$2(this.profileImage === null ? void 0 : this.profileImage)}
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="medium-title-600" color="fg-100">
              ${this.profileName ? UiHelperUtil.getTruncateString({
            string: this.profileName,
            charsStart: 20,
            charsEnd: 0,
            truncate: "end"
        }) : UiHelperUtil.getTruncateString({
            string: this.address,
            charsStart: 4,
            charsEnd: 4,
            truncate: "middle"
        })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-text variant="paragraph-500" color="fg-200"
            >${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}</wui-text
          >
        </wui-flex>
        ${this.explorerBtnTemplate()}
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.emailCardTemplate()} ${this.emailBtnTemplate()}

        <wui-list-item
          .variant=${et ? "image" : "icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${o$2(et)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
          data-testid="w3m-account-select-network"
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${((tt = this.network) == null ? void 0 : tt.name) ?? "Unknown"}
          </wui-text>
        </wui-list-item>
        ${this.onrampTemplate()}
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalMedium"
          iconSize="sm"
          ?chevron=${!0}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${!1}
          .loading=${this.disconnecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>
    `
    }
    onrampTemplate() {
        const {enableOnramp: et} = OptionsController.state;
        return et ? x`
      <wui-list-item
        iconVariant="blue"
        icon="add"
        ?chevron=${!0}
        @click=${this.handleClickPay.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Buy</wui-text>
      </wui-list-item>
    ` : null
    }
    emailCardTemplate() {
        const et = StorageUtil.getConnectedConnector()
          , tt = ConnectorController.getEmailConnector()
          , {origin: rt} = location;
        return !tt || et !== "EMAIL" || rt.includes(ConstantsUtil$1.SECURE_SITE) ? null : x`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
      ></wui-notice-card>
    `
    }
    handleClickPay() {
        RouterController.push("OnRampProviders")
    }
    explorerBtnTemplate() {
        const {addressExplorerUrl: et} = AccountController.state;
        return et ? x`
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    ` : null
    }
    emailBtnTemplate() {
        const et = StorageUtil.getConnectedConnector()
          , tt = ConnectorController.getEmailConnector();
        if (!tt || et !== "EMAIL")
            return null;
        const rt = tt.provider.getEmail() ?? "";
        return x`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="mail"
        iconSize="sm"
        ?chevron=${!0}
        @click=${()=>this.onGoToUpdateEmail(rt)}
      >
        <wui-text variant="paragraph-500" color="fg-100">${rt}</wui-text>
      </wui-list-item>
    `
    }
    isAllowedNetworkSwitch() {
        const {requestedCaipNetworks: et} = NetworkController.state
          , tt = et ? et.length > 1 : !1
          , rt = et == null ? void 0 : et.find(({id: nt})=>{
            var it;
            return nt === ((it = this.network) == null ? void 0 : it.id)
        }
        );
        return tt || !rt
    }
    onCopyAddress() {
        try {
            this.address && (CoreHelperUtil.copyToClopboard(this.address),
            SnackController.showSuccess("Address copied"))
        } catch {
            SnackController.showError("Failed to copy")
        }
    }
    onNetworks() {
        this.isAllowedNetworkSwitch() && (EventsController.sendEvent({
            type: "track",
            event: "CLICK_NETWORKS"
        }),
        RouterController.push("Networks"))
    }
    onTransactions() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_TRANSACTIONS"
        }),
        RouterController.push("Transactions")
    }
    async onDisconnect() {
        try {
            this.disconnecting = !0,
            await ConnectionController.disconnect(),
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_SUCCESS"
            }),
            ModalController.close()
        } catch {
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_ERROR"
            }),
            SnackController.showError("Failed to disconnect")
        } finally {
            this.disconnecting = !1
        }
    }
    onExplorer() {
        const {addressExplorerUrl: et} = AccountController.state;
        et && CoreHelperUtil.openHref(et, "_blank")
    }
    onGoToUpgradeView() {
        EventsController.sendEvent({
            type: "track",
            event: "EMAIL_UPGRADE_FROM_MODAL"
        }),
        RouterController.push("UpgradeEmailWallet")
    }
    onGoToUpdateEmail(et) {
        RouterController.push("UpdateEmailWallet", {
            email: et
        })
    }
}
;
W3mAccountView.styles = styles$p;
__decorate$K([r$3()], W3mAccountView.prototype, "address", void 0);
__decorate$K([r$3()], W3mAccountView.prototype, "profileImage", void 0);
__decorate$K([r$3()], W3mAccountView.prototype, "profileName", void 0);
__decorate$K([r$3()], W3mAccountView.prototype, "network", void 0);
__decorate$K([r$3()], W3mAccountView.prototype, "disconnecting", void 0);
__decorate$K([r$3()], W3mAccountView.prototype, "balance", void 0);
__decorate$K([r$3()], W3mAccountView.prototype, "balanceSymbol", void 0);
W3mAccountView = __decorate$K([customElement("w3m-account-view")], W3mAccountView);
var __decorate$J = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mAllWalletsView = class extends s$1 {
    constructor() {
        super(...arguments),
        this.search = "",
        this.onDebouncedSearch = CoreHelperUtil.debounce(et=>{
            this.search = et
        }
        )
    }
    render() {
        const et = this.search.length >= 2;
        return x`
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${et ? x`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : x`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `
    }
    onInputChange(et) {
        this.onDebouncedSearch(et.detail)
    }
    qrButtonTemplate() {
        return CoreHelperUtil.isMobile() ? x`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      ` : null
    }
    onWalletConnectQr() {
        RouterController.push("ConnectingWalletConnect")
    }
}
;
__decorate$J([r$3()], W3mAllWalletsView.prototype, "search", void 0);
W3mAllWalletsView = __decorate$J([customElement("w3m-all-wallets-view")], W3mAllWalletsView);
const styles$o = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;
var __decorate$I = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mBuyInProgressView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.selectedOnRampProvider = OnRampController.state.selectedProvider,
        this.uri = ConnectionController.state.wcUri,
        this.ready = !1,
        this.showRetry = !1,
        this.buffering = !1,
        this.error = !1,
        this.intervalId = null,
        this.startTime = null,
        this.isMobile = !1,
        this.onRetry = void 0,
        this.unsubscribe.push(OnRampController.subscribeKey("selectedProvider", et=>{
            this.selectedOnRampProvider = et
        }
        )),
        this.watchTransactions()
    }
    disconnectedCallback() {
        this.intervalId && clearInterval(this.intervalId)
    }
    render() {
        var rt, nt;
        let et = "Continue in external window";
        this.error ? et = "Buy failed" : this.selectedOnRampProvider && (et = `Buy in ${(rt = this.selectedOnRampProvider) == null ? void 0 : rt.label}`);
        const tt = this.error ? "Buy can be declined from your side or due to and error on the provider app" : "We’ll notify you once your Buy is processed";
        return x`
      <wui-flex
        data-error=${o$2(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-visual
            name=${o$2((nt = this.selectedOnRampProvider) == null ? void 0 : nt.name)}
            size="lg"
            class="provider-image"
          >
          </wui-visual>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${et}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${tt}</wui-text>
        </wui-flex>

        ${this.error ? this.tryAgainTemplate() : null}
      </wui-flex>

      <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy link
        </wui-link>
      </wui-flex>
    `
    }
    watchTransactions() {
        if (this.selectedOnRampProvider)
            switch (this.selectedOnRampProvider.name) {
            case "coinbase":
                this.startTime = Date.now(),
                this.initializeCoinbaseTransactions();
                break
            }
    }
    async initializeCoinbaseTransactions() {
        await this.watchCoinbaseTransactions(),
        this.intervalId = setInterval(()=>this.watchCoinbaseTransactions(), 1e4)
    }
    async watchCoinbaseTransactions() {
        try {
            await this.fetchCoinbaseTransactions()
        } catch (et) {
            SnackController.showError(et)
        }
    }
    async fetchCoinbaseTransactions() {
        const et = AccountController.state.address
          , tt = OptionsController.state.projectId;
        if (!et)
            throw new Error("No address found");
        const nt = (await BlockchainApiController.fetchTransactions({
            account: et,
            onramp: "coinbase",
            projectId: tt
        })).data.filter(it=>it.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
        this.intervalId && clearInterval(this.intervalId),
        nt.length ? RouterController.replace("OnRampActivity") : this.startTime && Date.now() - this.startTime >= 18e4 && (this.error = !0)
    }
    onTryAgain() {
        this.selectedOnRampProvider && (this.error = !1,
        CoreHelperUtil.openHref(this.selectedOnRampProvider.url, "popupWindow", "width=600,height=800,scrollbars=yes"))
    }
    tryAgainTemplate() {
        var et;
        return (et = this.selectedOnRampProvider) != null && et.url ? x`<wui-button variant="accent" @click=${this.onTryAgain.bind(this)}>
      <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
      Try again
    </wui-button>` : null
    }
    loaderTemplate() {
        const et = ThemeController.state.themeVariables["--w3m-border-radius-master"]
          , tt = et ? parseInt(et.replace("px", ""), 10) : 4;
        return x`<wui-loading-thumbnail radius=${tt * 9}></wui-loading-thumbnail>`
    }
    onCopyUri() {
        var et;
        if (!((et = this.selectedOnRampProvider) != null && et.url)) {
            SnackController.showError("No link found"),
            RouterController.goBack();
            return
        }
        try {
            CoreHelperUtil.copyToClopboard(this.selectedOnRampProvider.url),
            SnackController.showSuccess("Link copied")
        } catch {
            SnackController.showError("Failed to copy")
        }
    }
}
;
W3mBuyInProgressView.styles = styles$o;
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "selectedOnRampProvider", void 0);
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "uri", void 0);
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "ready", void 0);
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "showRetry", void 0);
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "buffering", void 0);
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "error", void 0);
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "intervalId", void 0);
__decorate$I([r$3()], W3mBuyInProgressView.prototype, "startTime", void 0);
__decorate$I([n$4({
    type: Boolean
})], W3mBuyInProgressView.prototype, "isMobile", void 0);
__decorate$I([n$4()], W3mBuyInProgressView.prototype, "onRetry", void 0);
W3mBuyInProgressView = __decorate$I([customElement("w3m-buy-in-progress-view")], W3mBuyInProgressView);
const styles$n = i$4`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$H = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.connectors = ConnectorController.state.connectors,
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", et=>this.connectors = et))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-email-login-widget></w3m-email-login-widget>

        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.externalTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `
    }
    walletConnectConnectorTemplate() {
        if (CoreHelperUtil.isMobile())
            return null;
        const et = this.connectors.find(tt=>tt.type === "WALLET_CONNECT");
        return et ? x`
      <wui-list-wallet
        imageSrc=${o$2(AssetUtil.getConnectorImage(et))}
        name=${et.name ?? "Unknown"}
        @click=${()=>this.onConnector(et)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    ` : null
    }
    customTemplate() {
        const {customWallets: et} = OptionsController.state;
        return et != null && et.length ? this.filterOutDuplicateWallets(et).map(rt=>x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(rt))}
          name=${rt.name ?? "Unknown"}
          @click=${()=>this.onConnectWallet(rt)}
        >
        </wui-list-wallet>
      `) : null
    }
    featuredTemplate() {
        if (!this.connectors.find(nt=>nt.type === "WALLET_CONNECT"))
            return null;
        const {featured: tt} = ApiController.state;
        return tt.length ? this.filterOutDuplicateWallets(tt).map(nt=>x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(nt))}
          name=${nt.name ?? "Unknown"}
          @click=${()=>this.onConnectWallet(nt)}
        >
        </wui-list-wallet>
      `) : null
    }
    recentTemplate() {
        return StorageUtil.getRecentWallets().map(tt=>x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(tt))}
          name=${tt.name ?? "Unknown"}
          @click=${()=>this.onConnectWallet(tt)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `)
    }
    announcedTemplate() {
        return this.connectors.map(et=>et.type !== "ANNOUNCED" ? null : x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(et))}
          name=${et.name ?? "Unknown"}
          @click=${()=>this.onConnector(et)}
          tagVariant="success"
          .installed=${!0}
        >
        </wui-list-wallet>
      `)
    }
    injectedTemplate() {
        return this.connectors.map(et=>et.type !== "INJECTED" || !ConnectionController.checkInstalled() ? null : x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(et))}
          .installed=${!0}
          name=${et.name ?? "Unknown"}
          @click=${()=>this.onConnector(et)}
        >
        </wui-list-wallet>
      `)
    }
    externalTemplate() {
        const et = ConnectorController.getAnnouncedConnectorRdns();
        return this.connectors.map(tt=>["WALLET_CONNECT", "INJECTED", "ANNOUNCED", "EMAIL"].includes(tt.type) || et.includes(ConstantsUtil$1.CONNECTOR_RDNS_MAP[tt.id]) ? null : x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(tt))}
          name=${tt.name ?? "Unknown"}
          @click=${()=>this.onConnector(tt)}
        >
        </wui-list-wallet>
      `)
    }
    allWalletsTemplate() {
        const et = this.connectors.find(ot=>ot.type === "WALLET_CONNECT")
          , {allWallets: tt} = OptionsController.state;
        if (!et || tt === "HIDE" || tt === "ONLY_MOBILE" && !CoreHelperUtil.isMobile())
            return null;
        const rt = ApiController.state.count
          , nt = ApiController.state.featured.length
          , it = rt + nt
          , st = it < 10 ? it : Math.floor(it / 10) * 10
          , at = st < it ? `${st}+` : `${st}`;
        return x`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${at}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `
    }
    recommendedTemplate() {
        if (!this.connectors.find(ut=>ut.type === "WALLET_CONNECT"))
            return null;
        const {recommended: tt} = ApiController.state
          , {customWallets: rt, featuredWalletIds: nt} = OptionsController.state
          , {connectors: it} = ConnectorController.state
          , st = StorageUtil.getRecentWallets()
          , ot = it.filter(ut=>ut.type === "INJECTED").filter(ut=>ut.name !== "Browser Wallet");
        if (nt || rt || !tt.length)
            return null;
        const lt = ot.length + st.length
          , dt = Math.max(0, 2 - lt);
        return this.filterOutDuplicateWallets(tt).slice(0, dt).map(ut=>x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(ut))}
          name=${(ut == null ? void 0 : ut.name) ?? "Unknown"}
          @click=${()=>this.onConnectWallet(ut)}
        >
        </wui-list-wallet>
      `)
    }
    onConnector(et) {
        et.type === "WALLET_CONNECT" ? CoreHelperUtil.isMobile() ? RouterController.push("AllWallets") : RouterController.push("ConnectingWalletConnect") : RouterController.push("ConnectingExternal", {
            connector: et
        })
    }
    filterOutDuplicateWallets(et) {
        const rt = StorageUtil.getRecentWallets().map(it=>it.id);
        return et.filter(it=>!rt.includes(it.id))
    }
    onAllWallets() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_ALL_WALLETS"
        }),
        RouterController.push("AllWallets")
    }
    onConnectWallet(et) {
        RouterController.push("ConnectingWalletConnect", {
            wallet: et
        })
    }
}
;
W3mConnectView.styles = styles$n;
__decorate$H([r$3()], W3mConnectView.prototype, "connectors", void 0);
W3mConnectView = __decorate$H([customElement("w3m-connect-view")], W3mConnectView);
const styles$m = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var __decorate$G = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
class W3mConnectingWidget extends s$1 {
    constructor() {
        var et, tt, rt, nt;
        super(),
        this.wallet = (et = RouterController.state.data) == null ? void 0 : et.wallet,
        this.connector = (tt = RouterController.state.data) == null ? void 0 : tt.connector,
        this.timeout = void 0,
        this.secondaryBtnLabel = "Try again",
        this.secondaryBtnIcon = "refresh",
        this.secondaryLabel = "Accept connection request in the wallet",
        this.onConnect = void 0,
        this.onRender = void 0,
        this.onAutoConnect = void 0,
        this.isWalletConnect = !0,
        this.unsubscribe = [],
        this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector),
        this.name = ((rt = this.wallet) == null ? void 0 : rt.name) ?? ((nt = this.connector) == null ? void 0 : nt.name) ?? "Wallet",
        this.isRetrying = !1,
        this.uri = ConnectionController.state.wcUri,
        this.error = ConnectionController.state.wcError,
        this.ready = !1,
        this.showRetry = !1,
        this.buffering = !1,
        this.isMobile = !1,
        this.onRetry = void 0,
        this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", it=>{
            var st;
            this.uri = it,
            this.isRetrying && this.onRetry && (this.isRetrying = !1,
            (st = this.onConnect) == null || st.call(this))
        }
        ), ConnectionController.subscribeKey("wcError", it=>this.error = it), ConnectionController.subscribeKey("buffering", it=>this.buffering = it))
    }
    firstUpdated() {
        var et;
        (et = this.onAutoConnect) == null || et.call(this),
        this.showRetry = !this.onAutoConnect
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et()),
        clearTimeout(this.timeout)
    }
    render() {
        var rt;
        (rt = this.onRender) == null || rt.call(this),
        this.onShowRetry();
        const et = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
        let tt = `Continue in ${this.name}`;
        return this.buffering && (tt = "Connecting..."),
        this.error && (tt = "Connection declined"),
        x`
      <wui-flex
        data-error=${o$2(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${o$2(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${tt}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${et}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? x`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
    onShowRetry() {
        var et;
        if (this.error && !this.showRetry) {
            this.showRetry = !0;
            const tt = (et = this.shadowRoot) == null ? void 0 : et.querySelector("wui-button");
            tt == null || tt.animate([{
                opacity: 0
            }, {
                opacity: 1
            }], {
                fill: "forwards",
                easing: "ease"
            })
        }
    }
    onTryAgain() {
        var et, tt;
        this.buffering || (ConnectionController.setWcError(!1),
        this.onRetry ? (this.isRetrying = !0,
        (et = this.onRetry) == null || et.call(this)) : (tt = this.onConnect) == null || tt.call(this))
    }
    loaderTemplate() {
        const et = ThemeController.state.themeVariables["--w3m-border-radius-master"]
          , tt = et ? parseInt(et.replace("px", ""), 10) : 4;
        return x`<wui-loading-thumbnail radius=${tt * 9}></wui-loading-thumbnail>`
    }
    onCopyUri() {
        try {
            this.uri && (CoreHelperUtil.copyToClopboard(this.uri),
            SnackController.showSuccess("Link copied"))
        } catch {
            SnackController.showError("Failed to copy")
        }
    }
}
W3mConnectingWidget.styles = styles$m;
__decorate$G([r$3()], W3mConnectingWidget.prototype, "uri", void 0);
__decorate$G([r$3()], W3mConnectingWidget.prototype, "error", void 0);
__decorate$G([r$3()], W3mConnectingWidget.prototype, "ready", void 0);
__decorate$G([r$3()], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate$G([r$3()], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate$G([n$4({
    type: Boolean
})], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate$G([n$4()], W3mConnectingWidget.prototype, "onRetry", void 0);
var __decorate$F = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const platformMap = {
    INJECTED: "browser",
    ANNOUNCED: "browser"
};
let W3mConnectingExternalView = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.connector)
            throw new Error("w3m-connecting-view: No connector provided");
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.connector.name ?? "Unknown",
                platform: platformMap[this.connector.type] ?? "external"
            }
        }),
        this.onConnect = this.onConnectProxy.bind(this),
        this.onAutoConnect = this.onConnectProxy.bind(this),
        this.isWalletConnect = !1
    }
    async onConnectProxy() {
        try {
            this.error = !1,
            this.connector && (this.connector.imageUrl && StorageUtil.setConnectedWalletImageUrl(this.connector.imageUrl),
            await ConnectionController.connectExternal(this.connector),
            SIWEController.state.isSiweEnabled ? RouterController.push("ConnectingSiwe") : ModalController.close(),
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                    method: "external"
                }
            }))
        } catch (et) {
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: (et == null ? void 0 : et.message) ?? "Unknown"
                }
            }),
            this.error = !0
        }
    }
}
;
W3mConnectingExternalView = __decorate$F([customElement("w3m-connecting-external-view")], W3mConnectingExternalView);
var __decorate$E = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingSiweView = class extends s$1 {
    constructor() {
        var et;
        super(...arguments),
        this.dappName = (et = OptionsController.state.metadata) == null ? void 0 : et.name,
        this.isSigning = !1
    }
    render() {
        return x`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${!0}
          variant="shade"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${!0}
          variant="fill"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? "Signing..." : "Sign"}
        </wui-button>
      </wui-flex>
    `
    }
    async onSign() {
        this.isSigning = !0,
        EventsController.sendEvent({
            event: "CLICK_SIGN_SIWE_MESSAGE",
            type: "track"
        });
        try {
            SIWEController.setStatus("loading");
            const et = await SIWEController.signIn();
            return SIWEController.setStatus("success"),
            EventsController.sendEvent({
                event: "SIWE_AUTH_SUCCESS",
                type: "track"
            }),
            et
        } catch {
            return SnackController.showError("Signature declined"),
            SIWEController.setStatus("error"),
            EventsController.sendEvent({
                event: "SIWE_AUTH_ERROR",
                type: "track"
            })
        } finally {
            this.isSigning = !1
        }
    }
    async onCancel() {
        const {isConnected: et} = AccountController.state;
        et ? (await ConnectionController.disconnect(),
        ModalController.close()) : RouterController.push("Connect"),
        EventsController.sendEvent({
            event: "CLICK_CANCEL_SIWE",
            type: "track"
        })
    }
}
;
__decorate$E([r$3()], W3mConnectingSiweView.prototype, "isSigning", void 0);
W3mConnectingSiweView = __decorate$E([customElement("w3m-connecting-siwe-view")], W3mConnectingSiweView);
var __decorate$D = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingWcView = class extends s$1 {
    constructor() {
        var et;
        super(),
        this.interval = void 0,
        this.lastRetry = Date.now(),
        this.wallet = (et = RouterController.state.data) == null ? void 0 : et.wallet,
        this.platform = void 0,
        this.platforms = [],
        this.initializeConnection(),
        this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$1.TEN_SEC_MS)
    }
    disconnectedCallback() {
        clearTimeout(this.interval)
    }
    render() {
        return this.wallet ? (this.determinePlatforms(),
        x`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `) : x`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`
    }
    async initializeConnection(et=!1) {
        try {
            const {wcPairingExpiry: tt} = ConnectionController.state;
            if (et || CoreHelperUtil.isPairingExpired(tt)) {
                if (ConnectionController.connectWalletConnect(),
                this.wallet) {
                    const rt = AssetUtil.getWalletImage(this.wallet);
                    rt && StorageUtil.setConnectedWalletImageUrl(rt)
                } else {
                    const nt = ConnectorController.state.connectors.find(st=>st.type === "WALLET_CONNECT")
                      , it = AssetUtil.getConnectorImage(nt);
                    it && StorageUtil.setConnectedWalletImageUrl(it)
                }
                await ConnectionController.state.wcPromise,
                this.finalizeConnection(),
                SIWEController.state.isSiweEnabled ? RouterController.push("ConnectingSiwe") : ModalController.close()
            }
        } catch (tt) {
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: (tt == null ? void 0 : tt.message) ?? "Unknown"
                }
            }),
            ConnectionController.setWcError(!0),
            CoreHelperUtil.isAllowedRetry(this.lastRetry) && (SnackController.showError("Declined"),
            this.lastRetry = Date.now(),
            this.initializeConnection(!0))
        }
    }
    finalizeConnection() {
        const {wcLinking: et, recentWallet: tt} = ConnectionController.state;
        et && StorageUtil.setWalletConnectDeepLink(et),
        tt && StorageUtil.setWeb3ModalRecent(tt),
        EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: {
                method: et ? "mobile" : "qrcode"
            }
        })
    }
    determinePlatforms() {
        if (!this.wallet)
            throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
        if (this.platform)
            return;
        const {mobile_link: et, desktop_link: tt, webapp_link: rt, injected: nt, rdns: it} = this.wallet
          , st = nt == null ? void 0 : nt.map(({injected_id: ht})=>ht).filter(Boolean)
          , at = it ? [it] : st ?? []
          , ot = at.length
          , lt = et
          , dt = rt
          , ct = ConnectionController.checkInstalled(at)
          , ut = ot && ct
          , ft = tt && !CoreHelperUtil.isMobile();
        ut && this.platforms.push("browser"),
        lt && this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode"),
        dt && this.platforms.push("web"),
        ft && this.platforms.push("desktop"),
        !ut && ot && this.platforms.push("unsupported"),
        this.platform = this.platforms[0]
    }
    platformTemplate() {
        switch (this.platform) {
        case "browser":
            return x`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
        case "desktop":
            return x`
          <w3m-connecting-wc-desktop .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-desktop>
        `;
        case "web":
            return x`
          <w3m-connecting-wc-web .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-web>
        `;
        case "mobile":
            return x`
          <w3m-connecting-wc-mobile isMobile .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-mobile>
        `;
        case "qrcode":
            return x`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
        default:
            return x`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`
        }
    }
    headerTemplate() {
        return this.platforms.length > 1 ? x`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    ` : null
    }
    async onSelectPlatform(et) {
        var rt;
        const tt = (rt = this.shadowRoot) == null ? void 0 : rt.querySelector("div");
        tt && (await tt.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.platform = et,
        tt.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
}
;
__decorate$D([r$3()], W3mConnectingWcView.prototype, "platform", void 0);
__decorate$D([r$3()], W3mConnectingWcView.prototype, "platforms", void 0);
W3mConnectingWcView = __decorate$D([customElement("w3m-connecting-wc-view")], W3mConnectingWcView);
var __decorate$C = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mDownloadsView = class extends s$1 {
    constructor() {
        var et;
        super(...arguments),
        this.wallet = (et = RouterController.state.data) == null ? void 0 : et.wallet
    }
    render() {
        if (!this.wallet)
            throw new Error("w3m-downloads-view");
        return x`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `
    }
    chromeTemplate() {
        var et;
        return (et = this.wallet) != null && et.chrome_store ? x`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>` : null
    }
    iosTemplate() {
        var et;
        return (et = this.wallet) != null && et.app_store ? x`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>` : null
    }
    androidTemplate() {
        var et;
        return (et = this.wallet) != null && et.play_store ? x`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>` : null
    }
    homepageTemplate() {
        var et;
        return (et = this.wallet) != null && et.homepage ? x`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    ` : null
    }
    onChromeStore() {
        var et;
        (et = this.wallet) != null && et.chrome_store && CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank")
    }
    onAppStore() {
        var et;
        (et = this.wallet) != null && et.app_store && CoreHelperUtil.openHref(this.wallet.app_store, "_blank")
    }
    onPlayStore() {
        var et;
        (et = this.wallet) != null && et.play_store && CoreHelperUtil.openHref(this.wallet.play_store, "_blank")
    }
    onHomePage() {
        var et;
        (et = this.wallet) != null && et.homepage && CoreHelperUtil.openHref(this.wallet.homepage, "_blank")
    }
}
;
W3mDownloadsView = __decorate$C([customElement("w3m-downloads-view")], W3mDownloadsView);
var __decorate$B = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const EXPLORER = "https://walletconnect.com/explorer";
let W3mGetWalletView = class extends s$1 {
    render() {
        return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${()=>{
            CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank")
        }
        }
        ></wui-list-wallet>
      </wui-flex>
    `
    }
    recommendedWalletsTemplate() {
        const {recommended: et, featured: tt} = ApiController.state
          , {customWallets: rt} = OptionsController.state;
        return [...tt, ...rt ?? [], ...et].slice(0, 4).map(it=>x`
        <wui-list-wallet
          name=${it.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${o$2(AssetUtil.getWalletImage(it))}
          @click=${()=>{
            CoreHelperUtil.openHref(it.homepage ?? EXPLORER, "_blank")
        }
        }
        ></wui-list-wallet>
      `)
    }
}
;
W3mGetWalletView = __decorate$B([customElement("w3m-get-wallet-view")], W3mGetWalletView);
const styles$l = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var __decorate$A = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mNetworkSwitchView = class extends s$1 {
    constructor() {
        var et;
        super(),
        this.network = (et = RouterController.state.data) == null ? void 0 : et.network,
        this.unsubscribe = [],
        this.showRetry = !1,
        this.error = !1
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    firstUpdated() {
        this.onSwitchNetwork()
    }
    render() {
        if (!this.network)
            throw new Error("w3m-network-switch-view: No network provided");
        this.onShowRetry();
        const et = this.error ? "Switch declined" : "Approve in wallet"
          , tt = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
        return x`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${o$2(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : x`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${!0}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${et}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${tt}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `
    }
    onShowRetry() {
        var et;
        if (this.error && !this.showRetry) {
            this.showRetry = !0;
            const tt = (et = this.shadowRoot) == null ? void 0 : et.querySelector("wui-button");
            tt == null || tt.animate([{
                opacity: 0
            }, {
                opacity: 1
            }], {
                fill: "forwards",
                easing: "ease"
            })
        }
    }
    async onSwitchNetwork() {
        try {
            this.error = !1,
            this.network && (await NetworkController.switchActiveNetwork(this.network),
            SIWEController.state.isSiweEnabled || RouterUtil.navigateAfterNetworkSwitch())
        } catch {
            this.error = !0
        }
    }
}
;
W3mNetworkSwitchView.styles = styles$l;
__decorate$A([r$3()], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate$A([r$3()], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate$A([customElement("w3m-network-switch-view")], W3mNetworkSwitchView);
const styles$k = i$4`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$z = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mNetworksView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.caipNetwork = NetworkController.state.caipNetwork,
        this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", et=>this.caipNetwork = et))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return x`
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `
    }
    onNetworkHelp() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_NETWORK_HELP"
        }),
        RouterController.push("WhatIsANetwork")
    }
    networksTemplate() {
        const {approvedCaipNetworkIds: et, requestedCaipNetworks: tt, supportsAllNetworks: rt} = NetworkController.state
          , nt = CoreHelperUtil.sortRequestedNetworks(et, tt);
        return nt == null ? void 0 : nt.map(it=>{
            var st;
            return x`
        <wui-card-select
          .selected=${((st = this.caipNetwork) == null ? void 0 : st.id) === it.id}
          imageSrc=${o$2(AssetUtil.getNetworkImage(it))}
          type="network"
          name=${it.name ?? it.id}
          @click=${()=>this.onSwitchNetwork(it)}
          .disabled=${!rt && !(et != null && et.includes(it.id))}
          data-testid=${`w3m-network-switch-${it.name ?? it.id}`}
        ></wui-card-select>
      `
        }
        )
    }
    async onSwitchNetwork(et) {
        const {isConnected: tt} = AccountController.state
          , {approvedCaipNetworkIds: rt, supportsAllNetworks: nt, caipNetwork: it} = NetworkController.state
          , {data: st} = RouterController.state;
        tt && (it == null ? void 0 : it.id) !== et.id ? rt != null && rt.includes(et.id) ? (await NetworkController.switchActiveNetwork(et),
        RouterUtil.navigateAfterNetworkSwitch()) : nt && RouterController.push("SwitchNetwork", {
            ...st,
            network: et
        }) : tt || (NetworkController.setCaipNetwork(et),
        RouterController.push("Connect"))
    }
}
;
W3mNetworksView.styles = styles$k;
__decorate$z([r$3()], W3mNetworksView.prototype, "caipNetwork", void 0);
W3mNetworksView = __decorate$z([customElement("w3m-networks-view")], W3mNetworksView);
const styles$j = i$4`
  :host > wui-flex {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  :host > wui-flex > wui-flex {
    width: 100%;
  }

  wui-transaction-list-item-loader {
    width: 100%;
  }
`;
var __decorate$y = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const LOADING_ITEM_COUNT$1 = 7;
let W3mOnRampActivityView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.refetchTimeout = void 0,
        this.selectedOnRampProvider = OnRampController.state.selectedProvider,
        this.loading = !1,
        this.coinbaseTransactions = TransactionsController.state.coinbaseTransactions,
        this.tokenImages = AssetController.state.tokenImages,
        this.unsubscribe.push(OnRampController.subscribeKey("selectedProvider", et=>{
            this.selectedOnRampProvider = et
        }
        ), AssetController.subscribeKey("tokenImages", et=>this.tokenImages = et), ()=>{
            clearTimeout(this.refetchTimeout)
        }
        , TransactionsController.subscribe(et=>{
            this.coinbaseTransactions = {
                ...et.coinbaseTransactions
            }
        }
        )),
        this.fetchTransactions()
    }
    render() {
        return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.loading ? this.templateLoading() : this.templateTransactionsByYear()}
      </wui-flex>
    `
    }
    templateTransactions(et) {
        return et == null ? void 0 : et.map(tt=>{
            var at, ot, lt;
            const rt = DateUtil.formatDate((at = tt == null ? void 0 : tt.metadata) == null ? void 0 : at.minedAt)
              , nt = tt.transfers[0]
              , it = nt == null ? void 0 : nt.fungible_info;
            if (!it)
                return null;
            const st = ((ot = it == null ? void 0 : it.icon) == null ? void 0 : ot.url) || ((lt = this.tokenImages) == null ? void 0 : lt[it.symbol || ""]);
            return x`
        <wui-onramp-activity-item
          label="Bought"
          .completed=${tt.metadata.status === "ONRAMP_TRANSACTION_STATUS_SUCCESS"}
          .inProgress=${tt.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS"}
          .failed=${tt.metadata.status === "ONRAMP_TRANSACTION_STATUS_FAILED"}
          purchaseCurrency=${o$2(it.symbol)}
          purchaseValue=${nt.quantity.numeric}
          date=${rt}
          icon=${o$2(st)}
          symbol=${o$2(it.symbol)}
        ></wui-onramp-activity-item>
      `
        }
        )
    }
    templateTransactionsByYear() {
        return Object.keys(this.coinbaseTransactions).sort().reverse().map(tt=>{
            const rt = parseInt(tt, 10);
            return new Array(12).fill(null).map((it,st)=>st).reverse().map(it=>{
                var ot;
                const st = TransactionUtil.getTransactionGroupTitle(rt, it)
                  , at = (ot = this.coinbaseTransactions[rt]) == null ? void 0 : ot[it];
                return at ? x`
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${st}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(at)}
            </wui-flex>
          </wui-flex>
        ` : null
            }
            )
        }
        )
    }
    async fetchTransactions() {
        await this.fetchCoinbaseTransactions()
    }
    async fetchCoinbaseTransactions() {
        const et = AccountController.state.address
          , tt = OptionsController.state.projectId;
        if (!et)
            throw new Error("No address found");
        if (!tt)
            throw new Error("No projectId found");
        this.loading = !0,
        await TransactionsController.fetchTransactions(et, "coinbase"),
        this.loading = !1,
        this.refetchLoadingTransactions()
    }
    refetchLoadingTransactions() {
        var nt;
        const et = new Date;
        if ((((nt = this.coinbaseTransactions[et.getFullYear()]) == null ? void 0 : nt[et.getMonth()]) || []).filter(it=>it.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS").length === 0) {
            clearTimeout(this.refetchTimeout);
            return
        }
        this.refetchTimeout = setTimeout(async()=>{
            const it = AccountController.state.address;
            await TransactionsController.fetchTransactions(it, "coinbase"),
            this.refetchLoadingTransactions()
        }
        , 3e3)
    }
    templateLoading() {
        return Array(LOADING_ITEM_COUNT$1).fill(x` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map(et=>et)
    }
}
;
W3mOnRampActivityView.styles = styles$j;
__decorate$y([r$3()], W3mOnRampActivityView.prototype, "selectedOnRampProvider", void 0);
__decorate$y([r$3()], W3mOnRampActivityView.prototype, "loading", void 0);
__decorate$y([r$3()], W3mOnRampActivityView.prototype, "coinbaseTransactions", void 0);
__decorate$y([r$3()], W3mOnRampActivityView.prototype, "tokenImages", void 0);
W3mOnRampActivityView = __decorate$y([customElement("w3m-onramp-activity-view")], W3mOnRampActivityView);
const styles$i = i$4`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$x = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mOnrampFiatSelectView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.selectedCurrency = OnRampController.state.paymentCurrency,
        this.currencies = OnRampController.state.paymentCurrencies,
        this.currencyImages = AssetController.state.currencyImages,
        this.unsubscribe.push(OnRampController.subscribe(et=>{
            this.selectedCurrency = et.paymentCurrency,
            this.currencies = et.paymentCurrencies
        }
        ), AssetController.subscribeKey("currencyImages", et=>this.currencyImages = et))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `
    }
    currenciesTemplate() {
        return this.currencies.map(et=>{
            var tt;
            return x`
        <wui-list-item
          imageSrc=${o$2((tt = this.currencyImages) == null ? void 0 : tt[et.id])}
          @click=${()=>this.selectCurrency(et)}
          variant="image"
        >
          <wui-text variant="paragraph-500" color="fg-100">${et.id}</wui-text>
        </wui-list-item>
      `
        }
        )
    }
    selectCurrency(et) {
        et && (OnRampController.setPaymentCurrency(et),
        ModalController.close())
    }
}
;
W3mOnrampFiatSelectView.styles = styles$i;
__decorate$x([r$3()], W3mOnrampFiatSelectView.prototype, "selectedCurrency", void 0);
__decorate$x([r$3()], W3mOnrampFiatSelectView.prototype, "currencies", void 0);
__decorate$x([r$3()], W3mOnrampFiatSelectView.prototype, "currencyImages", void 0);
W3mOnrampFiatSelectView = __decorate$x([customElement("w3m-onramp-fiat-select-view")], W3mOnrampFiatSelectView);
var __decorate$w = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mOnRampProvidersView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.providers = OnRampController.state.providers,
        this.unsubscribe.push(OnRampController.subscribeKey("providers", et=>{
            this.providers = et
        }
        ))
    }
    firstUpdated() {
        const et = this.providers.map(async tt=>tt.name === "coinbase" ? await this.getCoinbaseOnRampURL() : Promise.resolve(tt == null ? void 0 : tt.url));
        Promise.all(et).then(tt=>{
            this.providers = this.providers.map((rt,nt)=>({
                ...rt,
                url: tt[nt] || ""
            }))
        }
        )
    }
    render() {
        return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.onRampProvidersTemplate()}
      </wui-flex>
      <w3m-onramp-providers-footer></w3m-onramp-providers-footer>
    `
    }
    onRampProvidersTemplate() {
        return this.providers.map(et=>x`
        <wui-onramp-provider-item
          label=${et.label}
          name=${et.name}
          feeRange=${et.feeRange}
          @click=${()=>{
            this.onClickProvider(et)
        }
        }
          ?disabled=${!et.url}
        ></wui-onramp-provider-item>
      `)
    }
    onClickProvider(et) {
        OnRampController.setSelectedProvider(et),
        RouterController.push("BuyInProgress"),
        CoreHelperUtil.openHref(et.url, "popupWindow", "width=600,height=800,scrollbars=yes")
    }
    async getCoinbaseOnRampURL() {
        const et = AccountController.state.address
          , tt = NetworkController.state.caipNetwork;
        if (!et)
            throw new Error("No address found");
        if (!(tt != null && tt.name))
            throw new Error("No network found");
        const rt = ConstantsUtil$1.WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP[tt.name] ?? ConstantsUtil$1.WC_COINBASE_PAY_SDK_FALLBACK_CHAIN
          , nt = OnRampController.state.purchaseCurrency
          , it = nt ? [nt.symbol] : OnRampController.state.purchaseCurrencies.map(st=>st.symbol);
        return await BlockchainApiController.generateOnRampURL({
            defaultNetwork: rt,
            destinationWallets: [{
                address: et,
                blockchains: ConstantsUtil$1.WC_COINBASE_PAY_SDK_CHAINS,
                assets: it
            }],
            partnerUserId: et,
            purchaseAmount: OnRampController.state.purchaseAmount
        })
    }
}
;
__decorate$w([r$3()], W3mOnRampProvidersView.prototype, "providers", void 0);
W3mOnRampProvidersView = __decorate$w([customElement("w3m-onramp-providers-view")], W3mOnRampProvidersView);
const styles$h = i$4`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$v = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mOnrampTokensView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.selectedCurrency = OnRampController.state.purchaseCurrencies,
        this.tokens = OnRampController.state.purchaseCurrencies,
        this.tokenImages = AssetController.state.tokenImages,
        this.unsubscribe.push(OnRampController.subscribe(et=>{
            this.selectedCurrency = et.purchaseCurrencies,
            this.tokens = et.purchaseCurrencies
        }
        ), AssetController.subscribeKey("tokenImages", et=>this.tokenImages = et))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `
    }
    currenciesTemplate() {
        return this.tokens.map(et=>{
            var tt;
            return x`
        <wui-list-item
          imageSrc=${o$2((tt = this.tokenImages) == null ? void 0 : tt[et.symbol])}
          @click=${()=>this.selectToken(et)}
          variant="image"
        >
          <wui-flex gap="3xs" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-100">${et.name}</wui-text>
            <wui-text variant="small-400" color="fg-200">${et.symbol}</wui-text>
          </wui-flex>
        </wui-list-item>
      `
        }
        )
    }
    selectToken(et) {
        et && (OnRampController.setPurchaseCurrency(et),
        ModalController.close())
    }
}
;
W3mOnrampTokensView.styles = styles$h;
__decorate$v([r$3()], W3mOnrampTokensView.prototype, "selectedCurrency", void 0);
__decorate$v([r$3()], W3mOnrampTokensView.prototype, "tokens", void 0);
__decorate$v([r$3()], W3mOnrampTokensView.prototype, "tokenImages", void 0);
W3mOnrampTokensView = __decorate$v([customElement("w3m-onramp-token-select-view")], W3mOnrampTokensView);
const styles$g = i$4`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$u = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const PAGINATOR_ID$1 = "last-transaction"
  , LOADING_ITEM_COUNT = 7;
let W3mTransactionsView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.paginationObserver = void 0,
        this.address = AccountController.state.address,
        this.transactionsByYear = TransactionsController.state.transactionsByYear,
        this.loading = TransactionsController.state.loading,
        this.empty = TransactionsController.state.empty,
        this.next = TransactionsController.state.next,
        this.unsubscribe.push(AccountController.subscribe(et=>{
            et.isConnected && this.address !== et.address && (this.address = et.address,
            TransactionsController.resetTransactions(),
            TransactionsController.fetchTransactions(et.address))
        }
        ), TransactionsController.subscribe(et=>{
            this.transactionsByYear = et.transactionsByYear,
            this.loading = et.loading,
            this.empty = et.empty,
            this.next = et.next
        }
        ))
    }
    firstUpdated() {
        TransactionsController.fetchTransactions(this.address),
        this.createPaginationObserver()
    }
    updated() {
        this.setPaginationObserver()
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return x`
      <wui-flex flexDirection="column" gap="s">
        ${this.empty ? null : this.templateTransactionsByYear()}
        ${this.loading ? this.templateLoading() : null}
        ${!this.loading && this.empty ? this.templateEmpty() : null}
      </wui-flex>
    `
    }
    templateTransactionsByYear() {
        const et = Object.keys(this.transactionsByYear).sort().reverse();
        return et.map((tt,rt)=>{
            const nt = rt === et.length - 1
              , it = parseInt(tt, 10);
            return new Array(12).fill(null).map((at,ot)=>ot).reverse().map(at=>{
                var dt;
                const ot = TransactionUtil.getTransactionGroupTitle(it, at)
                  , lt = (dt = this.transactionsByYear[it]) == null ? void 0 : dt[at];
                return lt ? x`
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${ot}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(lt, nt)}
            </wui-flex>
          </wui-flex>
        ` : null
            }
            )
        }
        )
    }
    templateRenderTransaction(et, tt) {
        const {date: rt, descriptions: nt, direction: it, isAllNFT: st, images: at, status: ot, transfers: lt, type: dt} = this.getTransactionListItemProps(et)
          , ct = (lt == null ? void 0 : lt.length) > 1;
        return (lt == null ? void 0 : lt.length) === 2 && !st ? x`
        <wui-transaction-list-item
          date=${rt}
          .direction=${it}
          id=${tt && this.next ? PAGINATOR_ID$1 : ""}
          status=${ot}
          type=${dt}
          .images=${at}
          .descriptions=${nt}
        ></wui-transaction-list-item>
      ` : ct ? lt.map((ft,ht)=>{
            const gt = TransactionUtil.getTransferDescription(ft)
              , bt = tt && ht === lt.length - 1;
            return x` <wui-transaction-list-item
          date=${rt}
          direction=${ft.direction}
          id=${bt && this.next ? PAGINATOR_ID$1 : ""}
          status=${ot}
          type=${dt}
          .onlyDirectionIcon=${!0}
          .images=${[at[ht]]}
          .descriptions=${[gt]}
        ></wui-transaction-list-item>`
        }
        ) : x`
      <wui-transaction-list-item
        date=${rt}
        .direction=${it}
        id=${tt && this.next ? PAGINATOR_ID$1 : ""}
        status=${ot}
        type=${dt}
        .images=${at}
        .descriptions=${nt}
      ></wui-transaction-list-item>
    `
    }
    templateTransactions(et, tt) {
        return et.map((rt,nt)=>{
            const it = tt && nt === et.length - 1;
            return x`${this.templateRenderTransaction(rt, it)}`
        }
        )
    }
    templateEmpty() {
        return x`
      <wui-flex
        flexGrow="1"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-icon-box
          backgroundColor="glass-005"
          background="gray"
          iconColor="fg-200"
          icon="wallet"
          size="lg"
          ?border=${!0}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >No Transactions yet</wui-text
          >
          <wui-text align="center" variant="small-500" color="fg-200"
            >Start trading on dApps <br />
            to grow your wallet!</wui-text
          >
        </wui-flex>
      </wui-flex>
    `
    }
    templateLoading() {
        return Array(LOADING_ITEM_COUNT).fill(x` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map(et=>et)
    }
    createPaginationObserver() {
        const {projectId: et} = OptionsController.state;
        this.paginationObserver = new IntersectionObserver(([tt])=>{
            tt != null && tt.isIntersecting && !this.loading && (TransactionsController.fetchTransactions(this.address),
            EventsController.sendEvent({
                type: "track",
                event: "LOAD_MORE_TRANSACTIONS",
                properties: {
                    address: this.address,
                    projectId: et,
                    cursor: this.next
                }
            }))
        }
        ,{}),
        this.setPaginationObserver()
    }
    setPaginationObserver() {
        var tt, rt, nt;
        (tt = this.paginationObserver) == null || tt.disconnect();
        const et = (rt = this.shadowRoot) == null ? void 0 : rt.querySelector(`#${PAGINATOR_ID$1}`);
        et && ((nt = this.paginationObserver) == null || nt.observe(et))
    }
    getTransactionListItemProps(et) {
        var ot, lt, dt, ct, ut;
        const tt = DateUtil.formatDate((ot = et == null ? void 0 : et.metadata) == null ? void 0 : ot.minedAt)
          , rt = TransactionUtil.getTransactionDescriptions(et)
          , nt = et == null ? void 0 : et.transfers
          , it = (lt = et == null ? void 0 : et.transfers) == null ? void 0 : lt[0]
          , st = !!it && ((dt = et == null ? void 0 : et.transfers) == null ? void 0 : dt.every(ft=>!!ft.nft_info))
          , at = TransactionUtil.getTransactionImages(nt);
        return {
            date: tt,
            direction: it == null ? void 0 : it.direction,
            descriptions: rt,
            isAllNFT: st,
            images: at,
            status: (ct = et.metadata) == null ? void 0 : ct.status,
            transfers: nt,
            type: (ut = et.metadata) == null ? void 0 : ut.operationType
        }
    }
}
;
W3mTransactionsView.styles = styles$g;
__decorate$u([r$3()], W3mTransactionsView.prototype, "address", void 0);
__decorate$u([r$3()], W3mTransactionsView.prototype, "transactionsByYear", void 0);
__decorate$u([r$3()], W3mTransactionsView.prototype, "loading", void 0);
__decorate$u([r$3()], W3mTransactionsView.prototype, "empty", void 0);
__decorate$u([r$3()], W3mTransactionsView.prototype, "next", void 0);
W3mTransactionsView = __decorate$u([customElement("w3m-transactions-view")], W3mTransactionsView);
var __decorate$t = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const data$1 = [{
    images: ["network", "layers", "system"],
    title: "The system’s nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
}, {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
}];
let W3mWhatIsANetworkView = class extends s$1 {
    render() {
        return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$1}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${()=>{
            CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank")
        }
        }
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `
    }
}
;
W3mWhatIsANetworkView = __decorate$t([customElement("w3m-what-is-a-network-view")], W3mWhatIsANetworkView);
var __decorate$s = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const data = [{
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
}, {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
}, {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
}];
let W3mWhatIsAWalletView = class extends s$1 {
    render() {
        return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `
    }
    onGetWallet() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_GET_WALLET"
        }),
        RouterController.push("GetWallet")
    }
}
;
W3mWhatIsAWalletView = __decorate$s([customElement("w3m-what-is-a-wallet-view")], W3mWhatIsAWalletView);
var __decorate$r = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mWhatIsABuyView = class extends s$1 {
    render() {
        return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "3xl", "xl", "3xl"]}
        alignItems="center"
        gap="xl"
      >
        <wui-visual name="onrampCard"></wui-visual>
        <wui-flex flexDirection="column" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Buy assets to unlock your trade opportunities
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200"
            >With on-ram Buy, simply buy crypto with fiat via credit card or bank transfer and add
            funds in your wallet to trade</wui-text
          >
        </wui-flex>
        <wui-button @click=${RouterController.goBack}>
          <wui-icon size="sm" color="inherit" name="add" slot="iconLeft"></wui-icon>
          Buy
        </wui-button>
      </wui-flex>
    `
    }
}
;
W3mWhatIsABuyView = __decorate$r([customElement("w3m-what-is-a-buy-view")], W3mWhatIsABuyView);
const styles$f = i$4`
  wui-loading-spinner {
    margin: 9px auto;
  }
`
  , W3mFrameConstants = {
    SECURE_SITE_SDK: "https://secure.walletconnect.com/sdk",
    APP_EVENT_KEY: "@w3m-app/",
    FRAME_EVENT_KEY: "@w3m-frame/",
    RPC_METHOD_KEY: "RPC_",
    STORAGE_KEY: "@w3m-storage/",
    SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
    EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
    LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
    LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
    EMAIL: "EMAIL",
    APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
    APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
    APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
    APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
    APP_GET_USER: "@w3m-app/GET_USER",
    APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
    APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
    APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
    APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
    APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
    APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
    APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
    APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
    APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
    APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
    FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
    FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
    FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
    FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
    FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
    FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
    FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
    FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
    FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
    FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
    FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
    FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
    FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
    FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
    FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
    FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
    FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
    FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
    FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
    FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
    FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
    FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
    FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
    FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
    FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR"
}
  , W3mFrameRpcConstants = {
    SAFE_RPC_METHODS: ["eth_blockNumber", "eth_estimateGas", "eth_getTransactionByHash"],
    GET_CHAIN_ID: "eth_chainId"
};
var util;
(function(_e) {
    _e.assertEqual = nt=>nt;
    function et(nt) {}
    _e.assertIs = et;
    function tt(nt) {
        throw new Error
    }
    _e.assertNever = tt,
    _e.arrayToEnum = nt=>{
        const it = {};
        for (const st of nt)
            it[st] = st;
        return it
    }
    ,
    _e.getValidEnumValues = nt=>{
        const it = _e.objectKeys(nt).filter(at=>typeof nt[nt[at]] != "number")
          , st = {};
        for (const at of it)
            st[at] = nt[at];
        return _e.objectValues(st)
    }
    ,
    _e.objectValues = nt=>_e.objectKeys(nt).map(function(it) {
        return nt[it]
    }),
    _e.objectKeys = typeof Object.keys == "function" ? nt=>Object.keys(nt) : nt=>{
        const it = [];
        for (const st in nt)
            Object.prototype.hasOwnProperty.call(nt, st) && it.push(st);
        return it
    }
    ,
    _e.find = (nt,it)=>{
        for (const st of nt)
            if (it(st))
                return st
    }
    ,
    _e.isInteger = typeof Number.isInteger == "function" ? nt=>Number.isInteger(nt) : nt=>typeof nt == "number" && isFinite(nt) && Math.floor(nt) === nt;
    function rt(nt, it=" | ") {
        return nt.map(st=>typeof st == "string" ? `'${st}'` : st).join(it)
    }
    _e.joinValues = rt,
    _e.jsonStringifyReplacer = (nt,it)=>typeof it == "bigint" ? it.toString() : it
}
)(util || (util = {}));
var objectUtil;
(function(_e) {
    _e.mergeShapes = (et,tt)=>({
        ...et,
        ...tt
    })
}
)(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , getParsedType = _e=>{
    switch (typeof _e) {
    case "undefined":
        return ZodParsedType.undefined;
    case "string":
        return ZodParsedType.string;
    case "number":
        return isNaN(_e) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
        return ZodParsedType.boolean;
    case "function":
        return ZodParsedType.function;
    case "bigint":
        return ZodParsedType.bigint;
    case "symbol":
        return ZodParsedType.symbol;
    case "object":
        return Array.isArray(_e) ? ZodParsedType.array : _e === null ? ZodParsedType.null : _e.then && typeof _e.then == "function" && _e.catch && typeof _e.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && _e instanceof Map ? ZodParsedType.map : typeof Set < "u" && _e instanceof Set ? ZodParsedType.set : typeof Date < "u" && _e instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
        return ZodParsedType.unknown
    }
}
  , ZodIssueCode = util.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
  , quotelessJson = _e=>JSON.stringify(_e, null, 2).replace(/"([^"]+)":/g, "$1:");
class ZodError extends Error {
    constructor(et) {
        super(),
        this.issues = [],
        this.addIssue = rt=>{
            this.issues = [...this.issues, rt]
        }
        ,
        this.addIssues = (rt=[])=>{
            this.issues = [...this.issues, ...rt]
        }
        ;
        const tt = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, tt) : this.__proto__ = tt,
        this.name = "ZodError",
        this.issues = et
    }
    get errors() {
        return this.issues
    }
    format(et) {
        const tt = et || function(it) {
            return it.message
        }
          , rt = {
            _errors: []
        }
          , nt = it=>{
            for (const st of it.issues)
                if (st.code === "invalid_union")
                    st.unionErrors.map(nt);
                else if (st.code === "invalid_return_type")
                    nt(st.returnTypeError);
                else if (st.code === "invalid_arguments")
                    nt(st.argumentsError);
                else if (st.path.length === 0)
                    rt._errors.push(tt(st));
                else {
                    let at = rt
                      , ot = 0;
                    for (; ot < st.path.length; ) {
                        const lt = st.path[ot];
                        ot === st.path.length - 1 ? (at[lt] = at[lt] || {
                            _errors: []
                        },
                        at[lt]._errors.push(tt(st))) : at[lt] = at[lt] || {
                            _errors: []
                        },
                        at = at[lt],
                        ot++
                    }
                }
        }
        ;
        return nt(this),
        rt
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(et=tt=>tt.message) {
        const tt = {}
          , rt = [];
        for (const nt of this.issues)
            nt.path.length > 0 ? (tt[nt.path[0]] = tt[nt.path[0]] || [],
            tt[nt.path[0]].push(et(nt))) : rt.push(et(nt));
        return {
            formErrors: rt,
            fieldErrors: tt
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
ZodError.create = _e=>new ZodError(_e);
const errorMap = (_e,et)=>{
    let tt;
    switch (_e.code) {
    case ZodIssueCode.invalid_type:
        _e.received === ZodParsedType.undefined ? tt = "Required" : tt = `Expected ${_e.expected}, received ${_e.received}`;
        break;
    case ZodIssueCode.invalid_literal:
        tt = `Invalid literal value, expected ${JSON.stringify(_e.expected, util.jsonStringifyReplacer)}`;
        break;
    case ZodIssueCode.unrecognized_keys:
        tt = `Unrecognized key(s) in object: ${util.joinValues(_e.keys, ", ")}`;
        break;
    case ZodIssueCode.invalid_union:
        tt = "Invalid input";
        break;
    case ZodIssueCode.invalid_union_discriminator:
        tt = `Invalid discriminator value. Expected ${util.joinValues(_e.options)}`;
        break;
    case ZodIssueCode.invalid_enum_value:
        tt = `Invalid enum value. Expected ${util.joinValues(_e.options)}, received '${_e.received}'`;
        break;
    case ZodIssueCode.invalid_arguments:
        tt = "Invalid function arguments";
        break;
    case ZodIssueCode.invalid_return_type:
        tt = "Invalid function return type";
        break;
    case ZodIssueCode.invalid_date:
        tt = "Invalid date";
        break;
    case ZodIssueCode.invalid_string:
        typeof _e.validation == "object" ? "includes"in _e.validation ? (tt = `Invalid input: must include "${_e.validation.includes}"`,
        typeof _e.validation.position == "number" && (tt = `${tt} at one or more positions greater than or equal to ${_e.validation.position}`)) : "startsWith"in _e.validation ? tt = `Invalid input: must start with "${_e.validation.startsWith}"` : "endsWith"in _e.validation ? tt = `Invalid input: must end with "${_e.validation.endsWith}"` : util.assertNever(_e.validation) : _e.validation !== "regex" ? tt = `Invalid ${_e.validation}` : tt = "Invalid";
        break;
    case ZodIssueCode.too_small:
        _e.type === "array" ? tt = `Array must contain ${_e.exact ? "exactly" : _e.inclusive ? "at least" : "more than"} ${_e.minimum} element(s)` : _e.type === "string" ? tt = `String must contain ${_e.exact ? "exactly" : _e.inclusive ? "at least" : "over"} ${_e.minimum} character(s)` : _e.type === "number" ? tt = `Number must be ${_e.exact ? "exactly equal to " : _e.inclusive ? "greater than or equal to " : "greater than "}${_e.minimum}` : _e.type === "date" ? tt = `Date must be ${_e.exact ? "exactly equal to " : _e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(_e.minimum))}` : tt = "Invalid input";
        break;
    case ZodIssueCode.too_big:
        _e.type === "array" ? tt = `Array must contain ${_e.exact ? "exactly" : _e.inclusive ? "at most" : "less than"} ${_e.maximum} element(s)` : _e.type === "string" ? tt = `String must contain ${_e.exact ? "exactly" : _e.inclusive ? "at most" : "under"} ${_e.maximum} character(s)` : _e.type === "number" ? tt = `Number must be ${_e.exact ? "exactly" : _e.inclusive ? "less than or equal to" : "less than"} ${_e.maximum}` : _e.type === "bigint" ? tt = `BigInt must be ${_e.exact ? "exactly" : _e.inclusive ? "less than or equal to" : "less than"} ${_e.maximum}` : _e.type === "date" ? tt = `Date must be ${_e.exact ? "exactly" : _e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(_e.maximum))}` : tt = "Invalid input";
        break;
    case ZodIssueCode.custom:
        tt = "Invalid input";
        break;
    case ZodIssueCode.invalid_intersection_types:
        tt = "Intersection results could not be merged";
        break;
    case ZodIssueCode.not_multiple_of:
        tt = `Number must be a multiple of ${_e.multipleOf}`;
        break;
    case ZodIssueCode.not_finite:
        tt = "Number must be finite";
        break;
    default:
        tt = et.defaultError,
        util.assertNever(_e)
    }
    return {
        message: tt
    }
}
;
let overrideErrorMap = errorMap;
function setErrorMap(_e) {
    overrideErrorMap = _e
}
function getErrorMap() {
    return overrideErrorMap
}
const makeIssue = _e=>{
    const {data: et, path: tt, errorMaps: rt, issueData: nt} = _e
      , it = [...tt, ...nt.path || []]
      , st = {
        ...nt,
        path: it
    };
    let at = "";
    const ot = rt.filter(lt=>!!lt).slice().reverse();
    for (const lt of ot)
        at = lt(st, {
            data: et,
            defaultError: at
        }).message;
    return {
        ...nt,
        path: it,
        message: nt.message || at
    }
}
  , EMPTY_PATH = [];
function addIssueToContext(_e, et) {
    const tt = makeIssue({
        issueData: et,
        data: _e.data,
        path: _e.path,
        errorMaps: [_e.common.contextualErrorMap, _e.schemaErrorMap, getErrorMap(), errorMap].filter(rt=>!!rt)
    });
    _e.common.issues.push(tt)
}
class ParseStatus {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(et, tt) {
        const rt = [];
        for (const nt of tt) {
            if (nt.status === "aborted")
                return INVALID;
            nt.status === "dirty" && et.dirty(),
            rt.push(nt.value)
        }
        return {
            status: et.value,
            value: rt
        }
    }
    static async mergeObjectAsync(et, tt) {
        const rt = [];
        for (const nt of tt)
            rt.push({
                key: await nt.key,
                value: await nt.value
            });
        return ParseStatus.mergeObjectSync(et, rt)
    }
    static mergeObjectSync(et, tt) {
        const rt = {};
        for (const nt of tt) {
            const {key: it, value: st} = nt;
            if (it.status === "aborted" || st.status === "aborted")
                return INVALID;
            it.status === "dirty" && et.dirty(),
            st.status === "dirty" && et.dirty(),
            it.value !== "__proto__" && (typeof st.value < "u" || nt.alwaysSet) && (rt[it.value] = st.value)
        }
        return {
            status: et.value,
            value: rt
        }
    }
}
const INVALID = Object.freeze({
    status: "aborted"
})
  , DIRTY = _e=>({
    status: "dirty",
    value: _e
})
  , OK = _e=>({
    status: "valid",
    value: _e
})
  , isAborted = _e=>_e.status === "aborted"
  , isDirty = _e=>_e.status === "dirty"
  , isValid$1 = _e=>_e.status === "valid"
  , isAsync = _e=>typeof Promise < "u" && _e instanceof Promise;
var errorUtil;
(function(_e) {
    _e.errToObj = et=>typeof et == "string" ? {
        message: et
    } : et || {},
    _e.toString = et=>typeof et == "string" ? et : et == null ? void 0 : et.message
}
)(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
    constructor(et, tt, rt, nt) {
        this._cachedPath = [],
        this.parent = et,
        this.data = tt,
        this._path = rt,
        this._key = nt
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const handleResult = (_e,et)=>{
    if (isValid$1(et))
        return {
            success: !0,
            data: et.value
        };
    if (!_e.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const tt = new ZodError(_e.common.issues);
            return this._error = tt,
            this._error
        }
    }
}
;
function processCreateParams(_e) {
    if (!_e)
        return {};
    const {errorMap: et, invalid_type_error: tt, required_error: rt, description: nt} = _e;
    if (et && (tt || rt))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return et ? {
        errorMap: et,
        description: nt
    } : {
        errorMap: (st,at)=>st.code !== "invalid_type" ? {
            message: at.defaultError
        } : typeof at.data > "u" ? {
            message: rt ?? at.defaultError
        } : {
            message: tt ?? at.defaultError
        },
        description: nt
    }
}
class ZodType {
    constructor(et) {
        this.spa = this.safeParseAsync,
        this._def = et,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this)
    }
    get description() {
        return this._def.description
    }
    _getType(et) {
        return getParsedType(et.data)
    }
    _getOrReturnCtx(et, tt) {
        return tt || {
            common: et.parent.common,
            data: et.data,
            parsedType: getParsedType(et.data),
            schemaErrorMap: this._def.errorMap,
            path: et.path,
            parent: et.parent
        }
    }
    _processInputParams(et) {
        return {
            status: new ParseStatus,
            ctx: {
                common: et.parent.common,
                data: et.data,
                parsedType: getParsedType(et.data),
                schemaErrorMap: this._def.errorMap,
                path: et.path,
                parent: et.parent
            }
        }
    }
    _parseSync(et) {
        const tt = this._parse(et);
        if (isAsync(tt))
            throw new Error("Synchronous parse encountered promise.");
        return tt
    }
    _parseAsync(et) {
        const tt = this._parse(et);
        return Promise.resolve(tt)
    }
    parse(et, tt) {
        const rt = this.safeParse(et, tt);
        if (rt.success)
            return rt.data;
        throw rt.error
    }
    safeParse(et, tt) {
        var rt;
        const nt = {
            common: {
                issues: [],
                async: (rt = tt == null ? void 0 : tt.async) !== null && rt !== void 0 ? rt : !1,
                contextualErrorMap: tt == null ? void 0 : tt.errorMap
            },
            path: (tt == null ? void 0 : tt.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: et,
            parsedType: getParsedType(et)
        }
          , it = this._parseSync({
            data: et,
            path: nt.path,
            parent: nt
        });
        return handleResult(nt, it)
    }
    async parseAsync(et, tt) {
        const rt = await this.safeParseAsync(et, tt);
        if (rt.success)
            return rt.data;
        throw rt.error
    }
    async safeParseAsync(et, tt) {
        const rt = {
            common: {
                issues: [],
                contextualErrorMap: tt == null ? void 0 : tt.errorMap,
                async: !0
            },
            path: (tt == null ? void 0 : tt.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: et,
            parsedType: getParsedType(et)
        }
          , nt = this._parse({
            data: et,
            path: rt.path,
            parent: rt
        })
          , it = await (isAsync(nt) ? nt : Promise.resolve(nt));
        return handleResult(rt, it)
    }
    refine(et, tt) {
        const rt = nt=>typeof tt == "string" || typeof tt > "u" ? {
            message: tt
        } : typeof tt == "function" ? tt(nt) : tt;
        return this._refinement((nt,it)=>{
            const st = et(nt)
              , at = ()=>it.addIssue({
                code: ZodIssueCode.custom,
                ...rt(nt)
            });
            return typeof Promise < "u" && st instanceof Promise ? st.then(ot=>ot ? !0 : (at(),
            !1)) : st ? !0 : (at(),
            !1)
        }
        )
    }
    refinement(et, tt) {
        return this._refinement((rt,nt)=>et(rt) ? !0 : (nt.addIssue(typeof tt == "function" ? tt(rt, nt) : tt),
        !1))
    }
    _refinement(et) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement: et
            }
        })
    }
    superRefine(et) {
        return this._refinement(et)
    }
    optional() {
        return ZodOptional.create(this, this._def)
    }
    nullable() {
        return ZodNullable.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return ZodArray.create(this, this._def)
    }
    promise() {
        return ZodPromise.create(this, this._def)
    }
    or(et) {
        return ZodUnion.create([this, et], this._def)
    }
    and(et) {
        return ZodIntersection.create(this, et, this._def)
    }
    transform(et) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform: et
            }
        })
    }
    default(et) {
        const tt = typeof et == "function" ? et : ()=>et;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: tt,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        })
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        })
    }
    catch(et) {
        const tt = typeof et == "function" ? et : ()=>et;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: tt,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        })
    }
    describe(et) {
        const tt = this.constructor;
        return new tt({
            ...this._def,
            description: et
        })
    }
    pipe(et) {
        return ZodPipeline.create(this, et)
    }
    readonly() {
        return ZodReadonly.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i
  , cuid2Regex = /^[a-z][a-z0-9]*$/
  , ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/
  , uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/
  , ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
  , datetimeRegex = _e=>_e.precision ? _e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${_e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${_e.precision}}Z$`) : _e.precision === 0 ? _e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : _e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function isValidIP(_e, et) {
    return !!((et === "v4" || !et) && ipv4Regex.test(_e) || (et === "v6" || !et) && ipv6Regex.test(_e))
}
class ZodString extends ZodType {
    _parse(et) {
        if (this._def.coerce && (et.data = String(et.data)),
        this._getType(et) !== ZodParsedType.string) {
            const it = this._getOrReturnCtx(et);
            return addIssueToContext(it, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: it.parsedType
            }),
            INVALID
        }
        const rt = new ParseStatus;
        let nt;
        for (const it of this._def.checks)
            if (it.kind === "min")
                et.data.length < it.value && (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    code: ZodIssueCode.too_small,
                    minimum: it.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "max")
                et.data.length > it.value && (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    code: ZodIssueCode.too_big,
                    maximum: it.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "length") {
                const st = et.data.length > it.value
                  , at = et.data.length < it.value;
                (st || at) && (nt = this._getOrReturnCtx(et, nt),
                st ? addIssueToContext(nt, {
                    code: ZodIssueCode.too_big,
                    maximum: it.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: it.message
                }) : at && addIssueToContext(nt, {
                    code: ZodIssueCode.too_small,
                    minimum: it.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: it.message
                }),
                rt.dirty())
            } else if (it.kind === "email")
                emailRegex.test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "email",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "emoji")
                emojiRegex || (emojiRegex = new RegExp(_emojiRegex,"u")),
                emojiRegex.test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "emoji",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "uuid")
                uuidRegex.test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "uuid",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "cuid")
                cuidRegex.test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "cuid",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "cuid2")
                cuid2Regex.test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "cuid2",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "ulid")
                ulidRegex.test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "ulid",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty());
            else if (it.kind === "url")
                try {
                    new URL(et.data)
                } catch {
                    nt = this._getOrReturnCtx(et, nt),
                    addIssueToContext(nt, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: it.message
                    }),
                    rt.dirty()
                }
            else
                it.kind === "regex" ? (it.regex.lastIndex = 0,
                it.regex.test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "regex",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty())) : it.kind === "trim" ? et.data = et.data.trim() : it.kind === "includes" ? et.data.includes(it.value, it.position) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    code: ZodIssueCode.invalid_string,
                    validation: {
                        includes: it.value,
                        position: it.position
                    },
                    message: it.message
                }),
                rt.dirty()) : it.kind === "toLowerCase" ? et.data = et.data.toLowerCase() : it.kind === "toUpperCase" ? et.data = et.data.toUpperCase() : it.kind === "startsWith" ? et.data.startsWith(it.value) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    code: ZodIssueCode.invalid_string,
                    validation: {
                        startsWith: it.value
                    },
                    message: it.message
                }),
                rt.dirty()) : it.kind === "endsWith" ? et.data.endsWith(it.value) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    code: ZodIssueCode.invalid_string,
                    validation: {
                        endsWith: it.value
                    },
                    message: it.message
                }),
                rt.dirty()) : it.kind === "datetime" ? datetimeRegex(it).test(et.data) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    code: ZodIssueCode.invalid_string,
                    validation: "datetime",
                    message: it.message
                }),
                rt.dirty()) : it.kind === "ip" ? isValidIP(et.data, it.version) || (nt = this._getOrReturnCtx(et, nt),
                addIssueToContext(nt, {
                    validation: "ip",
                    code: ZodIssueCode.invalid_string,
                    message: it.message
                }),
                rt.dirty()) : util.assertNever(it);
        return {
            status: rt.value,
            value: et.data
        }
    }
    _regex(et, tt, rt) {
        return this.refinement(nt=>et.test(nt), {
            validation: tt,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(rt)
        })
    }
    _addCheck(et) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, et]
        })
    }
    email(et) {
        return this._addCheck({
            kind: "email",
            ...errorUtil.errToObj(et)
        })
    }
    url(et) {
        return this._addCheck({
            kind: "url",
            ...errorUtil.errToObj(et)
        })
    }
    emoji(et) {
        return this._addCheck({
            kind: "emoji",
            ...errorUtil.errToObj(et)
        })
    }
    uuid(et) {
        return this._addCheck({
            kind: "uuid",
            ...errorUtil.errToObj(et)
        })
    }
    cuid(et) {
        return this._addCheck({
            kind: "cuid",
            ...errorUtil.errToObj(et)
        })
    }
    cuid2(et) {
        return this._addCheck({
            kind: "cuid2",
            ...errorUtil.errToObj(et)
        })
    }
    ulid(et) {
        return this._addCheck({
            kind: "ulid",
            ...errorUtil.errToObj(et)
        })
    }
    ip(et) {
        return this._addCheck({
            kind: "ip",
            ...errorUtil.errToObj(et)
        })
    }
    datetime(et) {
        var tt;
        return typeof et == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            message: et
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (et == null ? void 0 : et.precision) > "u" ? null : et == null ? void 0 : et.precision,
            offset: (tt = et == null ? void 0 : et.offset) !== null && tt !== void 0 ? tt : !1,
            ...errorUtil.errToObj(et == null ? void 0 : et.message)
        })
    }
    regex(et, tt) {
        return this._addCheck({
            kind: "regex",
            regex: et,
            ...errorUtil.errToObj(tt)
        })
    }
    includes(et, tt) {
        return this._addCheck({
            kind: "includes",
            value: et,
            position: tt == null ? void 0 : tt.position,
            ...errorUtil.errToObj(tt == null ? void 0 : tt.message)
        })
    }
    startsWith(et, tt) {
        return this._addCheck({
            kind: "startsWith",
            value: et,
            ...errorUtil.errToObj(tt)
        })
    }
    endsWith(et, tt) {
        return this._addCheck({
            kind: "endsWith",
            value: et,
            ...errorUtil.errToObj(tt)
        })
    }
    min(et, tt) {
        return this._addCheck({
            kind: "min",
            value: et,
            ...errorUtil.errToObj(tt)
        })
    }
    max(et, tt) {
        return this._addCheck({
            kind: "max",
            value: et,
            ...errorUtil.errToObj(tt)
        })
    }
    length(et, tt) {
        return this._addCheck({
            kind: "length",
            value: et,
            ...errorUtil.errToObj(tt)
        })
    }
    nonempty(et) {
        return this.min(1, errorUtil.errToObj(et))
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(et=>et.kind === "datetime")
    }
    get isEmail() {
        return !!this._def.checks.find(et=>et.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(et=>et.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(et=>et.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(et=>et.kind === "uuid")
    }
    get isCUID() {
        return !!this._def.checks.find(et=>et.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(et=>et.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(et=>et.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(et=>et.kind === "ip")
    }
    get minLength() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "min" && (et === null || tt.value > et) && (et = tt.value);
        return et
    }
    get maxLength() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "max" && (et === null || tt.value < et) && (et = tt.value);
        return et
    }
}
ZodString.create = _e=>{
    var et;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (et = _e == null ? void 0 : _e.coerce) !== null && et !== void 0 ? et : !1,
        ...processCreateParams(_e)
    })
}
;
function floatSafeRemainder(_e, et) {
    const tt = (_e.toString().split(".")[1] || "").length
      , rt = (et.toString().split(".")[1] || "").length
      , nt = tt > rt ? tt : rt
      , it = parseInt(_e.toFixed(nt).replace(".", ""))
      , st = parseInt(et.toFixed(nt).replace(".", ""));
    return it % st / Math.pow(10, nt)
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(et) {
        if (this._def.coerce && (et.data = Number(et.data)),
        this._getType(et) !== ZodParsedType.number) {
            const it = this._getOrReturnCtx(et);
            return addIssueToContext(it, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: it.parsedType
            }),
            INVALID
        }
        let rt;
        const nt = new ParseStatus;
        for (const it of this._def.checks)
            it.kind === "int" ? util.isInteger(et.data) || (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: it.message
            }),
            nt.dirty()) : it.kind === "min" ? (it.inclusive ? et.data < it.value : et.data <= it.value) && (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.too_small,
                minimum: it.value,
                type: "number",
                inclusive: it.inclusive,
                exact: !1,
                message: it.message
            }),
            nt.dirty()) : it.kind === "max" ? (it.inclusive ? et.data > it.value : et.data >= it.value) && (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.too_big,
                maximum: it.value,
                type: "number",
                inclusive: it.inclusive,
                exact: !1,
                message: it.message
            }),
            nt.dirty()) : it.kind === "multipleOf" ? floatSafeRemainder(et.data, it.value) !== 0 && (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: it.value,
                message: it.message
            }),
            nt.dirty()) : it.kind === "finite" ? Number.isFinite(et.data) || (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.not_finite,
                message: it.message
            }),
            nt.dirty()) : util.assertNever(it);
        return {
            status: nt.value,
            value: et.data
        }
    }
    gte(et, tt) {
        return this.setLimit("min", et, !0, errorUtil.toString(tt))
    }
    gt(et, tt) {
        return this.setLimit("min", et, !1, errorUtil.toString(tt))
    }
    lte(et, tt) {
        return this.setLimit("max", et, !0, errorUtil.toString(tt))
    }
    lt(et, tt) {
        return this.setLimit("max", et, !1, errorUtil.toString(tt))
    }
    setLimit(et, tt, rt, nt) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, {
                kind: et,
                value: tt,
                inclusive: rt,
                message: errorUtil.toString(nt)
            }]
        })
    }
    _addCheck(et) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, et]
        })
    }
    int(et) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(et)
        })
    }
    positive(et) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: errorUtil.toString(et)
        })
    }
    negative(et) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: errorUtil.toString(et)
        })
    }
    nonpositive(et) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: errorUtil.toString(et)
        })
    }
    nonnegative(et) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: errorUtil.toString(et)
        })
    }
    multipleOf(et, tt) {
        return this._addCheck({
            kind: "multipleOf",
            value: et,
            message: errorUtil.toString(tt)
        })
    }
    finite(et) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(et)
        })
    }
    safe(et) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(et)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(et)
        })
    }
    get minValue() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "min" && (et === null || tt.value > et) && (et = tt.value);
        return et
    }
    get maxValue() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "max" && (et === null || tt.value < et) && (et = tt.value);
        return et
    }
    get isInt() {
        return !!this._def.checks.find(et=>et.kind === "int" || et.kind === "multipleOf" && util.isInteger(et.value))
    }
    get isFinite() {
        let et = null
          , tt = null;
        for (const rt of this._def.checks) {
            if (rt.kind === "finite" || rt.kind === "int" || rt.kind === "multipleOf")
                return !0;
            rt.kind === "min" ? (tt === null || rt.value > tt) && (tt = rt.value) : rt.kind === "max" && (et === null || rt.value < et) && (et = rt.value)
        }
        return Number.isFinite(tt) && Number.isFinite(et)
    }
}
ZodNumber.create = _e=>new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (_e == null ? void 0 : _e.coerce) || !1,
    ...processCreateParams(_e)
});
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(et) {
        if (this._def.coerce && (et.data = BigInt(et.data)),
        this._getType(et) !== ZodParsedType.bigint) {
            const it = this._getOrReturnCtx(et);
            return addIssueToContext(it, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: it.parsedType
            }),
            INVALID
        }
        let rt;
        const nt = new ParseStatus;
        for (const it of this._def.checks)
            it.kind === "min" ? (it.inclusive ? et.data < it.value : et.data <= it.value) && (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: it.value,
                inclusive: it.inclusive,
                message: it.message
            }),
            nt.dirty()) : it.kind === "max" ? (it.inclusive ? et.data > it.value : et.data >= it.value) && (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: it.value,
                inclusive: it.inclusive,
                message: it.message
            }),
            nt.dirty()) : it.kind === "multipleOf" ? et.data % it.value !== BigInt(0) && (rt = this._getOrReturnCtx(et, rt),
            addIssueToContext(rt, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: it.value,
                message: it.message
            }),
            nt.dirty()) : util.assertNever(it);
        return {
            status: nt.value,
            value: et.data
        }
    }
    gte(et, tt) {
        return this.setLimit("min", et, !0, errorUtil.toString(tt))
    }
    gt(et, tt) {
        return this.setLimit("min", et, !1, errorUtil.toString(tt))
    }
    lte(et, tt) {
        return this.setLimit("max", et, !0, errorUtil.toString(tt))
    }
    lt(et, tt) {
        return this.setLimit("max", et, !1, errorUtil.toString(tt))
    }
    setLimit(et, tt, rt, nt) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, {
                kind: et,
                value: tt,
                inclusive: rt,
                message: errorUtil.toString(nt)
            }]
        })
    }
    _addCheck(et) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, et]
        })
    }
    positive(et) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: errorUtil.toString(et)
        })
    }
    negative(et) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: errorUtil.toString(et)
        })
    }
    nonpositive(et) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: errorUtil.toString(et)
        })
    }
    nonnegative(et) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: errorUtil.toString(et)
        })
    }
    multipleOf(et, tt) {
        return this._addCheck({
            kind: "multipleOf",
            value: et,
            message: errorUtil.toString(tt)
        })
    }
    get minValue() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "min" && (et === null || tt.value > et) && (et = tt.value);
        return et
    }
    get maxValue() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "max" && (et === null || tt.value < et) && (et = tt.value);
        return et
    }
}
ZodBigInt.create = _e=>{
    var et;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (et = _e == null ? void 0 : _e.coerce) !== null && et !== void 0 ? et : !1,
        ...processCreateParams(_e)
    })
}
;
class ZodBoolean extends ZodType {
    _parse(et) {
        if (this._def.coerce && (et.data = !!et.data),
        this._getType(et) !== ZodParsedType.boolean) {
            const rt = this._getOrReturnCtx(et);
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: rt.parsedType
            }),
            INVALID
        }
        return OK(et.data)
    }
}
ZodBoolean.create = _e=>new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (_e == null ? void 0 : _e.coerce) || !1,
    ...processCreateParams(_e)
});
class ZodDate extends ZodType {
    _parse(et) {
        if (this._def.coerce && (et.data = new Date(et.data)),
        this._getType(et) !== ZodParsedType.date) {
            const it = this._getOrReturnCtx(et);
            return addIssueToContext(it, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: it.parsedType
            }),
            INVALID
        }
        if (isNaN(et.data.getTime())) {
            const it = this._getOrReturnCtx(et);
            return addIssueToContext(it, {
                code: ZodIssueCode.invalid_date
            }),
            INVALID
        }
        const rt = new ParseStatus;
        let nt;
        for (const it of this._def.checks)
            it.kind === "min" ? et.data.getTime() < it.value && (nt = this._getOrReturnCtx(et, nt),
            addIssueToContext(nt, {
                code: ZodIssueCode.too_small,
                message: it.message,
                inclusive: !0,
                exact: !1,
                minimum: it.value,
                type: "date"
            }),
            rt.dirty()) : it.kind === "max" ? et.data.getTime() > it.value && (nt = this._getOrReturnCtx(et, nt),
            addIssueToContext(nt, {
                code: ZodIssueCode.too_big,
                message: it.message,
                inclusive: !0,
                exact: !1,
                maximum: it.value,
                type: "date"
            }),
            rt.dirty()) : util.assertNever(it);
        return {
            status: rt.value,
            value: new Date(et.data.getTime())
        }
    }
    _addCheck(et) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, et]
        })
    }
    min(et, tt) {
        return this._addCheck({
            kind: "min",
            value: et.getTime(),
            message: errorUtil.toString(tt)
        })
    }
    max(et, tt) {
        return this._addCheck({
            kind: "max",
            value: et.getTime(),
            message: errorUtil.toString(tt)
        })
    }
    get minDate() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "min" && (et === null || tt.value > et) && (et = tt.value);
        return et != null ? new Date(et) : null
    }
    get maxDate() {
        let et = null;
        for (const tt of this._def.checks)
            tt.kind === "max" && (et === null || tt.value < et) && (et = tt.value);
        return et != null ? new Date(et) : null
    }
}
ZodDate.create = _e=>new ZodDate({
    checks: [],
    coerce: (_e == null ? void 0 : _e.coerce) || !1,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(_e)
});
class ZodSymbol extends ZodType {
    _parse(et) {
        if (this._getType(et) !== ZodParsedType.symbol) {
            const rt = this._getOrReturnCtx(et);
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: rt.parsedType
            }),
            INVALID
        }
        return OK(et.data)
    }
}
ZodSymbol.create = _e=>new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(_e)
});
class ZodUndefined extends ZodType {
    _parse(et) {
        if (this._getType(et) !== ZodParsedType.undefined) {
            const rt = this._getOrReturnCtx(et);
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: rt.parsedType
            }),
            INVALID
        }
        return OK(et.data)
    }
}
ZodUndefined.create = _e=>new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(_e)
});
class ZodNull extends ZodType {
    _parse(et) {
        if (this._getType(et) !== ZodParsedType.null) {
            const rt = this._getOrReturnCtx(et);
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: rt.parsedType
            }),
            INVALID
        }
        return OK(et.data)
    }
}
ZodNull.create = _e=>new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(_e)
});
class ZodAny extends ZodType {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(et) {
        return OK(et.data)
    }
}
ZodAny.create = _e=>new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(_e)
});
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(et) {
        return OK(et.data)
    }
}
ZodUnknown.create = _e=>new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(_e)
});
class ZodNever extends ZodType {
    _parse(et) {
        const tt = this._getOrReturnCtx(et);
        return addIssueToContext(tt, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: tt.parsedType
        }),
        INVALID
    }
}
ZodNever.create = _e=>new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(_e)
});
class ZodVoid extends ZodType {
    _parse(et) {
        if (this._getType(et) !== ZodParsedType.undefined) {
            const rt = this._getOrReturnCtx(et);
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: rt.parsedType
            }),
            INVALID
        }
        return OK(et.data)
    }
}
ZodVoid.create = _e=>new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(_e)
});
class ZodArray extends ZodType {
    _parse(et) {
        const {ctx: tt, status: rt} = this._processInputParams(et)
          , nt = this._def;
        if (tt.parsedType !== ZodParsedType.array)
            return addIssueToContext(tt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: tt.parsedType
            }),
            INVALID;
        if (nt.exactLength !== null) {
            const st = tt.data.length > nt.exactLength.value
              , at = tt.data.length < nt.exactLength.value;
            (st || at) && (addIssueToContext(tt, {
                code: st ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: at ? nt.exactLength.value : void 0,
                maximum: st ? nt.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: nt.exactLength.message
            }),
            rt.dirty())
        }
        if (nt.minLength !== null && tt.data.length < nt.minLength.value && (addIssueToContext(tt, {
            code: ZodIssueCode.too_small,
            minimum: nt.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: nt.minLength.message
        }),
        rt.dirty()),
        nt.maxLength !== null && tt.data.length > nt.maxLength.value && (addIssueToContext(tt, {
            code: ZodIssueCode.too_big,
            maximum: nt.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: nt.maxLength.message
        }),
        rt.dirty()),
        tt.common.async)
            return Promise.all([...tt.data].map((st,at)=>nt.type._parseAsync(new ParseInputLazyPath(tt,st,tt.path,at)))).then(st=>ParseStatus.mergeArray(rt, st));
        const it = [...tt.data].map((st,at)=>nt.type._parseSync(new ParseInputLazyPath(tt,st,tt.path,at)));
        return ParseStatus.mergeArray(rt, it)
    }
    get element() {
        return this._def.type
    }
    min(et, tt) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: et,
                message: errorUtil.toString(tt)
            }
        })
    }
    max(et, tt) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: et,
                message: errorUtil.toString(tt)
            }
        })
    }
    length(et, tt) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: et,
                message: errorUtil.toString(tt)
            }
        })
    }
    nonempty(et) {
        return this.min(1, et)
    }
}
ZodArray.create = (_e,et)=>new ZodArray({
    type: _e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(et)
});
function deepPartialify(_e) {
    if (_e instanceof ZodObject) {
        const et = {};
        for (const tt in _e.shape) {
            const rt = _e.shape[tt];
            et[tt] = ZodOptional.create(deepPartialify(rt))
        }
        return new ZodObject({
            ..._e._def,
            shape: ()=>et
        })
    } else
        return _e instanceof ZodArray ? new ZodArray({
            ..._e._def,
            type: deepPartialify(_e.element)
        }) : _e instanceof ZodOptional ? ZodOptional.create(deepPartialify(_e.unwrap())) : _e instanceof ZodNullable ? ZodNullable.create(deepPartialify(_e.unwrap())) : _e instanceof ZodTuple ? ZodTuple.create(_e.items.map(et=>deepPartialify(et))) : _e
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const et = this._def.shape()
          , tt = util.objectKeys(et);
        return this._cached = {
            shape: et,
            keys: tt
        }
    }
    _parse(et) {
        if (this._getType(et) !== ZodParsedType.object) {
            const lt = this._getOrReturnCtx(et);
            return addIssueToContext(lt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: lt.parsedType
            }),
            INVALID
        }
        const {status: rt, ctx: nt} = this._processInputParams(et)
          , {shape: it, keys: st} = this._getCached()
          , at = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
            for (const lt in nt.data)
                st.includes(lt) || at.push(lt);
        const ot = [];
        for (const lt of st) {
            const dt = it[lt]
              , ct = nt.data[lt];
            ot.push({
                key: {
                    status: "valid",
                    value: lt
                },
                value: dt._parse(new ParseInputLazyPath(nt,ct,nt.path,lt)),
                alwaysSet: lt in nt.data
            })
        }
        if (this._def.catchall instanceof ZodNever) {
            const lt = this._def.unknownKeys;
            if (lt === "passthrough")
                for (const dt of at)
                    ot.push({
                        key: {
                            status: "valid",
                            value: dt
                        },
                        value: {
                            status: "valid",
                            value: nt.data[dt]
                        }
                    });
            else if (lt === "strict")
                at.length > 0 && (addIssueToContext(nt, {
                    code: ZodIssueCode.unrecognized_keys,
                    keys: at
                }),
                rt.dirty());
            else if (lt !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const lt = this._def.catchall;
            for (const dt of at) {
                const ct = nt.data[dt];
                ot.push({
                    key: {
                        status: "valid",
                        value: dt
                    },
                    value: lt._parse(new ParseInputLazyPath(nt,ct,nt.path,dt)),
                    alwaysSet: dt in nt.data
                })
            }
        }
        return nt.common.async ? Promise.resolve().then(async()=>{
            const lt = [];
            for (const dt of ot) {
                const ct = await dt.key;
                lt.push({
                    key: ct,
                    value: await dt.value,
                    alwaysSet: dt.alwaysSet
                })
            }
            return lt
        }
        ).then(lt=>ParseStatus.mergeObjectSync(rt, lt)) : ParseStatus.mergeObjectSync(rt, ot)
    }
    get shape() {
        return this._def.shape()
    }
    strict(et) {
        return errorUtil.errToObj,
        new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...et !== void 0 ? {
                errorMap: (tt,rt)=>{
                    var nt, it, st, at;
                    const ot = (st = (it = (nt = this._def).errorMap) === null || it === void 0 ? void 0 : it.call(nt, tt, rt).message) !== null && st !== void 0 ? st : rt.defaultError;
                    return tt.code === "unrecognized_keys" ? {
                        message: (at = errorUtil.errToObj(et).message) !== null && at !== void 0 ? at : ot
                    } : {
                        message: ot
                    }
                }
            } : {}
        })
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(et) {
        return new ZodObject({
            ...this._def,
            shape: ()=>({
                ...this._def.shape(),
                ...et
            })
        })
    }
    merge(et) {
        return new ZodObject({
            unknownKeys: et._def.unknownKeys,
            catchall: et._def.catchall,
            shape: ()=>({
                ...this._def.shape(),
                ...et._def.shape()
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        })
    }
    setKey(et, tt) {
        return this.augment({
            [et]: tt
        })
    }
    catchall(et) {
        return new ZodObject({
            ...this._def,
            catchall: et
        })
    }
    pick(et) {
        const tt = {};
        return util.objectKeys(et).forEach(rt=>{
            et[rt] && this.shape[rt] && (tt[rt] = this.shape[rt])
        }
        ),
        new ZodObject({
            ...this._def,
            shape: ()=>tt
        })
    }
    omit(et) {
        const tt = {};
        return util.objectKeys(this.shape).forEach(rt=>{
            et[rt] || (tt[rt] = this.shape[rt])
        }
        ),
        new ZodObject({
            ...this._def,
            shape: ()=>tt
        })
    }
    deepPartial() {
        return deepPartialify(this)
    }
    partial(et) {
        const tt = {};
        return util.objectKeys(this.shape).forEach(rt=>{
            const nt = this.shape[rt];
            et && !et[rt] ? tt[rt] = nt : tt[rt] = nt.optional()
        }
        ),
        new ZodObject({
            ...this._def,
            shape: ()=>tt
        })
    }
    required(et) {
        const tt = {};
        return util.objectKeys(this.shape).forEach(rt=>{
            if (et && !et[rt])
                tt[rt] = this.shape[rt];
            else {
                let it = this.shape[rt];
                for (; it instanceof ZodOptional; )
                    it = it._def.innerType;
                tt[rt] = it
            }
        }
        ),
        new ZodObject({
            ...this._def,
            shape: ()=>tt
        })
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape))
    }
}
ZodObject.create = (_e,et)=>new ZodObject({
    shape: ()=>_e,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(et)
});
ZodObject.strictCreate = (_e,et)=>new ZodObject({
    shape: ()=>_e,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(et)
});
ZodObject.lazycreate = (_e,et)=>new ZodObject({
    shape: _e,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(et)
});
class ZodUnion extends ZodType {
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et)
          , rt = this._def.options;
        function nt(it) {
            for (const at of it)
                if (at.result.status === "valid")
                    return at.result;
            for (const at of it)
                if (at.result.status === "dirty")
                    return tt.common.issues.push(...at.ctx.common.issues),
                    at.result;
            const st = it.map(at=>new ZodError(at.ctx.common.issues));
            return addIssueToContext(tt, {
                code: ZodIssueCode.invalid_union,
                unionErrors: st
            }),
            INVALID
        }
        if (tt.common.async)
            return Promise.all(rt.map(async it=>{
                const st = {
                    ...tt,
                    common: {
                        ...tt.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await it._parseAsync({
                        data: tt.data,
                        path: tt.path,
                        parent: st
                    }),
                    ctx: st
                }
            }
            )).then(nt);
        {
            let it;
            const st = [];
            for (const ot of rt) {
                const lt = {
                    ...tt,
                    common: {
                        ...tt.common,
                        issues: []
                    },
                    parent: null
                }
                  , dt = ot._parseSync({
                    data: tt.data,
                    path: tt.path,
                    parent: lt
                });
                if (dt.status === "valid")
                    return dt;
                dt.status === "dirty" && !it && (it = {
                    result: dt,
                    ctx: lt
                }),
                lt.common.issues.length && st.push(lt.common.issues)
            }
            if (it)
                return tt.common.issues.push(...it.ctx.common.issues),
                it.result;
            const at = st.map(ot=>new ZodError(ot));
            return addIssueToContext(tt, {
                code: ZodIssueCode.invalid_union,
                unionErrors: at
            }),
            INVALID
        }
    }
    get options() {
        return this._def.options
    }
}
ZodUnion.create = (_e,et)=>new ZodUnion({
    options: _e,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(et)
});
const getDiscriminator = _e=>_e instanceof ZodLazy ? getDiscriminator(_e.schema) : _e instanceof ZodEffects ? getDiscriminator(_e.innerType()) : _e instanceof ZodLiteral ? [_e.value] : _e instanceof ZodEnum ? _e.options : _e instanceof ZodNativeEnum ? Object.keys(_e.enum) : _e instanceof ZodDefault ? getDiscriminator(_e._def.innerType) : _e instanceof ZodUndefined ? [void 0] : _e instanceof ZodNull ? [null] : null;
class ZodDiscriminatedUnion extends ZodType {
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et);
        if (tt.parsedType !== ZodParsedType.object)
            return addIssueToContext(tt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: tt.parsedType
            }),
            INVALID;
        const rt = this.discriminator
          , nt = tt.data[rt]
          , it = this.optionsMap.get(nt);
        return it ? tt.common.async ? it._parseAsync({
            data: tt.data,
            path: tt.path,
            parent: tt
        }) : it._parseSync({
            data: tt.data,
            path: tt.path,
            parent: tt
        }) : (addIssueToContext(tt, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [rt]
        }),
        INVALID)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(et, tt, rt) {
        const nt = new Map;
        for (const it of tt) {
            const st = getDiscriminator(it.shape[et]);
            if (!st)
                throw new Error(`A discriminator value for key \`${et}\` could not be extracted from all schema options`);
            for (const at of st) {
                if (nt.has(at))
                    throw new Error(`Discriminator property ${String(et)} has duplicate value ${String(at)}`);
                nt.set(at, it)
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator: et,
            options: tt,
            optionsMap: nt,
            ...processCreateParams(rt)
        })
    }
}
function mergeValues(_e, et) {
    const tt = getParsedType(_e)
      , rt = getParsedType(et);
    if (_e === et)
        return {
            valid: !0,
            data: _e
        };
    if (tt === ZodParsedType.object && rt === ZodParsedType.object) {
        const nt = util.objectKeys(et)
          , it = util.objectKeys(_e).filter(at=>nt.indexOf(at) !== -1)
          , st = {
            ..._e,
            ...et
        };
        for (const at of it) {
            const ot = mergeValues(_e[at], et[at]);
            if (!ot.valid)
                return {
                    valid: !1
                };
            st[at] = ot.data
        }
        return {
            valid: !0,
            data: st
        }
    } else if (tt === ZodParsedType.array && rt === ZodParsedType.array) {
        if (_e.length !== et.length)
            return {
                valid: !1
            };
        const nt = [];
        for (let it = 0; it < _e.length; it++) {
            const st = _e[it]
              , at = et[it]
              , ot = mergeValues(st, at);
            if (!ot.valid)
                return {
                    valid: !1
                };
            nt.push(ot.data)
        }
        return {
            valid: !0,
            data: nt
        }
    } else
        return tt === ZodParsedType.date && rt === ZodParsedType.date && +_e == +et ? {
            valid: !0,
            data: _e
        } : {
            valid: !1
        }
}
class ZodIntersection extends ZodType {
    _parse(et) {
        const {status: tt, ctx: rt} = this._processInputParams(et)
          , nt = (it,st)=>{
            if (isAborted(it) || isAborted(st))
                return INVALID;
            const at = mergeValues(it.value, st.value);
            return at.valid ? ((isDirty(it) || isDirty(st)) && tt.dirty(),
            {
                status: tt.value,
                value: at.data
            }) : (addIssueToContext(rt, {
                code: ZodIssueCode.invalid_intersection_types
            }),
            INVALID)
        }
        ;
        return rt.common.async ? Promise.all([this._def.left._parseAsync({
            data: rt.data,
            path: rt.path,
            parent: rt
        }), this._def.right._parseAsync({
            data: rt.data,
            path: rt.path,
            parent: rt
        })]).then(([it,st])=>nt(it, st)) : nt(this._def.left._parseSync({
            data: rt.data,
            path: rt.path,
            parent: rt
        }), this._def.right._parseSync({
            data: rt.data,
            path: rt.path,
            parent: rt
        }))
    }
}
ZodIntersection.create = (_e,et,tt)=>new ZodIntersection({
    left: _e,
    right: et,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(tt)
});
class ZodTuple extends ZodType {
    _parse(et) {
        const {status: tt, ctx: rt} = this._processInputParams(et);
        if (rt.parsedType !== ZodParsedType.array)
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: rt.parsedType
            }),
            INVALID;
        if (rt.data.length < this._def.items.length)
            return addIssueToContext(rt, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            INVALID;
        !this._def.rest && rt.data.length > this._def.items.length && (addIssueToContext(rt, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        tt.dirty());
        const it = [...rt.data].map((st,at)=>{
            const ot = this._def.items[at] || this._def.rest;
            return ot ? ot._parse(new ParseInputLazyPath(rt,st,rt.path,at)) : null
        }
        ).filter(st=>!!st);
        return rt.common.async ? Promise.all(it).then(st=>ParseStatus.mergeArray(tt, st)) : ParseStatus.mergeArray(tt, it)
    }
    get items() {
        return this._def.items
    }
    rest(et) {
        return new ZodTuple({
            ...this._def,
            rest: et
        })
    }
}
ZodTuple.create = (_e,et)=>{
    if (!Array.isArray(_e))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new ZodTuple({
        items: _e,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(et)
    })
}
;
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(et) {
        const {status: tt, ctx: rt} = this._processInputParams(et);
        if (rt.parsedType !== ZodParsedType.object)
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: rt.parsedType
            }),
            INVALID;
        const nt = []
          , it = this._def.keyType
          , st = this._def.valueType;
        for (const at in rt.data)
            nt.push({
                key: it._parse(new ParseInputLazyPath(rt,at,rt.path,at)),
                value: st._parse(new ParseInputLazyPath(rt,rt.data[at],rt.path,at))
            });
        return rt.common.async ? ParseStatus.mergeObjectAsync(tt, nt) : ParseStatus.mergeObjectSync(tt, nt)
    }
    get element() {
        return this._def.valueType
    }
    static create(et, tt, rt) {
        return tt instanceof ZodType ? new ZodRecord({
            keyType: et,
            valueType: tt,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(rt)
        }) : new ZodRecord({
            keyType: ZodString.create(),
            valueType: et,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(tt)
        })
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(et) {
        const {status: tt, ctx: rt} = this._processInputParams(et);
        if (rt.parsedType !== ZodParsedType.map)
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: rt.parsedType
            }),
            INVALID;
        const nt = this._def.keyType
          , it = this._def.valueType
          , st = [...rt.data.entries()].map(([at,ot],lt)=>({
            key: nt._parse(new ParseInputLazyPath(rt,at,rt.path,[lt, "key"])),
            value: it._parse(new ParseInputLazyPath(rt,ot,rt.path,[lt, "value"]))
        }));
        if (rt.common.async) {
            const at = new Map;
            return Promise.resolve().then(async()=>{
                for (const ot of st) {
                    const lt = await ot.key
                      , dt = await ot.value;
                    if (lt.status === "aborted" || dt.status === "aborted")
                        return INVALID;
                    (lt.status === "dirty" || dt.status === "dirty") && tt.dirty(),
                    at.set(lt.value, dt.value)
                }
                return {
                    status: tt.value,
                    value: at
                }
            }
            )
        } else {
            const at = new Map;
            for (const ot of st) {
                const lt = ot.key
                  , dt = ot.value;
                if (lt.status === "aborted" || dt.status === "aborted")
                    return INVALID;
                (lt.status === "dirty" || dt.status === "dirty") && tt.dirty(),
                at.set(lt.value, dt.value)
            }
            return {
                status: tt.value,
                value: at
            }
        }
    }
}
ZodMap.create = (_e,et,tt)=>new ZodMap({
    valueType: et,
    keyType: _e,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(tt)
});
class ZodSet extends ZodType {
    _parse(et) {
        const {status: tt, ctx: rt} = this._processInputParams(et);
        if (rt.parsedType !== ZodParsedType.set)
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: rt.parsedType
            }),
            INVALID;
        const nt = this._def;
        nt.minSize !== null && rt.data.size < nt.minSize.value && (addIssueToContext(rt, {
            code: ZodIssueCode.too_small,
            minimum: nt.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: nt.minSize.message
        }),
        tt.dirty()),
        nt.maxSize !== null && rt.data.size > nt.maxSize.value && (addIssueToContext(rt, {
            code: ZodIssueCode.too_big,
            maximum: nt.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: nt.maxSize.message
        }),
        tt.dirty());
        const it = this._def.valueType;
        function st(ot) {
            const lt = new Set;
            for (const dt of ot) {
                if (dt.status === "aborted")
                    return INVALID;
                dt.status === "dirty" && tt.dirty(),
                lt.add(dt.value)
            }
            return {
                status: tt.value,
                value: lt
            }
        }
        const at = [...rt.data.values()].map((ot,lt)=>it._parse(new ParseInputLazyPath(rt,ot,rt.path,lt)));
        return rt.common.async ? Promise.all(at).then(ot=>st(ot)) : st(at)
    }
    min(et, tt) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: et,
                message: errorUtil.toString(tt)
            }
        })
    }
    max(et, tt) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: et,
                message: errorUtil.toString(tt)
            }
        })
    }
    size(et, tt) {
        return this.min(et, tt).max(et, tt)
    }
    nonempty(et) {
        return this.min(1, et)
    }
}
ZodSet.create = (_e,et)=>new ZodSet({
    valueType: _e,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(et)
});
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments),
        this.validate = this.implement
    }
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et);
        if (tt.parsedType !== ZodParsedType.function)
            return addIssueToContext(tt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: tt.parsedType
            }),
            INVALID;
        function rt(at, ot) {
            return makeIssue({
                data: at,
                path: tt.path,
                errorMaps: [tt.common.contextualErrorMap, tt.schemaErrorMap, getErrorMap(), errorMap].filter(lt=>!!lt),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: ot
                }
            })
        }
        function nt(at, ot) {
            return makeIssue({
                data: at,
                path: tt.path,
                errorMaps: [tt.common.contextualErrorMap, tt.schemaErrorMap, getErrorMap(), errorMap].filter(lt=>!!lt),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: ot
                }
            })
        }
        const it = {
            errorMap: tt.common.contextualErrorMap
        }
          , st = tt.data;
        if (this._def.returns instanceof ZodPromise) {
            const at = this;
            return OK(async function(...ot) {
                const lt = new ZodError([])
                  , dt = await at._def.args.parseAsync(ot, it).catch(ft=>{
                    throw lt.addIssue(rt(ot, ft)),
                    lt
                }
                )
                  , ct = await Reflect.apply(st, this, dt);
                return await at._def.returns._def.type.parseAsync(ct, it).catch(ft=>{
                    throw lt.addIssue(nt(ct, ft)),
                    lt
                }
                )
            })
        } else {
            const at = this;
            return OK(function(...ot) {
                const lt = at._def.args.safeParse(ot, it);
                if (!lt.success)
                    throw new ZodError([rt(ot, lt.error)]);
                const dt = Reflect.apply(st, this, lt.data)
                  , ct = at._def.returns.safeParse(dt, it);
                if (!ct.success)
                    throw new ZodError([nt(dt, ct.error)]);
                return ct.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...et) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(et).rest(ZodUnknown.create())
        })
    }
    returns(et) {
        return new ZodFunction({
            ...this._def,
            returns: et
        })
    }
    implement(et) {
        return this.parse(et)
    }
    strictImplement(et) {
        return this.parse(et)
    }
    static create(et, tt, rt) {
        return new ZodFunction({
            args: et || ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: tt || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(rt)
        })
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter()
    }
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et);
        return this._def.getter()._parse({
            data: tt.data,
            path: tt.path,
            parent: tt
        })
    }
}
ZodLazy.create = (_e,et)=>new ZodLazy({
    getter: _e,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(et)
});
class ZodLiteral extends ZodType {
    _parse(et) {
        if (et.data !== this._def.value) {
            const tt = this._getOrReturnCtx(et);
            return addIssueToContext(tt, {
                received: tt.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value
            }),
            INVALID
        }
        return {
            status: "valid",
            value: et.data
        }
    }
    get value() {
        return this._def.value
    }
}
ZodLiteral.create = (_e,et)=>new ZodLiteral({
    value: _e,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(et)
});
function createZodEnum(_e, et) {
    return new ZodEnum({
        values: _e,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(et)
    })
}
class ZodEnum extends ZodType {
    _parse(et) {
        if (typeof et.data != "string") {
            const tt = this._getOrReturnCtx(et)
              , rt = this._def.values;
            return addIssueToContext(tt, {
                expected: util.joinValues(rt),
                received: tt.parsedType,
                code: ZodIssueCode.invalid_type
            }),
            INVALID
        }
        if (this._def.values.indexOf(et.data) === -1) {
            const tt = this._getOrReturnCtx(et)
              , rt = this._def.values;
            return addIssueToContext(tt, {
                received: tt.data,
                code: ZodIssueCode.invalid_enum_value,
                options: rt
            }),
            INVALID
        }
        return OK(et.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const et = {};
        for (const tt of this._def.values)
            et[tt] = tt;
        return et
    }
    get Values() {
        const et = {};
        for (const tt of this._def.values)
            et[tt] = tt;
        return et
    }
    get Enum() {
        const et = {};
        for (const tt of this._def.values)
            et[tt] = tt;
        return et
    }
    extract(et) {
        return ZodEnum.create(et)
    }
    exclude(et) {
        return ZodEnum.create(this.options.filter(tt=>!et.includes(tt)))
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(et) {
        const tt = util.getValidEnumValues(this._def.values)
          , rt = this._getOrReturnCtx(et);
        if (rt.parsedType !== ZodParsedType.string && rt.parsedType !== ZodParsedType.number) {
            const nt = util.objectValues(tt);
            return addIssueToContext(rt, {
                expected: util.joinValues(nt),
                received: rt.parsedType,
                code: ZodIssueCode.invalid_type
            }),
            INVALID
        }
        if (tt.indexOf(et.data) === -1) {
            const nt = util.objectValues(tt);
            return addIssueToContext(rt, {
                received: rt.data,
                code: ZodIssueCode.invalid_enum_value,
                options: nt
            }),
            INVALID
        }
        return OK(et.data)
    }
    get enum() {
        return this._def.values
    }
}
ZodNativeEnum.create = (_e,et)=>new ZodNativeEnum({
    values: _e,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(et)
});
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type
    }
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et);
        if (tt.parsedType !== ZodParsedType.promise && tt.common.async === !1)
            return addIssueToContext(tt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: tt.parsedType
            }),
            INVALID;
        const rt = tt.parsedType === ZodParsedType.promise ? tt.data : Promise.resolve(tt.data);
        return OK(rt.then(nt=>this._def.type.parseAsync(nt, {
            path: tt.path,
            errorMap: tt.common.contextualErrorMap
        })))
    }
}
ZodPromise.create = (_e,et)=>new ZodPromise({
    type: _e,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(et)
});
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(et) {
        const {status: tt, ctx: rt} = this._processInputParams(et)
          , nt = this._def.effect || null
          , it = {
            addIssue: st=>{
                addIssueToContext(rt, st),
                st.fatal ? tt.abort() : tt.dirty()
            }
            ,
            get path() {
                return rt.path
            }
        };
        if (it.addIssue = it.addIssue.bind(it),
        nt.type === "preprocess") {
            const st = nt.transform(rt.data, it);
            return rt.common.issues.length ? {
                status: "dirty",
                value: rt.data
            } : rt.common.async ? Promise.resolve(st).then(at=>this._def.schema._parseAsync({
                data: at,
                path: rt.path,
                parent: rt
            })) : this._def.schema._parseSync({
                data: st,
                path: rt.path,
                parent: rt
            })
        }
        if (nt.type === "refinement") {
            const st = at=>{
                const ot = nt.refinement(at, it);
                if (rt.common.async)
                    return Promise.resolve(ot);
                if (ot instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return at
            }
            ;
            if (rt.common.async === !1) {
                const at = this._def.schema._parseSync({
                    data: rt.data,
                    path: rt.path,
                    parent: rt
                });
                return at.status === "aborted" ? INVALID : (at.status === "dirty" && tt.dirty(),
                st(at.value),
                {
                    status: tt.value,
                    value: at.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: rt.data,
                    path: rt.path,
                    parent: rt
                }).then(at=>at.status === "aborted" ? INVALID : (at.status === "dirty" && tt.dirty(),
                st(at.value).then(()=>({
                    status: tt.value,
                    value: at.value
                }))))
        }
        if (nt.type === "transform")
            if (rt.common.async === !1) {
                const st = this._def.schema._parseSync({
                    data: rt.data,
                    path: rt.path,
                    parent: rt
                });
                if (!isValid$1(st))
                    return st;
                const at = nt.transform(st.value, it);
                if (at instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: tt.value,
                    value: at
                }
            } else
                return this._def.schema._parseAsync({
                    data: rt.data,
                    path: rt.path,
                    parent: rt
                }).then(st=>isValid$1(st) ? Promise.resolve(nt.transform(st.value, it)).then(at=>({
                    status: tt.value,
                    value: at
                })) : st);
        util.assertNever(nt)
    }
}
ZodEffects.create = (_e,et,tt)=>new ZodEffects({
    schema: _e,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: et,
    ...processCreateParams(tt)
});
ZodEffects.createWithPreprocess = (_e,et,tt)=>new ZodEffects({
    schema: et,
    effect: {
        type: "preprocess",
        transform: _e
    },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(tt)
});
class ZodOptional extends ZodType {
    _parse(et) {
        return this._getType(et) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(et)
    }
    unwrap() {
        return this._def.innerType
    }
}
ZodOptional.create = (_e,et)=>new ZodOptional({
    innerType: _e,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(et)
});
class ZodNullable extends ZodType {
    _parse(et) {
        return this._getType(et) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(et)
    }
    unwrap() {
        return this._def.innerType
    }
}
ZodNullable.create = (_e,et)=>new ZodNullable({
    innerType: _e,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(et)
});
class ZodDefault extends ZodType {
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et);
        let rt = tt.data;
        return tt.parsedType === ZodParsedType.undefined && (rt = this._def.defaultValue()),
        this._def.innerType._parse({
            data: rt,
            path: tt.path,
            parent: tt
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
ZodDefault.create = (_e,et)=>new ZodDefault({
    innerType: _e,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof et.default == "function" ? et.default : ()=>et.default,
    ...processCreateParams(et)
});
class ZodCatch extends ZodType {
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et)
          , rt = {
            ...tt,
            common: {
                ...tt.common,
                issues: []
            }
        }
          , nt = this._def.innerType._parse({
            data: rt.data,
            path: rt.path,
            parent: {
                ...rt
            }
        });
        return isAsync(nt) ? nt.then(it=>({
            status: "valid",
            value: it.status === "valid" ? it.value : this._def.catchValue({
                get error() {
                    return new ZodError(rt.common.issues)
                },
                input: rt.data
            })
        })) : {
            status: "valid",
            value: nt.status === "valid" ? nt.value : this._def.catchValue({
                get error() {
                    return new ZodError(rt.common.issues)
                },
                input: rt.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
ZodCatch.create = (_e,et)=>new ZodCatch({
    innerType: _e,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof et.catch == "function" ? et.catch : ()=>et.catch,
    ...processCreateParams(et)
});
class ZodNaN extends ZodType {
    _parse(et) {
        if (this._getType(et) !== ZodParsedType.nan) {
            const rt = this._getOrReturnCtx(et);
            return addIssueToContext(rt, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: rt.parsedType
            }),
            INVALID
        }
        return {
            status: "valid",
            value: et.data
        }
    }
}
ZodNaN.create = _e=>new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(_e)
});
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(et) {
        const {ctx: tt} = this._processInputParams(et)
          , rt = tt.data;
        return this._def.type._parse({
            data: rt,
            path: tt.path,
            parent: tt
        })
    }
    unwrap() {
        return this._def.type
    }
}
class ZodPipeline extends ZodType {
    _parse(et) {
        const {status: tt, ctx: rt} = this._processInputParams(et);
        if (rt.common.async)
            return (async()=>{
                const it = await this._def.in._parseAsync({
                    data: rt.data,
                    path: rt.path,
                    parent: rt
                });
                return it.status === "aborted" ? INVALID : it.status === "dirty" ? (tt.dirty(),
                DIRTY(it.value)) : this._def.out._parseAsync({
                    data: it.value,
                    path: rt.path,
                    parent: rt
                })
            }
            )();
        {
            const nt = this._def.in._parseSync({
                data: rt.data,
                path: rt.path,
                parent: rt
            });
            return nt.status === "aborted" ? INVALID : nt.status === "dirty" ? (tt.dirty(),
            {
                status: "dirty",
                value: nt.value
            }) : this._def.out._parseSync({
                data: nt.value,
                path: rt.path,
                parent: rt
            })
        }
    }
    static create(et, tt) {
        return new ZodPipeline({
            in: et,
            out: tt,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        })
    }
}
class ZodReadonly extends ZodType {
    _parse(et) {
        const tt = this._def.innerType._parse(et);
        return isValid$1(tt) && (tt.value = Object.freeze(tt.value)),
        tt
    }
}
ZodReadonly.create = (_e,et)=>new ZodReadonly({
    innerType: _e,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(et)
});
const custom = (_e,et={},tt)=>_e ? ZodAny.create().superRefine((rt,nt)=>{
    var it, st;
    if (!_e(rt)) {
        const at = typeof et == "function" ? et(rt) : typeof et == "string" ? {
            message: et
        } : et
          , ot = (st = (it = at.fatal) !== null && it !== void 0 ? it : tt) !== null && st !== void 0 ? st : !0
          , lt = typeof at == "string" ? {
            message: at
        } : at;
        nt.addIssue({
            code: "custom",
            ...lt,
            fatal: ot
        })
    }
}
) : ZodAny.create()
  , late = {
    object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(_e) {
    _e.ZodString = "ZodString",
    _e.ZodNumber = "ZodNumber",
    _e.ZodNaN = "ZodNaN",
    _e.ZodBigInt = "ZodBigInt",
    _e.ZodBoolean = "ZodBoolean",
    _e.ZodDate = "ZodDate",
    _e.ZodSymbol = "ZodSymbol",
    _e.ZodUndefined = "ZodUndefined",
    _e.ZodNull = "ZodNull",
    _e.ZodAny = "ZodAny",
    _e.ZodUnknown = "ZodUnknown",
    _e.ZodNever = "ZodNever",
    _e.ZodVoid = "ZodVoid",
    _e.ZodArray = "ZodArray",
    _e.ZodObject = "ZodObject",
    _e.ZodUnion = "ZodUnion",
    _e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    _e.ZodIntersection = "ZodIntersection",
    _e.ZodTuple = "ZodTuple",
    _e.ZodRecord = "ZodRecord",
    _e.ZodMap = "ZodMap",
    _e.ZodSet = "ZodSet",
    _e.ZodFunction = "ZodFunction",
    _e.ZodLazy = "ZodLazy",
    _e.ZodLiteral = "ZodLiteral",
    _e.ZodEnum = "ZodEnum",
    _e.ZodEffects = "ZodEffects",
    _e.ZodNativeEnum = "ZodNativeEnum",
    _e.ZodOptional = "ZodOptional",
    _e.ZodNullable = "ZodNullable",
    _e.ZodDefault = "ZodDefault",
    _e.ZodCatch = "ZodCatch",
    _e.ZodPromise = "ZodPromise",
    _e.ZodBranded = "ZodBranded",
    _e.ZodPipeline = "ZodPipeline",
    _e.ZodReadonly = "ZodReadonly"
}
)(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (_e,et={
    message: `Input not instance of ${_e.name}`
})=>custom(tt=>tt instanceof _e, et)
  , stringType = ZodString.create
  , numberType = ZodNumber.create
  , nanType = ZodNaN.create
  , bigIntType = ZodBigInt.create
  , booleanType = ZodBoolean.create
  , dateType = ZodDate.create
  , symbolType = ZodSymbol.create
  , undefinedType = ZodUndefined.create
  , nullType = ZodNull.create
  , anyType = ZodAny.create
  , unknownType = ZodUnknown.create
  , neverType = ZodNever.create
  , voidType = ZodVoid.create
  , arrayType = ZodArray.create
  , objectType = ZodObject.create
  , strictObjectType = ZodObject.strictCreate
  , unionType = ZodUnion.create
  , discriminatedUnionType = ZodDiscriminatedUnion.create
  , intersectionType = ZodIntersection.create
  , tupleType = ZodTuple.create
  , recordType = ZodRecord.create
  , mapType = ZodMap.create
  , setType = ZodSet.create
  , functionType = ZodFunction.create
  , lazyType = ZodLazy.create
  , literalType = ZodLiteral.create
  , enumType = ZodEnum.create
  , nativeEnumType = ZodNativeEnum.create
  , promiseType = ZodPromise.create
  , effectsType = ZodEffects.create
  , optionalType = ZodOptional.create
  , nullableType = ZodNullable.create
  , preprocessType = ZodEffects.createWithPreprocess
  , pipelineType = ZodPipeline.create
  , ostring = ()=>stringType().optional()
  , onumber = ()=>numberType().optional()
  , oboolean = ()=>booleanType().optional()
  , coerce = {
    string: _e=>ZodString.create({
        ..._e,
        coerce: !0
    }),
    number: _e=>ZodNumber.create({
        ..._e,
        coerce: !0
    }),
    boolean: _e=>ZodBoolean.create({
        ..._e,
        coerce: !0
    }),
    bigint: _e=>ZodBigInt.create({
        ..._e,
        coerce: !0
    }),
    date: _e=>ZodDate.create({
        ..._e,
        coerce: !0
    })
}
  , NEVER = INVALID;
var z = Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid: isValid$1,
    isAsync,
    get util() {
        return util
    },
    get objectUtil() {
        return objectUtil
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    enum: enumType,
    function: functionType,
    instanceof: instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    null: nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    undefined: undefinedType,
    union: unionType,
    unknown: unknownType,
    void: voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
});
const zError = z.object({
    message: z.string()
});
function zType(_e) {
    return z.literal(W3mFrameConstants[_e])
}
z.object({
    accessList: z.array(z.string()),
    blockHash: z.string().nullable(),
    blockNumber: z.string().nullable(),
    chainId: z.string(),
    from: z.string(),
    gas: z.string(),
    hash: z.string(),
    input: z.string().nullable(),
    maxFeePerGas: z.string(),
    maxPriorityFeePerGas: z.string(),
    nonce: z.string(),
    r: z.string(),
    s: z.string(),
    to: z.string(),
    transactionIndex: z.string().nullable(),
    type: z.string(),
    v: z.string(),
    value: z.string()
});
const AppSwitchNetworkRequest = z.object({
    chainId: z.number()
})
  , AppConnectEmailRequest = z.object({
    email: z.string().email()
})
  , AppConnectOtpRequest = z.object({
    otp: z.string()
})
  , AppGetUserRequest = z.object({
    chainId: z.optional(z.number())
})
  , AppUpdateEmailRequest = z.object({
    email: z.string().email()
})
  , AppUpdateEmailPrimaryOtpRequest = z.object({
    otp: z.string()
})
  , AppUpdateEmailSecondaryOtpRequest = z.object({
    otp: z.string()
})
  , AppSyncThemeRequest = z.object({
    themeMode: z.optional(z.enum(["light", "dark"])),
    themeVariables: z.optional(z.record(z.string(), z.string().or(z.number())))
})
  , AppSyncDappDataRequest = z.object({
    metadata: z.object({
        name: z.string(),
        description: z.string(),
        url: z.string(),
        icons: z.array(z.string())
    }).optional(),
    sdkVersion: z.string(),
    projectId: z.string()
})
  , FrameConnectEmailResponse = z.object({
    action: z.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
})
  , FrameGetUserResponse = z.object({
    email: z.string().email(),
    address: z.string(),
    chainId: z.number()
})
  , FrameIsConnectedResponse = z.object({
    isConnected: z.boolean()
})
  , FrameGetChainIdResponse = z.object({
    chainId: z.number()
})
  , FrameSwitchNetworkResponse = z.object({
    chainId: z.number()
})
  , FrameUpdateEmailSecondaryOtpResolver = z.object({
    newEmail: z.string().email()
})
  , RpcResponse = z.any()
  , RpcPersonalSignRequest = z.object({
    method: z.literal("personal_sign"),
    params: z.array(z.any())
})
  , RpcEthSendTransactionRequest = z.object({
    method: z.literal("eth_sendTransaction"),
    params: z.array(z.any())
})
  , RpcEthAccountsRequest = z.object({
    method: z.literal("eth_accounts")
})
  , RpcGetBalance = z.object({
    method: z.literal("eth_getBalance"),
    params: z.array(z.any())
})
  , RpcEthEstimateGas = z.object({
    method: z.literal("eth_estimateGas"),
    params: z.array(z.any())
})
  , RpcEthGasPrice = z.object({
    method: z.literal("eth_gasPrice")
})
  , RpcEthSignTypedDataV4 = z.object({
    method: z.literal("eth_signTypedData_v4"),
    params: z.array(z.any())
})
  , RpcEthGetTransactionByHash = z.object({
    method: z.literal("eth_getTransactionByHash"),
    params: z.array(z.any())
})
  , RpcEthBlockNumber = z.object({
    method: z.literal("eth_blockNumber")
})
  , RpcEthChainId = z.object({
    method: z.literal("eth_chainId")
})
  , FrameSession = z.object({
    token: z.string()
})
  , W3mFrameSchema = {
    appEvent: z.object({
        type: zType("APP_SWITCH_NETWORK"),
        payload: AppSwitchNetworkRequest
    }).or(z.object({
        type: zType("APP_CONNECT_EMAIL"),
        payload: AppConnectEmailRequest
    })).or(z.object({
        type: zType("APP_CONNECT_DEVICE")
    })).or(z.object({
        type: zType("APP_CONNECT_OTP"),
        payload: AppConnectOtpRequest
    })).or(z.object({
        type: zType("APP_GET_USER"),
        payload: z.optional(AppGetUserRequest)
    })).or(z.object({
        type: zType("APP_SIGN_OUT")
    })).or(z.object({
        type: zType("APP_IS_CONNECTED"),
        payload: z.optional(FrameSession)
    })).or(z.object({
        type: zType("APP_GET_CHAIN_ID")
    })).or(z.object({
        type: zType("APP_RPC_REQUEST"),
        payload: RpcPersonalSignRequest.or(RpcEthSendTransactionRequest).or(RpcEthAccountsRequest).or(RpcGetBalance).or(RpcEthEstimateGas).or(RpcEthGasPrice).or(RpcEthSignTypedDataV4).or(RpcEthBlockNumber).or(RpcEthChainId).or(RpcEthGetTransactionByHash)
    })).or(z.object({
        type: zType("APP_UPDATE_EMAIL"),
        payload: AppUpdateEmailRequest
    })).or(z.object({
        type: zType("APP_UPDATE_EMAIL_PRIMARY_OTP"),
        payload: AppUpdateEmailPrimaryOtpRequest
    })).or(z.object({
        type: zType("APP_UPDATE_EMAIL_SECONDARY_OTP"),
        payload: AppUpdateEmailSecondaryOtpRequest
    })).or(z.object({
        type: zType("APP_SYNC_THEME"),
        payload: AppSyncThemeRequest
    })).or(z.object({
        type: zType("APP_SYNC_DAPP_DATA"),
        payload: AppSyncDappDataRequest
    })),
    frameEvent: z.object({
        type: zType("FRAME_SWITCH_NETWORK_ERROR"),
        payload: zError
    }).or(z.object({
        type: zType("FRAME_SWITCH_NETWORK_SUCCESS"),
        payload: FrameSwitchNetworkResponse
    })).or(z.object({
        type: zType("FRAME_CONNECT_EMAIL_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_CONNECT_EMAIL_SUCCESS"),
        payload: FrameConnectEmailResponse
    })).or(z.object({
        type: zType("FRAME_CONNECT_OTP_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_CONNECT_OTP_SUCCESS")
    })).or(z.object({
        type: zType("FRAME_CONNECT_DEVICE_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_CONNECT_DEVICE_SUCCESS")
    })).or(z.object({
        type: zType("FRAME_GET_USER_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_GET_USER_SUCCESS"),
        payload: FrameGetUserResponse
    })).or(z.object({
        type: zType("FRAME_SIGN_OUT_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_SIGN_OUT_SUCCESS")
    })).or(z.object({
        type: zType("FRAME_IS_CONNECTED_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_IS_CONNECTED_SUCCESS"),
        payload: FrameIsConnectedResponse
    })).or(z.object({
        type: zType("FRAME_GET_CHAIN_ID_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_GET_CHAIN_ID_SUCCESS"),
        payload: FrameGetChainIdResponse
    })).or(z.object({
        type: zType("FRAME_RPC_REQUEST_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_RPC_REQUEST_SUCCESS"),
        payload: RpcResponse
    })).or(z.object({
        type: zType("FRAME_SESSION_UPDATE"),
        payload: FrameSession
    })).or(z.object({
        type: zType("FRAME_UPDATE_EMAIL_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_UPDATE_EMAIL_SUCCESS")
    })).or(z.object({
        type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS")
    })).or(z.object({
        type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
        payload: FrameUpdateEmailSecondaryOtpResolver
    })).or(z.object({
        type: zType("FRAME_SYNC_THEME_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_SYNC_THEME_SUCCESS")
    })).or(z.object({
        type: zType("FRAME_SYNC_DAPP_DATA_ERROR"),
        payload: zError
    })).or(z.object({
        type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS")
    }))
}
  , W3mFrameStorage = {
    set(_e, et) {
        W3mFrameHelpers.isClient && localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${_e}`, et)
    },
    get(_e) {
        return W3mFrameHelpers.isClient ? localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${_e}`) : null
    },
    delete(_e) {
        W3mFrameHelpers.isClient && localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${_e}`)
    }
}
  , RESTRICTED_TIMEZONES = ["ASIA/SHANGHAI", "ASIA/URUMQI", "ASIA/CHONGQING", "ASIA/HARBIN", "ASIA/KASHGAR", "ASIA/MACAU", "ASIA/HONG_KONG", "ASIA/MACAO", "ASIA/BEIJING", "ASIA/HARBIN"]
  , EMAIL_MINIMUM_TIMEOUT = 30 * 1e3
  , W3mFrameHelpers = {
    getBlockchainApiUrl() {
        try {
            const {timeZone: _e} = new Intl.DateTimeFormat().resolvedOptions()
              , et = _e.toUpperCase();
            return RESTRICTED_TIMEZONES.includes(et) ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com"
        } catch {
            return !1
        }
    },
    checkIfAllowedToTriggerEmail() {
        const _e = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
        if (_e) {
            const et = Date.now() - Number(_e);
            if (et < EMAIL_MINIMUM_TIMEOUT) {
                const tt = Math.ceil((EMAIL_MINIMUM_TIMEOUT - et) / 1e3);
                throw new Error(`Please try again after ${tt} seconds`)
            }
        }
    },
    getTimeToNextEmailLogin() {
        const _e = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
        if (_e) {
            const et = Date.now() - Number(_e);
            if (et < EMAIL_MINIMUM_TIMEOUT)
                return Math.ceil((EMAIL_MINIMUM_TIMEOUT - et) / 1e3)
        }
        return 0
    },
    checkIfRequestIsAllowed(_e) {
        var tt;
        const et = (tt = _e == null ? void 0 : _e.payload) == null ? void 0 : tt.method;
        return W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(et)
    },
    isClient: typeof window < "u"
};
class W3mFrame {
    constructor(et, tt=!1) {
        if (this.iframe = null,
        this.rpcUrl = W3mFrameHelpers.getBlockchainApiUrl(),
        this.events = {
            onFrameEvent: rt=>{
                W3mFrameHelpers.isClient && window.addEventListener("message", ({data: nt})=>{
                    var st;
                    if (!((st = nt.type) != null && st.includes(W3mFrameConstants.FRAME_EVENT_KEY)))
                        return;
                    const it = W3mFrameSchema.frameEvent.parse(nt);
                    rt(it)
                }
                )
            }
            ,
            onAppEvent: rt=>{
                W3mFrameHelpers.isClient && window.addEventListener("message", ({data: nt})=>{
                    var st;
                    if (!((st = nt.type) != null && st.includes(W3mFrameConstants.APP_EVENT_KEY)))
                        return;
                    const it = W3mFrameSchema.appEvent.parse(nt);
                    rt(it)
                }
                )
            }
            ,
            postAppEvent: rt=>{
                var nt;
                if (W3mFrameHelpers.isClient) {
                    if (!((nt = this.iframe) != null && nt.contentWindow))
                        throw new Error("W3mFrame: iframe is not set");
                    W3mFrameSchema.appEvent.parse(rt),
                    window.postMessage(rt),
                    this.iframe.contentWindow.postMessage(rt, "*")
                }
            }
            ,
            postFrameEvent: rt=>{
                if (W3mFrameHelpers.isClient) {
                    if (!parent)
                        throw new Error("W3mFrame: parent is not set");
                    W3mFrameSchema.frameEvent.parse(rt),
                    parent.postMessage(rt, "*")
                }
            }
        },
        this.projectId = et,
        this.frameLoadPromise = new Promise((rt,nt)=>{
            this.frameLoadPromiseResolver = {
                resolve: rt,
                reject: nt
            }
        }
        ),
        tt && (this.frameLoadPromise = new Promise((rt,nt)=>{
            this.frameLoadPromiseResolver = {
                resolve: rt,
                reject: nt
            }
        }
        ),
        W3mFrameHelpers.isClient)) {
            const rt = document.createElement("iframe");
            rt.id = "w3m-iframe",
            rt.src = `${W3mFrameConstants.SECURE_SITE_SDK}?projectId=${et}`,
            rt.style.position = "fixed",
            rt.style.zIndex = "999999",
            rt.style.display = "none",
            rt.style.opacity = "0",
            rt.style.borderRadius = "clamp(0px, var(--wui-border-radius-l), 44px)",
            document.body.appendChild(rt),
            this.iframe = rt,
            this.iframe.onload = ()=>{
                var nt;
                (nt = this.frameLoadPromiseResolver) == null || nt.resolve(void 0)
            }
            ,
            this.iframe.onerror = ()=>{
                var nt;
                (nt = this.frameLoadPromiseResolver) == null || nt.reject("Unable to load email login dependency")
            }
        }
    }
    get networks() {
        const et = [1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97, 43114, 43113, 324, 280, 100, 8453, 84531, 7777777, 999].map(tt=>({
            [tt]: {
                rpcUrl: `${this.rpcUrl}/v1/?chainId=eip155:${tt}&projectId=${this.projectId}`,
                chainId: tt
            }
        }));
        return Object.assign({}, ...et)
    }
}
class W3mFrameProvider {
    constructor(et) {
        this.connectEmailResolver = void 0,
        this.connectDeviceResolver = void 0,
        this.connectOtpResolver = void 0,
        this.connectResolver = void 0,
        this.disconnectResolver = void 0,
        this.isConnectedResolver = void 0,
        this.getChainIdResolver = void 0,
        this.switchChainResolver = void 0,
        this.rpcRequestResolver = void 0,
        this.updateEmailResolver = void 0,
        this.updateEmailPrimaryOtpResolver = void 0,
        this.updateEmailSecondaryOtpResolver = void 0,
        this.syncThemeResolver = void 0,
        this.syncDappDataResolver = void 0,
        this.w3mFrame = new W3mFrame(et,!0),
        this.w3mFrame.events.onFrameEvent(tt=>{
            switch (console.log("💻 received", tt),
            tt.type) {
            case W3mFrameConstants.FRAME_CONNECT_EMAIL_SUCCESS:
                return this.onConnectEmailSuccess(tt);
            case W3mFrameConstants.FRAME_CONNECT_EMAIL_ERROR:
                return this.onConnectEmailError(tt);
            case W3mFrameConstants.FRAME_CONNECT_DEVICE_SUCCESS:
                return this.onConnectDeviceSuccess();
            case W3mFrameConstants.FRAME_CONNECT_DEVICE_ERROR:
                return this.onConnectDeviceError(tt);
            case W3mFrameConstants.FRAME_CONNECT_OTP_SUCCESS:
                return this.onConnectOtpSuccess();
            case W3mFrameConstants.FRAME_CONNECT_OTP_ERROR:
                return this.onConnectOtpError(tt);
            case W3mFrameConstants.FRAME_GET_USER_SUCCESS:
                return this.onConnectSuccess(tt);
            case W3mFrameConstants.FRAME_GET_USER_ERROR:
                return this.onConnectError(tt);
            case W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS:
                return this.onIsConnectedSuccess(tt);
            case W3mFrameConstants.FRAME_IS_CONNECTED_ERROR:
                return this.onIsConnectedError(tt);
            case W3mFrameConstants.FRAME_GET_CHAIN_ID_SUCCESS:
                return this.onGetChainIdSuccess(tt);
            case W3mFrameConstants.FRAME_GET_CHAIN_ID_ERROR:
                return this.onGetChainIdError(tt);
            case W3mFrameConstants.FRAME_SIGN_OUT_SUCCESS:
                return this.onSignOutSuccess();
            case W3mFrameConstants.FRAME_SIGN_OUT_ERROR:
                return this.onSignOutError(tt);
            case W3mFrameConstants.FRAME_SWITCH_NETWORK_SUCCESS:
                return this.onSwitchChainSuccess(tt);
            case W3mFrameConstants.FRAME_SWITCH_NETWORK_ERROR:
                return this.onSwitchChainError(tt);
            case W3mFrameConstants.FRAME_RPC_REQUEST_SUCCESS:
                return this.onRpcRequestSuccess(tt);
            case W3mFrameConstants.FRAME_RPC_REQUEST_ERROR:
                return this.onRpcRequestError(tt);
            case W3mFrameConstants.FRAME_SESSION_UPDATE:
                return this.onSessionUpdate(tt);
            case W3mFrameConstants.FRAME_UPDATE_EMAIL_SUCCESS:
                return this.onUpdateEmailSuccess();
            case W3mFrameConstants.FRAME_UPDATE_EMAIL_ERROR:
                return this.onUpdateEmailError(tt);
            case W3mFrameConstants.FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
                return this.onUpdateEmailPrimaryOtpSuccess();
            case W3mFrameConstants.FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
                return this.onUpdateEmailPrimaryOtpError(tt);
            case W3mFrameConstants.FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
                return this.onUpdateEmailSecondaryOtpSuccess(tt);
            case W3mFrameConstants.FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
                return this.onUpdateEmailSecondaryOtpError(tt);
            case W3mFrameConstants.FRAME_SYNC_THEME_SUCCESS:
                return this.onSyncThemeSuccess();
            case W3mFrameConstants.FRAME_SYNC_THEME_ERROR:
                return this.onSyncThemeError(tt);
            case W3mFrameConstants.FRAME_SYNC_DAPP_DATA_SUCCESS:
                return this.onSyncDappDataSuccess();
            case W3mFrameConstants.FRAME_SYNC_DAPP_DATA_ERROR:
                return this.onSyncDappDataError(tt);
            default:
                return null
            }
        }
        )
    }
    getLoginEmailUsed() {
        return !!W3mFrameStorage.get(W3mFrameConstants.EMAIL_LOGIN_USED_KEY)
    }
    getEmail() {
        return W3mFrameStorage.get(W3mFrameConstants.EMAIL)
    }
    async connectEmail(et) {
        return await this.w3mFrame.frameLoadPromise,
        W3mFrameHelpers.checkIfAllowedToTriggerEmail(),
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_CONNECT_EMAIL,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.connectEmailResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async connectDevice() {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_CONNECT_DEVICE
        }),
        new Promise((et,tt)=>{
            this.connectDeviceResolver = {
                resolve: et,
                reject: tt
            }
        }
        )
    }
    async connectOtp(et) {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_CONNECT_OTP,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.connectOtpResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async isConnected() {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_IS_CONNECTED,
            payload: void 0
        }),
        new Promise((et,tt)=>{
            this.isConnectedResolver = {
                resolve: et,
                reject: tt
            }
        }
        )
    }
    async getChainId() {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_GET_CHAIN_ID
        }),
        new Promise((et,tt)=>{
            this.getChainIdResolver = {
                resolve: et,
                reject: tt
            }
        }
        )
    }
    async updateEmail(et) {
        return await this.w3mFrame.frameLoadPromise,
        W3mFrameHelpers.checkIfAllowedToTriggerEmail(),
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_UPDATE_EMAIL,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.updateEmailResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async updateEmailPrimaryOtp(et) {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_UPDATE_EMAIL_PRIMARY_OTP,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.updateEmailPrimaryOtpResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async updateEmailSecondaryOtp(et) {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_UPDATE_EMAIL_SECONDARY_OTP,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.updateEmailSecondaryOtpResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async syncTheme(et) {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_SYNC_THEME,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.syncThemeResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async syncDappData(et) {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_SYNC_DAPP_DATA,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.syncDappDataResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async connect(et) {
        const tt = (et == null ? void 0 : et.chainId) ?? this.getLastUsedChainId() ?? 1;
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_GET_USER,
            payload: {
                chainId: tt
            }
        }),
        new Promise((rt,nt)=>{
            this.connectResolver = {
                resolve: rt,
                reject: nt
            }
        }
        )
    }
    async switchNetwork(et) {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_SWITCH_NETWORK,
            payload: {
                chainId: et
            }
        }),
        new Promise((tt,rt)=>{
            this.switchChainResolver = {
                resolve: tt,
                reject: rt
            }
        }
        )
    }
    async disconnect() {
        return await this.w3mFrame.frameLoadPromise,
        this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_SIGN_OUT
        }),
        new Promise((et,tt)=>{
            this.disconnectResolver = {
                resolve: et,
                reject: tt
            }
        }
        )
    }
    async request(et) {
        return await this.w3mFrame.frameLoadPromise,
        W3mFrameRpcConstants.GET_CHAIN_ID === et.method ? this.getLastUsedChainId() : (this.w3mFrame.events.postAppEvent({
            type: W3mFrameConstants.APP_RPC_REQUEST,
            payload: et
        }),
        new Promise((tt,rt)=>{
            this.rpcRequestResolver = {
                resolve: tt,
                reject: rt
            }
        }
        ))
    }
    onRpcRequest(et) {
        this.w3mFrame.events.onAppEvent(tt=>{
            tt.type.includes(W3mFrameConstants.RPC_METHOD_KEY) && et(tt)
        }
        )
    }
    onRpcResponse(et) {
        this.w3mFrame.events.onFrameEvent(tt=>{
            tt.type.includes(W3mFrameConstants.RPC_METHOD_KEY) && et(tt)
        }
        )
    }
    onIsConnected(et) {
        this.w3mFrame.events.onFrameEvent(tt=>{
            tt.type === W3mFrameConstants.FRAME_GET_USER_SUCCESS && et()
        }
        )
    }
    onConnectEmailSuccess(et) {
        var tt;
        (tt = this.connectEmailResolver) == null || tt.resolve(et.payload),
        this.setNewLastEmailLoginTime()
    }
    onConnectEmailError(et) {
        var tt;
        (tt = this.connectEmailResolver) == null || tt.reject(et.payload.message)
    }
    onConnectDeviceSuccess() {
        var et;
        (et = this.connectDeviceResolver) == null || et.resolve(void 0)
    }
    onConnectDeviceError(et) {
        var tt;
        (tt = this.connectDeviceResolver) == null || tt.reject(et.payload.message)
    }
    onConnectOtpSuccess() {
        var et;
        (et = this.connectOtpResolver) == null || et.resolve(void 0)
    }
    onConnectOtpError(et) {
        var tt;
        (tt = this.connectOtpResolver) == null || tt.reject(et.payload.message)
    }
    onConnectSuccess(et) {
        var tt;
        this.setEmailLoginSuccess(et.payload.email),
        this.setLastUsedChainId(et.payload.chainId),
        (tt = this.connectResolver) == null || tt.resolve(et.payload)
    }
    onConnectError(et) {
        var tt;
        (tt = this.connectResolver) == null || tt.reject(et.payload.message)
    }
    onIsConnectedSuccess(et) {
        var tt;
        et.payload.isConnected || this.deleteEmailLoginCache(),
        (tt = this.isConnectedResolver) == null || tt.resolve(et.payload)
    }
    onIsConnectedError(et) {
        var tt;
        (tt = this.isConnectedResolver) == null || tt.reject(et.payload.message)
    }
    onGetChainIdSuccess(et) {
        var tt;
        this.setLastUsedChainId(et.payload.chainId),
        (tt = this.getChainIdResolver) == null || tt.resolve(et.payload)
    }
    onGetChainIdError(et) {
        var tt;
        (tt = this.getChainIdResolver) == null || tt.reject(et.payload.message)
    }
    onSignOutSuccess() {
        var et;
        (et = this.disconnectResolver) == null || et.resolve(void 0),
        this.deleteEmailLoginCache()
    }
    onSignOutError(et) {
        var tt;
        (tt = this.disconnectResolver) == null || tt.reject(et.payload.message)
    }
    onSwitchChainSuccess(et) {
        var tt;
        this.setLastUsedChainId(et.payload.chainId),
        (tt = this.switchChainResolver) == null || tt.resolve(et.payload)
    }
    onSwitchChainError(et) {
        var tt;
        (tt = this.switchChainResolver) == null || tt.reject(et.payload.message)
    }
    onRpcRequestSuccess(et) {
        var tt;
        (tt = this.rpcRequestResolver) == null || tt.resolve(et.payload)
    }
    onRpcRequestError(et) {
        var tt;
        (tt = this.rpcRequestResolver) == null || tt.reject(et.payload.message)
    }
    onSessionUpdate(et) {}
    onUpdateEmailSuccess() {
        var et;
        (et = this.updateEmailResolver) == null || et.resolve(void 0),
        this.setNewLastEmailLoginTime()
    }
    onUpdateEmailError(et) {
        var tt;
        (tt = this.updateEmailResolver) == null || tt.reject(et.payload.message)
    }
    onUpdateEmailPrimaryOtpSuccess() {
        var et;
        (et = this.updateEmailPrimaryOtpResolver) == null || et.resolve(void 0)
    }
    onUpdateEmailPrimaryOtpError(et) {
        var tt;
        (tt = this.updateEmailPrimaryOtpResolver) == null || tt.reject(et.payload.message)
    }
    onUpdateEmailSecondaryOtpSuccess(et) {
        var rt;
        const {newEmail: tt} = et.payload;
        this.setEmailLoginSuccess(tt),
        (rt = this.updateEmailSecondaryOtpResolver) == null || rt.resolve({
            newEmail: tt
        })
    }
    onUpdateEmailSecondaryOtpError(et) {
        var tt;
        (tt = this.updateEmailSecondaryOtpResolver) == null || tt.reject(et.payload.message)
    }
    onSyncThemeSuccess() {
        var et;
        (et = this.syncThemeResolver) == null || et.resolve(void 0)
    }
    onSyncThemeError(et) {
        var tt;
        (tt = this.syncThemeResolver) == null || tt.reject(et.payload.message)
    }
    onSyncDappDataSuccess() {
        var et;
        (et = this.syncDappDataResolver) == null || et.resolve(void 0)
    }
    onSyncDappDataError(et) {
        var tt;
        (tt = this.syncDappDataResolver) == null || tt.reject(et.payload.message)
    }
    setNewLastEmailLoginTime() {
        W3mFrameStorage.set(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME, Date.now().toString())
    }
    setEmailLoginSuccess(et) {
        W3mFrameStorage.set(W3mFrameConstants.EMAIL, et),
        W3mFrameStorage.set(W3mFrameConstants.EMAIL_LOGIN_USED_KEY, "true"),
        W3mFrameStorage.delete(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME)
    }
    deleteEmailLoginCache() {
        W3mFrameStorage.delete(W3mFrameConstants.EMAIL_LOGIN_USED_KEY),
        W3mFrameStorage.delete(W3mFrameConstants.EMAIL),
        W3mFrameStorage.delete(W3mFrameConstants.LAST_USED_CHAIN_KEY)
    }
    setLastUsedChainId(et) {
        W3mFrameStorage.set(W3mFrameConstants.LAST_USED_CHAIN_KEY, `${et}`)
    }
    getLastUsedChainId() {
        return Number(W3mFrameStorage.get(W3mFrameConstants.LAST_USED_CHAIN_KEY))
    }
}
var __decorate$q = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const OTP_LENGTH = 6;
let W3mEmailOtpWidget = class extends s$1 {
    firstUpdated() {
        this.startOTPTimeout()
    }
    disconnectedCallback() {
        clearTimeout(this.OTPTimeout)
    }
    constructor() {
        var et;
        super(),
        this.loading = !1,
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin(),
        this.error = "",
        this.otp = "",
        this.email = (et = RouterController.state.data) == null ? void 0 : et.email,
        this.emailConnector = ConnectorController.getEmailConnector()
    }
    render() {
        if (!this.email)
            throw new Error("w3m-email-otp-widget: No email provided");
        const et = !!this.timeoutTimeLeft
          , tt = this.getFooterLabels(et);
        return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">Enter the code we sent to</wui-text>
          <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 10 minutes</wui-text>

        ${this.loading ? x`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : x` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error ? x`
                    <wui-text variant="small-400" color="error-100">
                      ${this.error}. Try Again
                    </wui-text>
                  ` : null}
            </wui-flex>`}

        <wui-flex alignItems="center">
          <wui-text variant="small-400" color="fg-200">${tt.title}</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${et}>
            ${tt.action}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `
    }
    startOTPTimeout() {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin(),
        this.OTPTimeout = setInterval(()=>{
            this.timeoutTimeLeft > 0 ? this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin() : clearInterval(this.OTPTimeout)
        }
        , 1e3)
    }
    async onOtpInputChange(et) {
        var tt;
        try {
            this.loading || (this.otp = et.detail,
            this.emailConnector && this.otp.length === OTP_LENGTH && (this.loading = !0,
            await ((tt = this.onOtpSubmit) == null ? void 0 : tt.call(this, this.otp))))
        } catch (rt) {
            this.error = CoreHelperUtil.parseError(rt),
            this.loading = !1
        }
    }
    async onResendCode() {
        try {
            if (this.onOtpResend) {
                if (!this.loading && !this.timeoutTimeLeft) {
                    if (this.error = "",
                    this.otp = "",
                    !ConnectorController.getEmailConnector() || !this.email)
                        throw new Error("w3m-email-otp-widget: Unable to resend email");
                    this.loading = !0,
                    await this.onOtpResend(this.email),
                    this.startOTPTimeout(),
                    SnackController.showSuccess("Code email resent")
                }
            } else
                this.onStartOver && this.onStartOver()
        } catch (et) {
            SnackController.showError(et)
        } finally {
            this.loading = !1
        }
    }
    getFooterLabels(et) {
        return this.onStartOver ? {
            title: "Something wrong?",
            action: `Try again ${et ? `in ${this.timeoutTimeLeft}s` : ""}`
        } : {
            title: "Didn't receive it?",
            action: `Resend ${et ? `in ${this.timeoutTimeLeft}s` : "Code"}`
        }
    }
}
;
W3mEmailOtpWidget.styles = styles$f;
__decorate$q([r$3()], W3mEmailOtpWidget.prototype, "loading", void 0);
__decorate$q([r$3()], W3mEmailOtpWidget.prototype, "timeoutTimeLeft", void 0);
__decorate$q([r$3()], W3mEmailOtpWidget.prototype, "error", void 0);
W3mEmailOtpWidget = __decorate$q([customElement("w3m-email-otp-widget")], W3mEmailOtpWidget);
var __decorate$p = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mEmailVerifyOtpView = class extends W3mEmailOtpWidget {
    constructor() {
        super(),
        this.onOtpSubmit = async et=>{
            try {
                this.emailConnector && (await this.emailConnector.provider.connectOtp({
                    otp: et
                }),
                EventsController.sendEvent({
                    type: "track",
                    event: "EMAIL_VERIFICATION_CODE_PASS"
                }),
                await ConnectionController.connectExternal(this.emailConnector),
                ModalController.close(),
                EventsController.sendEvent({
                    type: "track",
                    event: "CONNECT_SUCCESS",
                    properties: {
                        method: "email"
                    }
                }))
            } catch (tt) {
                throw EventsController.sendEvent({
                    type: "track",
                    event: "EMAIL_VERIFICATION_CODE_FAIL"
                }),
                tt
            }
        }
        ,
        this.onOtpResend = async et=>{
            this.emailConnector && (await this.emailConnector.provider.connectEmail({
                email: et
            }),
            EventsController.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_SENT"
            }))
        }
    }
}
;
W3mEmailVerifyOtpView = __decorate$p([customElement("w3m-email-verify-otp-view")], W3mEmailVerifyOtpView);
const styles$e = i$4`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$o = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mEmailVerifyDeviceView = class extends s$1 {
    constructor() {
        var et;
        super(),
        this.email = (et = RouterController.state.data) == null ? void 0 : et.email,
        this.emailConnector = ConnectorController.getEmailConnector(),
        this.loading = !1,
        this.listenForDeviceApproval()
    }
    render() {
        if (!this.email)
            throw new Error("w3m-email-verify-device-view: No email provided");
        if (!this.emailConnector)
            throw new Error("w3m-email-verify-device-view: No email connector provided");
        return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 10 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `
    }
    async listenForDeviceApproval() {
        this.emailConnector && (await this.emailConnector.provider.connectDevice(),
        EventsController.sendEvent({
            type: "track",
            event: "DEVICE_REGISTERED_FOR_EMAIL"
        }),
        EventsController.sendEvent({
            type: "track",
            event: "EMAIL_VERIFICATION_CODE_SENT"
        }),
        RouterController.replace("EmailVerifyOtp", {
            email: this.email
        }))
    }
    async onResendCode() {
        try {
            if (!this.loading) {
                if (!this.emailConnector || !this.email)
                    throw new Error("w3m-email-login-widget: Unable to resend email");
                this.loading = !0,
                await this.emailConnector.provider.connectEmail({
                    email: this.email
                }),
                SnackController.showSuccess("Code email resent")
            }
        } catch (et) {
            SnackController.showError(et)
        } finally {
            this.loading = !1
        }
    }
}
;
W3mEmailVerifyDeviceView.styles = styles$e;
__decorate$o([r$3()], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate$o([customElement("w3m-email-verify-device-view")], W3mEmailVerifyDeviceView);
const styles$d = i$4`
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var __decorate$n = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mApproveTransactionView = class extends s$1 {
    constructor() {
        super(),
        this.bodyObserver = void 0,
        this.unsubscribe = [],
        this.iframe = document.getElementById("w3m-iframe"),
        this.ready = !1,
        this.unsubscribe.push(ModalController.subscribeKey("open", et=>{
            et || this.onHideIframe()
        }
        ))
    }
    disconnectedCallback() {
        var et;
        this.unsubscribe.forEach(tt=>tt()),
        (et = this.bodyObserver) == null || et.unobserve(window.document.body)
    }
    async firstUpdated() {
        await this.syncTheme(),
        this.iframe.style.display = "block";
        const tt = this.renderRoot.querySelector("div");
        this.bodyObserver = new ResizeObserver(()=>{
            const nt = (tt == null ? void 0 : tt.getBoundingClientRect()) ?? {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
            this.iframe.style.width = `${nt.width}px`,
            this.iframe.style.height = `${nt.height - 10}px`,
            this.iframe.style.left = `${nt.left}px`,
            this.iframe.style.top = `${nt.top + 10 / 2}px`,
            this.ready = !0
        }
        ),
        this.bodyObserver.observe(window.document.body)
    }
    render() {
        return this.ready && this.onShowIframe(),
        x`<div data-ready=${this.ready}></div>`
    }
    onShowIframe() {
        const et = window.innerWidth <= 430;
        this.iframe.animate([{
            opacity: 0,
            transform: et ? "translateY(50px)" : "scale(.95)"
        }, {
            opacity: 1,
            transform: et ? "translateY(0)" : "scale(1)"
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards",
            delay: 300
        })
    }
    async onHideIframe() {
        await this.iframe.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards"
        }).finished,
        this.iframe.style.display = "none"
    }
    async syncTheme() {
        const et = ConnectorController.getEmailConnector();
        et && await et.provider.syncTheme({
            themeVariables: ThemeController.getSnapshot().themeVariables
        })
    }
}
;
W3mApproveTransactionView.styles = styles$d;
__decorate$n([r$3()], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate$n([customElement("w3m-approve-transaction-view")], W3mApproveTransactionView);
var __decorate$m = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mUpgradeWalletView = class extends s$1 {
    render() {
        return x`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil$1.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil$1.SECURE_SITE_FAVICON}
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `
    }
}
;
W3mUpgradeWalletView = __decorate$m([customElement("w3m-upgrade-wallet-view")], W3mUpgradeWalletView);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f$1 = _e=>_e.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
}
  , e$1 = _e=>(...et)=>({
    _$litDirective$: _e,
    values: et
});
let i$1 = class {
    constructor(et) {}
    get _$AU() {
        return this._$AM._$AU
    }
    _$AT(et, tt, rt) {
        this._$Ct = et,
        this._$AM = tt,
        this._$Ci = rt
    }
    _$AS(et, tt) {
        return this.update(et, tt)
    }
    update(et, tt) {
        return this.render(...tt)
    }
}
;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s = (_e,et)=>{
    var rt;
    const tt = _e._$AN;
    if (tt === void 0)
        return !1;
    for (const nt of tt)
        (rt = nt._$AO) == null || rt.call(nt, et, !1),
        s(nt, et);
    return !0
}
  , o$1 = _e=>{
    let et, tt;
    do {
        if ((et = _e._$AM) === void 0)
            break;
        tt = et._$AN,
        tt.delete(_e),
        _e = et
    } while ((tt == null ? void 0 : tt.size) === 0)
}
  , r$2 = _e=>{
    for (let et; et = _e._$AM; _e = et) {
        let tt = et._$AN;
        if (tt === void 0)
            et._$AN = tt = new Set;
        else if (tt.has(_e))
            break;
        tt.add(_e),
        c(et)
    }
}
;
function h$3(_e) {
    this._$AN !== void 0 ? (o$1(this),
    this._$AM = _e,
    r$2(this)) : this._$AM = _e
}
function n$3(_e, et=!1, tt=0) {
    const rt = this._$AH
      , nt = this._$AN;
    if (nt !== void 0 && nt.size !== 0)
        if (et)
            if (Array.isArray(rt))
                for (let it = tt; it < rt.length; it++)
                    s(rt[it], !1),
                    o$1(rt[it]);
            else
                rt != null && (s(rt, !1),
                o$1(rt));
        else
            s(this, _e)
}
const c = _e=>{
    _e.type == t$2.CHILD && (_e._$AP ?? (_e._$AP = n$3),
    _e._$AQ ?? (_e._$AQ = h$3))
}
;
class f extends i$1 {
    constructor() {
        super(...arguments),
        this._$AN = void 0
    }
    _$AT(et, tt, rt) {
        super._$AT(et, tt, rt),
        r$2(this),
        this.isConnected = et._$AU
    }
    _$AO(et, tt=!0) {
        var rt, nt;
        et !== this.isConnected && (this.isConnected = et,
        et ? (rt = this.reconnected) == null || rt.call(this) : (nt = this.disconnected) == null || nt.call(this)),
        tt && (s(this, et),
        o$1(this))
    }
    setValue(et) {
        if (f$1(this._$Ct))
            this._$Ct._$AI(et, this);
        else {
            const tt = [...this._$Ct._$AH];
            tt[this._$Ci] = et,
            this._$Ct._$AI(tt, this, 0)
        }
    }
    disconnected() {}
    reconnected() {}
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e = ()=>new h$2;
let h$2 = class {
}
;
const o = new WeakMap
  , n$2 = e$1(class extends f {
    render(_e) {
        return T
    }
    update(_e, [et]) {
        var rt;
        const tt = et !== this.Y;
        return tt && this.Y !== void 0 && this.rt(void 0),
        (tt || this.lt !== this.ct) && (this.Y = et,
        this.ht = (rt = _e.options) == null ? void 0 : rt.host,
        this.rt(this.ct = _e.element)),
        T
    }
    rt(_e) {
        if (typeof this.Y == "function") {
            const et = this.ht ?? globalThis;
            let tt = o.get(et);
            tt === void 0 && (tt = new WeakMap,
            o.set(et, tt)),
            tt.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0),
            tt.set(this.Y, _e),
            _e !== void 0 && this.Y.call(this.ht, _e)
        } else
            this.Y.value = _e
    }
    get lt() {
        var _e, et;
        return typeof this.Y == "function" ? (_e = o.get(this.ht ?? globalThis)) == null ? void 0 : _e.get(this.Y) : (et = this.Y) == null ? void 0 : et.value
    }
    disconnected() {
        this.lt === this.ct && this.rt(void 0)
    }
    reconnected() {
        this.rt(this.ct)
    }
}
)
  , styles$c = i$4`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var __decorate$l = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mUpdateEmailWalletView = class extends s$1 {
    constructor() {
        var et;
        super(...arguments),
        this.formRef = e(),
        this.initialEmail = ((et = RouterController.state.data) == null ? void 0 : et.email) ?? "",
        this.email = "",
        this.loading = !1
    }
    firstUpdated() {
        var et;
        (et = this.formRef.value) == null || et.addEventListener("keydown", tt=>{
            tt.key === "Enter" && this.onSubmitEmail(tt)
        }
        )
    }
    render() {
        const et = !this.loading && this.email.length > 3 && this.email !== this.initialEmail;
        return x`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${n$2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialEmail}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="shade" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="fill"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!et}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `
    }
    onEmailInputChange(et) {
        this.email = et.detail
    }
    async onSubmitEmail(et) {
        try {
            if (this.loading)
                return;
            this.loading = !0,
            et.preventDefault();
            const tt = ConnectorController.getEmailConnector();
            if (!tt)
                throw new Error("w3m-update-email-wallet: Email connector not found");
            await tt.provider.updateEmail({
                email: this.email
            }),
            EventsController.sendEvent({
                type: "track",
                event: "EMAIL_EDIT"
            }),
            RouterController.replace("UpdateEmailPrimaryOtp", {
                email: this.initialEmail,
                newEmail: this.email
            })
        } catch (tt) {
            SnackController.showError(tt),
            this.loading = !1
        }
    }
}
;
W3mUpdateEmailWalletView.styles = styles$c;
__decorate$l([r$3()], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate$l([r$3()], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate$l([customElement("w3m-update-email-wallet-view")], W3mUpdateEmailWalletView);
var __decorate$k = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mUpdateEmailPrimaryOtpView = class extends W3mEmailOtpWidget {
    constructor() {
        var et;
        super(),
        this.email = (et = RouterController.state.data) == null ? void 0 : et.email,
        this.onOtpSubmit = async tt=>{
            try {
                this.emailConnector && (await this.emailConnector.provider.updateEmailPrimaryOtp({
                    otp: tt
                }),
                EventsController.sendEvent({
                    type: "track",
                    event: "EMAIL_VERIFICATION_CODE_PASS"
                }),
                RouterController.replace("UpdateEmailSecondaryOtp", RouterController.state.data))
            } catch (rt) {
                throw EventsController.sendEvent({
                    type: "track",
                    event: "EMAIL_VERIFICATION_CODE_FAIL"
                }),
                rt
            }
        }
        ,
        this.onStartOver = ()=>{
            RouterController.replace("UpdateEmailWallet", RouterController.state.data)
        }
    }
}
;
W3mUpdateEmailPrimaryOtpView = __decorate$k([customElement("w3m-update-email-primary-otp-view")], W3mUpdateEmailPrimaryOtpView);
var __decorate$j = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mUpdateEmailSecondaryOtpView = class extends W3mEmailOtpWidget {
    constructor() {
        var et;
        super(),
        this.email = (et = RouterController.state.data) == null ? void 0 : et.newEmail,
        this.onOtpSubmit = async tt=>{
            try {
                this.emailConnector && (await this.emailConnector.provider.updateEmailSecondaryOtp({
                    otp: tt
                }),
                EventsController.sendEvent({
                    type: "track",
                    event: "EMAIL_VERIFICATION_CODE_PASS"
                }),
                RouterController.replace("Account", {
                    email: this.email
                }))
            } catch (rt) {
                throw EventsController.sendEvent({
                    type: "track",
                    event: "EMAIL_VERIFICATION_CODE_FAIL"
                }),
                rt
            }
        }
        ,
        this.onStartOver = ()=>{
            RouterController.replace("UpdateEmailWallet", RouterController.state.data)
        }
    }
}
;
W3mUpdateEmailSecondaryOtpView = __decorate$j([customElement("w3m-update-email-secondary-otp-view")], W3mUpdateEmailSecondaryOtpView);
const styles$b = i$4`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$i = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mUnsupportedChainView = class extends s$1 {
    constructor() {
        super(...arguments),
        this.disconecting = !1
    }
    render() {
        return x`
      <wui-flex class="container" flexDirection="column" gap="0">
        <wui-flex
          class="container"
          flexDirection="column"
          .padding=${["m", "xl", "xs", "xl"]}
          alignItems="center"
          gap="xl"
        >
          <wui-text variant="small-400" color="fg-200" align="center">
            This app doesn’t support your current network. Switch to an available option following
            to continue.
          </wui-text>
        </wui-flex>

        <wui-flex flexDirection="column" padding="s" gap="xs">
          ${this.networksTemplate()}
        </wui-flex>

        <wui-separator text="or"></wui-separator>
        <wui-flex flexDirection="column" padding="s" gap="xs">
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${!1}
            .loading=${this.disconecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `
    }
    networksTemplate() {
        const {approvedCaipNetworkIds: et, requestedCaipNetworks: tt} = NetworkController.state;
        return CoreHelperUtil.sortRequestedNetworks(et, tt).map(nt=>x`
        <wui-list-network
          imageSrc=${o$2(AssetUtil.getNetworkImage(nt))}
          name=${nt.name ?? "Unknown"}
          @click=${()=>this.onSwitchNetwork(nt)}
        >
        </wui-list-network>
      `)
    }
    async onDisconnect() {
        try {
            this.disconecting = !0,
            await ConnectionController.disconnect(),
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_SUCCESS"
            }),
            ModalController.close()
        } catch {
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_ERROR"
            }),
            SnackController.showError("Failed to disconnect")
        } finally {
            this.disconecting = !1
        }
    }
    async onSwitchNetwork(et) {
        const {isConnected: tt} = AccountController.state
          , {approvedCaipNetworkIds: rt, supportsAllNetworks: nt, caipNetwork: it} = NetworkController.state
          , {data: st} = RouterController.state;
        tt && (it == null ? void 0 : it.id) !== et.id ? rt != null && rt.includes(et.id) ? (await NetworkController.switchActiveNetwork(et),
        RouterUtil.navigateAfterNetworkSwitch()) : nt && RouterController.push("SwitchNetwork", {
            ...st,
            network: et
        }) : tt || (NetworkController.setCaipNetwork(et),
        RouterController.push("Connect"))
    }
}
;
W3mUnsupportedChainView.styles = styles$b;
__decorate$i([r$3()], W3mUnsupportedChainView.prototype, "disconecting", void 0);
W3mUnsupportedChainView = __decorate$i([customElement("w3m-unsupported-chain-view")], W3mUnsupportedChainView);
const styles$a = i$4`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
function markWalletsAsInstalled(_e) {
    const {connectors: et} = ConnectorController.state
      , tt = et.filter(it=>it.type === "ANNOUNCED").reduce((it,st)=>{
        var at;
        return (at = st.info) != null && at.rdns && (it[st.info.rdns] = !0),
        it
    }
    , {});
    return _e.map(it=>({
        ...it,
        installed: !!it.rdns && !!tt[it.rdns ?? ""]
    })).sort((it,st)=>Number(st.installed) - Number(it.installed))
}
var __decorate$h = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const PAGINATOR_ID = "local-paginator";
let W3mAllWalletsList = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.paginationObserver = void 0,
        this.initial = !ApiController.state.wallets.length,
        this.wallets = ApiController.state.wallets,
        this.recommended = ApiController.state.recommended,
        this.featured = ApiController.state.featured,
        this.unsubscribe.push(ApiController.subscribeKey("wallets", et=>this.wallets = et), ApiController.subscribeKey("recommended", et=>this.recommended = et), ApiController.subscribeKey("featured", et=>this.featured = et))
    }
    firstUpdated() {
        this.initialFetch(),
        this.createPaginationObserver()
    }
    disconnectedCallback() {
        var et;
        this.unsubscribe.forEach(tt=>tt()),
        (et = this.paginationObserver) == null || et.disconnect()
    }
    render() {
        return x`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `
    }
    async initialFetch() {
        var tt;
        const et = (tt = this.shadowRoot) == null ? void 0 : tt.querySelector("wui-grid");
        this.initial && et && (await ApiController.fetchWallets({
            page: 1
        }),
        await et.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.initial = !1,
        et.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
    shimmerTemplate(et, tt) {
        return [...Array(et)].map(()=>x`
        <wui-card-select-loader type="wallet" id=${o$2(tt)}></wui-card-select-loader>
      `)
    }
    walletsTemplate() {
        const et = [...this.featured, ...this.recommended, ...this.wallets];
        return markWalletsAsInstalled(et).map(rt=>x`
        <wui-card-select
          imageSrc=${o$2(AssetUtil.getWalletImage(rt))}
          type="wallet"
          name=${rt.name}
          @click=${()=>this.onConnectWallet(rt)}
          .installed=${rt.installed}
        ></wui-card-select>
      `)
    }
    paginationLoaderTemplate() {
        const {wallets: et, recommended: tt, featured: rt, count: nt} = ApiController.state
          , it = window.innerWidth < 352 ? 3 : 4
          , st = et.length + tt.length;
        let ot = Math.ceil(st / it) * it - st + it;
        return ot -= et.length ? rt.length % it : 0,
        nt === 0 && rt.length > 0 ? null : nt === 0 || [...rt, ...et, ...tt].length < nt ? this.shimmerTemplate(ot, PAGINATOR_ID) : null
    }
    createPaginationObserver() {
        var tt;
        const et = (tt = this.shadowRoot) == null ? void 0 : tt.querySelector(`#${PAGINATOR_ID}`);
        et && (this.paginationObserver = new IntersectionObserver(([rt])=>{
            if (rt != null && rt.isIntersecting && !this.initial) {
                const {page: nt, count: it, wallets: st} = ApiController.state;
                st.length < it && ApiController.fetchWallets({
                    page: nt + 1
                })
            }
        }
        ),
        this.paginationObserver.observe(et))
    }
    onConnectWallet(et) {
        const {connectors: tt} = ConnectorController.state
          , rt = tt.find(({explorerId: nt})=>nt === et.id);
        rt ? RouterController.push("ConnectingExternal", {
            connector: rt
        }) : RouterController.push("ConnectingWalletConnect", {
            wallet: et
        })
    }
}
;
W3mAllWalletsList.styles = styles$a;
__decorate$h([r$3()], W3mAllWalletsList.prototype, "initial", void 0);
__decorate$h([r$3()], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate$h([r$3()], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate$h([r$3()], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate$h([customElement("w3m-all-wallets-list")], W3mAllWalletsList);
const styles$9 = i$4`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var __decorate$g = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mAllWalletsSearch = class extends s$1 {
    constructor() {
        super(...arguments),
        this.prevQuery = "",
        this.loading = !0,
        this.query = ""
    }
    render() {
        return this.onSearch(),
        this.loading ? x`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate()
    }
    async onSearch() {
        this.query !== this.prevQuery && (this.prevQuery = this.query,
        this.loading = !0,
        await ApiController.searchWallet({
            search: this.query
        }),
        this.loading = !1)
    }
    walletsTemplate() {
        const {search: et} = ApiController.state
          , tt = markWalletsAsInstalled(et);
        return et.length ? x`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${tt.map(rt=>x`
            <wui-card-select
              imageSrc=${o$2(AssetUtil.getWalletImage(rt))}
              type="wallet"
              name=${rt.name}
              @click=${()=>this.onConnectWallet(rt)}
              .installed=${rt.installed}
            ></wui-card-select>
          `)}
      </wui-grid>
    ` : x`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `
    }
    onConnectWallet(et) {
        const {connectors: tt} = ConnectorController.state
          , rt = tt.find(({explorerId: nt})=>nt === et.id);
        rt ? RouterController.push("ConnectingExternal", {
            connector: rt
        }) : RouterController.push("ConnectingWalletConnect", {
            wallet: et
        })
    }
}
;
W3mAllWalletsSearch.styles = styles$9;
__decorate$g([r$3()], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate$g([n$4()], W3mAllWalletsSearch.prototype, "query", void 0);
W3mAllWalletsSearch = __decorate$g([customElement("w3m-all-wallets-search")], W3mAllWalletsSearch);
var __decorate$f = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingHeader = class extends s$1 {
    constructor() {
        super(),
        this.platformTabs = [],
        this.unsubscribe = [],
        this.platforms = [],
        this.onSelectPlatfrom = void 0,
        this.buffering = !1,
        this.unsubscribe.push(ConnectionController.subscribeKey("buffering", et=>this.buffering = et))
    }
    disconnectCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        const et = this.generateTabs();
        return x`
      <wui-flex justifyContent="center" .padding=${["l", "0", "0", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${et}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `
    }
    generateTabs() {
        const et = this.platforms.map(tt=>tt === "browser" ? {
            label: "Browser",
            icon: "extension",
            platform: "browser"
        } : tt === "mobile" ? {
            label: "Mobile",
            icon: "mobile",
            platform: "mobile"
        } : tt === "qrcode" ? {
            label: "Mobile",
            icon: "mobile",
            platform: "qrcode"
        } : tt === "web" ? {
            label: "Webapp",
            icon: "browser",
            platform: "web"
        } : tt === "desktop" ? {
            label: "Desktop",
            icon: "desktop",
            platform: "desktop"
        } : {
            label: "Browser",
            icon: "extension",
            platform: "unsupported"
        });
        return this.platformTabs = et.map(({platform: tt})=>tt),
        et
    }
    onTabChange(et) {
        var rt;
        const tt = this.platformTabs[et];
        tt && ((rt = this.onSelectPlatfrom) == null || rt.call(this, tt))
    }
}
;
__decorate$f([n$4({
    type: Array
})], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate$f([n$4()], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate$f([r$3()], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate$f([customElement("w3m-connecting-header")], W3mConnectingHeader);
var __decorate$e = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingWcBrowser = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-browser: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.onAutoConnect = this.onConnectProxy.bind(this),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "browser"
            }
        })
    }
    async onConnectProxy() {
        try {
            this.error = !1;
            const {connectors: et} = ConnectorController.state
              , tt = et.find(nt=>{
                var it, st;
                return nt.type === "ANNOUNCED" && ((it = nt.info) == null ? void 0 : it.rdns) === ((st = this.wallet) == null ? void 0 : st.rdns)
            }
            )
              , rt = et.find(nt=>nt.type === "INJECTED");
            tt ? await ConnectionController.connectExternal(tt) : rt && await ConnectionController.connectExternal(rt),
            ModalController.close(),
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                    method: "browser"
                }
            })
        } catch (et) {
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: (et == null ? void 0 : et.message) ?? "Unknown"
                }
            }),
            this.error = !0
        }
    }
}
;
W3mConnectingWcBrowser = __decorate$e([customElement("w3m-connecting-wc-browser")], W3mConnectingWcBrowser);
var __decorate$d = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingWcDesktop = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-desktop: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.onRender = this.onRenderProxy.bind(this),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "desktop"
            }
        })
    }
    onRenderProxy() {
        !this.ready && this.uri && (this.ready = !0,
        this.timeout = setTimeout(()=>{
            var et;
            (et = this.onConnect) == null || et.call(this)
        }
        , 200))
    }
    onConnectProxy() {
        var et;
        if ((et = this.wallet) != null && et.desktop_link && this.uri)
            try {
                this.error = !1;
                const {desktop_link: tt, name: rt} = this.wallet
                  , {redirect: nt, href: it} = CoreHelperUtil.formatNativeUrl(tt, this.uri);
                ConnectionController.setWcLinking({
                    name: rt,
                    href: it
                }),
                ConnectionController.setRecentWallet(this.wallet),
                CoreHelperUtil.openHref(nt, "_blank")
            } catch {
                this.error = !0
            }
    }
}
;
W3mConnectingWcDesktop = __decorate$d([customElement("w3m-connecting-wc-desktop")], W3mConnectingWcDesktop);
var __decorate$c = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingWcMobile = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-mobile: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.onRender = this.onRenderProxy.bind(this),
        document.addEventListener("visibilitychange", this.onBuffering.bind(this)),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "mobile"
            }
        })
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        document.removeEventListener("visibilitychange", this.onBuffering.bind(this))
    }
    onRenderProxy() {
        var et;
        !this.ready && this.uri && (this.ready = !0,
        (et = this.onConnect) == null || et.call(this))
    }
    onConnectProxy() {
        var et;
        if ((et = this.wallet) != null && et.mobile_link && this.uri)
            try {
                this.error = !1;
                const {mobile_link: tt, name: rt} = this.wallet
                  , {redirect: nt, href: it} = CoreHelperUtil.formatNativeUrl(tt, this.uri);
                ConnectionController.setWcLinking({
                    name: rt,
                    href: it
                }),
                ConnectionController.setRecentWallet(this.wallet),
                CoreHelperUtil.openHref(nt, "_self")
            } catch {
                this.error = !0
            }
    }
    onBuffering() {
        const et = CoreHelperUtil.isIos();
        (document == null ? void 0 : document.visibilityState) === "visible" && !this.error && et && (ConnectionController.setBuffering(!0),
        setTimeout(()=>{
            ConnectionController.setBuffering(!1)
        }
        , 5e3))
    }
}
;
W3mConnectingWcMobile = __decorate$c([customElement("w3m-connecting-wc-mobile")], W3mConnectingWcMobile);
const styles$8 = i$4`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var __decorate$b = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingWcQrcode = class extends W3mConnectingWidget {
    constructor() {
        var et;
        super(),
        this.forceUpdate = ()=>{
            this.requestUpdate()
        }
        ,
        window.addEventListener("resize", this.forceUpdate),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: ((et = this.wallet) == null ? void 0 : et.name) ?? "WalletConnect",
                platform: "qrcode"
            }
        })
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        window.removeEventListener("resize", this.forceUpdate)
    }
    render() {
        return this.onRenderProxy(),
        x`
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
    onRenderProxy() {
        !this.ready && this.uri && (this.timeout = setTimeout(()=>{
            this.ready = !0
        }
        , 200))
    }
    qrCodeTemplate() {
        if (!this.uri || !this.ready)
            return null;
        const et = this.getBoundingClientRect().width - 40
          , tt = this.wallet ? this.wallet.name : void 0;
        return ConnectionController.setWcLinking(void 0),
        ConnectionController.setRecentWallet(this.wallet),
        x` <wui-qr-code
      size=${et}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
      alt=${o$2(tt)}
    ></wui-qr-code>`
    }
    copyTemplate() {
        const et = !this.uri || !this.ready;
        return x`<wui-link
      .disabled=${et}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`
    }
}
;
W3mConnectingWcQrcode.styles = styles$8;
W3mConnectingWcQrcode = __decorate$b([customElement("w3m-connecting-wc-qrcode")], W3mConnectingWcQrcode);
const styles$7 = i$4`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;
var __decorate$a = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingSiwe = class extends s$1 {
    constructor() {
        var et;
        super(...arguments),
        this.dappImageUrl = (et = OptionsController.state.metadata) == null ? void 0 : et.icons,
        this.walletImageUrl = StorageUtil.getConnectedWalletImageUrl()
    }
    firstUpdated() {
        var tt;
        const et = (tt = this.shadowRoot) == null ? void 0 : tt.querySelectorAll("wui-visual-thumbnail");
        et != null && et[0] && this.createAnimation(et[0], "translate(18px)"),
        et != null && et[1] && this.createAnimation(et[1], "translate(-18px)")
    }
    render() {
        var et;
        return x`
      <wui-visual-thumbnail
        ?borderRadiusFull=${!0}
        .imageSrc=${(et = this.dappImageUrl) == null ? void 0 : et[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `
    }
    createAnimation(et, tt) {
        et.animate([{
            transform: "translateX(0px)"
        }, {
            transform: tt
        }], {
            duration: 1600,
            easing: "cubic-bezier(0.56, 0, 0.48, 1)",
            direction: "alternate",
            iterations: 1 / 0
        })
    }
}
;
W3mConnectingSiwe.styles = styles$7;
W3mConnectingSiwe = __decorate$a([customElement("w3m-connecting-siwe")], W3mConnectingSiwe);
var __decorate$9 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingWcUnsupported = class extends s$1 {
    constructor() {
        var et;
        if (super(),
        this.wallet = (et = RouterController.state.data) == null ? void 0 : et.wallet,
        !this.wallet)
            throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "browser"
            }
        })
    }
    render() {
        return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
}
;
W3mConnectingWcUnsupported = __decorate$9([customElement("w3m-connecting-wc-unsupported")], W3mConnectingWcUnsupported);
var __decorate$8 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mConnectingWcWeb = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-web: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.secondaryBtnLabel = "Open",
        this.secondaryLabel = "Open and continue in a new browser tab",
        this.secondaryBtnIcon = "externalLink",
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "web"
            }
        })
    }
    onConnectProxy() {
        var et;
        if ((et = this.wallet) != null && et.webapp_link && this.uri)
            try {
                this.error = !1;
                const {webapp_link: tt, name: rt} = this.wallet
                  , {redirect: nt, href: it} = CoreHelperUtil.formatUniversalUrl(tt, this.uri);
                ConnectionController.setWcLinking({
                    name: rt,
                    href: it
                }),
                ConnectionController.setRecentWallet(this.wallet),
                CoreHelperUtil.openHref(nt, "_blank")
            } catch {
                this.error = !0
            }
    }
}
;
W3mConnectingWcWeb = __decorate$8([customElement("w3m-connecting-wc-web")], W3mConnectingWcWeb);
const styles$6 = i$4`
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;
var __decorate$7 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
function headings() {
    var st, at, ot, lt, dt, ct, ut;
    const _e = (at = (st = RouterController.state.data) == null ? void 0 : st.connector) == null ? void 0 : at.name
      , et = (lt = (ot = RouterController.state.data) == null ? void 0 : ot.wallet) == null ? void 0 : lt.name
      , tt = (ct = (dt = RouterController.state.data) == null ? void 0 : dt.network) == null ? void 0 : ct.name
      , rt = et ?? _e
      , nt = ConnectorController.getConnectors();
    return {
        Connect: `Connect ${nt.length === 1 && ((ut = nt[0]) == null ? void 0 : ut.id) === "w3m-email" ? "Email" : ""} Wallet`,
        Account: void 0,
        AccountSettings: void 0,
        ConnectingExternal: rt ?? "Connect Wallet",
        ConnectingWalletConnect: rt ?? "WalletConnect",
        ConnectingSiwe: "Sign In",
        Networks: "Choose Network",
        SwitchNetwork: tt ?? "Switch Network",
        AllWallets: "All Wallets",
        WhatIsANetwork: "What is a network?",
        WhatIsAWallet: "What is a wallet?",
        GetWallet: "Get a wallet",
        Downloads: rt ? `Get ${rt}` : "Downloads",
        EmailVerifyOtp: "Confirm Email",
        EmailVerifyDevice: "Register Device",
        ApproveTransaction: "Approve Transaction",
        Transactions: "Activity",
        UpgradeEmailWallet: "Upgrade your Wallet",
        UpdateEmailWallet: "Edit Email",
        UpdateEmailPrimaryOtp: "Confirm Current Email",
        UpdateEmailSecondaryOtp: "Confirm New Email",
        UnsupportedChain: "Switch Network",
        OnRampProviders: "Choose Provider",
        OnRampActivity: "Activity",
        WhatIsABuy: "What is Buy?",
        BuyInProgress: "Buy",
        OnRampTokenSelect: "Select Token",
        OnRampFiatSelect: "Select Currency"
    }
}
let W3mHeader = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.heading = headings()[RouterController.state.view],
        this.buffering = !1,
        this.showBack = !1,
        this.unsubscribe.push(RouterController.subscribeKey("view", et=>{
            this.onViewChange(et),
            this.onHistoryChange()
        }
        ), ConnectionController.subscribeKey("buffering", et=>this.buffering = et))
    }
    disconnectCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        return x`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${this.onClose.bind(this)}
          data-testid="w3m-header-close"
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `
    }
    onWalletHelp() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_WALLET_HELP"
        }),
        RouterController.push("WhatIsAWallet")
    }
    async onClose() {
        SIWEController.state.isSiweEnabled && SIWEController.state.status !== "success" && await ConnectionController.disconnect(),
        ModalController.close()
    }
    titleTemplate() {
        return x`<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`
    }
    dynamicButtonTemplate() {
        const {view: et} = RouterController.state
          , tt = et === "Connect"
          , rt = et === "ApproveTransaction";
        return this.showBack && !rt ? x`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>` : x`<wui-icon-link
      data-hidden=${!tt}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`
    }
    separatorTemplate() {
        return this.heading ? x`<wui-separator></wui-separator>` : null
    }
    getPadding() {
        return this.heading ? ["l", "2l", "l", "2l"] : ["l", "2l", "0", "2l"]
    }
    async onViewChange(et) {
        var rt;
        const tt = (rt = this.shadowRoot) == null ? void 0 : rt.querySelector("wui-text");
        if (tt) {
            const nt = headings()[et];
            await tt.animate([{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: 200,
                fill: "forwards",
                easing: "ease"
            }).finished,
            this.heading = nt,
            tt.animate([{
                opacity: 0
            }, {
                opacity: 1
            }], {
                duration: 200,
                fill: "forwards",
                easing: "ease"
            })
        }
    }
    async onHistoryChange() {
        var rt;
        const {history: et} = RouterController.state
          , tt = (rt = this.shadowRoot) == null ? void 0 : rt.querySelector("#dynamic");
        et.length > 1 && !this.showBack && tt ? (await tt.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.showBack = !0,
        tt.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        })) : et.length <= 1 && this.showBack && tt && (await tt.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.showBack = !1,
        tt.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
    onGoBack() {
        RouterController.state.view === "ConnectingSiwe" ? RouterController.push("Connect") : RouterController.goBack()
    }
}
;
W3mHeader.styles = [styles$6];
__decorate$7([r$3()], W3mHeader.prototype, "heading", void 0);
__decorate$7([r$3()], W3mHeader.prototype, "buffering", void 0);
__decorate$7([r$3()], W3mHeader.prototype, "showBack", void 0);
W3mHeader = __decorate$7([customElement("w3m-header")], W3mHeader);
var __decorate$6 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mHelpWidget = class extends s$1 {
    constructor() {
        super(...arguments),
        this.data = []
    }
    render() {
        return x`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map(et=>x`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${et.images.map(tt=>x`<wui-visual name=${tt}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${et.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${et.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `
    }
}
;
__decorate$6([n$4({
    type: Array
})], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate$6([customElement("w3m-help-widget")], W3mHelpWidget);
const styles$5 = i$4`
  :host {
    width: 100%;
  }

  wui-loading-spinner {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
  }

  .currency-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
    right: var(--wui-spacing-1xs);
    height: 40px;
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs) var(--wui-spacing-xs)
      var(--wui-spacing-xs);
    min-width: 95px;
    border-radius: var(--FULL, 1000px);
    border: 1px solid var(--wui-gray-glass-002);
    background: var(--wui-gray-glass-002);
    cursor: pointer;
  }

  .currency-container > wui-image {
    height: 24px;
    width: 24px;
    border-radius: 50%;
  }
`;
var __decorate$5 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mInputCurrency = class extends s$1 {
    constructor() {
        var et;
        super(),
        this.unsubscribe = [],
        this.type = "Token",
        this.value = 0,
        this.currencies = [],
        this.selectedCurrency = (et = this.currencies) == null ? void 0 : et[0],
        this.currencyImages = AssetController.state.currencyImages,
        this.tokenImages = AssetController.state.tokenImages,
        this.unsubscribe.push(OnRampController.subscribeKey("purchaseCurrency", tt=>{
            !tt || this.type === "Fiat" || (this.selectedCurrency = this.formatPurchaseCurrency(tt))
        }
        ), OnRampController.subscribeKey("paymentCurrency", tt=>{
            !tt || this.type === "Token" || (this.selectedCurrency = this.formatPaymentCurrency(tt))
        }
        ), OnRampController.subscribe(tt=>{
            this.type === "Fiat" ? this.currencies = tt.purchaseCurrencies.map(this.formatPurchaseCurrency) : this.currencies = tt.paymentCurrencies.map(this.formatPaymentCurrency)
        }
        ), AssetController.subscribe(tt=>{
            this.currencyImages = {
                ...tt.currencyImages
            },
            this.tokenImages = {
                ...tt.tokenImages
            }
        }
        ))
    }
    firstUpdated() {
        OnRampController.getAvailableCurrencies()
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        var rt;
        const et = ((rt = this.selectedCurrency) == null ? void 0 : rt.symbol) || ""
          , tt = this.currencyImages[et] || this.tokenImages[et];
        return x` <wui-input-text type="number" size="lg" value=${this.value}>
      ${this.selectedCurrency ? x` <wui-flex
            class="currency-container"
            justifyContent="space-between"
            alignItems="center"
            gap="xxs"
            @click=${()=>ModalController.open({
            view: `OnRamp${this.type}Select`
        })}
          >
            <wui-image src=${o$2(tt)}></wui-image>
            <wui-text color="fg-100"> ${this.selectedCurrency.symbol} </wui-text>
          </wui-flex>` : x`<wui-loading-spinner></wui-loading-spinner>`}
    </wui-input-text>`
    }
    formatPaymentCurrency(et) {
        return {
            name: et.id,
            symbol: et.id
        }
    }
    formatPurchaseCurrency(et) {
        return {
            name: et.name,
            symbol: et.symbol
        }
    }
}
;
W3mInputCurrency.styles = styles$5;
__decorate$5([n$4({
    type: String
})], W3mInputCurrency.prototype, "type", void 0);
__decorate$5([n$4({
    type: Number
})], W3mInputCurrency.prototype, "value", void 0);
__decorate$5([r$3()], W3mInputCurrency.prototype, "currencies", void 0);
__decorate$5([r$3()], W3mInputCurrency.prototype, "selectedCurrency", void 0);
__decorate$5([r$3()], W3mInputCurrency.prototype, "currencyImages", void 0);
__decorate$5([r$3()], W3mInputCurrency.prototype, "tokenImages", void 0);
W3mInputCurrency = __decorate$5([customElement("w3m-swap-input")], W3mInputCurrency);
const styles$4 = i$4`
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var __decorate$4 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mLegalFooter = class extends s$1 {
    render() {
        const {termsConditionsUrl: et, privacyPolicyUrl: tt} = OptionsController.state;
        return !et && !tt ? null : x`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `
    }
    andTemplate() {
        const {termsConditionsUrl: et, privacyPolicyUrl: tt} = OptionsController.state;
        return et && tt ? "and" : ""
    }
    termsTemplate() {
        const {termsConditionsUrl: et} = OptionsController.state;
        return et ? x`<a href=${et}>Terms of Service</a>` : null
    }
    privacyTemplate() {
        const {privacyPolicyUrl: et} = OptionsController.state;
        return et ? x`<a href=${et}>Privacy Policy</a>` : null
    }
}
;
W3mLegalFooter.styles = [styles$4];
W3mLegalFooter = __decorate$4([customElement("w3m-legal-footer")], W3mLegalFooter);
const styles$3 = i$4`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var __decorate$3 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mMobileDownloadLinks = class extends s$1 {
    constructor() {
        super(...arguments),
        this.wallet = void 0
    }
    render() {
        if (!this.wallet)
            return this.style.display = "none",
            null;
        const {name: et, app_store: tt, play_store: rt, chrome_store: nt, homepage: it} = this.wallet
          , st = CoreHelperUtil.isMobile()
          , at = CoreHelperUtil.isIos()
          , ot = CoreHelperUtil.isAndroid()
          , lt = [tt, rt, it, nt].filter(Boolean).length > 1
          , dt = UiHelperUtil.getTruncateString({
            string: et,
            charsStart: 12,
            charsEnd: 0,
            truncate: "end"
        });
        return lt && !st ? x`
        <wui-cta-button
          label=${`Don't have ${dt}?`}
          buttonLabel="Get"
          @click=${()=>RouterController.push("Downloads", {
            wallet: this.wallet
        })}
        ></wui-cta-button>
      ` : !lt && it ? x`
        <wui-cta-button
          label=${`Don't have ${dt}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      ` : tt && at ? x`
        <wui-cta-button
          label=${`Don't have ${dt}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      ` : rt && ot ? x`
        <wui-cta-button
          label=${`Don't have ${dt}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      ` : (this.style.display = "none",
        null)
    }
    onAppStore() {
        var et;
        (et = this.wallet) != null && et.app_store && CoreHelperUtil.openHref(this.wallet.app_store, "_blank")
    }
    onPlayStore() {
        var et;
        (et = this.wallet) != null && et.play_store && CoreHelperUtil.openHref(this.wallet.play_store, "_blank")
    }
    onHomePage() {
        var et;
        (et = this.wallet) != null && et.homepage && CoreHelperUtil.openHref(this.wallet.homepage, "_blank")
    }
}
;
W3mMobileDownloadLinks.styles = [styles$3];
__decorate$3([n$4({
    type: Object
})], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate$3([customElement("w3m-mobile-download-links")], W3mMobileDownloadLinks);
const styles$2 = i$4`
  wui-flex {
    border-top: 1px solid var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-3xs);
  }
`;
var __decorate$2 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mOnRampProvidersFooter = class extends s$1 {
    render() {
        const {termsConditionsUrl: et, privacyPolicyUrl: tt} = OptionsController.state;
        return !et && !tt ? null : x`
      <wui-flex
        .padding=${["m", "s", "s", "s"]}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="s"
      >
        <wui-text color="fg-250" variant="small-400" align="center">
          We work with the best providers to fit your buyer needs, region, and to get you the lowest
          fees
        </wui-text>

        ${this.whatIsBuyTemplate()}
      </wui-flex>
    `
    }
    whatIsBuyTemplate() {
        return x` <wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
      What is Buy
    </wui-link>`
    }
    onWhatIsBuy() {
        RouterController.push("WhatIsABuy")
    }
}
;
W3mOnRampProvidersFooter.styles = [styles$2];
W3mOnRampProvidersFooter = __decorate$2([customElement("w3m-onramp-providers-footer")], W3mOnRampProvidersFooter);
const styles$1 = i$4`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var __decorate$1 = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
const presets = {
    success: {
        backgroundColor: "success-100",
        iconColor: "success-100",
        icon: "checkmark"
    },
    error: {
        backgroundColor: "error-100",
        iconColor: "error-100",
        icon: "close"
    }
};
let W3mSnackBar = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.timeout = void 0,
        this.open = SnackController.state.open,
        this.unsubscribe.push(SnackController.subscribeKey("open", et=>{
            this.open = et,
            this.onOpen()
        }
        ))
    }
    disconnectedCallback() {
        clearTimeout(this.timeout),
        this.unsubscribe.forEach(et=>et())
    }
    render() {
        const {message: et, variant: tt} = SnackController.state
          , rt = presets[tt];
        return x`
      <wui-snackbar
        message=${et}
        backgroundColor=${rt.backgroundColor}
        iconColor=${rt.iconColor}
        icon=${rt.icon}
      ></wui-snackbar>
    `
    }
    onOpen() {
        clearTimeout(this.timeout),
        this.open ? (this.animate([{
            opacity: 0,
            transform: "translateX(-50%) scale(0.85)"
        }, {
            opacity: 1,
            transform: "translateX(-50%) scale(1)"
        }], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
        }),
        this.timeout = setTimeout(()=>SnackController.hide(), 2500)) : this.animate([{
            opacity: 1,
            transform: "translateX(-50%) scale(1)"
        }, {
            opacity: 0,
            transform: "translateX(-50%) scale(0.85)"
        }], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
        })
    }
}
;
W3mSnackBar.styles = styles$1;
__decorate$1([r$3()], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate$1([customElement("w3m-snackbar")], W3mSnackBar);
const styles = i$4`
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 21px;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }

  .betaBanner {
    padding: 10px 12px 10px 10px;
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-accent-glass-010);
    margin-bottom: var(--wui-spacing-s);
  }
`;
var __decorate = function(_e, et, tt, rt) {
    var nt = arguments.length, it = nt < 3 ? et : rt === null ? rt = Object.getOwnPropertyDescriptor(et, tt) : rt, st;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        it = Reflect.decorate(_e, et, tt, rt);
    else
        for (var at = _e.length - 1; at >= 0; at--)
            (st = _e[at]) && (it = (nt < 3 ? st(it) : nt > 3 ? st(et, tt, it) : st(et, tt)) || it);
    return nt > 3 && it && Object.defineProperty(et, tt, it),
    it
};
let W3mEmailLoginWidget = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.formRef = e(),
        this.connectors = ConnectorController.state.connectors,
        this.email = "",
        this.loading = !1,
        this.error = "",
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", et=>this.connectors = et))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(et=>et())
    }
    firstUpdated() {
        var et;
        (et = this.formRef.value) == null || et.addEventListener("keydown", tt=>{
            tt.key === "Enter" && this.onSubmitEmail(tt)
        }
        )
    }
    render() {
        const et = this.connectors.length > 1;
        return this.connectors.find(rt=>rt.type === "EMAIL") ? x`
      ${this.betaWarningTemplate()}
      <form ${n$2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${et ? x`<wui-separator text="or"></wui-separator>` : null}
    ` : null
    }
    betaWarningTemplate() {
        return x`
          <wui-flex class="betaBanner" gap="xs" alignItems="center" justifyContent="center">
            <wui-text variant="small-400" color="accent-100">Email login is in beta</wui-text>
          </wui-flex>
        `
    }
    submitButtonTemplate() {
        return !this.loading && this.email.length > 3 ? x`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null
    }
    loadingTemplate() {
        return this.loading ? x`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null
    }
    onEmailInputChange(et) {
        this.email = et.detail,
        this.error = ""
    }
    async onSubmitEmail(et) {
        try {
            if (this.loading)
                return;
            this.loading = !0,
            et.preventDefault();
            const tt = ConnectorController.getEmailConnector();
            if (!tt)
                throw new Error("w3m-email-login-widget: Email connector not found");
            const {action: rt} = await tt.provider.connectEmail({
                email: this.email
            });
            EventsController.sendEvent({
                type: "track",
                event: "EMAIL_SUBMITTED"
            }),
            rt === "VERIFY_OTP" ? (EventsController.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_SENT"
            }),
            RouterController.push("EmailVerifyOtp", {
                email: this.email
            })) : rt === "VERIFY_DEVICE" && RouterController.push("EmailVerifyDevice", {
                email: this.email
            })
        } catch (tt) {
            const rt = CoreHelperUtil.parseError(tt);
            rt != null && rt.includes("Invalid email") ? this.error = "Invalid email. Try again." : SnackController.showError(tt)
        } finally {
            this.loading = !1
        }
    }
    onFocusEvent() {
        EventsController.sendEvent({
            type: "track",
            event: "EMAIL_LOGIN_SELECTED"
        })
    }
}
;
W3mEmailLoginWidget.styles = styles;
__decorate([r$3()], W3mEmailLoginWidget.prototype, "connectors", void 0);
__decorate([r$3()], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate([r$3()], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate([r$3()], W3mEmailLoginWidget.prototype, "error", void 0);
W3mEmailLoginWidget = __decorate([customElement("w3m-email-login-widget")], W3mEmailLoginWidget);
let isInitialized = !1;
class Web3ModalScaffold {
    constructor(et) {
        this.initPromise = void 0,
        this.setIsConnected = tt=>{
            AccountController.setIsConnected(tt)
        }
        ,
        this.setCaipAddress = tt=>{
            AccountController.setCaipAddress(tt)
        }
        ,
        this.setBalance = (tt,rt)=>{
            AccountController.setBalance(tt, rt)
        }
        ,
        this.setProfileName = tt=>{
            AccountController.setProfileName(tt)
        }
        ,
        this.setProfileImage = tt=>{
            AccountController.setProfileImage(tt)
        }
        ,
        this.resetAccount = ()=>{
            AccountController.resetAccount()
        }
        ,
        this.setCaipNetwork = tt=>{
            NetworkController.setCaipNetwork(tt)
        }
        ,
        this.getCaipNetwork = ()=>NetworkController.state.caipNetwork,
        this.setRequestedCaipNetworks = tt=>{
            NetworkController.setRequestedCaipNetworks(tt)
        }
        ,
        this.getApprovedCaipNetworksData = ()=>NetworkController.getApprovedCaipNetworksData(),
        this.resetNetwork = ()=>{
            NetworkController.resetNetwork()
        }
        ,
        this.setConnectors = tt=>{
            ConnectorController.setConnectors(tt)
        }
        ,
        this.addConnector = tt=>{
            ConnectorController.addConnector(tt)
        }
        ,
        this.getConnectors = ()=>ConnectorController.getConnectors(),
        this.resetWcConnection = ()=>{
            ConnectionController.resetWcConnection()
        }
        ,
        this.fetchIdentity = tt=>BlockchainApiController.fetchIdentity(tt),
        this.setAddressExplorerUrl = tt=>{
            AccountController.setAddressExplorerUrl(tt)
        }
        ,
        this.setSIWENonce = tt=>{
            SIWEController.setNonce(tt)
        }
        ,
        this.setSIWESession = tt=>{
            SIWEController.setSession(tt)
        }
        ,
        this.setSIWEStatus = tt=>{
            SIWEController.setStatus(tt)
        }
        ,
        this.setSIWEMessage = tt=>{
            SIWEController.setMessage(tt)
        }
        ,
        this.initControllers(et),
        this.initOrContinue()
    }
    async open(et) {
        await this.initOrContinue(),
        ModalController.open(et)
    }
    async close() {
        await this.initOrContinue(),
        ModalController.close()
    }
    setLoading(et) {
        ModalController.setLoading(et)
    }
    getThemeMode() {
        return ThemeController.state.themeMode
    }
    getThemeVariables() {
        return ThemeController.state.themeVariables
    }
    setThemeMode(et) {
        ThemeController.setThemeMode(et),
        setColorTheme(ThemeController.state.themeMode)
    }
    setThemeVariables(et) {
        ThemeController.setThemeVariables(et),
        setThemeVariables(ThemeController.state.themeVariables)
    }
    subscribeTheme(et) {
        return ThemeController.subscribe(et)
    }
    getState() {
        return {
            ...PublicStateController.state
        }
    }
    subscribeState(et) {
        return PublicStateController.subscribe(et)
    }
    getEvent() {
        return {
            ...EventsController.state
        }
    }
    subscribeEvents(et) {
        return EventsController.subscribe(et)
    }
    subscribeSIWEState(et) {
        return SIWEController.subscribe(et)
    }
    initControllers(et) {
        if (NetworkController.setClient(et.networkControllerClient),
        NetworkController.setDefaultCaipNetwork(et.defaultChain),
        OptionsController.setProjectId(et.projectId),
        OptionsController.setAllWallets(et.allWallets),
        OptionsController.setIncludeWalletIds(et.includeWalletIds),
        OptionsController.setExcludeWalletIds(et.excludeWalletIds),
        OptionsController.setFeaturedWalletIds(et.featuredWalletIds),
        OptionsController.setTokens(et.tokens),
        OptionsController.setTermsConditionsUrl(et.termsConditionsUrl),
        OptionsController.setPrivacyPolicyUrl(et.privacyPolicyUrl),
        OptionsController.setCustomWallets(et.customWallets),
        OptionsController.setEnableAnalytics(et.enableAnalytics),
        OptionsController.setSdkVersion(et._sdkVersion),
        ConnectionController.setClient(et.connectionControllerClient),
        et.siweControllerClient) {
            const tt = et.siweControllerClient;
            SIWEController.setSIWEClient(tt)
        }
        et.metadata && OptionsController.setMetadata(et.metadata),
        et.themeMode && ThemeController.setThemeMode(et.themeMode),
        et.themeVariables && ThemeController.setThemeVariables(et.themeVariables),
        et.enableOnramp && OptionsController.setOnrampEnabled(!!et.enableOnramp)
    }
    async initOrContinue() {
        return !this.initPromise && !isInitialized && CoreHelperUtil.isClient() && (isInitialized = !0,
        this.initPromise = new Promise(async et=>{
            await Promise.all([__vitePreload(()=>Promise.resolve().then(()=>index$1), void 0), __vitePreload(()=>Promise.resolve().then(()=>index), void 0)]);
            const tt = document.createElement("w3m-modal");
            document.body.insertAdjacentElement("beforeend", tt),
            et()
        }
        )),
        this.initPromise
    }
}
const ConstantsUtil = {
    WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
    INJECTED_CONNECTOR_ID: "injected",
    COINBASE_CONNECTOR_ID: "coinbaseWallet",
    COINBASE_SDK_CONNECTOR_ID: "coinbaseWalletSDK",
    SAFE_CONNECTOR_ID: "safe",
    LEDGER_CONNECTOR_ID: "ledger",
    EIP6963_CONNECTOR_ID: "eip6963",
    EMAIL_CONNECTOR_ID: "w3mEmail",
    EIP155: "eip155",
    ADD_CHAIN_METHOD: "wallet_addEthereumChain",
    EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
    EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
    VERSION: "4.0.5"
}
  , PresetsUtil = {
    ConnectorExplorerIds: {
        [ConstantsUtil.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
        [ConstantsUtil.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
        [ConstantsUtil.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
    },
    EIP155NetworkImageIds: {
        1: "692ed6ba-e569-459a-556a-776476829e00",
        42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
        43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
        56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
        250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
        10: "ab9c186a-c52f-464b-2906-ca59d760a400",
        137: "41d04d42-da3b-4453-8506-668cc0727900",
        100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
        9001: "f926ff41-260d-4028-635e-91913fc28e00",
        324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
        314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
        4689: "34e68754-e536-40da-c153-6ef2e7188a00",
        1088: "3897a66d-40b9-4833-162f-a2c90531c900",
        1284: "161038da-44ae-4ec7-1208-0ea569454b00",
        1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
        7777777: "845c60df-d429-4991-e687-91ae45791600",
        42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
        8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
        1313161554: "3ff73439-a619-4894-9262-4470c773a100",
        2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
        2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00"
    },
    ConnectorImageIds: {
        [ConstantsUtil.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
        [ConstantsUtil.COINBASE_SDK_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
        [ConstantsUtil.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
        [ConstantsUtil.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
        [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
        [ConstantsUtil.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
    },
    ConnectorNamesMap: {
        [ConstantsUtil.INJECTED_CONNECTOR_ID]: "Browser Wallet",
        [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
        [ConstantsUtil.COINBASE_CONNECTOR_ID]: "Coinbase",
        [ConstantsUtil.COINBASE_SDK_CONNECTOR_ID]: "Coinbase",
        [ConstantsUtil.LEDGER_CONNECTOR_ID]: "Ledger",
        [ConstantsUtil.SAFE_CONNECTOR_ID]: "Safe"
    },
    ConnectorTypesMap: {
        [ConstantsUtil.INJECTED_CONNECTOR_ID]: "INJECTED",
        [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
        [ConstantsUtil.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
        [ConstantsUtil.EMAIL_CONNECTOR_ID]: "EMAIL"
    },
    WalletConnectRpcChainIds: [1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324, 280]
}
  , HelpersUtil = {
    caipNetworkIdToNumber(_e) {
        return _e ? Number(_e.split(":")[1]) : void 0
    },
    getCaipTokens(_e) {
        if (!_e)
            return;
        const et = {};
        return Object.entries(_e).forEach(([tt,rt])=>{
            et[`${ConstantsUtil.EIP155}:${tt}`] = rt
        }
        ),
        et
    }
};
function getCaipDefaultChain(_e) {
    if (_e)
        return {
            id: `${ConstantsUtil.EIP155}:${_e.id}`,
            name: _e.name,
            imageId: PresetsUtil.EIP155NetworkImageIds[_e.id]
        }
}
async function getWalletConnectCaipNetworks(_e) {
    var it, st, at, ot;
    if (!_e)
        throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
    const et = await (_e == null ? void 0 : _e.getProvider())
      , tt = (st = (it = et == null ? void 0 : et.signer) == null ? void 0 : it.session) == null ? void 0 : st.namespaces
      , rt = (at = tt == null ? void 0 : tt[ConstantsUtil.EIP155]) == null ? void 0 : at.methods
      , nt = (ot = tt == null ? void 0 : tt[ConstantsUtil.EIP155]) == null ? void 0 : ot.chains;
    return {
        supportsAllNetworks: !!(rt != null && rt.includes(ConstantsUtil.ADD_CHAIN_METHOD)),
        approvedCaipNetworkIds: nt
    }
}
function getEmailCaipNetworks() {
    return {
        supportsAllNetworks: !1,
        approvedCaipNetworkIds: PresetsUtil.WalletConnectRpcChainIds.map(_e=>`${ConstantsUtil.EIP155}:${_e}`)
    }
}
function getTransport({chainId: _e, projectId: et}) {
    const tt = CoreHelperUtil.getBlockchainApiUrl();
    return PresetsUtil.WalletConnectRpcChainIds.includes(_e) ? http(`${tt}/v1/?chainId=${ConstantsUtil.EIP155}:${_e}&projectId=${et}`) : http()
}
class Web3Modal extends Web3ModalScaffold {
    constructor(et) {
        const {wagmiConfig: tt, siweConfig: rt, defaultChain: nt, tokens: it, _sdkVersion: st, ...at} = et;
        if (!tt)
            throw new Error("web3modal:constructor - wagmiConfig is undefined");
        if (!at.projectId)
            throw new Error("web3modal:constructor - projectId is undefined");
        const ot = {
            switchCaipNetwork: async dt=>{
                const ct = HelpersUtil.caipNetworkIdToNumber(dt == null ? void 0 : dt.id);
                ct && await switchChain(this.wagmiConfig, {
                    chainId: ct
                })
            }
            ,
            getApprovedCaipNetworksData: async()=>new Promise(dt=>{
                var ft, ht;
                const ut = new Map(tt.state.connections).get(tt.state.current || "");
                if (((ft = ut == null ? void 0 : ut.connector) == null ? void 0 : ft.id) === ConstantsUtil.EMAIL_CONNECTOR_ID)
                    dt(getEmailCaipNetworks());
                else if (((ht = ut == null ? void 0 : ut.connector) == null ? void 0 : ht.id) === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID) {
                    const gt = tt.connectors.find(bt=>bt.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
                    dt(getWalletConnectCaipNetworks(gt))
                }
                dt({
                    approvedCaipNetworkIds: void 0,
                    supportsAllNetworks: !0
                })
            }
            )
        }
          , lt = {
            connectWalletConnect: async dt=>{
                var ht;
                const ct = tt.connectors.find(gt=>gt.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
                if (!ct)
                    throw new Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
                (await ct.getProvider()).on("display_uri", gt=>{
                    dt(gt)
                }
                );
                const ft = HelpersUtil.caipNetworkIdToNumber((ht = this.getCaipNetwork()) == null ? void 0 : ht.id);
                await connect(this.wagmiConfig, {
                    connector: ct,
                    chainId: ft
                })
            }
            ,
            connectExternal: async({id: dt, provider: ct, info: ut})=>{
                var gt, bt;
                const ft = tt.connectors.find(pt=>pt.id === dt);
                if (!ft)
                    throw new Error("connectionControllerClient:connectExternal - connector is undefined");
                ct && ut && ft.id === ConstantsUtil.EIP6963_CONNECTOR_ID && ((gt = ft.setEip6963Wallet) == null || gt.call(ft, {
                    provider: ct,
                    info: ut
                }));
                const ht = HelpersUtil.caipNetworkIdToNumber((bt = this.getCaipNetwork()) == null ? void 0 : bt.id);
                await connect(this.wagmiConfig, {
                    connector: ft,
                    chainId: ht
                })
            }
            ,
            checkInstalled: dt=>{
                const ct = this.getConnectors().find(ut=>ut.type === "INJECTED");
                return dt ? ct && window != null && window.ethereum ? dt.some(ut=>{
                    var ft;
                    return !!((ft = window.ethereum) != null && ft[String(ut)])
                }
                ) : !1 : !!window.ethereum
            }
            ,
            disconnect: async()=>{
                var dt;
                await disconnect(this.wagmiConfig),
                (dt = rt == null ? void 0 : rt.options) != null && dt.signOutOnDisconnect && await rt.signOut()
            }
            ,
            signMessage: async dt=>signMessage(this.wagmiConfig, {
                message: dt
            })
        };
        super({
            networkControllerClient: ot,
            connectionControllerClient: lt,
            siweControllerClient: rt,
            defaultChain: getCaipDefaultChain(nt),
            tokens: HelpersUtil.getCaipTokens(it),
            _sdkVersion: st ?? `html-wagmi-${ConstantsUtil.VERSION}`,
            ...at
        }),
        this.hasSyncedConnectedAccount = !1,
        this.options = void 0,
        this.options = et,
        this.wagmiConfig = tt,
        this.syncRequestedNetworks([...tt.chains]),
        this.syncConnectors([...tt.connectors]),
        watchConnectors(this.wagmiConfig, {
            onChange: dt=>this.syncConnectors(dt)
        }),
        watchAccount(this.wagmiConfig, {
            onChange: dt=>this.syncAccount({
                ...dt
            })
        })
    }
    getState() {
        const et = super.getState();
        return {
            ...et,
            selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(et.selectedNetworkId)
        }
    }
    subscribeState(et) {
        return super.subscribeState(tt=>et({
            ...tt,
            selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(tt.selectedNetworkId)
        }))
    }
    syncRequestedNetworks(et) {
        const tt = et == null ? void 0 : et.map(rt=>{
            var nt, it;
            return {
                id: `${ConstantsUtil.EIP155}:${rt.id}`,
                name: rt.name,
                imageId: PresetsUtil.EIP155NetworkImageIds[rt.id],
                imageUrl: (it = (nt = this.options) == null ? void 0 : nt.chainImages) == null ? void 0 : it[rt.id]
            }
        }
        );
        this.setRequestedCaipNetworks(tt ?? [])
    }
    async syncAccount({address: et, isConnected: tt, chainId: rt}) {
        if (this.resetAccount(),
        this.syncNetwork(),
        tt && et && rt) {
            const nt = `${ConstantsUtil.EIP155}:${rt}:${et}`;
            this.setIsConnected(tt),
            this.setCaipAddress(nt),
            await Promise.all([this.syncProfile(et, rt), this.syncBalance(et, rt), this.getApprovedCaipNetworksData()]),
            this.hasSyncedConnectedAccount = !0
        } else
            !tt && this.hasSyncedConnectedAccount && (this.resetWcConnection(),
            this.resetNetwork())
    }
    async syncNetwork() {
        var it, st, at, ot;
        const {address: et, isConnected: tt, chainId: rt} = getAccount(this.wagmiConfig)
          , nt = this.wagmiConfig.chains.find(lt=>lt.id === rt);
        if (nt || rt) {
            const lt = (nt == null ? void 0 : nt.name) ?? (rt == null ? void 0 : rt.toString())
              , dt = Number((nt == null ? void 0 : nt.id) ?? rt)
              , ct = `${ConstantsUtil.EIP155}:${dt}`;
            if (this.setCaipNetwork({
                id: ct,
                name: lt,
                imageId: PresetsUtil.EIP155NetworkImageIds[dt],
                imageUrl: (st = (it = this.options) == null ? void 0 : it.chainImages) == null ? void 0 : st[dt]
            }),
            tt && et && rt) {
                const ut = `${ConstantsUtil.EIP155}:${dt}:${et}`;
                if (this.setCaipAddress(ut),
                (ot = (at = nt == null ? void 0 : nt.blockExplorers) == null ? void 0 : at.default) != null && ot.url) {
                    const ft = `${nt.blockExplorers.default.url}/address/${et}`;
                    this.setAddressExplorerUrl(ft)
                } else
                    this.setAddressExplorerUrl(void 0);
                this.hasSyncedConnectedAccount && (await this.syncProfile(et, rt),
                await this.syncBalance(et, rt))
            }
        }
    }
    async syncProfile(et, tt) {
        if (tt !== mainnet.id) {
            this.setProfileName(null),
            this.setProfileImage(null);
            return
        }
        try {
            const {name: rt, avatar: nt} = await this.fetchIdentity({
                caipChainId: `${ConstantsUtil.EIP155}:${tt}`,
                address: et
            });
            this.setProfileName(rt),
            this.setProfileImage(nt)
        } catch {
            const rt = await getEnsName(this.wagmiConfig, {
                address: et,
                chainId: tt
            });
            if (rt) {
                this.setProfileName(rt);
                const nt = await getEnsAvatar(this.wagmiConfig, {
                    name: rt,
                    chainId: tt
                });
                nt && this.setProfileImage(nt)
            }
        }
    }
    async syncBalance(et, tt) {
        var nt, it, st;
        const rt = this.wagmiConfig.chains.find(at=>at.id === tt);
        if (rt) {
            const at = await getBalance(this.wagmiConfig, {
                address: et,
                chainId: rt.id,
                token: (st = (it = (nt = this.options) == null ? void 0 : nt.tokens) == null ? void 0 : it[rt.id]) == null ? void 0 : st.address
            });
            this.setBalance(at.formatted, at.symbol);
            return
        }
        this.setBalance(void 0, void 0)
    }
    syncConnectors(et) {
        const tt = new Set
          , rt = et.filter(at=>!tt.has(at.id) && tt.add(at.id))
          , nt = []
          , it = ConstantsUtil.COINBASE_SDK_CONNECTOR_ID
          , st = rt.find(at=>at.id === ConstantsUtil$1.CONNECTOR_RDNS_MAP[it]);
        rt.forEach(({id: at, name: ot, type: lt, icon: dt})=>{
            var ut, ft;
            st && at === it || ConstantsUtil.EMAIL_CONNECTOR_ID === at || nt.push({
                id: at,
                explorerId: PresetsUtil.ConnectorExplorerIds[at],
                imageUrl: ((ft = (ut = this.options) == null ? void 0 : ut.connectorImages) == null ? void 0 : ft[at]) ?? dt,
                name: PresetsUtil.ConnectorNamesMap[at] ?? ot,
                imageId: PresetsUtil.ConnectorImageIds[at],
                type: PresetsUtil.ConnectorTypesMap[lt] ?? "EXTERNAL"
            })
        }
        ),
        this.setConnectors(nt),
        this.syncEmailConnector(rt)
    }
    async syncEmailConnector(et) {
        const tt = et.find(({id: rt})=>rt === ConstantsUtil.EMAIL_CONNECTOR_ID);
        if (tt) {
            const rt = await tt.getProvider();
            this.addConnector({
                id: ConstantsUtil.EMAIL_CONNECTOR_ID,
                type: "EMAIL",
                name: "Email",
                provider: rt
            }),
            this.listenEmailConnector(tt)
        }
    }
    async listenEmailConnector(et) {
        if (typeof window < "u" && et) {
            super.setLoading(!0);
            const tt = await et.getProvider()
              , rt = tt.getLoginEmailUsed();
            super.setLoading(rt),
            rt && this.setIsConnected(!1),
            tt.onRpcRequest(nt=>{
                W3mFrameHelpers.checkIfRequestIsAllowed(nt) || super.open({
                    view: "ApproveTransaction"
                })
            }
            ),
            tt.onRpcResponse(()=>{
                super.close()
            }
            ),
            tt.onIsConnected(()=>{
                this.setIsConnected(!0),
                super.setLoading(!1)
            }
            )
        }
    }
}
let modal;
function createWeb3Modal(_e) {
    return modal || (modal = new Web3Modal({
        ..._e,
        _sdkVersion: `react-wagmi-${ConstantsUtil.VERSION}`
    }),
    getWeb3Modal(modal)),
    modal
}
function Hydrate(_e) {
    const {children: et, config: tt, initialState: rt, reconnectOnMount: nt=!0} = _e
      , {onMount: it} = hydrate(tt, {
        initialState: rt,
        reconnectOnMount: nt
    });
    tt._internal.ssr || it();
    const st = reactExports.useRef(!0);
    return reactExports.useEffect(()=>{
        if (st.current && tt._internal.ssr)
            return it(),
            ()=>{
                st.current = !1
            }
    }
    , []),
    et
}
const WagmiContext = reactExports.createContext(void 0);
function WagmiProvider(_e) {
    const {children: et, config: tt} = _e
      , rt = {
        value: tt
    };
    return reactExports.createElement(Hydrate, _e, reactExports.createElement(WagmiContext.Provider, rt, et))
}
const version = "2.5.7"
  , getVersion = ()=>`wagmi@${version}`;
class BaseError extends BaseError$1 {
    constructor() {
        super(...arguments),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiError"
        })
    }
    get docsBaseUrl() {
        return "https://wagmi.sh/react"
    }
    get version() {
        return getVersion()
    }
}
class WagmiProviderNotFoundError extends BaseError {
    constructor() {
        super("`useConfig` must be used within `WagmiProvider`.", {
            docsPath: "https://wagmi.sh/react/api/WagmiProvider"
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiProviderNotFoundError"
        })
    }
}
var Subscribable = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(_e) {
        return this.listeners.add(_e),
        this.onSubscribe(),
        ()=>{
            this.listeners.delete(_e),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , isServer = typeof window > "u" || "Deno"in window;
function noop$3() {}
function functionalUpdate(_e, et) {
    return typeof _e == "function" ? _e(et) : _e
}
function isValidTimeout(_e) {
    return typeof _e == "number" && _e >= 0 && _e !== 1 / 0
}
function timeUntilStale(_e, et) {
    return Math.max(_e + (et || 0) - Date.now(), 0)
}
function matchQuery(_e, et) {
    const {type: tt="all", exact: rt, fetchStatus: nt, predicate: it, queryKey: st, stale: at} = _e;
    if (st) {
        if (rt) {
            if (et.queryHash !== hashQueryKeyByOptions(st, et.options))
                return !1
        } else if (!partialMatchKey(et.queryKey, st))
            return !1
    }
    if (tt !== "all") {
        const ot = et.isActive();
        if (tt === "active" && !ot || tt === "inactive" && ot)
            return !1
    }
    return !(typeof at == "boolean" && et.isStale() !== at || typeof nt < "u" && nt !== et.state.fetchStatus || it && !it(et))
}
function matchMutation(_e, et) {
    const {exact: tt, status: rt, predicate: nt, mutationKey: it} = _e;
    if (it) {
        if (!et.options.mutationKey)
            return !1;
        if (tt) {
            if (hashKey(et.options.mutationKey) !== hashKey(it))
                return !1
        } else if (!partialMatchKey(et.options.mutationKey, it))
            return !1
    }
    return !(rt && et.state.status !== rt || nt && !nt(et))
}
function hashQueryKeyByOptions(_e, et) {
    return ((et == null ? void 0 : et.queryKeyHashFn) || hashKey)(_e)
}
function hashKey(_e) {
    return JSON.stringify(_e, (et,tt)=>isPlainObject$5(tt) ? Object.keys(tt).sort().reduce((rt,nt)=>(rt[nt] = tt[nt],
    rt), {}) : tt)
}
function partialMatchKey(_e, et) {
    return _e === et ? !0 : typeof _e != typeof et ? !1 : _e && et && typeof _e == "object" && typeof et == "object" ? !Object.keys(et).some(tt=>!partialMatchKey(_e[tt], et[tt])) : !1
}
function replaceEqualDeep(_e, et) {
    if (_e === et)
        return _e;
    const tt = isPlainArray(_e) && isPlainArray(et);
    if (tt || isPlainObject$5(_e) && isPlainObject$5(et)) {
        const rt = tt ? _e : Object.keys(_e)
          , nt = rt.length
          , it = tt ? et : Object.keys(et)
          , st = it.length
          , at = tt ? [] : {};
        let ot = 0;
        for (let lt = 0; lt < st; lt++) {
            const dt = tt ? lt : it[lt];
            !tt && _e[dt] === void 0 && et[dt] === void 0 && rt.includes(dt) ? (at[dt] = void 0,
            ot++) : (at[dt] = replaceEqualDeep(_e[dt], et[dt]),
            at[dt] === _e[dt] && _e[dt] !== void 0 && ot++)
        }
        return nt === st && ot === nt ? _e : at
    }
    return et
}
function shallowEqualObjects(_e, et) {
    if (!et || Object.keys(_e).length !== Object.keys(et).length)
        return !1;
    for (const tt in _e)
        if (_e[tt] !== et[tt])
            return !1;
    return !0
}
function isPlainArray(_e) {
    return Array.isArray(_e) && _e.length === Object.keys(_e).length
}
function isPlainObject$5(_e) {
    if (!hasObjectPrototype$1(_e))
        return !1;
    const et = _e.constructor;
    if (typeof et > "u")
        return !0;
    const tt = et.prototype;
    return !(!hasObjectPrototype$1(tt) || !tt.hasOwnProperty("isPrototypeOf"))
}
function hasObjectPrototype$1(_e) {
    return Object.prototype.toString.call(_e) === "[object Object]"
}
function sleep(_e) {
    return new Promise(et=>{
        setTimeout(et, _e)
    }
    )
}
function replaceData(_e, et, tt) {
    return typeof tt.structuralSharing == "function" ? tt.structuralSharing(_e, et) : tt.structuralSharing !== !1 ? replaceEqualDeep(_e, et) : et
}
function addToEnd(_e, et, tt=0) {
    const rt = [..._e, et];
    return tt && rt.length > tt ? rt.slice(1) : rt
}
function addToStart(_e, et, tt=0) {
    const rt = [et, ..._e];
    return tt && rt.length > tt ? rt.slice(0, -1) : rt
}
var Vn, On, ts, Xo, FocusManager = (Xo = class extends Subscribable {
    constructor() {
        super();
        wr(this, Vn, void 0);
        wr(this, On, void 0);
        wr(this, ts, void 0);
        vr(this, ts, et=>{
            if (!isServer && window.addEventListener) {
                const tt = ()=>et();
                return window.addEventListener("visibilitychange", tt, !1),
                ()=>{
                    window.removeEventListener("visibilitychange", tt)
                }
            }
        }
        )
    }
    onSubscribe() {
        Kt(this, On) || this.setEventListener(Kt(this, ts))
    }
    onUnsubscribe() {
        var et;
        this.hasListeners() || ((et = Kt(this, On)) == null || et.call(this),
        vr(this, On, void 0))
    }
    setEventListener(et) {
        var tt;
        vr(this, ts, et),
        (tt = Kt(this, On)) == null || tt.call(this),
        vr(this, On, et(rt=>{
            typeof rt == "boolean" ? this.setFocused(rt) : this.onFocus()
        }
        ))
    }
    setFocused(et) {
        Kt(this, Vn) !== et && (vr(this, Vn, et),
        this.onFocus())
    }
    onFocus() {
        this.listeners.forEach(et=>{
            et()
        }
        )
    }
    isFocused() {
        var et;
        return typeof Kt(this, Vn) == "boolean" ? Kt(this, Vn) : ((et = globalThis.document) == null ? void 0 : et.visibilityState) !== "hidden"
    }
}
,
Vn = new WeakMap,
On = new WeakMap,
ts = new WeakMap,
Xo), focusManager$1 = new FocusManager, rs, jn, ns, Jo, OnlineManager = (Jo = class extends Subscribable {
    constructor() {
        super();
        wr(this, rs, !0);
        wr(this, jn, void 0);
        wr(this, ns, void 0);
        vr(this, ns, et=>{
            if (!isServer && window.addEventListener) {
                const tt = ()=>et(!0)
                  , rt = ()=>et(!1);
                return window.addEventListener("online", tt, !1),
                window.addEventListener("offline", rt, !1),
                ()=>{
                    window.removeEventListener("online", tt),
                    window.removeEventListener("offline", rt)
                }
            }
        }
        )
    }
    onSubscribe() {
        Kt(this, jn) || this.setEventListener(Kt(this, ns))
    }
    onUnsubscribe() {
        var et;
        this.hasListeners() || ((et = Kt(this, jn)) == null || et.call(this),
        vr(this, jn, void 0))
    }
    setEventListener(et) {
        var tt;
        vr(this, ns, et),
        (tt = Kt(this, jn)) == null || tt.call(this),
        vr(this, jn, et(this.setOnline.bind(this)))
    }
    setOnline(et) {
        Kt(this, rs) !== et && (vr(this, rs, et),
        this.listeners.forEach(rt=>{
            rt(et)
        }
        ))
    }
    isOnline() {
        return Kt(this, rs)
    }
}
,
rs = new WeakMap,
jn = new WeakMap,
ns = new WeakMap,
Jo), onlineManager = new OnlineManager;
function defaultRetryDelay(_e) {
    return Math.min(1e3 * 2 ** _e, 3e4)
}
function canFetch(_e) {
    return (_e ?? "online") === "online" ? onlineManager.isOnline() : !0
}
var CancelledError = class {
    constructor(_e) {
        this.revert = _e == null ? void 0 : _e.revert,
        this.silent = _e == null ? void 0 : _e.silent
    }
}
;
function isCancelledError(_e) {
    return _e instanceof CancelledError
}
function createRetryer(_e) {
    let et = !1, tt = 0, rt = !1, nt, it, st;
    const at = new Promise((bt,pt)=>{
        it = bt,
        st = pt
    }
    )
      , ot = bt=>{
        var pt;
        rt || (ft(new CancelledError(bt)),
        (pt = _e.abort) == null || pt.call(_e))
    }
      , lt = ()=>{
        et = !0
    }
      , dt = ()=>{
        et = !1
    }
      , ct = ()=>!focusManager$1.isFocused() || _e.networkMode !== "always" && !onlineManager.isOnline()
      , ut = bt=>{
        var pt;
        rt || (rt = !0,
        (pt = _e.onSuccess) == null || pt.call(_e, bt),
        nt == null || nt(),
        it(bt))
    }
      , ft = bt=>{
        var pt;
        rt || (rt = !0,
        (pt = _e.onError) == null || pt.call(_e, bt),
        nt == null || nt(),
        st(bt))
    }
      , ht = ()=>new Promise(bt=>{
        var pt;
        nt = mt=>{
            const yt = rt || !ct();
            return yt && bt(mt),
            yt
        }
        ,
        (pt = _e.onPause) == null || pt.call(_e)
    }
    ).then(()=>{
        var bt;
        nt = void 0,
        rt || (bt = _e.onContinue) == null || bt.call(_e)
    }
    )
      , gt = ()=>{
        if (rt)
            return;
        let bt;
        try {
            bt = _e.fn()
        } catch (pt) {
            bt = Promise.reject(pt)
        }
        Promise.resolve(bt).then(ut).catch(pt=>{
            var _t;
            if (rt)
                return;
            const mt = _e.retry ?? (isServer ? 0 : 3)
              , yt = _e.retryDelay ?? defaultRetryDelay
              , vt = typeof yt == "function" ? yt(tt, pt) : yt
              , wt = mt === !0 || typeof mt == "number" && tt < mt || typeof mt == "function" && mt(tt, pt);
            if (et || !wt) {
                ft(pt);
                return
            }
            tt++,
            (_t = _e.onFail) == null || _t.call(_e, tt, pt),
            sleep(vt).then(()=>{
                if (ct())
                    return ht()
            }
            ).then(()=>{
                et ? ft(pt) : gt()
            }
            )
        }
        )
    }
    ;
    return canFetch(_e.networkMode) ? gt() : ht().then(gt),
    {
        promise: at,
        cancel: ot,
        continue: ()=>(nt == null ? void 0 : nt()) ? at : Promise.resolve(),
        cancelRetry: lt,
        continueRetry: dt
    }
}
function createNotifyManager() {
    let _e = []
      , et = 0
      , tt = ut=>{
        ut()
    }
      , rt = ut=>{
        ut()
    }
      , nt = ut=>setTimeout(ut, 0);
    const it = ut=>{
        nt = ut
    }
      , st = ut=>{
        let ft;
        et++;
        try {
            ft = ut()
        } finally {
            et--,
            et || lt()
        }
        return ft
    }
      , at = ut=>{
        et ? _e.push(ut) : nt(()=>{
            tt(ut)
        }
        )
    }
      , ot = ut=>(...ft)=>{
        at(()=>{
            ut(...ft)
        }
        )
    }
      , lt = ()=>{
        const ut = _e;
        _e = [],
        ut.length && nt(()=>{
            rt(()=>{
                ut.forEach(ft=>{
                    tt(ft)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: st,
        batchCalls: ot,
        schedule: at,
        setNotifyFunction: ut=>{
            tt = ut
        }
        ,
        setBatchNotifyFunction: ut=>{
            rt = ut
        }
        ,
        setScheduler: it
    }
}
var notifyManager = createNotifyManager(), Hn, yl, Removable = (yl = class {
    constructor() {
        wr(this, Hn, void 0)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        isValidTimeout(this.gcTime) && vr(this, Hn, setTimeout(()=>{
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(_e) {
        this.gcTime = Math.max(this.gcTime || 0, _e ?? (isServer ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        Kt(this, Hn) && (clearTimeout(Kt(this, Hn)),
        vr(this, Hn, void 0))
    }
}
,
Hn = new WeakMap,
yl), ss, as, hn, Mn, mn, an, $s, Zn, os, Xs, bn, Tn, xl, Query = (xl = class extends Removable {
    constructor(et) {
        super();
        wr(this, os);
        wr(this, bn);
        wr(this, ss, void 0);
        wr(this, as, void 0);
        wr(this, hn, void 0);
        wr(this, Mn, void 0);
        wr(this, mn, void 0);
        wr(this, an, void 0);
        wr(this, $s, void 0);
        wr(this, Zn, void 0);
        vr(this, Zn, !1),
        vr(this, $s, et.defaultOptions),
        Or(this, os, Xs).call(this, et.options),
        vr(this, an, []),
        vr(this, hn, et.cache),
        this.queryKey = et.queryKey,
        this.queryHash = et.queryHash,
        vr(this, ss, et.state || getDefaultState$1(this.options)),
        this.state = Kt(this, ss),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    optionalRemove() {
        !Kt(this, an).length && this.state.fetchStatus === "idle" && Kt(this, hn).remove(this)
    }
    setData(et, tt) {
        const rt = replaceData(this.state.data, et, this.options);
        return Or(this, bn, Tn).call(this, {
            data: rt,
            type: "success",
            dataUpdatedAt: tt == null ? void 0 : tt.updatedAt,
            manual: tt == null ? void 0 : tt.manual
        }),
        rt
    }
    setState(et, tt) {
        Or(this, bn, Tn).call(this, {
            type: "setState",
            state: et,
            setStateOptions: tt
        })
    }
    cancel(et) {
        var rt;
        const tt = Kt(this, Mn);
        return (rt = Kt(this, mn)) == null || rt.cancel(et),
        tt ? tt.then(noop$3).catch(noop$3) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(Kt(this, ss))
    }
    isActive() {
        return Kt(this, an).some(et=>et.options.enabled !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive()
    }
    isStale() {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || Kt(this, an).some(et=>et.getCurrentResult().isStale)
    }
    isStaleByTime(et=0) {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, et)
    }
    onFocus() {
        var tt;
        const et = Kt(this, an).find(rt=>rt.shouldFetchOnWindowFocus());
        et == null || et.refetch({
            cancelRefetch: !1
        }),
        (tt = Kt(this, mn)) == null || tt.continue()
    }
    onOnline() {
        var tt;
        const et = Kt(this, an).find(rt=>rt.shouldFetchOnReconnect());
        et == null || et.refetch({
            cancelRefetch: !1
        }),
        (tt = Kt(this, mn)) == null || tt.continue()
    }
    addObserver(et) {
        Kt(this, an).includes(et) || (Kt(this, an).push(et),
        this.clearGcTimeout(),
        Kt(this, hn).notify({
            type: "observerAdded",
            query: this,
            observer: et
        }))
    }
    removeObserver(et) {
        Kt(this, an).includes(et) && (vr(this, an, Kt(this, an).filter(tt=>tt !== et)),
        Kt(this, an).length || (Kt(this, mn) && (Kt(this, Zn) ? Kt(this, mn).cancel({
            revert: !0
        }) : Kt(this, mn).cancelRetry()),
        this.scheduleGc()),
        Kt(this, hn).notify({
            type: "observerRemoved",
            query: this,
            observer: et
        }))
    }
    getObserversCount() {
        return Kt(this, an).length
    }
    invalidate() {
        this.state.isInvalidated || Or(this, bn, Tn).call(this, {
            type: "invalidate"
        })
    }
    fetch(et, tt) {
        var lt, dt, ct, ut;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.dataUpdatedAt && (tt != null && tt.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (Kt(this, Mn))
                return (lt = Kt(this, mn)) == null || lt.continueRetry(),
                Kt(this, Mn)
        }
        if (et && Or(this, os, Xs).call(this, et),
        !this.options.queryFn) {
            const ft = Kt(this, an).find(ht=>ht.options.queryFn);
            ft && Or(this, os, Xs).call(this, ft.options)
        }
        const rt = new AbortController
          , nt = {
            queryKey: this.queryKey,
            meta: this.meta
        }
          , it = ft=>{
            Object.defineProperty(ft, "signal", {
                enumerable: !0,
                get: ()=>(vr(this, Zn, !0),
                rt.signal)
            })
        }
        ;
        it(nt);
        const st = ()=>this.options.queryFn ? (vr(this, Zn, !1),
        this.options.persister ? this.options.persister(this.options.queryFn, nt, this) : this.options.queryFn(nt)) : Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`))
          , at = {
            fetchOptions: tt,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: st
        };
        it(at),
        (dt = this.options.behavior) == null || dt.onFetch(at, this),
        vr(this, as, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((ct = at.fetchOptions) == null ? void 0 : ct.meta)) && Or(this, bn, Tn).call(this, {
            type: "fetch",
            meta: (ut = at.fetchOptions) == null ? void 0 : ut.meta
        });
        const ot = ft=>{
            var ht, gt, bt, pt;
            isCancelledError(ft) && ft.silent || Or(this, bn, Tn).call(this, {
                type: "error",
                error: ft
            }),
            isCancelledError(ft) || ((gt = (ht = Kt(this, hn).config).onError) == null || gt.call(ht, ft, this),
            (pt = (bt = Kt(this, hn).config).onSettled) == null || pt.call(bt, this.state.data, ft, this)),
            this.isFetchingOptimistic || this.scheduleGc(),
            this.isFetchingOptimistic = !1
        }
        ;
        return vr(this, mn, createRetryer({
            fn: at.fetchFn,
            abort: rt.abort.bind(rt),
            onSuccess: ft=>{
                var ht, gt, bt, pt;
                if (typeof ft > "u") {
                    ot(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                this.setData(ft),
                (gt = (ht = Kt(this, hn).config).onSuccess) == null || gt.call(ht, ft, this),
                (pt = (bt = Kt(this, hn).config).onSettled) == null || pt.call(bt, ft, this.state.error, this),
                this.isFetchingOptimistic || this.scheduleGc(),
                this.isFetchingOptimistic = !1
            }
            ,
            onError: ot,
            onFail: (ft,ht)=>{
                Or(this, bn, Tn).call(this, {
                    type: "failed",
                    failureCount: ft,
                    error: ht
                })
            }
            ,
            onPause: ()=>{
                Or(this, bn, Tn).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: ()=>{
                Or(this, bn, Tn).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: at.options.retry,
            retryDelay: at.options.retryDelay,
            networkMode: at.options.networkMode
        })),
        vr(this, Mn, Kt(this, mn).promise),
        Kt(this, Mn)
    }
}
,
ss = new WeakMap,
as = new WeakMap,
hn = new WeakMap,
Mn = new WeakMap,
mn = new WeakMap,
an = new WeakMap,
$s = new WeakMap,
Zn = new WeakMap,
os = new WeakSet,
Xs = function(et) {
    this.options = {
        ...Kt(this, $s),
        ...et
    },
    this.updateGcTime(this.options.gcTime)
}
,
bn = new WeakSet,
Tn = function(et) {
    const tt = rt=>{
        switch (et.type) {
        case "failed":
            return {
                ...rt,
                fetchFailureCount: et.failureCount,
                fetchFailureReason: et.error
            };
        case "pause":
            return {
                ...rt,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...rt,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...rt,
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchMeta: et.meta ?? null,
                fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
                ...!rt.dataUpdatedAt && {
                    error: null,
                    status: "pending"
                }
            };
        case "success":
            return {
                ...rt,
                data: et.data,
                dataUpdateCount: rt.dataUpdateCount + 1,
                dataUpdatedAt: et.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!et.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const nt = et.error;
            return isCancelledError(nt) && nt.revert && Kt(this, as) ? {
                ...Kt(this, as),
                fetchStatus: "idle"
            } : {
                ...rt,
                error: nt,
                errorUpdateCount: rt.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: rt.fetchFailureCount + 1,
                fetchFailureReason: nt,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...rt,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...rt,
                ...et.state
            }
        }
    }
    ;
    this.state = tt(this.state),
    notifyManager.batch(()=>{
        Kt(this, an).forEach(rt=>{
            rt.onQueryUpdate()
        }
        ),
        Kt(this, hn).notify({
            query: this,
            type: "updated",
            action: et
        })
    }
    )
}
,
xl);
function getDefaultState$1(_e) {
    const et = typeof _e.initialData == "function" ? _e.initialData() : _e.initialData
      , tt = typeof et < "u"
      , rt = tt ? typeof _e.initialDataUpdatedAt == "function" ? _e.initialDataUpdatedAt() : _e.initialDataUpdatedAt : 0;
    return {
        data: et,
        dataUpdateCount: 0,
        dataUpdatedAt: tt ? rt ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: tt ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var _n, El, QueryCache = (El = class extends Subscribable {
    constructor(et={}) {
        super();
        wr(this, _n, void 0);
        this.config = et,
        vr(this, _n, new Map)
    }
    build(et, tt, rt) {
        const nt = tt.queryKey
          , it = tt.queryHash ?? hashQueryKeyByOptions(nt, tt);
        let st = this.get(it);
        return st || (st = new Query({
            cache: this,
            queryKey: nt,
            queryHash: it,
            options: et.defaultQueryOptions(tt),
            state: rt,
            defaultOptions: et.getQueryDefaults(nt)
        }),
        this.add(st)),
        st
    }
    add(et) {
        Kt(this, _n).has(et.queryHash) || (Kt(this, _n).set(et.queryHash, et),
        this.notify({
            type: "added",
            query: et
        }))
    }
    remove(et) {
        const tt = Kt(this, _n).get(et.queryHash);
        tt && (et.destroy(),
        tt === et && Kt(this, _n).delete(et.queryHash),
        this.notify({
            type: "removed",
            query: et
        }))
    }
    clear() {
        notifyManager.batch(()=>{
            this.getAll().forEach(et=>{
                this.remove(et)
            }
            )
        }
        )
    }
    get(et) {
        return Kt(this, _n).get(et)
    }
    getAll() {
        return [...Kt(this, _n).values()]
    }
    find(et) {
        const tt = {
            exact: !0,
            ...et
        };
        return this.getAll().find(rt=>matchQuery(tt, rt))
    }
    findAll(et={}) {
        const tt = this.getAll();
        return Object.keys(et).length > 0 ? tt.filter(rt=>matchQuery(et, rt)) : tt
    }
    notify(et) {
        notifyManager.batch(()=>{
            this.listeners.forEach(tt=>{
                tt(et)
            }
            )
        }
        )
    }
    onFocus() {
        notifyManager.batch(()=>{
            this.getAll().forEach(et=>{
                et.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        notifyManager.batch(()=>{
            this.getAll().forEach(et=>{
                et.onOnline()
            }
            )
        }
        )
    }
}
,
_n = new WeakMap,
El), Cn, Ps, dn, ls, Sn, In, _l, Mutation = (_l = class extends Removable {
    constructor(et) {
        super();
        wr(this, Sn);
        wr(this, Cn, void 0);
        wr(this, Ps, void 0);
        wr(this, dn, void 0);
        wr(this, ls, void 0);
        this.mutationId = et.mutationId,
        vr(this, Ps, et.defaultOptions),
        vr(this, dn, et.mutationCache),
        vr(this, Cn, []),
        this.state = et.state || getDefaultState(),
        this.setOptions(et.options),
        this.scheduleGc()
    }
    setOptions(et) {
        this.options = {
            ...Kt(this, Ps),
            ...et
        },
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(et) {
        Kt(this, Cn).includes(et) || (Kt(this, Cn).push(et),
        this.clearGcTimeout(),
        Kt(this, dn).notify({
            type: "observerAdded",
            mutation: this,
            observer: et
        }))
    }
    removeObserver(et) {
        vr(this, Cn, Kt(this, Cn).filter(tt=>tt !== et)),
        this.scheduleGc(),
        Kt(this, dn).notify({
            type: "observerRemoved",
            mutation: this,
            observer: et
        })
    }
    optionalRemove() {
        Kt(this, Cn).length || (this.state.status === "pending" ? this.scheduleGc() : Kt(this, dn).remove(this))
    }
    continue() {
        var et;
        return ((et = Kt(this, ls)) == null ? void 0 : et.continue()) ?? this.execute(this.state.variables)
    }
    async execute(et) {
        var nt, it, st, at, ot, lt, dt, ct, ut, ft, ht, gt, bt, pt, mt, yt, vt, wt, _t, Et;
        const tt = ()=>(vr(this, ls, createRetryer({
            fn: ()=>this.options.mutationFn ? this.options.mutationFn(et) : Promise.reject(new Error("No mutationFn found")),
            onFail: (xt,Ct)=>{
                Or(this, Sn, In).call(this, {
                    type: "failed",
                    failureCount: xt,
                    error: Ct
                })
            }
            ,
            onPause: ()=>{
                Or(this, Sn, In).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: ()=>{
                Or(this, Sn, In).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode
        })),
        Kt(this, ls).promise)
          , rt = this.state.status === "pending";
        try {
            if (!rt) {
                Or(this, Sn, In).call(this, {
                    type: "pending",
                    variables: et
                }),
                await ((it = (nt = Kt(this, dn).config).onMutate) == null ? void 0 : it.call(nt, et, this));
                const Ct = await ((at = (st = this.options).onMutate) == null ? void 0 : at.call(st, et));
                Ct !== this.state.context && Or(this, Sn, In).call(this, {
                    type: "pending",
                    context: Ct,
                    variables: et
                })
            }
            const xt = await tt();
            return await ((lt = (ot = Kt(this, dn).config).onSuccess) == null ? void 0 : lt.call(ot, xt, et, this.state.context, this)),
            await ((ct = (dt = this.options).onSuccess) == null ? void 0 : ct.call(dt, xt, et, this.state.context)),
            await ((ft = (ut = Kt(this, dn).config).onSettled) == null ? void 0 : ft.call(ut, xt, null, this.state.variables, this.state.context, this)),
            await ((gt = (ht = this.options).onSettled) == null ? void 0 : gt.call(ht, xt, null, et, this.state.context)),
            Or(this, Sn, In).call(this, {
                type: "success",
                data: xt
            }),
            xt
        } catch (xt) {
            try {
                throw await ((pt = (bt = Kt(this, dn).config).onError) == null ? void 0 : pt.call(bt, xt, et, this.state.context, this)),
                await ((yt = (mt = this.options).onError) == null ? void 0 : yt.call(mt, xt, et, this.state.context)),
                await ((wt = (vt = Kt(this, dn).config).onSettled) == null ? void 0 : wt.call(vt, void 0, xt, this.state.variables, this.state.context, this)),
                await ((Et = (_t = this.options).onSettled) == null ? void 0 : Et.call(_t, void 0, xt, et, this.state.context)),
                xt
            } finally {
                Or(this, Sn, In).call(this, {
                    type: "error",
                    error: xt
                })
            }
        }
    }
}
,
Cn = new WeakMap,
Ps = new WeakMap,
dn = new WeakMap,
ls = new WeakMap,
Sn = new WeakSet,
In = function(et) {
    const tt = rt=>{
        switch (et.type) {
        case "failed":
            return {
                ...rt,
                failureCount: et.failureCount,
                failureReason: et.error
            };
        case "pause":
            return {
                ...rt,
                isPaused: !0
            };
        case "continue":
            return {
                ...rt,
                isPaused: !1
            };
        case "pending":
            return {
                ...rt,
                context: et.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: !canFetch(this.options.networkMode),
                status: "pending",
                variables: et.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...rt,
                data: et.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...rt,
                data: void 0,
                error: et.error,
                failureCount: rt.failureCount + 1,
                failureReason: et.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = tt(this.state),
    notifyManager.batch(()=>{
        Kt(this, Cn).forEach(rt=>{
            rt.onMutationUpdate(et)
        }
        ),
        Kt(this, dn).notify({
            mutation: this,
            type: "updated",
            action: et
        })
    }
    )
}
,
_l);
function getDefaultState() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var gn, Rs, Gn, Cl, MutationCache = (Cl = class extends Subscribable {
    constructor(et={}) {
        super();
        wr(this, gn, void 0);
        wr(this, Rs, void 0);
        wr(this, Gn, void 0);
        this.config = et,
        vr(this, gn, []),
        vr(this, Rs, 0)
    }
    build(et, tt, rt) {
        const nt = new Mutation({
            mutationCache: this,
            mutationId: ++Qs(this, Rs)._,
            options: et.defaultMutationOptions(tt),
            state: rt
        });
        return this.add(nt),
        nt
    }
    add(et) {
        Kt(this, gn).push(et),
        this.notify({
            type: "added",
            mutation: et
        })
    }
    remove(et) {
        vr(this, gn, Kt(this, gn).filter(tt=>tt !== et)),
        this.notify({
            type: "removed",
            mutation: et
        })
    }
    clear() {
        notifyManager.batch(()=>{
            Kt(this, gn).forEach(et=>{
                this.remove(et)
            }
            )
        }
        )
    }
    getAll() {
        return Kt(this, gn)
    }
    find(et) {
        const tt = {
            exact: !0,
            ...et
        };
        return Kt(this, gn).find(rt=>matchMutation(tt, rt))
    }
    findAll(et={}) {
        return Kt(this, gn).filter(tt=>matchMutation(et, tt))
    }
    notify(et) {
        notifyManager.batch(()=>{
            this.listeners.forEach(tt=>{
                tt(et)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        return vr(this, Gn, (Kt(this, Gn) ?? Promise.resolve()).then(()=>{
            const et = Kt(this, gn).filter(tt=>tt.state.isPaused);
            return notifyManager.batch(()=>et.reduce((tt,rt)=>tt.then(()=>rt.continue().catch(noop$3)), Promise.resolve()))
        }
        ).then(()=>{
            vr(this, Gn, void 0)
        }
        )),
        Kt(this, Gn)
    }
}
,
gn = new WeakMap,
Rs = new WeakMap,
Gn = new WeakMap,
Cl);
function infiniteQueryBehavior(_e) {
    return {
        onFetch: (et,tt)=>{
            const rt = async()=>{
                var ht, gt, bt, pt, mt;
                const nt = et.options
                  , it = (bt = (gt = (ht = et.fetchOptions) == null ? void 0 : ht.meta) == null ? void 0 : gt.fetchMore) == null ? void 0 : bt.direction
                  , st = ((pt = et.state.data) == null ? void 0 : pt.pages) || []
                  , at = ((mt = et.state.data) == null ? void 0 : mt.pageParams) || []
                  , ot = {
                    pages: [],
                    pageParams: []
                };
                let lt = !1;
                const dt = yt=>{
                    Object.defineProperty(yt, "signal", {
                        enumerable: !0,
                        get: ()=>(et.signal.aborted ? lt = !0 : et.signal.addEventListener("abort", ()=>{
                            lt = !0
                        }
                        ),
                        et.signal)
                    })
                }
                  , ct = et.options.queryFn || (()=>Promise.reject(new Error(`Missing queryFn: '${et.options.queryHash}'`)))
                  , ut = async(yt,vt,wt)=>{
                    if (lt)
                        return Promise.reject();
                    if (vt == null && yt.pages.length)
                        return Promise.resolve(yt);
                    const _t = {
                        queryKey: et.queryKey,
                        pageParam: vt,
                        direction: wt ? "backward" : "forward",
                        meta: et.options.meta
                    };
                    dt(_t);
                    const Et = await ct(_t)
                      , {maxPages: xt} = et.options
                      , Ct = wt ? addToStart : addToEnd;
                    return {
                        pages: Ct(yt.pages, Et, xt),
                        pageParams: Ct(yt.pageParams, vt, xt)
                    }
                }
                ;
                let ft;
                if (it && st.length) {
                    const yt = it === "backward"
                      , vt = yt ? getPreviousPageParam : getNextPageParam
                      , wt = {
                        pages: st,
                        pageParams: at
                    }
                      , _t = vt(nt, wt);
                    ft = await ut(wt, _t, yt)
                } else {
                    ft = await ut(ot, at[0] ?? nt.initialPageParam);
                    const yt = _e ?? st.length;
                    for (let vt = 1; vt < yt; vt++) {
                        const wt = getNextPageParam(nt, ft);
                        ft = await ut(ft, wt)
                    }
                }
                return ft
            }
            ;
            et.options.persister ? et.fetchFn = ()=>{
                var nt, it;
                return (it = (nt = et.options).persister) == null ? void 0 : it.call(nt, rt, {
                    queryKey: et.queryKey,
                    meta: et.options.meta,
                    signal: et.signal
                }, tt)
            }
            : et.fetchFn = rt
        }
    }
}
function getNextPageParam(_e, {pages: et, pageParams: tt}) {
    const rt = et.length - 1;
    return _e.getNextPageParam(et[rt], et, tt[rt], tt)
}
function getPreviousPageParam(_e, {pages: et, pageParams: tt}) {
    var rt;
    return (rt = _e.getPreviousPageParam) == null ? void 0 : rt.call(_e, et[0], et, tt[0], tt)
}
var nn, Nn, Ln, cs, us, Dn, ds, ps, Sl, QueryClient = (Sl = class {
    constructor(_e={}) {
        wr(this, nn, void 0);
        wr(this, Nn, void 0);
        wr(this, Ln, void 0);
        wr(this, cs, void 0);
        wr(this, us, void 0);
        wr(this, Dn, void 0);
        wr(this, ds, void 0);
        wr(this, ps, void 0);
        vr(this, nn, _e.queryCache || new QueryCache),
        vr(this, Nn, _e.mutationCache || new MutationCache),
        vr(this, Ln, _e.defaultOptions || {}),
        vr(this, cs, new Map),
        vr(this, us, new Map),
        vr(this, Dn, 0)
    }
    mount() {
        Qs(this, Dn)._++,
        Kt(this, Dn) === 1 && (vr(this, ds, focusManager$1.subscribe(()=>{
            focusManager$1.isFocused() && (this.resumePausedMutations(),
            Kt(this, nn).onFocus())
        }
        )),
        vr(this, ps, onlineManager.subscribe(()=>{
            onlineManager.isOnline() && (this.resumePausedMutations(),
            Kt(this, nn).onOnline())
        }
        )))
    }
    unmount() {
        var _e, et;
        Qs(this, Dn)._--,
        Kt(this, Dn) === 0 && ((_e = Kt(this, ds)) == null || _e.call(this),
        vr(this, ds, void 0),
        (et = Kt(this, ps)) == null || et.call(this),
        vr(this, ps, void 0))
    }
    isFetching(_e) {
        return Kt(this, nn).findAll({
            ..._e,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(_e) {
        return Kt(this, Nn).findAll({
            ..._e,
            status: "pending"
        }).length
    }
    getQueryData(_e) {
        var tt;
        const et = this.defaultQueryOptions({
            queryKey: _e
        });
        return (tt = Kt(this, nn).get(et.queryHash)) == null ? void 0 : tt.state.data
    }
    ensureQueryData(_e) {
        const et = this.getQueryData(_e.queryKey);
        return et !== void 0 ? Promise.resolve(et) : this.fetchQuery(_e)
    }
    getQueriesData(_e) {
        return this.getQueryCache().findAll(_e).map(({queryKey: et, state: tt})=>{
            const rt = tt.data;
            return [et, rt]
        }
        )
    }
    setQueryData(_e, et, tt) {
        const rt = this.defaultQueryOptions({
            queryKey: _e
        })
          , nt = Kt(this, nn).get(rt.queryHash)
          , it = nt == null ? void 0 : nt.state.data
          , st = functionalUpdate(et, it);
        if (!(typeof st > "u"))
            return Kt(this, nn).build(this, rt).setData(st, {
                ...tt,
                manual: !0
            })
    }
    setQueriesData(_e, et, tt) {
        return notifyManager.batch(()=>this.getQueryCache().findAll(_e).map(({queryKey: rt})=>[rt, this.setQueryData(rt, et, tt)]))
    }
    getQueryState(_e) {
        var tt;
        const et = this.defaultQueryOptions({
            queryKey: _e
        });
        return (tt = Kt(this, nn).get(et.queryHash)) == null ? void 0 : tt.state
    }
    removeQueries(_e) {
        const et = Kt(this, nn);
        notifyManager.batch(()=>{
            et.findAll(_e).forEach(tt=>{
                et.remove(tt)
            }
            )
        }
        )
    }
    resetQueries(_e, et) {
        const tt = Kt(this, nn)
          , rt = {
            type: "active",
            ..._e
        };
        return notifyManager.batch(()=>(tt.findAll(_e).forEach(nt=>{
            nt.reset()
        }
        ),
        this.refetchQueries(rt, et)))
    }
    cancelQueries(_e={}, et={}) {
        const tt = {
            revert: !0,
            ...et
        }
          , rt = notifyManager.batch(()=>Kt(this, nn).findAll(_e).map(nt=>nt.cancel(tt)));
        return Promise.all(rt).then(noop$3).catch(noop$3)
    }
    invalidateQueries(_e={}, et={}) {
        return notifyManager.batch(()=>{
            if (Kt(this, nn).findAll(_e).forEach(rt=>{
                rt.invalidate()
            }
            ),
            _e.refetchType === "none")
                return Promise.resolve();
            const tt = {
                ..._e,
                type: _e.refetchType ?? _e.type ?? "active"
            };
            return this.refetchQueries(tt, et)
        }
        )
    }
    refetchQueries(_e={}, et) {
        const tt = {
            ...et,
            cancelRefetch: (et == null ? void 0 : et.cancelRefetch) ?? !0
        }
          , rt = notifyManager.batch(()=>Kt(this, nn).findAll(_e).filter(nt=>!nt.isDisabled()).map(nt=>{
            let it = nt.fetch(void 0, tt);
            return tt.throwOnError || (it = it.catch(noop$3)),
            nt.state.fetchStatus === "paused" ? Promise.resolve() : it
        }
        ));
        return Promise.all(rt).then(noop$3)
    }
    fetchQuery(_e) {
        const et = this.defaultQueryOptions(_e);
        typeof et.retry > "u" && (et.retry = !1);
        const tt = Kt(this, nn).build(this, et);
        return tt.isStaleByTime(et.staleTime) ? tt.fetch(et) : Promise.resolve(tt.state.data)
    }
    prefetchQuery(_e) {
        return this.fetchQuery(_e).then(noop$3).catch(noop$3)
    }
    fetchInfiniteQuery(_e) {
        return _e.behavior = infiniteQueryBehavior(_e.pages),
        this.fetchQuery(_e)
    }
    prefetchInfiniteQuery(_e) {
        return this.fetchInfiniteQuery(_e).then(noop$3).catch(noop$3)
    }
    resumePausedMutations() {
        return Kt(this, Nn).resumePausedMutations()
    }
    getQueryCache() {
        return Kt(this, nn)
    }
    getMutationCache() {
        return Kt(this, Nn)
    }
    getDefaultOptions() {
        return Kt(this, Ln)
    }
    setDefaultOptions(_e) {
        vr(this, Ln, _e)
    }
    setQueryDefaults(_e, et) {
        Kt(this, cs).set(hashKey(_e), {
            queryKey: _e,
            defaultOptions: et
        })
    }
    getQueryDefaults(_e) {
        const et = [...Kt(this, cs).values()];
        let tt = {};
        return et.forEach(rt=>{
            partialMatchKey(_e, rt.queryKey) && (tt = {
                ...tt,
                ...rt.defaultOptions
            })
        }
        ),
        tt
    }
    setMutationDefaults(_e, et) {
        Kt(this, us).set(hashKey(_e), {
            mutationKey: _e,
            defaultOptions: et
        })
    }
    getMutationDefaults(_e) {
        const et = [...Kt(this, us).values()];
        let tt = {};
        return et.forEach(rt=>{
            partialMatchKey(_e, rt.mutationKey) && (tt = {
                ...tt,
                ...rt.defaultOptions
            })
        }
        ),
        tt
    }
    defaultQueryOptions(_e) {
        if (_e._defaulted)
            return _e;
        const et = {
            ...Kt(this, Ln).queries,
            ...this.getQueryDefaults(_e.queryKey),
            ..._e,
            _defaulted: !0
        };
        return et.queryHash || (et.queryHash = hashQueryKeyByOptions(et.queryKey, et)),
        typeof et.refetchOnReconnect > "u" && (et.refetchOnReconnect = et.networkMode !== "always"),
        typeof et.throwOnError > "u" && (et.throwOnError = !!et.suspense),
        typeof et.networkMode > "u" && et.persister && (et.networkMode = "offlineFirst"),
        et
    }
    defaultMutationOptions(_e) {
        return _e != null && _e._defaulted ? _e : {
            ...Kt(this, Ln).mutations,
            ...(_e == null ? void 0 : _e.mutationKey) && this.getMutationDefaults(_e.mutationKey),
            ..._e,
            _defaulted: !0
        }
    }
    clear() {
        Kt(this, nn).clear(),
        Kt(this, Nn).clear()
    }
}
,
nn = new WeakMap,
Nn = new WeakMap,
Ln = new WeakMap,
cs = new WeakMap,
us = new WeakMap,
Dn = new WeakMap,
ds = new WeakMap,
ps = new WeakMap,
Sl), un, Kr, ks, cn, qn, fs, An, Is, hs, ms, Kn, Yn, Fn, gs, Qn, As, Os, po, js, fo, Ms, ho, Ns, mo, Ls, go, Ds, yo, Fs, vo, na, Il, Al, QueryObserver = (Al = class extends Subscribable {
    constructor(et, tt) {
        super();
        wr(this, Qn);
        wr(this, Os);
        wr(this, js);
        wr(this, Ms);
        wr(this, Ns);
        wr(this, Ls);
        wr(this, Ds);
        wr(this, Fs);
        wr(this, na);
        wr(this, un, void 0);
        wr(this, Kr, void 0);
        wr(this, ks, void 0);
        wr(this, cn, void 0);
        wr(this, qn, void 0);
        wr(this, fs, void 0);
        wr(this, An, void 0);
        wr(this, Is, void 0);
        wr(this, hs, void 0);
        wr(this, ms, void 0);
        wr(this, Kn, void 0);
        wr(this, Yn, void 0);
        wr(this, Fn, void 0);
        wr(this, gs, new Set);
        this.options = tt,
        vr(this, un, et),
        vr(this, An, null),
        this.bindMethods(),
        this.setOptions(tt)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (Kt(this, Kr).addObserver(this),
        shouldFetchOnMount(Kt(this, Kr), this.options) ? Or(this, Qn, As).call(this) : this.updateResult(),
        Or(this, Ns, mo).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return shouldFetchOn(Kt(this, Kr), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return shouldFetchOn(Kt(this, Kr), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        Or(this, Ls, go).call(this),
        Or(this, Ds, yo).call(this),
        Kt(this, Kr).removeObserver(this)
    }
    setOptions(et, tt) {
        const rt = this.options
          , nt = Kt(this, Kr);
        if (this.options = Kt(this, un).defaultQueryOptions(et),
        typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
            throw new Error("Expected enabled to be a boolean");
        Or(this, Fs, vo).call(this),
        shallowEqualObjects(this.options, rt) || Kt(this, un).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: Kt(this, Kr),
            observer: this
        });
        const it = this.hasListeners();
        it && shouldFetchOptionally(Kt(this, Kr), nt, this.options, rt) && Or(this, Qn, As).call(this),
        this.updateResult(tt),
        it && (Kt(this, Kr) !== nt || this.options.enabled !== rt.enabled || this.options.staleTime !== rt.staleTime) && Or(this, Os, po).call(this);
        const st = Or(this, js, fo).call(this);
        it && (Kt(this, Kr) !== nt || this.options.enabled !== rt.enabled || st !== Kt(this, Fn)) && Or(this, Ms, ho).call(this, st)
    }
    getOptimisticResult(et) {
        const tt = Kt(this, un).getQueryCache().build(Kt(this, un), et)
          , rt = this.createResult(tt, et);
        return shouldAssignObserverCurrentProperties(this, rt) && (vr(this, cn, rt),
        vr(this, fs, this.options),
        vr(this, qn, Kt(this, Kr).state)),
        rt
    }
    getCurrentResult() {
        return Kt(this, cn)
    }
    trackResult(et) {
        const tt = {};
        return Object.keys(et).forEach(rt=>{
            Object.defineProperty(tt, rt, {
                configurable: !1,
                enumerable: !0,
                get: ()=>(Kt(this, gs).add(rt),
                et[rt])
            })
        }
        ),
        tt
    }
    getCurrentQuery() {
        return Kt(this, Kr)
    }
    refetch({...et}={}) {
        return this.fetch({
            ...et
        })
    }
    fetchOptimistic(et) {
        const tt = Kt(this, un).defaultQueryOptions(et)
          , rt = Kt(this, un).getQueryCache().build(Kt(this, un), tt);
        return rt.isFetchingOptimistic = !0,
        rt.fetch().then(()=>this.createResult(rt, tt))
    }
    fetch(et) {
        return Or(this, Qn, As).call(this, {
            ...et,
            cancelRefetch: et.cancelRefetch ?? !0
        }).then(()=>(this.updateResult(),
        Kt(this, cn)))
    }
    createResult(et, tt) {
        var _t;
        const rt = Kt(this, Kr)
          , nt = this.options
          , it = Kt(this, cn)
          , st = Kt(this, qn)
          , at = Kt(this, fs)
          , lt = et !== rt ? et.state : Kt(this, ks)
          , {state: dt} = et;
        let {error: ct, errorUpdatedAt: ut, fetchStatus: ft, status: ht} = dt, gt = !1, bt;
        if (tt._optimisticResults) {
            const Et = this.hasListeners()
              , xt = !Et && shouldFetchOnMount(et, tt)
              , Ct = Et && shouldFetchOptionally(et, rt, tt, nt);
            (xt || Ct) && (ft = canFetch(et.options.networkMode) ? "fetching" : "paused",
            dt.dataUpdatedAt || (ht = "pending")),
            tt._optimisticResults === "isRestoring" && (ft = "idle")
        }
        if (tt.select && typeof dt.data < "u")
            if (it && dt.data === (st == null ? void 0 : st.data) && tt.select === Kt(this, Is))
                bt = Kt(this, hs);
            else
                try {
                    vr(this, Is, tt.select),
                    bt = tt.select(dt.data),
                    bt = replaceData(it == null ? void 0 : it.data, bt, tt),
                    vr(this, hs, bt),
                    vr(this, An, null)
                } catch (Et) {
                    vr(this, An, Et)
                }
        else
            bt = dt.data;
        if (typeof tt.placeholderData < "u" && typeof bt > "u" && ht === "pending") {
            let Et;
            if (it != null && it.isPlaceholderData && tt.placeholderData === (at == null ? void 0 : at.placeholderData))
                Et = it.data;
            else if (Et = typeof tt.placeholderData == "function" ? tt.placeholderData((_t = Kt(this, ms)) == null ? void 0 : _t.state.data, Kt(this, ms)) : tt.placeholderData,
            tt.select && typeof Et < "u")
                try {
                    Et = tt.select(Et),
                    vr(this, An, null)
                } catch (xt) {
                    vr(this, An, xt)
                }
            typeof Et < "u" && (ht = "success",
            bt = replaceData(it == null ? void 0 : it.data, Et, tt),
            gt = !0)
        }
        Kt(this, An) && (ct = Kt(this, An),
        bt = Kt(this, hs),
        ut = Date.now(),
        ht = "error");
        const pt = ft === "fetching"
          , mt = ht === "pending"
          , yt = ht === "error"
          , vt = mt && pt;
        return {
            status: ht,
            fetchStatus: ft,
            isPending: mt,
            isSuccess: ht === "success",
            isError: yt,
            isInitialLoading: vt,
            isLoading: vt,
            data: bt,
            dataUpdatedAt: dt.dataUpdatedAt,
            error: ct,
            errorUpdatedAt: ut,
            failureCount: dt.fetchFailureCount,
            failureReason: dt.fetchFailureReason,
            errorUpdateCount: dt.errorUpdateCount,
            isFetched: dt.dataUpdateCount > 0 || dt.errorUpdateCount > 0,
            isFetchedAfterMount: dt.dataUpdateCount > lt.dataUpdateCount || dt.errorUpdateCount > lt.errorUpdateCount,
            isFetching: pt,
            isRefetching: pt && !mt,
            isLoadingError: yt && dt.dataUpdatedAt === 0,
            isPaused: ft === "paused",
            isPlaceholderData: gt,
            isRefetchError: yt && dt.dataUpdatedAt !== 0,
            isStale: isStale(et, tt),
            refetch: this.refetch
        }
    }
    updateResult(et) {
        const tt = Kt(this, cn)
          , rt = this.createResult(Kt(this, Kr), this.options);
        if (vr(this, qn, Kt(this, Kr).state),
        vr(this, fs, this.options),
        Kt(this, qn).data !== void 0 && vr(this, ms, Kt(this, Kr)),
        shallowEqualObjects(rt, tt))
            return;
        vr(this, cn, rt);
        const nt = {}
          , it = ()=>{
            if (!tt)
                return !0;
            const {notifyOnChangeProps: st} = this.options
              , at = typeof st == "function" ? st() : st;
            if (at === "all" || !at && !Kt(this, gs).size)
                return !0;
            const ot = new Set(at ?? Kt(this, gs));
            return this.options.throwOnError && ot.add("error"),
            Object.keys(Kt(this, cn)).some(lt=>{
                const dt = lt;
                return Kt(this, cn)[dt] !== tt[dt] && ot.has(dt)
            }
            )
        }
        ;
        (et == null ? void 0 : et.listeners) !== !1 && it() && (nt.listeners = !0),
        Or(this, na, Il).call(this, {
            ...nt,
            ...et
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && Or(this, Ns, mo).call(this)
    }
}
,
un = new WeakMap,
Kr = new WeakMap,
ks = new WeakMap,
cn = new WeakMap,
qn = new WeakMap,
fs = new WeakMap,
An = new WeakMap,
Is = new WeakMap,
hs = new WeakMap,
ms = new WeakMap,
Kn = new WeakMap,
Yn = new WeakMap,
Fn = new WeakMap,
gs = new WeakMap,
Qn = new WeakSet,
As = function(et) {
    Or(this, Fs, vo).call(this);
    let tt = Kt(this, Kr).fetch(this.options, et);
    return et != null && et.throwOnError || (tt = tt.catch(noop$3)),
    tt
}
,
Os = new WeakSet,
po = function() {
    if (Or(this, Ls, go).call(this),
    isServer || Kt(this, cn).isStale || !isValidTimeout(this.options.staleTime))
        return;
    const tt = timeUntilStale(Kt(this, cn).dataUpdatedAt, this.options.staleTime) + 1;
    vr(this, Kn, setTimeout(()=>{
        Kt(this, cn).isStale || this.updateResult()
    }
    , tt))
}
,
js = new WeakSet,
fo = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(Kt(this, Kr)) : this.options.refetchInterval) ?? !1
}
,
Ms = new WeakSet,
ho = function(et) {
    Or(this, Ds, yo).call(this),
    vr(this, Fn, et),
    !(isServer || this.options.enabled === !1 || !isValidTimeout(Kt(this, Fn)) || Kt(this, Fn) === 0) && vr(this, Yn, setInterval(()=>{
        (this.options.refetchIntervalInBackground || focusManager$1.isFocused()) && Or(this, Qn, As).call(this)
    }
    , Kt(this, Fn)))
}
,
Ns = new WeakSet,
mo = function() {
    Or(this, Os, po).call(this),
    Or(this, Ms, ho).call(this, Or(this, js, fo).call(this))
}
,
Ls = new WeakSet,
go = function() {
    Kt(this, Kn) && (clearTimeout(Kt(this, Kn)),
    vr(this, Kn, void 0))
}
,
Ds = new WeakSet,
yo = function() {
    Kt(this, Yn) && (clearInterval(Kt(this, Yn)),
    vr(this, Yn, void 0))
}
,
Fs = new WeakSet,
vo = function() {
    const et = Kt(this, un).getQueryCache().build(Kt(this, un), this.options);
    if (et === Kt(this, Kr))
        return;
    const tt = Kt(this, Kr);
    vr(this, Kr, et),
    vr(this, ks, et.state),
    this.hasListeners() && (tt == null || tt.removeObserver(this),
    et.addObserver(this))
}
,
na = new WeakSet,
Il = function(et) {
    notifyManager.batch(()=>{
        et.listeners && this.listeners.forEach(tt=>{
            tt(Kt(this, cn))
        }
        ),
        Kt(this, un).getQueryCache().notify({
            query: Kt(this, Kr),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
Al);
function shouldLoadOnMount(_e, et) {
    return et.enabled !== !1 && !_e.state.dataUpdatedAt && !(_e.state.status === "error" && et.retryOnMount === !1)
}
function shouldFetchOnMount(_e, et) {
    return shouldLoadOnMount(_e, et) || _e.state.dataUpdatedAt > 0 && shouldFetchOn(_e, et, et.refetchOnMount)
}
function shouldFetchOn(_e, et, tt) {
    if (et.enabled !== !1) {
        const rt = typeof tt == "function" ? tt(_e) : tt;
        return rt === "always" || rt !== !1 && isStale(_e, et)
    }
    return !1
}
function shouldFetchOptionally(_e, et, tt, rt) {
    return tt.enabled !== !1 && (_e !== et || rt.enabled === !1) && (!tt.suspense || _e.state.status !== "error") && isStale(_e, tt)
}
function isStale(_e, et) {
    return _e.isStaleByTime(et.staleTime)
}
function shouldAssignObserverCurrentProperties(_e, et) {
    return !shallowEqualObjects(_e.getCurrentResult(), et)
}
var Bn, Wn, pn, Pn, ys, Js, Bs, bo, Tl, MutationObserver$1 = (Tl = class extends Subscribable {
    constructor(tt, rt) {
        super();
        wr(this, ys);
        wr(this, Bs);
        wr(this, Bn, void 0);
        wr(this, Wn, void 0);
        wr(this, pn, void 0);
        wr(this, Pn, void 0);
        vr(this, Bn, tt),
        this.setOptions(rt),
        this.bindMethods(),
        Or(this, ys, Js).call(this)
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(tt) {
        var nt;
        const rt = this.options;
        this.options = Kt(this, Bn).defaultMutationOptions(tt),
        shallowEqualObjects(this.options, rt) || Kt(this, Bn).getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: Kt(this, pn),
            observer: this
        }),
        rt != null && rt.mutationKey && this.options.mutationKey && hashKey(rt.mutationKey) !== hashKey(this.options.mutationKey) ? this.reset() : (nt = Kt(this, pn)) == null || nt.setOptions(this.options)
    }
    onUnsubscribe() {
        var tt;
        this.hasListeners() || (tt = Kt(this, pn)) == null || tt.removeObserver(this)
    }
    onMutationUpdate(tt) {
        Or(this, ys, Js).call(this),
        Or(this, Bs, bo).call(this, tt)
    }
    getCurrentResult() {
        return Kt(this, Wn)
    }
    reset() {
        var tt;
        (tt = Kt(this, pn)) == null || tt.removeObserver(this),
        vr(this, pn, void 0),
        Or(this, ys, Js).call(this),
        Or(this, Bs, bo).call(this)
    }
    mutate(tt, rt) {
        var nt;
        return vr(this, Pn, rt),
        (nt = Kt(this, pn)) == null || nt.removeObserver(this),
        vr(this, pn, Kt(this, Bn).getMutationCache().build(Kt(this, Bn), this.options)),
        Kt(this, pn).addObserver(this),
        Kt(this, pn).execute(tt)
    }
}
,
Bn = new WeakMap,
Wn = new WeakMap,
pn = new WeakMap,
Pn = new WeakMap,
ys = new WeakSet,
Js = function() {
    var rt;
    const tt = ((rt = Kt(this, pn)) == null ? void 0 : rt.state) ?? getDefaultState();
    vr(this, Wn, {
        ...tt,
        isPending: tt.status === "pending",
        isSuccess: tt.status === "success",
        isError: tt.status === "error",
        isIdle: tt.status === "idle",
        mutate: this.mutate,
        reset: this.reset
    })
}
,
Bs = new WeakSet,
bo = function(tt) {
    notifyManager.batch(()=>{
        var rt, nt, it, st, at, ot, lt, dt;
        if (Kt(this, Pn) && this.hasListeners()) {
            const ct = Kt(this, Wn).variables
              , ut = Kt(this, Wn).context;
            (tt == null ? void 0 : tt.type) === "success" ? ((nt = (rt = Kt(this, Pn)).onSuccess) == null || nt.call(rt, tt.data, ct, ut),
            (st = (it = Kt(this, Pn)).onSettled) == null || st.call(it, tt.data, null, ct, ut)) : (tt == null ? void 0 : tt.type) === "error" && ((ot = (at = Kt(this, Pn)).onError) == null || ot.call(at, tt.error, ct, ut),
            (dt = (lt = Kt(this, Pn)).onSettled) == null || dt.call(lt, void 0, tt.error, ct, ut))
        }
        this.listeners.forEach(ct=>{
            ct(Kt(this, Wn))
        }
        )
    }
    )
}
,
Tl), QueryClientContext = reactExports.createContext(void 0), useQueryClient = _e=>{
    const et = reactExports.useContext(QueryClientContext);
    if (_e)
        return _e;
    if (!et)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return et
}
, QueryClientProvider = ({client: _e, children: et})=>(reactExports.useEffect(()=>(_e.mount(),
()=>{
    _e.unmount()
}
), [_e]),
jsxRuntimeExports.jsx(QueryClientContext.Provider, {
    value: _e,
    children: et
})), IsRestoringContext = reactExports.createContext(!1), useIsRestoring = ()=>reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
    let _e = !1;
    return {
        clearReset: ()=>{
            _e = !1
        }
        ,
        reset: ()=>{
            _e = !0
        }
        ,
        isReset: ()=>_e
    }
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue())
  , useQueryErrorResetBoundary = ()=>reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(_e, et) {
    return typeof _e == "function" ? _e(...et) : !!_e
}
var ensurePreventErrorBoundaryRetry = (_e,et)=>{
    (_e.suspense || _e.throwOnError) && (et.isReset() || (_e.retryOnMount = !1))
}
  , useClearResetErrorBoundary = _e=>{
    reactExports.useEffect(()=>{
        _e.clearReset()
    }
    , [_e])
}
  , getHasError = ({result: _e, errorResetBoundary: et, throwOnError: tt, query: rt})=>_e.isError && !et.isReset() && !_e.isFetching && rt && shouldThrowError(tt, [_e.error, rt])
  , ensureStaleTime = _e=>{
    _e.suspense && typeof _e.staleTime != "number" && (_e.staleTime = 1e3)
}
  , shouldSuspend = (_e,et)=>(_e == null ? void 0 : _e.suspense) && et.isPending
  , fetchOptimistic = (_e,et,tt)=>et.fetchOptimistic(_e).catch(()=>{
    tt.clearReset()
}
);
function useBaseQuery(_e, et, tt) {
    const rt = useQueryClient(tt)
      , nt = useIsRestoring()
      , it = useQueryErrorResetBoundary()
      , st = rt.defaultQueryOptions(_e);
    st._optimisticResults = nt ? "isRestoring" : "optimistic",
    ensureStaleTime(st),
    ensurePreventErrorBoundaryRetry(st, it),
    useClearResetErrorBoundary(it);
    const [at] = reactExports.useState(()=>new et(rt,st))
      , ot = at.getOptimisticResult(st);
    if (reactExports.useSyncExternalStore(reactExports.useCallback(lt=>{
        const dt = nt ? ()=>{}
        : at.subscribe(notifyManager.batchCalls(lt));
        return at.updateResult(),
        dt
    }
    , [at, nt]), ()=>at.getCurrentResult(), ()=>at.getCurrentResult()),
    reactExports.useEffect(()=>{
        at.setOptions(st, {
            listeners: !1
        })
    }
    , [st, at]),
    shouldSuspend(st, ot))
        throw fetchOptimistic(st, at, it);
    if (getHasError({
        result: ot,
        errorResetBoundary: it,
        throwOnError: st.throwOnError,
        query: rt.getQueryCache().get(st.queryHash)
    }))
        throw ot.error;
    return st.notifyOnChangeProps ? ot : at.trackResult(ot)
}
function useQuery$1(_e, et) {
    return useBaseQuery(_e, QueryObserver, et)
}
function useMutation(_e, et) {
    const tt = useQueryClient(et)
      , [rt] = reactExports.useState(()=>new MutationObserver$1(tt,_e));
    reactExports.useEffect(()=>{
        rt.setOptions(_e)
    }
    , [rt, _e]);
    const nt = reactExports.useSyncExternalStore(reactExports.useCallback(st=>rt.subscribe(notifyManager.batchCalls(st)), [rt]), ()=>rt.getCurrentResult(), ()=>rt.getCurrentResult())
      , it = reactExports.useCallback((st,at)=>{
        rt.mutate(st, at).catch(noop$2)
    }
    , [rt]);
    if (nt.error && shouldThrowError(rt.options.throwOnError, [nt.error]))
        throw nt.error;
    return {
        ...nt,
        mutate: it,
        mutateAsync: nt.mutate
    }
}
function noop$2() {}
function watchChains(_e, et) {
    const {onChange: tt} = et;
    return _e._internal.chains.subscribe((rt,nt)=>{
        tt(rt, nt)
    }
    )
}
function useConfig(_e={}) {
    const et = _e.config ?? reactExports.useContext(WagmiContext);
    if (!et)
        throw new WagmiProviderNotFoundError;
    return et
}
var withSelector$1 = {
    exports: {}
}
  , withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$1 = reactExports
  , n$1 = shimExports;
function p$1(_e, et) {
    return _e === et && (_e !== 0 || 1 / _e === 1 / et) || _e !== _e && et !== et
}
var q$1 = typeof Object.is == "function" ? Object.is : p$1
  , r$1 = n$1.useSyncExternalStore
  , t$1 = h$1.useRef
  , u$1 = h$1.useEffect
  , v$2 = h$1.useMemo
  , w$1 = h$1.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(_e, et, tt, rt, nt) {
    var it = t$1(null);
    if (it.current === null) {
        var st = {
            hasValue: !1,
            value: null
        };
        it.current = st
    } else
        st = it.current;
    it = v$2(function() {
        function ot(ft) {
            if (!lt) {
                if (lt = !0,
                dt = ft,
                ft = rt(ft),
                nt !== void 0 && st.hasValue) {
                    var ht = st.value;
                    if (nt(ht, ft))
                        return ct = ht
                }
                return ct = ft
            }
            if (ht = ct,
            q$1(dt, ft))
                return ht;
            var gt = rt(ft);
            return nt !== void 0 && nt(ht, gt) ? ht : (dt = ft,
            ct = gt)
        }
        var lt = !1, dt, ct, ut = tt === void 0 ? null : tt;
        return [function() {
            return ot(et())
        }
        , ut === null ? void 0 : function() {
            return ot(ut())
        }
        ]
    }, [et, tt, rt, nt]);
    var at = r$1(_e, it[0], it[1]);
    return u$1(function() {
        st.hasValue = !0,
        st.value = at
    }, [at]),
    w$1(at),
    at
}
;
withSelector$1.exports = withSelector_production_min;
var withSelectorExports$1 = withSelector$1.exports;
const isPlainObject$4 = _e=>typeof _e == "object" && !Array.isArray(_e);
function useSyncExternalStoreWithTracked(_e, et, tt=et, rt=deepEqual$1) {
    const nt = reactExports.useRef([])
      , it = withSelectorExports$1.useSyncExternalStoreWithSelector(_e, et, tt, st=>st, (st,at)=>{
        if (isPlainObject$4(st) && isPlainObject$4(at) && nt.current.length) {
            for (const ot of nt.current)
                if (!rt(st[ot], at[ot]))
                    return !1;
            return !0
        }
        return rt(st, at)
    }
    );
    if (isPlainObject$4(it)) {
        const st = {
            ...it
        };
        return Object.defineProperties(st, Object.entries(st).reduce((at,[ot,lt])=>({
            ...at,
            [ot]: {
                configurable: !1,
                enumerable: !0,
                get: ()=>(nt.current.includes(ot) || nt.current.push(ot),
                lt)
            }
        }), {})),
        st
    }
    return it
}
function useAccount(_e={}) {
    const et = useConfig(_e);
    return useSyncExternalStoreWithTracked(tt=>watchAccount(et, {
        onChange: tt
    }), ()=>getAccount(et))
}
function hashFn(_e) {
    return JSON.stringify(_e, (et,tt)=>isPlainObject$3(tt) ? Object.keys(tt).sort().reduce((rt,nt)=>(rt[nt] = tt[nt],
    rt), {}) : typeof tt == "bigint" ? tt.toString() : tt)
}
function isPlainObject$3(_e) {
    if (!hasObjectPrototype(_e))
        return !1;
    const et = _e.constructor;
    if (typeof et > "u")
        return !0;
    const tt = et.prototype;
    return !(!hasObjectPrototype(tt) || !tt.hasOwnProperty("isPrototypeOf"))
}
function hasObjectPrototype(_e) {
    return Object.prototype.toString.call(_e) === "[object Object]"
}
function filterQueryOptions(_e) {
    const {_defaulted: et, behavior: tt, gcTime: rt, initialData: nt, initialDataUpdatedAt: it, maxPages: st, meta: at, networkMode: ot, queryFn: lt, queryHash: dt, queryKey: ct, queryKeyHashFn: ut, retry: ft, retryDelay: ht, structuralSharing: gt, getPreviousPageParam: bt, getNextPageParam: pt, initialPageParam: mt, _optimisticResults: yt, enabled: vt, notifyOnChangeProps: wt, placeholderData: _t, refetchInterval: Et, refetchIntervalInBackground: xt, refetchOnMount: Ct, refetchOnReconnect: Tt, refetchOnWindowFocus: It, retryOnMount: Nt, select: Ft, staleTime: Lt, suspense: Mt, throwOnError: $t, config: kt, connector: At, query: Pt, ...Dt} = _e;
    return Dt
}
function getBalanceQueryOptions(_e, et={}) {
    return {
        async queryFn({queryKey: tt}) {
            const {address: rt, scopeKey: nt, ...it} = tt[1];
            if (!rt)
                throw new Error("address is required");
            return await getBalance(_e, {
                ...it,
                address: rt
            }) ?? null
        },
        queryKey: getBalanceQueryKey(et)
    }
}
function getBalanceQueryKey(_e={}) {
    return ["balance", filterQueryOptions(_e)]
}
function readContractQueryOptions(_e, et={}) {
    return {
        async queryFn({queryKey: tt}) {
            const rt = et.abi;
            if (!rt)
                throw new Error("abi is required");
            const {address: nt, functionName: it, scopeKey: st, ...at} = tt[1];
            if (!nt)
                throw new Error("address is required");
            if (!it)
                throw new Error("functionName is required");
            const ot = at.args;
            return readContract(_e, {
                abi: rt,
                address: nt,
                functionName: it,
                args: ot,
                ...at
            })
        },
        queryKey: readContractQueryKey(et)
    }
}
function readContractQueryKey(_e={}) {
    const {abi: et, ...tt} = _e;
    return ["readContract", filterQueryOptions(tt)]
}
function switchChainMutationOptions(_e) {
    return {
        mutationFn(et) {
            return switchChain(_e, et)
        },
        mutationKey: ["switchChain"]
    }
}
function waitForTransactionReceiptQueryOptions(_e, et={}) {
    return {
        async queryFn({queryKey: tt}) {
            const {hash: rt, ...nt} = tt[1];
            if (!rt)
                throw new Error("hash is required");
            return waitForTransactionReceipt(_e, {
                ...nt,
                onReplaced: et.onReplaced,
                hash: rt
            })
        },
        queryKey: waitForTransactionReceiptQueryKey(et)
    }
}
function waitForTransactionReceiptQueryKey(_e={}) {
    const {onReplaced: et, ...tt} = _e;
    return ["waitForTransactionReceipt", filterQueryOptions(tt)]
}
function writeContractMutationOptions(_e) {
    return {
        mutationFn(et) {
            return writeContract(_e, et)
        },
        mutationKey: ["writeContract"]
    }
}
function useQuery(_e) {
    const et = useQuery$1({
        ..._e,
        queryKeyHashFn: hashFn
    });
    return et.queryKey = _e.queryKey,
    et
}
function structuralSharing(_e, et) {
    return deepEqual$1(_e, et) ? _e : replaceEqualDeep(_e, et)
}
function useChainId(_e={}) {
    const et = useConfig(_e);
    return reactExports.useSyncExternalStore(tt=>watchChainId(et, {
        onChange: tt
    }), ()=>getChainId(et), ()=>getChainId(et))
}
function useBalance(_e={}) {
    const {address: et, query: tt={}} = _e
      , rt = useConfig(_e)
      , nt = useChainId()
      , it = getBalanceQueryOptions(rt, {
        ..._e,
        chainId: _e.chainId ?? nt
    })
      , st = !!(et && (tt.enabled ?? !0));
    return useQuery({
        ...tt,
        ...it,
        enabled: st
    })
}
function useChains(_e={}) {
    const et = useConfig(_e);
    return reactExports.useSyncExternalStore(tt=>watchChains(et, {
        onChange: tt
    }), ()=>getChains(et), ()=>getChains(et))
}
function useReadContract(_e={}) {
    const {abi: et, address: tt, functionName: rt, query: nt={}} = _e
      , it = useConfig(_e)
      , st = useChainId()
      , at = readContractQueryOptions(it, {
        ..._e,
        chainId: _e.chainId ?? st
    })
      , ot = !!(tt && et && rt && (nt.enabled ?? !0));
    return useQuery({
        ...nt,
        ...at,
        enabled: ot,
        structuralSharing: nt.structuralSharing ?? structuralSharing
    })
}
function useSwitchChain(_e={}) {
    const {mutation: et} = _e
      , tt = useConfig(_e)
      , rt = switchChainMutationOptions(tt)
      , {mutate: nt, mutateAsync: it, ...st} = useMutation({
        ...et,
        ...rt
    });
    return {
        ...st,
        chains: useChains({
            config: tt
        }),
        switchChain: nt,
        switchChainAsync: it
    }
}
function useWaitForTransactionReceipt(_e={}) {
    const {hash: et, query: tt={}} = _e
      , rt = useConfig(_e)
      , nt = useChainId()
      , it = waitForTransactionReceiptQueryOptions(rt, {
        ..._e,
        chainId: _e.chainId ?? nt
    })
      , st = !!(et && (tt.enabled ?? !0));
    return useQuery({
        ...tt,
        ...it,
        enabled: st
    })
}
function useWriteContract(_e={}) {
    const {mutation: et} = _e
      , tt = useConfig(_e)
      , rt = writeContractMutationOptions(tt)
      , {mutate: nt, mutateAsync: it, ...st} = useMutation({
        ...et,
        ...rt
    });
    return {
        ...st,
        writeContract: nt,
        writeContractAsync: it
    }
}
var lib$1 = {
    exports: {}
}
  , Modal$1 = {}
  , propTypes$1 = {
    exports: {}
}
  , ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , ReactPropTypesSecret_1 = ReactPropTypesSecret$1
  , ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function _e(rt, nt, it, st, at, ot) {
        if (ot !== ReactPropTypesSecret) {
            var lt = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw lt.name = "Invariant Violation",
            lt
        }
    }
    _e.isRequired = _e;
    function et() {
        return _e
    }
    var tt = {
        array: _e,
        bigint: _e,
        bool: _e,
        func: _e,
        number: _e,
        object: _e,
        string: _e,
        symbol: _e,
        any: _e,
        arrayOf: et,
        element: _e,
        elementType: _e,
        instanceOf: et,
        node: _e,
        objectOf: et,
        oneOf: et,
        oneOfType: et,
        shape: et,
        exact: et,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    return tt.PropTypes = tt,
    tt
};
propTypes$1.exports = factoryWithThrowingShims();
var propTypesExports = propTypes$1.exports
  , ModalPortal = {
    exports: {}
}
  , focusManager = {}
  , tabbable = {
    exports: {}
};
(function(_e, et) {
    Object.defineProperty(et, "__esModule", {
        value: !0
    }),
    et.default = dt;
    /*!
 * Adapted from jQuery UI core
 *
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
    var tt = "none"
      , rt = "contents"
      , nt = /input|select|textarea|button|object|iframe/;
    function it(ct, ut) {
        return ut.getPropertyValue("overflow") !== "visible" || ct.scrollWidth <= 0 && ct.scrollHeight <= 0
    }
    function st(ct) {
        var ut = ct.offsetWidth <= 0 && ct.offsetHeight <= 0;
        if (ut && !ct.innerHTML)
            return !0;
        try {
            var ft = window.getComputedStyle(ct)
              , ht = ft.getPropertyValue("display");
            return ut ? ht !== rt && it(ct, ft) : ht === tt
        } catch {
            return console.warn("Failed to inspect element style"),
            !1
        }
    }
    function at(ct) {
        for (var ut = ct, ft = ct.getRootNode && ct.getRootNode(); ut && ut !== document.body; ) {
            if (ft && ut === ft && (ut = ft.host.parentNode),
            st(ut))
                return !1;
            ut = ut.parentNode
        }
        return !0
    }
    function ot(ct, ut) {
        var ft = ct.nodeName.toLowerCase()
          , ht = nt.test(ft) && !ct.disabled || ft === "a" && ct.href || ut;
        return ht && at(ct)
    }
    function lt(ct) {
        var ut = ct.getAttribute("tabindex");
        ut === null && (ut = void 0);
        var ft = isNaN(ut);
        return (ft || ut >= 0) && ot(ct, !ft)
    }
    function dt(ct) {
        var ut = [].slice.call(ct.querySelectorAll("*"), 0).reduce(function(ft, ht) {
            return ft.concat(ht.shadowRoot ? dt(ht.shadowRoot) : [ht])
        }, []);
        return ut.filter(lt)
    }
    _e.exports = et.default
}
)(tabbable, tabbable.exports);
var tabbableExports = tabbable.exports;
Object.defineProperty(focusManager, "__esModule", {
    value: !0
});
focusManager.resetState = resetState$4;
focusManager.log = log$4;
focusManager.handleBlur = handleBlur;
focusManager.handleFocus = handleFocus;
focusManager.markForFocusLater = markForFocusLater;
focusManager.returnFocus = returnFocus;
focusManager.popWithoutFocus = popWithoutFocus;
focusManager.setupScopedFocus = setupScopedFocus;
focusManager.teardownScopedFocus = teardownScopedFocus;
var _tabbable = tabbableExports
  , _tabbable2 = _interopRequireDefault$5(_tabbable);
function _interopRequireDefault$5(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
var focusLaterElements = []
  , modalElement = null
  , needToFocus = !1;
function resetState$4() {
    focusLaterElements = []
}
function log$4() {}
function handleBlur() {
    needToFocus = !0
}
function handleFocus() {
    if (needToFocus) {
        if (needToFocus = !1,
        !modalElement)
            return;
        setTimeout(function() {
            if (!modalElement.contains(document.activeElement)) {
                var _e = (0,
                _tabbable2.default)(modalElement)[0] || modalElement;
                _e.focus()
            }
        }, 0)
    }
}
function markForFocusLater() {
    focusLaterElements.push(document.activeElement)
}
function returnFocus() {
    var _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
      , et = null;
    try {
        focusLaterElements.length !== 0 && (et = focusLaterElements.pop(),
        et.focus({
            preventScroll: _e
        }));
        return
    } catch {
        console.warn(["You tried to return focus to", et, "but it is not in the DOM anymore"].join(" "))
    }
}
function popWithoutFocus() {
    focusLaterElements.length > 0 && focusLaterElements.pop()
}
function setupScopedFocus(_e) {
    modalElement = _e,
    window.addEventListener ? (window.addEventListener("blur", handleBlur, !1),
    document.addEventListener("focus", handleFocus, !0)) : (window.attachEvent("onBlur", handleBlur),
    document.attachEvent("onFocus", handleFocus))
}
function teardownScopedFocus() {
    modalElement = null,
    window.addEventListener ? (window.removeEventListener("blur", handleBlur),
    document.removeEventListener("focus", handleFocus)) : (window.detachEvent("onBlur", handleBlur),
    document.detachEvent("onFocus", handleFocus))
}
var scopeTab = {
    exports: {}
};
(function(_e, et) {
    Object.defineProperty(et, "__esModule", {
        value: !0
    }),
    et.default = st;
    var tt = tabbableExports
      , rt = nt(tt);
    function nt(at) {
        return at && at.__esModule ? at : {
            default: at
        }
    }
    function it() {
        var at = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
        return at.activeElement.shadowRoot ? it(at.activeElement.shadowRoot) : at.activeElement
    }
    function st(at, ot) {
        var lt = (0,
        rt.default)(at);
        if (!lt.length) {
            ot.preventDefault();
            return
        }
        var dt = void 0
          , ct = ot.shiftKey
          , ut = lt[0]
          , ft = lt[lt.length - 1]
          , ht = it();
        if (at === ht) {
            if (!ct)
                return;
            dt = ft
        }
        if (ft === ht && !ct && (dt = ut),
        ut === ht && ct && (dt = ft),
        dt) {
            ot.preventDefault(),
            dt.focus();
            return
        }
        var gt = /(\bChrome\b|\bSafari\b)\//.exec(navigator.userAgent)
          , bt = gt != null && gt[1] != "Chrome" && /\biPod\b|\biPad\b/g.exec(navigator.userAgent) == null;
        if (bt) {
            var pt = lt.indexOf(ht);
            if (pt > -1 && (pt += ct ? -1 : 1),
            dt = lt[pt],
            typeof dt > "u") {
                ot.preventDefault(),
                dt = ct ? ft : ut,
                dt.focus();
                return
            }
            ot.preventDefault(),
            dt.focus()
        }
    }
    _e.exports = et.default
}
)(scopeTab, scopeTab.exports);
var scopeTabExports = scopeTab.exports
  , ariaAppHider$1 = {}
  , warning = function() {}
  , warning_1 = warning
  , safeHTMLElement = {}
  , exenv = {
    exports: {}
};
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/
(function(_e) {
    (function() {
        var et = !!(typeof window < "u" && window.document && window.document.createElement)
          , tt = {
            canUseDOM: et,
            canUseWorkers: typeof Worker < "u",
            canUseEventListeners: et && !!(window.addEventListener || window.attachEvent),
            canUseViewport: et && !!window.screen
        };
        _e.exports ? _e.exports = tt : window.ExecutionEnvironment = tt
    }
    )()
}
)(exenv);
var exenvExports = exenv.exports;
Object.defineProperty(safeHTMLElement, "__esModule", {
    value: !0
});
safeHTMLElement.canUseDOM = safeHTMLElement.SafeNodeList = safeHTMLElement.SafeHTMLCollection = void 0;
var _exenv = exenvExports
  , _exenv2 = _interopRequireDefault$4(_exenv);
function _interopRequireDefault$4(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
var EE = _exenv2.default
  , SafeHTMLElement = EE.canUseDOM ? window.HTMLElement : {};
safeHTMLElement.SafeHTMLCollection = EE.canUseDOM ? window.HTMLCollection : {};
safeHTMLElement.SafeNodeList = EE.canUseDOM ? window.NodeList : {};
safeHTMLElement.canUseDOM = EE.canUseDOM;
safeHTMLElement.default = SafeHTMLElement;
Object.defineProperty(ariaAppHider$1, "__esModule", {
    value: !0
});
ariaAppHider$1.resetState = resetState$3;
ariaAppHider$1.log = log$3;
ariaAppHider$1.assertNodeList = assertNodeList;
ariaAppHider$1.setElement = setElement;
ariaAppHider$1.validateElement = validateElement;
ariaAppHider$1.hide = hide;
ariaAppHider$1.show = show;
ariaAppHider$1.documentNotReadyOrSSRTesting = documentNotReadyOrSSRTesting;
var _warning = warning_1
  , _warning2 = _interopRequireDefault$3(_warning)
  , _safeHTMLElement$1 = safeHTMLElement;
function _interopRequireDefault$3(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
var globalElement = null;
function resetState$3() {
    globalElement && (globalElement.removeAttribute ? globalElement.removeAttribute("aria-hidden") : globalElement.length != null ? globalElement.forEach(function(_e) {
        return _e.removeAttribute("aria-hidden")
    }) : document.querySelectorAll(globalElement).forEach(function(_e) {
        return _e.removeAttribute("aria-hidden")
    })),
    globalElement = null
}
function log$3() {}
function assertNodeList(_e, et) {
    if (!_e || !_e.length)
        throw new Error("react-modal: No elements were found for selector " + et + ".")
}
function setElement(_e) {
    var et = _e;
    if (typeof et == "string" && _safeHTMLElement$1.canUseDOM) {
        var tt = document.querySelectorAll(et);
        assertNodeList(tt, et),
        et = tt
    }
    return globalElement = et || globalElement,
    globalElement
}
function validateElement(_e) {
    var et = _e || globalElement;
    return et ? Array.isArray(et) || et instanceof HTMLCollection || et instanceof NodeList ? et : [et] : ((0,
    _warning2.default)(!1, ["react-modal: App element is not defined.", "Please use `Modal.setAppElement(el)` or set `appElement={el}`.", "This is needed so screen readers don't see main content", "when modal is opened. It is not recommended, but you can opt-out", "by setting `ariaHideApp={false}`."].join(" ")),
    [])
}
function hide(_e) {
    var et = !0
      , tt = !1
      , rt = void 0;
    try {
        for (var nt = validateElement(_e)[Symbol.iterator](), it; !(et = (it = nt.next()).done); et = !0) {
            var st = it.value;
            st.setAttribute("aria-hidden", "true")
        }
    } catch (at) {
        tt = !0,
        rt = at
    } finally {
        try {
            !et && nt.return && nt.return()
        } finally {
            if (tt)
                throw rt
        }
    }
}
function show(_e) {
    var et = !0
      , tt = !1
      , rt = void 0;
    try {
        for (var nt = validateElement(_e)[Symbol.iterator](), it; !(et = (it = nt.next()).done); et = !0) {
            var st = it.value;
            st.removeAttribute("aria-hidden")
        }
    } catch (at) {
        tt = !0,
        rt = at
    } finally {
        try {
            !et && nt.return && nt.return()
        } finally {
            if (tt)
                throw rt
        }
    }
}
function documentNotReadyOrSSRTesting() {
    globalElement = null
}
var classList = {};
Object.defineProperty(classList, "__esModule", {
    value: !0
});
classList.resetState = resetState$2;
classList.log = log$2;
var htmlClassList = {}
  , docBodyClassList = {};
function removeClass(_e, et) {
    _e.classList.remove(et)
}
function resetState$2() {
    var _e = document.getElementsByTagName("html")[0];
    for (var et in htmlClassList)
        removeClass(_e, htmlClassList[et]);
    var tt = document.body;
    for (var rt in docBodyClassList)
        removeClass(tt, docBodyClassList[rt]);
    htmlClassList = {},
    docBodyClassList = {}
}
function log$2() {}
var incrementReference = function(et, tt) {
    return et[tt] || (et[tt] = 0),
    et[tt] += 1,
    tt
}
  , decrementReference = function(et, tt) {
    return et[tt] && (et[tt] -= 1),
    tt
}
  , trackClass = function(et, tt, rt) {
    rt.forEach(function(nt) {
        incrementReference(tt, nt),
        et.add(nt)
    })
}
  , untrackClass = function(et, tt, rt) {
    rt.forEach(function(nt) {
        decrementReference(tt, nt),
        tt[nt] === 0 && et.remove(nt)
    })
};
classList.add = function(et, tt) {
    return trackClass(et.classList, et.nodeName.toLowerCase() == "html" ? htmlClassList : docBodyClassList, tt.split(" "))
}
;
classList.remove = function(et, tt) {
    return untrackClass(et.classList, et.nodeName.toLowerCase() == "html" ? htmlClassList : docBodyClassList, tt.split(" "))
}
;
var portalOpenInstances$1 = {};
Object.defineProperty(portalOpenInstances$1, "__esModule", {
    value: !0
});
portalOpenInstances$1.log = log$1;
portalOpenInstances$1.resetState = resetState$1;
function _classCallCheck$3(_e, et) {
    if (!(_e instanceof et))
        throw new TypeError("Cannot call a class as a function")
}
var PortalOpenInstances = function _e() {
    var et = this;
    _classCallCheck$3(this, _e),
    this.register = function(tt) {
        et.openInstances.indexOf(tt) === -1 && (et.openInstances.push(tt),
        et.emit("register"))
    }
    ,
    this.deregister = function(tt) {
        var rt = et.openInstances.indexOf(tt);
        rt !== -1 && (et.openInstances.splice(rt, 1),
        et.emit("deregister"))
    }
    ,
    this.subscribe = function(tt) {
        et.subscribers.push(tt)
    }
    ,
    this.emit = function(tt) {
        et.subscribers.forEach(function(rt) {
            return rt(tt, et.openInstances.slice())
        })
    }
    ,
    this.openInstances = [],
    this.subscribers = []
}
  , portalOpenInstances = new PortalOpenInstances;
function log$1() {
    console.log("portalOpenInstances ----------"),
    console.log(portalOpenInstances.openInstances.length),
    portalOpenInstances.openInstances.forEach(function(_e) {
        return console.log(_e)
    }),
    console.log("end portalOpenInstances ----------")
}
function resetState$1() {
    portalOpenInstances = new PortalOpenInstances
}
portalOpenInstances$1.default = portalOpenInstances;
var bodyTrap$1 = {};
Object.defineProperty(bodyTrap$1, "__esModule", {
    value: !0
});
bodyTrap$1.resetState = resetState;
bodyTrap$1.log = log;
var _portalOpenInstances = portalOpenInstances$1
  , _portalOpenInstances2 = _interopRequireDefault$2(_portalOpenInstances);
function _interopRequireDefault$2(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
var before = void 0
  , after = void 0
  , instances = [];
function resetState() {
    for (var _e = [before, after], et = 0; et < _e.length; et++) {
        var tt = _e[et];
        tt && tt.parentNode && tt.parentNode.removeChild(tt)
    }
    before = after = null,
    instances = []
}
function log() {
    console.log("bodyTrap ----------"),
    console.log(instances.length);
    for (var _e = [before, after], et = 0; et < _e.length; et++) {
        var tt = _e[et]
          , rt = tt || {};
        console.log(rt.nodeName, rt.className, rt.id)
    }
    console.log("edn bodyTrap ----------")
}
function focusContent() {
    instances.length !== 0 && instances[instances.length - 1].focusContent()
}
function bodyTrap(_e, et) {
    !before && !after && (before = document.createElement("div"),
    before.setAttribute("data-react-modal-body-trap", ""),
    before.style.position = "absolute",
    before.style.opacity = "0",
    before.setAttribute("tabindex", "0"),
    before.addEventListener("focus", focusContent),
    after = before.cloneNode(),
    after.addEventListener("focus", focusContent)),
    instances = et,
    instances.length > 0 ? (document.body.firstChild !== before && document.body.insertBefore(before, document.body.firstChild),
    document.body.lastChild !== after && document.body.appendChild(after)) : (before.parentElement && before.parentElement.removeChild(before),
    after.parentElement && after.parentElement.removeChild(after))
}
_portalOpenInstances2.default.subscribe(bodyTrap);
(function(_e, et) {
    Object.defineProperty(et, "__esModule", {
        value: !0
    });
    var tt = Object.assign || function(Lt) {
        for (var Mt = 1; Mt < arguments.length; Mt++) {
            var $t = arguments[Mt];
            for (var kt in $t)
                Object.prototype.hasOwnProperty.call($t, kt) && (Lt[kt] = $t[kt])
        }
        return Lt
    }
      , rt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Lt) {
        return typeof Lt
    }
    : function(Lt) {
        return Lt && typeof Symbol == "function" && Lt.constructor === Symbol && Lt !== Symbol.prototype ? "symbol" : typeof Lt
    }
      , nt = function() {
        function Lt(Mt, $t) {
            for (var kt = 0; kt < $t.length; kt++) {
                var At = $t[kt];
                At.enumerable = At.enumerable || !1,
                At.configurable = !0,
                "value"in At && (At.writable = !0),
                Object.defineProperty(Mt, At.key, At)
            }
        }
        return function(Mt, $t, kt) {
            return $t && Lt(Mt.prototype, $t),
            kt && Lt(Mt, kt),
            Mt
        }
    }()
      , it = reactExports
      , st = propTypesExports
      , at = wt(st)
      , ot = focusManager
      , lt = vt(ot)
      , dt = scopeTabExports
      , ct = wt(dt)
      , ut = ariaAppHider$1
      , ft = vt(ut)
      , ht = classList
      , gt = vt(ht)
      , bt = safeHTMLElement
      , pt = wt(bt)
      , mt = portalOpenInstances$1
      , yt = wt(mt);
    function vt(Lt) {
        if (Lt && Lt.__esModule)
            return Lt;
        var Mt = {};
        if (Lt != null)
            for (var $t in Lt)
                Object.prototype.hasOwnProperty.call(Lt, $t) && (Mt[$t] = Lt[$t]);
        return Mt.default = Lt,
        Mt
    }
    function wt(Lt) {
        return Lt && Lt.__esModule ? Lt : {
            default: Lt
        }
    }
    function _t(Lt, Mt) {
        if (!(Lt instanceof Mt))
            throw new TypeError("Cannot call a class as a function")
    }
    function Et(Lt, Mt) {
        if (!Lt)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return Mt && (typeof Mt == "object" || typeof Mt == "function") ? Mt : Lt
    }
    function xt(Lt, Mt) {
        if (typeof Mt != "function" && Mt !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof Mt);
        Lt.prototype = Object.create(Mt && Mt.prototype, {
            constructor: {
                value: Lt,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        Mt && (Object.setPrototypeOf ? Object.setPrototypeOf(Lt, Mt) : Lt.__proto__ = Mt)
    }
    var Ct = {
        overlay: "ReactModal__Overlay",
        content: "ReactModal__Content"
    }
      , Tt = function(Mt) {
        return Mt.code === "Tab" || Mt.keyCode === 9
    }
      , It = function(Mt) {
        return Mt.code === "Escape" || Mt.keyCode === 27
    }
      , Nt = 0
      , Ft = function(Lt) {
        xt(Mt, Lt);
        function Mt($t) {
            _t(this, Mt);
            var kt = Et(this, (Mt.__proto__ || Object.getPrototypeOf(Mt)).call(this, $t));
            return kt.setOverlayRef = function(At) {
                kt.overlay = At,
                kt.props.overlayRef && kt.props.overlayRef(At)
            }
            ,
            kt.setContentRef = function(At) {
                kt.content = At,
                kt.props.contentRef && kt.props.contentRef(At)
            }
            ,
            kt.afterClose = function() {
                var At = kt.props
                  , Pt = At.appElement
                  , Dt = At.ariaHideApp
                  , Bt = At.htmlOpenClassName
                  , zt = At.bodyOpenClassName
                  , Yt = At.parentSelector
                  , rr = Yt && Yt().ownerDocument || document;
                zt && gt.remove(rr.body, zt),
                Bt && gt.remove(rr.getElementsByTagName("html")[0], Bt),
                Dt && Nt > 0 && (Nt -= 1,
                Nt === 0 && ft.show(Pt)),
                kt.props.shouldFocusAfterRender && (kt.props.shouldReturnFocusAfterClose ? (lt.returnFocus(kt.props.preventScroll),
                lt.teardownScopedFocus()) : lt.popWithoutFocus()),
                kt.props.onAfterClose && kt.props.onAfterClose(),
                yt.default.deregister(kt)
            }
            ,
            kt.open = function() {
                kt.beforeOpen(),
                kt.state.afterOpen && kt.state.beforeClose ? (clearTimeout(kt.closeTimer),
                kt.setState({
                    beforeClose: !1
                })) : (kt.props.shouldFocusAfterRender && (lt.setupScopedFocus(kt.node),
                lt.markForFocusLater()),
                kt.setState({
                    isOpen: !0
                }, function() {
                    kt.openAnimationFrame = requestAnimationFrame(function() {
                        kt.setState({
                            afterOpen: !0
                        }),
                        kt.props.isOpen && kt.props.onAfterOpen && kt.props.onAfterOpen({
                            overlayEl: kt.overlay,
                            contentEl: kt.content
                        })
                    })
                }))
            }
            ,
            kt.close = function() {
                kt.props.closeTimeoutMS > 0 ? kt.closeWithTimeout() : kt.closeWithoutTimeout()
            }
            ,
            kt.focusContent = function() {
                return kt.content && !kt.contentHasFocus() && kt.content.focus({
                    preventScroll: !0
                })
            }
            ,
            kt.closeWithTimeout = function() {
                var At = Date.now() + kt.props.closeTimeoutMS;
                kt.setState({
                    beforeClose: !0,
                    closesAt: At
                }, function() {
                    kt.closeTimer = setTimeout(kt.closeWithoutTimeout, kt.state.closesAt - Date.now())
                })
            }
            ,
            kt.closeWithoutTimeout = function() {
                kt.setState({
                    beforeClose: !1,
                    isOpen: !1,
                    afterOpen: !1,
                    closesAt: null
                }, kt.afterClose)
            }
            ,
            kt.handleKeyDown = function(At) {
                Tt(At) && (0,
                ct.default)(kt.content, At),
                kt.props.shouldCloseOnEsc && It(At) && (At.stopPropagation(),
                kt.requestClose(At))
            }
            ,
            kt.handleOverlayOnClick = function(At) {
                kt.shouldClose === null && (kt.shouldClose = !0),
                kt.shouldClose && kt.props.shouldCloseOnOverlayClick && (kt.ownerHandlesClose() ? kt.requestClose(At) : kt.focusContent()),
                kt.shouldClose = null
            }
            ,
            kt.handleContentOnMouseUp = function() {
                kt.shouldClose = !1
            }
            ,
            kt.handleOverlayOnMouseDown = function(At) {
                !kt.props.shouldCloseOnOverlayClick && At.target == kt.overlay && At.preventDefault()
            }
            ,
            kt.handleContentOnClick = function() {
                kt.shouldClose = !1
            }
            ,
            kt.handleContentOnMouseDown = function() {
                kt.shouldClose = !1
            }
            ,
            kt.requestClose = function(At) {
                return kt.ownerHandlesClose() && kt.props.onRequestClose(At)
            }
            ,
            kt.ownerHandlesClose = function() {
                return kt.props.onRequestClose
            }
            ,
            kt.shouldBeClosed = function() {
                return !kt.state.isOpen && !kt.state.beforeClose
            }
            ,
            kt.contentHasFocus = function() {
                return document.activeElement === kt.content || kt.content.contains(document.activeElement)
            }
            ,
            kt.buildClassName = function(At, Pt) {
                var Dt = (typeof Pt > "u" ? "undefined" : rt(Pt)) === "object" ? Pt : {
                    base: Ct[At],
                    afterOpen: Ct[At] + "--after-open",
                    beforeClose: Ct[At] + "--before-close"
                }
                  , Bt = Dt.base;
                return kt.state.afterOpen && (Bt = Bt + " " + Dt.afterOpen),
                kt.state.beforeClose && (Bt = Bt + " " + Dt.beforeClose),
                typeof Pt == "string" && Pt ? Bt + " " + Pt : Bt
            }
            ,
            kt.attributesFromObject = function(At, Pt) {
                return Object.keys(Pt).reduce(function(Dt, Bt) {
                    return Dt[At + "-" + Bt] = Pt[Bt],
                    Dt
                }, {})
            }
            ,
            kt.state = {
                afterOpen: !1,
                beforeClose: !1
            },
            kt.shouldClose = null,
            kt.moveFromContentToOverlay = null,
            kt
        }
        return nt(Mt, [{
            key: "componentDidMount",
            value: function() {
                this.props.isOpen && this.open()
            }
        }, {
            key: "componentDidUpdate",
            value: function(kt, At) {
                this.props.isOpen && !kt.isOpen ? this.open() : !this.props.isOpen && kt.isOpen && this.close(),
                this.props.shouldFocusAfterRender && this.state.isOpen && !At.isOpen && this.focusContent()
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                this.state.isOpen && this.afterClose(),
                clearTimeout(this.closeTimer),
                cancelAnimationFrame(this.openAnimationFrame)
            }
        }, {
            key: "beforeOpen",
            value: function() {
                var kt = this.props
                  , At = kt.appElement
                  , Pt = kt.ariaHideApp
                  , Dt = kt.htmlOpenClassName
                  , Bt = kt.bodyOpenClassName
                  , zt = kt.parentSelector
                  , Yt = zt && zt().ownerDocument || document;
                Bt && gt.add(Yt.body, Bt),
                Dt && gt.add(Yt.getElementsByTagName("html")[0], Dt),
                Pt && (Nt += 1,
                ft.hide(At)),
                yt.default.register(this)
            }
        }, {
            key: "render",
            value: function() {
                var kt = this.props
                  , At = kt.id
                  , Pt = kt.className
                  , Dt = kt.overlayClassName
                  , Bt = kt.defaultStyles
                  , zt = kt.children
                  , Yt = Pt ? {} : Bt.content
                  , rr = Dt ? {} : Bt.overlay;
                if (this.shouldBeClosed())
                    return null;
                var ar = {
                    ref: this.setOverlayRef,
                    className: this.buildClassName("overlay", Dt),
                    style: tt({}, rr, this.props.style.overlay),
                    onClick: this.handleOverlayOnClick,
                    onMouseDown: this.handleOverlayOnMouseDown
                }
                  , or = tt({
                    id: At,
                    ref: this.setContentRef,
                    style: tt({}, Yt, this.props.style.content),
                    className: this.buildClassName("content", Pt),
                    tabIndex: "-1",
                    onKeyDown: this.handleKeyDown,
                    onMouseDown: this.handleContentOnMouseDown,
                    onMouseUp: this.handleContentOnMouseUp,
                    onClick: this.handleContentOnClick,
                    role: this.props.role,
                    "aria-label": this.props.contentLabel
                }, this.attributesFromObject("aria", tt({
                    modal: !0
                }, this.props.aria)), this.attributesFromObject("data", this.props.data || {}), {
                    "data-testid": this.props.testId
                })
                  , pr = this.props.contentElement(or, zt);
                return this.props.overlayElement(ar, pr)
            }
        }]),
        Mt
    }(it.Component);
    Ft.defaultProps = {
        style: {
            overlay: {},
            content: {}
        },
        defaultStyles: {}
    },
    Ft.propTypes = {
        isOpen: at.default.bool.isRequired,
        defaultStyles: at.default.shape({
            content: at.default.object,
            overlay: at.default.object
        }),
        style: at.default.shape({
            content: at.default.object,
            overlay: at.default.object
        }),
        className: at.default.oneOfType([at.default.string, at.default.object]),
        overlayClassName: at.default.oneOfType([at.default.string, at.default.object]),
        parentSelector: at.default.func,
        bodyOpenClassName: at.default.string,
        htmlOpenClassName: at.default.string,
        ariaHideApp: at.default.bool,
        appElement: at.default.oneOfType([at.default.instanceOf(pt.default), at.default.instanceOf(bt.SafeHTMLCollection), at.default.instanceOf(bt.SafeNodeList), at.default.arrayOf(at.default.instanceOf(pt.default))]),
        onAfterOpen: at.default.func,
        onAfterClose: at.default.func,
        onRequestClose: at.default.func,
        closeTimeoutMS: at.default.number,
        shouldFocusAfterRender: at.default.bool,
        shouldCloseOnOverlayClick: at.default.bool,
        shouldReturnFocusAfterClose: at.default.bool,
        preventScroll: at.default.bool,
        role: at.default.string,
        contentLabel: at.default.string,
        aria: at.default.object,
        data: at.default.object,
        children: at.default.node,
        shouldCloseOnEsc: at.default.bool,
        overlayRef: at.default.func,
        contentRef: at.default.func,
        id: at.default.string,
        overlayElement: at.default.func,
        contentElement: at.default.func,
        testId: at.default.string
    },
    et.default = Ft,
    _e.exports = et.default
}
)(ModalPortal, ModalPortal.exports);
var ModalPortalExports = ModalPortal.exports;
function componentWillMount() {
    var _e = this.constructor.getDerivedStateFromProps(this.props, this.state);
    _e != null && this.setState(_e)
}
function componentWillReceiveProps(_e) {
    function et(tt) {
        var rt = this.constructor.getDerivedStateFromProps(_e, tt);
        return rt ?? null
    }
    this.setState(et.bind(this))
}
function componentWillUpdate(_e, et) {
    try {
        var tt = this.props
          , rt = this.state;
        this.props = _e,
        this.state = et,
        this.__reactInternalSnapshotFlag = !0,
        this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(tt, rt)
    } finally {
        this.props = tt,
        this.state = rt
    }
}
componentWillMount.__suppressDeprecationWarning = !0;
componentWillReceiveProps.__suppressDeprecationWarning = !0;
componentWillUpdate.__suppressDeprecationWarning = !0;
function polyfill(_e) {
    var et = _e.prototype;
    if (!et || !et.isReactComponent)
        throw new Error("Can only polyfill class components");
    if (typeof _e.getDerivedStateFromProps != "function" && typeof et.getSnapshotBeforeUpdate != "function")
        return _e;
    var tt = null
      , rt = null
      , nt = null;
    if (typeof et.componentWillMount == "function" ? tt = "componentWillMount" : typeof et.UNSAFE_componentWillMount == "function" && (tt = "UNSAFE_componentWillMount"),
    typeof et.componentWillReceiveProps == "function" ? rt = "componentWillReceiveProps" : typeof et.UNSAFE_componentWillReceiveProps == "function" && (rt = "UNSAFE_componentWillReceiveProps"),
    typeof et.componentWillUpdate == "function" ? nt = "componentWillUpdate" : typeof et.UNSAFE_componentWillUpdate == "function" && (nt = "UNSAFE_componentWillUpdate"),
    tt !== null || rt !== null || nt !== null) {
        var it = _e.displayName || _e.name
          , st = typeof _e.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
        throw Error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

` + it + " uses " + st + " but also contains the following legacy lifecycles:" + (tt !== null ? `
  ` + tt : "") + (rt !== null ? `
  ` + rt : "") + (nt !== null ? `
  ` + nt : "") + `

The above lifecycles should be removed. Learn more about this warning here:
https://fb.me/react-async-component-lifecycle-hooks`)
    }
    if (typeof _e.getDerivedStateFromProps == "function" && (et.componentWillMount = componentWillMount,
    et.componentWillReceiveProps = componentWillReceiveProps),
    typeof et.getSnapshotBeforeUpdate == "function") {
        if (typeof et.componentDidUpdate != "function")
            throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
        et.componentWillUpdate = componentWillUpdate;
        var at = et.componentDidUpdate;
        et.componentDidUpdate = function(lt, dt, ct) {
            var ut = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : ct;
            at.call(this, lt, dt, ut)
        }
    }
    return _e
}
const reactLifecyclesCompat_es = Object.freeze(Object.defineProperty({
    __proto__: null,
    polyfill
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$6 = getAugmentedNamespace(reactLifecyclesCompat_es);
Object.defineProperty(Modal$1, "__esModule", {
    value: !0
});
Modal$1.bodyOpenClassName = Modal$1.portalClassName = void 0;
var _extends$2 = Object.assign || function(_e) {
    for (var et = 1; et < arguments.length; et++) {
        var tt = arguments[et];
        for (var rt in tt)
            Object.prototype.hasOwnProperty.call(tt, rt) && (_e[rt] = tt[rt])
    }
    return _e
}
  , _createClass$2 = function() {
    function _e(et, tt) {
        for (var rt = 0; rt < tt.length; rt++) {
            var nt = tt[rt];
            nt.enumerable = nt.enumerable || !1,
            nt.configurable = !0,
            "value"in nt && (nt.writable = !0),
            Object.defineProperty(et, nt.key, nt)
        }
    }
    return function(et, tt, rt) {
        return tt && _e(et.prototype, tt),
        rt && _e(et, rt),
        et
    }
}()
  , _react$1 = reactExports
  , _react2 = _interopRequireDefault$1(_react$1)
  , _reactDom = reactDomExports
  , _reactDom2 = _interopRequireDefault$1(_reactDom)
  , _propTypes = propTypesExports
  , _propTypes2 = _interopRequireDefault$1(_propTypes)
  , _ModalPortal = ModalPortalExports
  , _ModalPortal2 = _interopRequireDefault$1(_ModalPortal)
  , _ariaAppHider = ariaAppHider$1
  , ariaAppHider = _interopRequireWildcard(_ariaAppHider)
  , _safeHTMLElement = safeHTMLElement
  , _safeHTMLElement2 = _interopRequireDefault$1(_safeHTMLElement)
  , _reactLifecyclesCompat = require$$6;
function _interopRequireWildcard(_e) {
    if (_e && _e.__esModule)
        return _e;
    var et = {};
    if (_e != null)
        for (var tt in _e)
            Object.prototype.hasOwnProperty.call(_e, tt) && (et[tt] = _e[tt]);
    return et.default = _e,
    et
}
function _interopRequireDefault$1(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
function _classCallCheck$2(_e, et) {
    if (!(_e instanceof et))
        throw new TypeError("Cannot call a class as a function")
}
function _possibleConstructorReturn$2(_e, et) {
    if (!_e)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return et && (typeof et == "object" || typeof et == "function") ? et : _e
}
function _inherits$2(_e, et) {
    if (typeof et != "function" && et !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof et);
    _e.prototype = Object.create(et && et.prototype, {
        constructor: {
            value: _e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    et && (Object.setPrototypeOf ? Object.setPrototypeOf(_e, et) : _e.__proto__ = et)
}
var portalClassName = Modal$1.portalClassName = "ReactModalPortal"
  , bodyOpenClassName = Modal$1.bodyOpenClassName = "ReactModal__Body--open"
  , isReact16 = _safeHTMLElement.canUseDOM && _reactDom2.default.createPortal !== void 0
  , createHTMLElement = function(et) {
    return document.createElement(et)
}
  , getCreatePortal = function() {
    return isReact16 ? _reactDom2.default.createPortal : _reactDom2.default.unstable_renderSubtreeIntoContainer
};
function getParentElement(_e) {
    return _e()
}
var Modal = function(_e) {
    _inherits$2(et, _e);
    function et() {
        var tt, rt, nt, it;
        _classCallCheck$2(this, et);
        for (var st = arguments.length, at = Array(st), ot = 0; ot < st; ot++)
            at[ot] = arguments[ot];
        return it = (rt = (nt = _possibleConstructorReturn$2(this, (tt = et.__proto__ || Object.getPrototypeOf(et)).call.apply(tt, [this].concat(at))),
        nt),
        nt.removePortal = function() {
            !isReact16 && _reactDom2.default.unmountComponentAtNode(nt.node);
            var lt = getParentElement(nt.props.parentSelector);
            lt && lt.contains(nt.node) ? lt.removeChild(nt.node) : console.warn('React-Modal: "parentSelector" prop did not returned any DOM element. Make sure that the parent element is unmounted to avoid any memory leaks.')
        }
        ,
        nt.portalRef = function(lt) {
            nt.portal = lt
        }
        ,
        nt.renderPortal = function(lt) {
            var dt = getCreatePortal()
              , ct = dt(nt, _react2.default.createElement(_ModalPortal2.default, _extends$2({
                defaultStyles: et.defaultStyles
            }, lt)), nt.node);
            nt.portalRef(ct)
        }
        ,
        rt),
        _possibleConstructorReturn$2(nt, it)
    }
    return _createClass$2(et, [{
        key: "componentDidMount",
        value: function() {
            if (_safeHTMLElement.canUseDOM) {
                isReact16 || (this.node = createHTMLElement("div")),
                this.node.className = this.props.portalClassName;
                var rt = getParentElement(this.props.parentSelector);
                rt.appendChild(this.node),
                !isReact16 && this.renderPortal(this.props)
            }
        }
    }, {
        key: "getSnapshotBeforeUpdate",
        value: function(rt) {
            var nt = getParentElement(rt.parentSelector)
              , it = getParentElement(this.props.parentSelector);
            return {
                prevParent: nt,
                nextParent: it
            }
        }
    }, {
        key: "componentDidUpdate",
        value: function(rt, nt, it) {
            if (_safeHTMLElement.canUseDOM) {
                var st = this.props
                  , at = st.isOpen
                  , ot = st.portalClassName;
                rt.portalClassName !== ot && (this.node.className = ot);
                var lt = it.prevParent
                  , dt = it.nextParent;
                dt !== lt && (lt.removeChild(this.node),
                dt.appendChild(this.node)),
                !(!rt.isOpen && !at) && !isReact16 && this.renderPortal(this.props)
            }
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            if (!(!_safeHTMLElement.canUseDOM || !this.node || !this.portal)) {
                var rt = this.portal.state
                  , nt = Date.now()
                  , it = rt.isOpen && this.props.closeTimeoutMS && (rt.closesAt || nt + this.props.closeTimeoutMS);
                it ? (rt.beforeClose || this.portal.closeWithTimeout(),
                setTimeout(this.removePortal, it - nt)) : this.removePortal()
            }
        }
    }, {
        key: "render",
        value: function() {
            if (!_safeHTMLElement.canUseDOM || !isReact16)
                return null;
            !this.node && isReact16 && (this.node = createHTMLElement("div"));
            var rt = getCreatePortal();
            return rt(_react2.default.createElement(_ModalPortal2.default, _extends$2({
                ref: this.portalRef,
                defaultStyles: et.defaultStyles
            }, this.props)), this.node)
        }
    }], [{
        key: "setAppElement",
        value: function(rt) {
            ariaAppHider.setElement(rt)
        }
    }]),
    et
}(_react$1.Component);
Modal.propTypes = {
    isOpen: _propTypes2.default.bool.isRequired,
    style: _propTypes2.default.shape({
        content: _propTypes2.default.object,
        overlay: _propTypes2.default.object
    }),
    portalClassName: _propTypes2.default.string,
    bodyOpenClassName: _propTypes2.default.string,
    htmlOpenClassName: _propTypes2.default.string,
    className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
        base: _propTypes2.default.string.isRequired,
        afterOpen: _propTypes2.default.string.isRequired,
        beforeClose: _propTypes2.default.string.isRequired
    })]),
    overlayClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
        base: _propTypes2.default.string.isRequired,
        afterOpen: _propTypes2.default.string.isRequired,
        beforeClose: _propTypes2.default.string.isRequired
    })]),
    appElement: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(_safeHTMLElement2.default), _propTypes2.default.instanceOf(_safeHTMLElement.SafeHTMLCollection), _propTypes2.default.instanceOf(_safeHTMLElement.SafeNodeList), _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_safeHTMLElement2.default))]),
    onAfterOpen: _propTypes2.default.func,
    onRequestClose: _propTypes2.default.func,
    closeTimeoutMS: _propTypes2.default.number,
    ariaHideApp: _propTypes2.default.bool,
    shouldFocusAfterRender: _propTypes2.default.bool,
    shouldCloseOnOverlayClick: _propTypes2.default.bool,
    shouldReturnFocusAfterClose: _propTypes2.default.bool,
    preventScroll: _propTypes2.default.bool,
    parentSelector: _propTypes2.default.func,
    aria: _propTypes2.default.object,
    data: _propTypes2.default.object,
    role: _propTypes2.default.string,
    contentLabel: _propTypes2.default.string,
    shouldCloseOnEsc: _propTypes2.default.bool,
    overlayRef: _propTypes2.default.func,
    contentRef: _propTypes2.default.func,
    id: _propTypes2.default.string,
    overlayElement: _propTypes2.default.func,
    contentElement: _propTypes2.default.func
};
Modal.defaultProps = {
    isOpen: !1,
    portalClassName,
    bodyOpenClassName,
    role: "dialog",
    ariaHideApp: !0,
    closeTimeoutMS: 0,
    shouldFocusAfterRender: !0,
    shouldCloseOnEsc: !0,
    shouldCloseOnOverlayClick: !0,
    shouldReturnFocusAfterClose: !0,
    preventScroll: !1,
    parentSelector: function() {
        return document.body
    },
    overlayElement: function(et, tt) {
        return _react2.default.createElement("div", et, tt)
    },
    contentElement: function(et, tt) {
        return _react2.default.createElement("div", et, tt)
    }
};
Modal.defaultStyles = {
    overlay: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(255, 255, 255, 0.75)"
    },
    content: {
        position: "absolute",
        top: "40px",
        left: "40px",
        right: "40px",
        bottom: "40px",
        border: "1px solid #ccc",
        background: "#fff",
        overflow: "auto",
        WebkitOverflowScrolling: "touch",
        borderRadius: "4px",
        outline: "none",
        padding: "20px"
    }
};
(0,
_reactLifecyclesCompat.polyfill)(Modal);
Modal$1.default = Modal;
(function(_e, et) {
    Object.defineProperty(et, "__esModule", {
        value: !0
    });
    var tt = Modal$1
      , rt = nt(tt);
    function nt(it) {
        return it && it.__esModule ? it : {
            default: it
        }
    }
    et.default = rt.default,
    _e.exports = et.default
}
)(lib$1, lib$1.exports);
var libExports = lib$1.exports;
const ReactModal = getDefaultExportFromCjs(libExports);
var DefaultContext = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , IconContext = React$1.createContext && React$1.createContext(DefaultContext)
  , _excluded$1 = ["attr", "size", "title"];
function _objectWithoutProperties$1(_e, et) {
    if (_e == null)
        return {};
    var tt = _objectWithoutPropertiesLoose$1(_e, et), rt, nt;
    if (Object.getOwnPropertySymbols) {
        var it = Object.getOwnPropertySymbols(_e);
        for (nt = 0; nt < it.length; nt++)
            rt = it[nt],
            !(et.indexOf(rt) >= 0) && Object.prototype.propertyIsEnumerable.call(_e, rt) && (tt[rt] = _e[rt])
    }
    return tt
}
function _objectWithoutPropertiesLoose$1(_e, et) {
    if (_e == null)
        return {};
    var tt = {}, rt = Object.keys(_e), nt, it;
    for (it = 0; it < rt.length; it++)
        nt = rt[it],
        !(et.indexOf(nt) >= 0) && (tt[nt] = _e[nt]);
    return tt
}
function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var et = 1; et < arguments.length; et++) {
            var tt = arguments[et];
            for (var rt in tt)
                Object.prototype.hasOwnProperty.call(tt, rt) && (_e[rt] = tt[rt])
        }
        return _e
    }
    ,
    _extends$1.apply(this, arguments)
}
function ownKeys$1(_e, et) {
    var tt = Object.keys(_e);
    if (Object.getOwnPropertySymbols) {
        var rt = Object.getOwnPropertySymbols(_e);
        et && (rt = rt.filter(function(nt) {
            return Object.getOwnPropertyDescriptor(_e, nt).enumerable
        })),
        tt.push.apply(tt, rt)
    }
    return tt
}
function _objectSpread$1(_e) {
    for (var et = 1; et < arguments.length; et++) {
        var tt = arguments[et] != null ? arguments[et] : {};
        et % 2 ? ownKeys$1(Object(tt), !0).forEach(function(rt) {
            _defineProperty$1(_e, rt, tt[rt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_e, Object.getOwnPropertyDescriptors(tt)) : ownKeys$1(Object(tt)).forEach(function(rt) {
            Object.defineProperty(_e, rt, Object.getOwnPropertyDescriptor(tt, rt))
        })
    }
    return _e
}
function _defineProperty$1(_e, et, tt) {
    return et = _toPropertyKey(et),
    et in _e ? Object.defineProperty(_e, et, {
        value: tt,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : _e[et] = tt,
    _e
}
function _toPropertyKey(_e) {
    var et = _toPrimitive(_e, "string");
    return typeof et == "symbol" ? et : String(et)
}
function _toPrimitive(_e, et) {
    if (typeof _e != "object" || _e === null)
        return _e;
    var tt = _e[Symbol.toPrimitive];
    if (tt !== void 0) {
        var rt = tt.call(_e, et || "default");
        if (typeof rt != "object")
            return rt;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (et === "string" ? String : Number)(_e)
}
function Tree2Element(_e) {
    return _e && _e.map((et,tt)=>React$1.createElement(et.tag, _objectSpread$1({
        key: tt
    }, et.attr), Tree2Element(et.child)))
}
function GenIcon(_e) {
    return et=>React$1.createElement(IconBase, _extends$1({
        attr: _objectSpread$1({}, _e.attr)
    }, et), Tree2Element(_e.child))
}
function IconBase(_e) {
    var et = tt=>{
        var {attr: rt, size: nt, title: it} = _e, st = _objectWithoutProperties$1(_e, _excluded$1), at = nt || tt.size || "1em", ot;
        return tt.className && (ot = tt.className),
        _e.className && (ot = (ot ? ot + " " : "") + _e.className),
        React$1.createElement("svg", _extends$1({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, tt.attr, rt, st, {
            className: ot,
            style: _objectSpread$1(_objectSpread$1({
                color: _e.color || tt.color
            }, tt.style), _e.style),
            height: at,
            width: at,
            xmlns: "http://www.w3.org/2000/svg"
        }), it && React$1.createElement("title", null, it), _e.children)
    }
    ;
    return IconContext !== void 0 ? React$1.createElement(IconContext.Consumer, null, tt=>et(tt)) : et(DefaultContext)
}
function VscReferences(_e) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            fill: "currentColor"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                clipRule: "evenodd",
                d: "M11.105 4.561l-3.43 3.427-1.134-1.12 2.07-2.08h-4.8a2.4 2.4 0 1 0 0 4.8h.89v1.6h-.88a4 4 0 0 1 0-7.991h4.8L6.54 1.13 7.675 0l3.43 3.432v1.13zM16.62 24h-9.6l-.8-.8V10.412l.8-.8h9.6l.8.8V23.2l-.8.8zm-8.8-1.6h8V11.212h-8V22.4zm5.6-20.798h9.6l.8.8v12.786l-.8.8h-4v-1.6h3.2V3.2h-8v4.787h-1.6V2.401l.8-.8zm.8 11.186h-4.8v1.6h4.8v-1.6zm-4.8 3.2h4.8v1.6h-4.8v-1.6zm4.8 3.2h-4.8v1.6h4.8v-1.6zm1.6-14.4h4.8v1.6h-4.8v-1.6zm4.8 6.4h-1.6v1.6h1.6v-1.6zm-3.338-3.176v-.024h3.338v1.6h-1.762l-1.576-1.576z"
            },
            child: []
        }]
    })(_e)
}
function formatProdErrorMessage$1(_e) {
    return `Minified Redux error #${_e}; visit https://redux.js.org/Errors?code=${_e} for the full message or use the non-minified dev environment for full errors. `
}
var $$observable = typeof Symbol == "function" && Symbol.observable || "@@observable"
  , symbol_observable_default = $$observable
  , randomString$1 = ()=>Math.random().toString(36).substring(7).split("").join(".")
  , ActionTypes = {
    INIT: `@@redux/INIT${randomString$1()}`,
    REPLACE: `@@redux/REPLACE${randomString$1()}`,
    PROBE_UNKNOWN_ACTION: ()=>`@@redux/PROBE_UNKNOWN_ACTION${randomString$1()}`
}
  , actionTypes_default = ActionTypes;
function isPlainObject$2(_e) {
    if (typeof _e != "object" || _e === null)
        return !1;
    let et = _e;
    for (; Object.getPrototypeOf(et) !== null; )
        et = Object.getPrototypeOf(et);
    return Object.getPrototypeOf(_e) === et || Object.getPrototypeOf(_e) === null
}
function createStore(_e, et, tt) {
    if (typeof _e != "function")
        throw new Error(formatProdErrorMessage$1(2));
    if (typeof et == "function" && typeof tt == "function" || typeof tt == "function" && typeof arguments[3] == "function")
        throw new Error(formatProdErrorMessage$1(0));
    if (typeof et == "function" && typeof tt > "u" && (tt = et,
    et = void 0),
    typeof tt < "u") {
        if (typeof tt != "function")
            throw new Error(formatProdErrorMessage$1(1));
        return tt(createStore)(_e, et)
    }
    let rt = _e
      , nt = et
      , it = new Map
      , st = it
      , at = 0
      , ot = !1;
    function lt() {
        st === it && (st = new Map,
        it.forEach((bt,pt)=>{
            st.set(pt, bt)
        }
        ))
    }
    function dt() {
        if (ot)
            throw new Error(formatProdErrorMessage$1(3));
        return nt
    }
    function ct(bt) {
        if (typeof bt != "function")
            throw new Error(formatProdErrorMessage$1(4));
        if (ot)
            throw new Error(formatProdErrorMessage$1(5));
        let pt = !0;
        lt();
        const mt = at++;
        return st.set(mt, bt),
        function() {
            if (pt) {
                if (ot)
                    throw new Error(formatProdErrorMessage$1(6));
                pt = !1,
                lt(),
                st.delete(mt),
                it = null
            }
        }
    }
    function ut(bt) {
        if (!isPlainObject$2(bt))
            throw new Error(formatProdErrorMessage$1(7));
        if (typeof bt.type > "u")
            throw new Error(formatProdErrorMessage$1(8));
        if (typeof bt.type != "string")
            throw new Error(formatProdErrorMessage$1(17));
        if (ot)
            throw new Error(formatProdErrorMessage$1(9));
        try {
            ot = !0,
            nt = rt(nt, bt)
        } finally {
            ot = !1
        }
        return (it = st).forEach(mt=>{
            mt()
        }
        ),
        bt
    }
    function ft(bt) {
        if (typeof bt != "function")
            throw new Error(formatProdErrorMessage$1(10));
        rt = bt,
        ut({
            type: actionTypes_default.REPLACE
        })
    }
    function ht() {
        const bt = ct;
        return {
            subscribe(pt) {
                if (typeof pt != "object" || pt === null)
                    throw new Error(formatProdErrorMessage$1(11));
                function mt() {
                    const vt = pt;
                    vt.next && vt.next(dt())
                }
                return mt(),
                {
                    unsubscribe: bt(mt)
                }
            },
            [symbol_observable_default]() {
                return this
            }
        }
    }
    return ut({
        type: actionTypes_default.INIT
    }),
    {
        dispatch: ut,
        subscribe: ct,
        getState: dt,
        replaceReducer: ft,
        [symbol_observable_default]: ht
    }
}
function assertReducerShape(_e) {
    Object.keys(_e).forEach(et=>{
        const tt = _e[et];
        if (typeof tt(void 0, {
            type: actionTypes_default.INIT
        }) > "u")
            throw new Error(formatProdErrorMessage$1(12));
        if (typeof tt(void 0, {
            type: actionTypes_default.PROBE_UNKNOWN_ACTION()
        }) > "u")
            throw new Error(formatProdErrorMessage$1(13))
    }
    )
}
function combineReducers(_e) {
    const et = Object.keys(_e)
      , tt = {};
    for (let it = 0; it < et.length; it++) {
        const st = et[it];
        typeof _e[st] == "function" && (tt[st] = _e[st])
    }
    const rt = Object.keys(tt);
    let nt;
    try {
        assertReducerShape(tt)
    } catch (it) {
        nt = it
    }
    return function(st={}, at) {
        if (nt)
            throw nt;
        let ot = !1;
        const lt = {};
        for (let dt = 0; dt < rt.length; dt++) {
            const ct = rt[dt]
              , ut = tt[ct]
              , ft = st[ct]
              , ht = ut(ft, at);
            if (typeof ht > "u")
                throw at && at.type,
                new Error(formatProdErrorMessage$1(14));
            lt[ct] = ht,
            ot = ot || ht !== ft
        }
        return ot = ot || rt.length !== Object.keys(st).length,
        ot ? lt : st
    }
}
function compose(..._e) {
    return _e.length === 0 ? et=>et : _e.length === 1 ? _e[0] : _e.reduce((et,tt)=>(...rt)=>et(tt(...rt)))
}
function applyMiddleware(..._e) {
    return et=>(tt,rt)=>{
        const nt = et(tt, rt);
        let it = ()=>{
            throw new Error(formatProdErrorMessage$1(15))
        }
        ;
        const st = {
            getState: nt.getState,
            dispatch: (ot,...lt)=>it(ot, ...lt)
        }
          , at = _e.map(ot=>ot(st));
        return it = compose(...at)(nt.dispatch),
        {
            ...nt,
            dispatch: it
        }
    }
}
function isAction(_e) {
    return isPlainObject$2(_e) && "type"in _e && typeof _e.type == "string"
}
var NOTHING = Symbol.for("immer-nothing")
  , DRAFTABLE = Symbol.for("immer-draftable")
  , DRAFT_STATE = Symbol.for("immer-state");
function die(_e, ...et) {
    throw new Error(`[Immer] minified error nr: ${_e}. Full error at: https://bit.ly/3cXEKWf`)
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(_e) {
    return !!_e && !!_e[DRAFT_STATE]
}
function isDraftable(_e) {
    var et;
    return _e ? isPlainObject$1(_e) || Array.isArray(_e) || !!_e[DRAFTABLE] || !!((et = _e.constructor) != null && et[DRAFTABLE]) || isMap(_e) || isSet(_e) : !1
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject$1(_e) {
    if (!_e || typeof _e != "object")
        return !1;
    const et = getPrototypeOf(_e);
    if (et === null)
        return !0;
    const tt = Object.hasOwnProperty.call(et, "constructor") && et.constructor;
    return tt === Object ? !0 : typeof tt == "function" && Function.toString.call(tt) === objectCtorString
}
function original(_e) {
    return isDraft(_e) || die(15, _e),
    _e[DRAFT_STATE].base_
}
function each(_e, et) {
    getArchtype(_e) === 0 ? Object.entries(_e).forEach(([tt,rt])=>{
        et(tt, rt, _e)
    }
    ) : _e.forEach((tt,rt)=>et(rt, tt, _e))
}
function getArchtype(_e) {
    const et = _e[DRAFT_STATE];
    return et ? et.type_ : Array.isArray(_e) ? 1 : isMap(_e) ? 2 : isSet(_e) ? 3 : 0
}
function has(_e, et) {
    return getArchtype(_e) === 2 ? _e.has(et) : Object.prototype.hasOwnProperty.call(_e, et)
}
function get$1(_e, et) {
    return getArchtype(_e) === 2 ? _e.get(et) : _e[et]
}
function set$1(_e, et, tt) {
    const rt = getArchtype(_e);
    rt === 2 ? _e.set(et, tt) : rt === 3 ? _e.add(tt) : _e[et] = tt
}
function is$1(_e, et) {
    return _e === et ? _e !== 0 || 1 / _e === 1 / et : _e !== _e && et !== et
}
function isMap(_e) {
    return _e instanceof Map
}
function isSet(_e) {
    return _e instanceof Set
}
function latest(_e) {
    return _e.copy_ || _e.base_
}
function shallowCopy(_e, et) {
    if (isMap(_e))
        return new Map(_e);
    if (isSet(_e))
        return new Set(_e);
    if (Array.isArray(_e))
        return Array.prototype.slice.call(_e);
    if (!et && isPlainObject$1(_e))
        return getPrototypeOf(_e) ? {
            ..._e
        } : Object.assign(Object.create(null), _e);
    const tt = Object.getOwnPropertyDescriptors(_e);
    delete tt[DRAFT_STATE];
    let rt = Reflect.ownKeys(tt);
    for (let nt = 0; nt < rt.length; nt++) {
        const it = rt[nt]
          , st = tt[it];
        st.writable === !1 && (st.writable = !0,
        st.configurable = !0),
        (st.get || st.set) && (tt[it] = {
            configurable: !0,
            writable: !0,
            enumerable: st.enumerable,
            value: _e[it]
        })
    }
    return Object.create(getPrototypeOf(_e), tt)
}
function freeze(_e, et=!1) {
    return isFrozen(_e) || isDraft(_e) || !isDraftable(_e) || (getArchtype(_e) > 1 && (_e.set = _e.add = _e.clear = _e.delete = dontMutateFrozenCollections),
    Object.freeze(_e),
    et && each(_e, (tt,rt)=>freeze(rt, !0))),
    _e
}
function dontMutateFrozenCollections() {
    die(2)
}
function isFrozen(_e) {
    return Object.isFrozen(_e)
}
var plugins = {};
function getPlugin(_e) {
    const et = plugins[_e];
    return et || die(0, _e),
    et
}
function loadPlugin(_e, et) {
    plugins[_e] || (plugins[_e] = et)
}
var currentScope;
function getCurrentScope() {
    return currentScope
}
function createScope(_e, et) {
    return {
        drafts_: [],
        parent_: _e,
        immer_: et,
        canAutoFreeze_: !0,
        unfinalizedDrafts_: 0
    }
}
function usePatchesInScope(_e, et) {
    et && (getPlugin("Patches"),
    _e.patches_ = [],
    _e.inversePatches_ = [],
    _e.patchListener_ = et)
}
function revokeScope(_e) {
    leaveScope(_e),
    _e.drafts_.forEach(revokeDraft),
    _e.drafts_ = null
}
function leaveScope(_e) {
    _e === currentScope && (currentScope = _e.parent_)
}
function enterScope(_e) {
    return currentScope = createScope(currentScope, _e)
}
function revokeDraft(_e) {
    const et = _e[DRAFT_STATE];
    et.type_ === 0 || et.type_ === 1 ? et.revoke_() : et.revoked_ = !0
}
function processResult(_e, et) {
    et.unfinalizedDrafts_ = et.drafts_.length;
    const tt = et.drafts_[0];
    return _e !== void 0 && _e !== tt ? (tt[DRAFT_STATE].modified_ && (revokeScope(et),
    die(4)),
    isDraftable(_e) && (_e = finalize(et, _e),
    et.parent_ || maybeFreeze(et, _e)),
    et.patches_ && getPlugin("Patches").generateReplacementPatches_(tt[DRAFT_STATE].base_, _e, et.patches_, et.inversePatches_)) : _e = finalize(et, tt, []),
    revokeScope(et),
    et.patches_ && et.patchListener_(et.patches_, et.inversePatches_),
    _e !== NOTHING ? _e : void 0
}
function finalize(_e, et, tt) {
    if (isFrozen(et))
        return et;
    const rt = et[DRAFT_STATE];
    if (!rt)
        return each(et, (nt,it)=>finalizeProperty(_e, rt, et, nt, it, tt)),
        et;
    if (rt.scope_ !== _e)
        return et;
    if (!rt.modified_)
        return maybeFreeze(_e, rt.base_, !0),
        rt.base_;
    if (!rt.finalized_) {
        rt.finalized_ = !0,
        rt.scope_.unfinalizedDrafts_--;
        const nt = rt.copy_;
        let it = nt
          , st = !1;
        rt.type_ === 3 && (it = new Set(nt),
        nt.clear(),
        st = !0),
        each(it, (at,ot)=>finalizeProperty(_e, rt, nt, at, ot, tt, st)),
        maybeFreeze(_e, nt, !1),
        tt && _e.patches_ && getPlugin("Patches").generatePatches_(rt, tt, _e.patches_, _e.inversePatches_)
    }
    return rt.copy_
}
function finalizeProperty(_e, et, tt, rt, nt, it, st) {
    if (isDraft(nt)) {
        const at = it && et && et.type_ !== 3 && !has(et.assigned_, rt) ? it.concat(rt) : void 0
          , ot = finalize(_e, nt, at);
        if (set$1(tt, rt, ot),
        isDraft(ot))
            _e.canAutoFreeze_ = !1;
        else
            return
    } else
        st && tt.add(nt);
    if (isDraftable(nt) && !isFrozen(nt)) {
        if (!_e.immer_.autoFreeze_ && _e.unfinalizedDrafts_ < 1)
            return;
        finalize(_e, nt),
        (!et || !et.scope_.parent_) && maybeFreeze(_e, nt)
    }
}
function maybeFreeze(_e, et, tt=!1) {
    !_e.parent_ && _e.immer_.autoFreeze_ && _e.canAutoFreeze_ && freeze(et, tt)
}
function createProxyProxy(_e, et) {
    const tt = Array.isArray(_e)
      , rt = {
        type_: tt ? 1 : 0,
        scope_: et ? et.scope_ : getCurrentScope(),
        modified_: !1,
        finalized_: !1,
        assigned_: {},
        parent_: et,
        base_: _e,
        draft_: null,
        copy_: null,
        revoke_: null,
        isManual_: !1
    };
    let nt = rt
      , it = objectTraps;
    tt && (nt = [rt],
    it = arrayTraps);
    const {revoke: st, proxy: at} = Proxy.revocable(nt, it);
    return rt.draft_ = at,
    rt.revoke_ = st,
    at
}
var objectTraps = {
    get(_e, et) {
        if (et === DRAFT_STATE)
            return _e;
        const tt = latest(_e);
        if (!has(tt, et))
            return readPropFromProto(_e, tt, et);
        const rt = tt[et];
        return _e.finalized_ || !isDraftable(rt) ? rt : rt === peek(_e.base_, et) ? (prepareCopy(_e),
        _e.copy_[et] = createProxy(rt, _e)) : rt
    },
    has(_e, et) {
        return et in latest(_e)
    },
    ownKeys(_e) {
        return Reflect.ownKeys(latest(_e))
    },
    set(_e, et, tt) {
        const rt = getDescriptorFromProto(latest(_e), et);
        if (rt != null && rt.set)
            return rt.set.call(_e.draft_, tt),
            !0;
        if (!_e.modified_) {
            const nt = peek(latest(_e), et)
              , it = nt == null ? void 0 : nt[DRAFT_STATE];
            if (it && it.base_ === tt)
                return _e.copy_[et] = tt,
                _e.assigned_[et] = !1,
                !0;
            if (is$1(tt, nt) && (tt !== void 0 || has(_e.base_, et)))
                return !0;
            prepareCopy(_e),
            markChanged(_e)
        }
        return _e.copy_[et] === tt && (tt !== void 0 || et in _e.copy_) || Number.isNaN(tt) && Number.isNaN(_e.copy_[et]) || (_e.copy_[et] = tt,
        _e.assigned_[et] = !0),
        !0
    },
    deleteProperty(_e, et) {
        return peek(_e.base_, et) !== void 0 || et in _e.base_ ? (_e.assigned_[et] = !1,
        prepareCopy(_e),
        markChanged(_e)) : delete _e.assigned_[et],
        _e.copy_ && delete _e.copy_[et],
        !0
    },
    getOwnPropertyDescriptor(_e, et) {
        const tt = latest(_e)
          , rt = Reflect.getOwnPropertyDescriptor(tt, et);
        return rt && {
            writable: !0,
            configurable: _e.type_ !== 1 || et !== "length",
            enumerable: rt.enumerable,
            value: tt[et]
        }
    },
    defineProperty() {
        die(11)
    },
    getPrototypeOf(_e) {
        return getPrototypeOf(_e.base_)
    },
    setPrototypeOf() {
        die(12)
    }
}
  , arrayTraps = {};
each(objectTraps, (_e,et)=>{
    arrayTraps[_e] = function() {
        return arguments[0] = arguments[0][0],
        et.apply(this, arguments)
    }
}
);
arrayTraps.deleteProperty = function(_e, et) {
    return arrayTraps.set.call(this, _e, et, void 0)
}
;
arrayTraps.set = function(_e, et, tt) {
    return objectTraps.set.call(this, _e[0], et, tt, _e[0])
}
;
function peek(_e, et) {
    const tt = _e[DRAFT_STATE];
    return (tt ? latest(tt) : _e)[et]
}
function readPropFromProto(_e, et, tt) {
    var nt;
    const rt = getDescriptorFromProto(et, tt);
    return rt ? "value"in rt ? rt.value : (nt = rt.get) == null ? void 0 : nt.call(_e.draft_) : void 0
}
function getDescriptorFromProto(_e, et) {
    if (!(et in _e))
        return;
    let tt = getPrototypeOf(_e);
    for (; tt; ) {
        const rt = Object.getOwnPropertyDescriptor(tt, et);
        if (rt)
            return rt;
        tt = getPrototypeOf(tt)
    }
}
function markChanged(_e) {
    _e.modified_ || (_e.modified_ = !0,
    _e.parent_ && markChanged(_e.parent_))
}
function prepareCopy(_e) {
    _e.copy_ || (_e.copy_ = shallowCopy(_e.base_, _e.scope_.immer_.useStrictShallowCopy_))
}
var Immer2 = class {
    constructor(_e) {
        this.autoFreeze_ = !0,
        this.useStrictShallowCopy_ = !1,
        this.produce = (et,tt,rt)=>{
            if (typeof et == "function" && typeof tt != "function") {
                const it = tt;
                tt = et;
                const st = this;
                return function(ot=it, ...lt) {
                    return st.produce(ot, dt=>tt.call(this, dt, ...lt))
                }
            }
            typeof tt != "function" && die(6),
            rt !== void 0 && typeof rt != "function" && die(7);
            let nt;
            if (isDraftable(et)) {
                const it = enterScope(this)
                  , st = createProxy(et, void 0);
                let at = !0;
                try {
                    nt = tt(st),
                    at = !1
                } finally {
                    at ? revokeScope(it) : leaveScope(it)
                }
                return usePatchesInScope(it, rt),
                processResult(nt, it)
            } else if (!et || typeof et != "object") {
                if (nt = tt(et),
                nt === void 0 && (nt = et),
                nt === NOTHING && (nt = void 0),
                this.autoFreeze_ && freeze(nt, !0),
                rt) {
                    const it = []
                      , st = [];
                    getPlugin("Patches").generateReplacementPatches_(et, nt, it, st),
                    rt(it, st)
                }
                return nt
            } else
                die(1, et)
        }
        ,
        this.produceWithPatches = (et,tt)=>{
            if (typeof et == "function")
                return (st,...at)=>this.produceWithPatches(st, ot=>et(ot, ...at));
            let rt, nt;
            return [this.produce(et, tt, (st,at)=>{
                rt = st,
                nt = at
            }
            ), rt, nt]
        }
        ,
        typeof (_e == null ? void 0 : _e.autoFreeze) == "boolean" && this.setAutoFreeze(_e.autoFreeze),
        typeof (_e == null ? void 0 : _e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(_e.useStrictShallowCopy)
    }
    createDraft(_e) {
        isDraftable(_e) || die(8),
        isDraft(_e) && (_e = current(_e));
        const et = enterScope(this)
          , tt = createProxy(_e, void 0);
        return tt[DRAFT_STATE].isManual_ = !0,
        leaveScope(et),
        tt
    }
    finishDraft(_e, et) {
        const tt = _e && _e[DRAFT_STATE];
        (!tt || !tt.isManual_) && die(9);
        const {scope_: rt} = tt;
        return usePatchesInScope(rt, et),
        processResult(void 0, rt)
    }
    setAutoFreeze(_e) {
        this.autoFreeze_ = _e
    }
    setUseStrictShallowCopy(_e) {
        this.useStrictShallowCopy_ = _e
    }
    applyPatches(_e, et) {
        let tt;
        for (tt = et.length - 1; tt >= 0; tt--) {
            const nt = et[tt];
            if (nt.path.length === 0 && nt.op === "replace") {
                _e = nt.value;
                break
            }
        }
        tt > -1 && (et = et.slice(tt + 1));
        const rt = getPlugin("Patches").applyPatches_;
        return isDraft(_e) ? rt(_e, et) : this.produce(_e, nt=>rt(nt, et))
    }
}
;
function createProxy(_e, et) {
    const tt = isMap(_e) ? getPlugin("MapSet").proxyMap_(_e, et) : isSet(_e) ? getPlugin("MapSet").proxySet_(_e, et) : createProxyProxy(_e, et);
    return (et ? et.scope_ : getCurrentScope()).drafts_.push(tt),
    tt
}
function current(_e) {
    return isDraft(_e) || die(10, _e),
    currentImpl(_e)
}
function currentImpl(_e) {
    if (!isDraftable(_e) || isFrozen(_e))
        return _e;
    const et = _e[DRAFT_STATE];
    let tt;
    if (et) {
        if (!et.modified_)
            return et.base_;
        et.finalized_ = !0,
        tt = shallowCopy(_e, et.scope_.immer_.useStrictShallowCopy_)
    } else
        tt = shallowCopy(_e, !0);
    return each(tt, (rt,nt)=>{
        set$1(tt, rt, currentImpl(nt))
    }
    ),
    et && (et.finalized_ = !1),
    tt
}
function enablePatches() {
    const et = "replace"
      , tt = "add"
      , rt = "remove";
    function nt(ut, ft, ht, gt) {
        switch (ut.type_) {
        case 0:
        case 2:
            return st(ut, ft, ht, gt);
        case 1:
            return it(ut, ft, ht, gt);
        case 3:
            return at(ut, ft, ht, gt)
        }
    }
    function it(ut, ft, ht, gt) {
        let {base_: bt, assigned_: pt} = ut
          , mt = ut.copy_;
        mt.length < bt.length && ([bt,mt] = [mt, bt],
        [ht,gt] = [gt, ht]);
        for (let yt = 0; yt < bt.length; yt++)
            if (pt[yt] && mt[yt] !== bt[yt]) {
                const vt = ft.concat([yt]);
                ht.push({
                    op: et,
                    path: vt,
                    value: ct(mt[yt])
                }),
                gt.push({
                    op: et,
                    path: vt,
                    value: ct(bt[yt])
                })
            }
        for (let yt = bt.length; yt < mt.length; yt++) {
            const vt = ft.concat([yt]);
            ht.push({
                op: tt,
                path: vt,
                value: ct(mt[yt])
            })
        }
        for (let yt = mt.length - 1; bt.length <= yt; --yt) {
            const vt = ft.concat([yt]);
            gt.push({
                op: rt,
                path: vt
            })
        }
    }
    function st(ut, ft, ht, gt) {
        const {base_: bt, copy_: pt} = ut;
        each(ut.assigned_, (mt,yt)=>{
            const vt = get$1(bt, mt)
              , wt = get$1(pt, mt)
              , _t = yt ? has(bt, mt) ? et : tt : rt;
            if (vt === wt && _t === et)
                return;
            const Et = ft.concat(mt);
            ht.push(_t === rt ? {
                op: _t,
                path: Et
            } : {
                op: _t,
                path: Et,
                value: wt
            }),
            gt.push(_t === tt ? {
                op: rt,
                path: Et
            } : _t === rt ? {
                op: tt,
                path: Et,
                value: ct(vt)
            } : {
                op: et,
                path: Et,
                value: ct(vt)
            })
        }
        )
    }
    function at(ut, ft, ht, gt) {
        let {base_: bt, copy_: pt} = ut
          , mt = 0;
        bt.forEach(yt=>{
            if (!pt.has(yt)) {
                const vt = ft.concat([mt]);
                ht.push({
                    op: rt,
                    path: vt,
                    value: yt
                }),
                gt.unshift({
                    op: tt,
                    path: vt,
                    value: yt
                })
            }
            mt++
        }
        ),
        mt = 0,
        pt.forEach(yt=>{
            if (!bt.has(yt)) {
                const vt = ft.concat([mt]);
                ht.push({
                    op: tt,
                    path: vt,
                    value: yt
                }),
                gt.unshift({
                    op: rt,
                    path: vt,
                    value: yt
                })
            }
            mt++
        }
        )
    }
    function ot(ut, ft, ht, gt) {
        ht.push({
            op: et,
            path: [],
            value: ft === NOTHING ? void 0 : ft
        }),
        gt.push({
            op: et,
            path: [],
            value: ut
        })
    }
    function lt(ut, ft) {
        return ft.forEach(ht=>{
            const {path: gt, op: bt} = ht;
            let pt = ut;
            for (let wt = 0; wt < gt.length - 1; wt++) {
                const _t = getArchtype(pt);
                let Et = gt[wt];
                typeof Et != "string" && typeof Et != "number" && (Et = "" + Et),
                (_t === 0 || _t === 1) && (Et === "__proto__" || Et === "constructor") && die(19),
                typeof pt == "function" && Et === "prototype" && die(19),
                pt = get$1(pt, Et),
                typeof pt != "object" && die(18, gt.join("/"))
            }
            const mt = getArchtype(pt)
              , yt = dt(ht.value)
              , vt = gt[gt.length - 1];
            switch (bt) {
            case et:
                switch (mt) {
                case 2:
                    return pt.set(vt, yt);
                case 3:
                    die(16);
                default:
                    return pt[vt] = yt
                }
            case tt:
                switch (mt) {
                case 1:
                    return vt === "-" ? pt.push(yt) : pt.splice(vt, 0, yt);
                case 2:
                    return pt.set(vt, yt);
                case 3:
                    return pt.add(yt);
                default:
                    return pt[vt] = yt
                }
            case rt:
                switch (mt) {
                case 1:
                    return pt.splice(vt, 1);
                case 2:
                    return pt.delete(vt);
                case 3:
                    return pt.delete(ht.value);
                default:
                    return delete pt[vt]
                }
            default:
                die(17, bt)
            }
        }
        ),
        ut
    }
    function dt(ut) {
        if (!isDraftable(ut))
            return ut;
        if (Array.isArray(ut))
            return ut.map(dt);
        if (isMap(ut))
            return new Map(Array.from(ut.entries()).map(([ht,gt])=>[ht, dt(gt)]));
        if (isSet(ut))
            return new Set(Array.from(ut).map(dt));
        const ft = Object.create(getPrototypeOf(ut));
        for (const ht in ut)
            ft[ht] = dt(ut[ht]);
        return has(ut, DRAFTABLE) && (ft[DRAFTABLE] = ut[DRAFTABLE]),
        ft
    }
    function ct(ut) {
        return isDraft(ut) ? dt(ut) : ut
    }
    loadPlugin("Patches", {
        applyPatches_: lt,
        generatePatches_: nt,
        generateReplacementPatches_: ot
    })
}
var immer = new Immer2
  , produce = immer.produce
  , produceWithPatches = immer.produceWithPatches.bind(immer);
immer.setAutoFreeze.bind(immer);
immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
immer.createDraft.bind(immer);
immer.finishDraft.bind(immer);
function assertIsFunction(_e, et=`expected a function, instead received ${typeof _e}`) {
    if (typeof _e != "function")
        throw new TypeError(et)
}
function assertIsObject(_e, et=`expected an object, instead received ${typeof _e}`) {
    if (typeof _e != "object")
        throw new TypeError(et)
}
function assertIsArrayOfFunctions(_e, et="expected all items to be functions, instead received the following types: ") {
    if (!_e.every(tt=>typeof tt == "function")) {
        const tt = _e.map(rt=>typeof rt == "function" ? `function ${rt.name || "unnamed"}()` : typeof rt).join(", ");
        throw new TypeError(`${et}[${tt}]`)
    }
}
var ensureIsArray = _e=>Array.isArray(_e) ? _e : [_e];
function getDependencies(_e) {
    const et = Array.isArray(_e[0]) ? _e[0] : _e;
    return assertIsArrayOfFunctions(et, "createSelector expects all input-selectors to be functions, but received the following types: "),
    et
}
function collectInputSelectorResults(_e, et) {
    const tt = []
      , {length: rt} = _e;
    for (let nt = 0; nt < rt; nt++)
        tt.push(_e[nt].apply(null, et));
    return tt
}
var StrongRef = class {
    constructor(_e) {
        this.value = _e
    }
    deref() {
        return this.value
    }
}
  , Ref = typeof WeakRef < "u" ? WeakRef : StrongRef
  , UNTERMINATED = 0
  , TERMINATED = 1;
function createCacheNode() {
    return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null
    }
}
function weakMapMemoize(_e, et={}) {
    let tt = createCacheNode();
    const {resultEqualityCheck: rt} = et;
    let nt, it = 0;
    function st() {
        var ct;
        let at = tt;
        const {length: ot} = arguments;
        for (let ut = 0, ft = ot; ut < ft; ut++) {
            const ht = arguments[ut];
            if (typeof ht == "function" || typeof ht == "object" && ht !== null) {
                let gt = at.o;
                gt === null && (at.o = gt = new WeakMap);
                const bt = gt.get(ht);
                bt === void 0 ? (at = createCacheNode(),
                gt.set(ht, at)) : at = bt
            } else {
                let gt = at.p;
                gt === null && (at.p = gt = new Map);
                const bt = gt.get(ht);
                bt === void 0 ? (at = createCacheNode(),
                gt.set(ht, at)) : at = bt
            }
        }
        const lt = at;
        let dt;
        if (at.s === TERMINATED ? dt = at.v : (dt = _e.apply(null, arguments),
        it++),
        lt.s = TERMINATED,
        rt) {
            const ut = ((ct = nt == null ? void 0 : nt.deref) == null ? void 0 : ct.call(nt)) ?? nt;
            ut != null && rt(ut, dt) && (dt = ut,
            it !== 0 && it--),
            nt = typeof dt == "object" && dt !== null || typeof dt == "function" ? new Ref(dt) : dt
        }
        return lt.v = dt,
        dt
    }
    return st.clearCache = ()=>{
        tt = createCacheNode(),
        st.resetResultsCount()
    }
    ,
    st.resultsCount = ()=>it,
    st.resetResultsCount = ()=>{
        it = 0
    }
    ,
    st
}
function createSelectorCreator(_e, ...et) {
    const tt = typeof _e == "function" ? {
        memoize: _e,
        memoizeOptions: et
    } : _e
      , rt = (...nt)=>{
        let it = 0, st = 0, at, ot = {}, lt = nt.pop();
        typeof lt == "object" && (ot = lt,
        lt = nt.pop()),
        assertIsFunction(lt, `createSelector expects an output function after the inputs, but received: [${typeof lt}]`);
        const dt = {
            ...tt,
            ...ot
        }
          , {memoize: ct, memoizeOptions: ut=[], argsMemoize: ft=weakMapMemoize, argsMemoizeOptions: ht=[], devModeChecks: gt={}} = dt
          , bt = ensureIsArray(ut)
          , pt = ensureIsArray(ht)
          , mt = getDependencies(nt)
          , yt = ct(function() {
            return it++,
            lt.apply(null, arguments)
        }, ...bt)
          , vt = ft(function() {
            st++;
            const _t = collectInputSelectorResults(mt, arguments);
            return at = yt.apply(null, _t),
            at
        }, ...pt);
        return Object.assign(vt, {
            resultFunc: lt,
            memoizedResultFunc: yt,
            dependencies: mt,
            dependencyRecomputations: ()=>st,
            resetDependencyRecomputations: ()=>{
                st = 0
            }
            ,
            lastResult: ()=>at,
            recomputations: ()=>it,
            resetRecomputations: ()=>{
                it = 0
            }
            ,
            memoize: ct,
            argsMemoize: ft
        })
    }
    ;
    return Object.assign(rt, {
        withTypes: ()=>rt
    }),
    rt
}
var createSelector = createSelectorCreator(weakMapMemoize)
  , createStructuredSelector = Object.assign((_e,et=createSelector)=>{
    assertIsObject(_e, `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof _e}`);
    const tt = Object.keys(_e)
      , rt = tt.map(it=>_e[it]);
    return et(rt, (...it)=>it.reduce((st,at,ot)=>(st[tt[ot]] = at,
    st), {}))
}
, {
    withTypes: ()=>createStructuredSelector
});
function createThunkMiddleware(_e) {
    return ({dispatch: tt, getState: rt})=>nt=>it=>typeof it == "function" ? it(tt, rt, _e) : nt(it)
}
var thunk = createThunkMiddleware()
  , withExtraArgument = createThunkMiddleware
  , createDraftSafeSelectorCreator = (..._e)=>{
    const et = createSelectorCreator(..._e)
      , tt = Object.assign((...rt)=>{
        const nt = et(...rt)
          , it = (st,...at)=>nt(isDraft(st) ? current(st) : st, ...at);
        return Object.assign(it, nt),
        it
    }
    , {
        withTypes: ()=>tt
    });
    return tt
}
;
createDraftSafeSelectorCreator(weakMapMemoize);
var composeWithDevTools = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length !== 0)
        return typeof arguments[0] == "object" ? compose : compose.apply(null, arguments)
}
  , hasMatchFunction = _e=>_e && typeof _e.match == "function";
function createAction(_e, et) {
    function tt(...rt) {
        if (et) {
            let nt = et(...rt);
            if (!nt)
                throw new Error(formatProdErrorMessage(0));
            return {
                type: _e,
                payload: nt.payload,
                ..."meta"in nt && {
                    meta: nt.meta
                },
                ..."error"in nt && {
                    error: nt.error
                }
            }
        }
        return {
            type: _e,
            payload: rt[0]
        }
    }
    return tt.toString = ()=>`${_e}`,
    tt.type = _e,
    tt.match = rt=>isAction(rt) && rt.type === _e,
    tt
}
var Tuple = class Ts extends Array {
    constructor(...et) {
        super(...et),
        Object.setPrototypeOf(this, Ts.prototype)
    }
    static get[Symbol.species]() {
        return Ts
    }
    concat(...et) {
        return super.concat.apply(this, et)
    }
    prepend(...et) {
        return et.length === 1 && Array.isArray(et[0]) ? new Ts(...et[0].concat(this)) : new Ts(...et.concat(this))
    }
}
;
function freezeDraftable(_e) {
    return isDraftable(_e) ? produce(_e, ()=>{}
    ) : _e
}
function emplace(_e, et, tt) {
    if (_e.has(et)) {
        let nt = _e.get(et);
        return tt.update && (nt = tt.update(nt, et, _e),
        _e.set(et, nt)),
        nt
    }
    if (!tt.insert)
        throw new Error(formatProdErrorMessage(10));
    const rt = tt.insert(et, _e);
    return _e.set(et, rt),
    rt
}
function isBoolean$1(_e) {
    return typeof _e == "boolean"
}
var buildGetDefaultMiddleware = ()=>function(et) {
    const {thunk: tt=!0, immutableCheck: rt=!0, serializableCheck: nt=!0, actionCreatorCheck: it=!0} = et ?? {};
    let st = new Tuple;
    return tt && (isBoolean$1(tt) ? st.push(thunk) : st.push(withExtraArgument(tt.extraArgument))),
    st
}
  , SHOULD_AUTOBATCH = "RTK_autoBatch"
  , prepareAutoBatched = ()=>_e=>({
    payload: _e,
    meta: {
        [SHOULD_AUTOBATCH]: !0
    }
})
  , createQueueWithTimer = _e=>et=>{
    setTimeout(et, _e)
}
  , rAF = typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  , autoBatchEnhancer = (_e={
    type: "raf"
})=>et=>(...tt)=>{
    const rt = et(...tt);
    let nt = !0
      , it = !1
      , st = !1;
    const at = new Set
      , ot = _e.type === "tick" ? queueMicrotask : _e.type === "raf" ? rAF : _e.type === "callback" ? _e.queueNotification : createQueueWithTimer(_e.timeout)
      , lt = ()=>{
        st = !1,
        it && (it = !1,
        at.forEach(dt=>dt()))
    }
    ;
    return Object.assign({}, rt, {
        subscribe(dt) {
            const ct = ()=>nt && dt()
              , ut = rt.subscribe(ct);
            return at.add(dt),
            ()=>{
                ut(),
                at.delete(dt)
            }
        },
        dispatch(dt) {
            var ct;
            try {
                return nt = !((ct = dt == null ? void 0 : dt.meta) != null && ct[SHOULD_AUTOBATCH]),
                it = !nt,
                it && (st || (st = !0,
                ot(lt))),
                rt.dispatch(dt)
            } finally {
                nt = !0
            }
        }
    })
}
  , buildGetDefaultEnhancers = _e=>function(tt) {
    const {autoBatch: rt=!0} = tt ?? {};
    let nt = new Tuple(_e);
    return rt && nt.push(autoBatchEnhancer(typeof rt == "object" ? rt : void 0)),
    nt
}
  , IS_PRODUCTION = !0;
function configureStore(_e) {
    const et = buildGetDefaultMiddleware()
      , {reducer: tt=void 0, middleware: rt, devTools: nt=!0, preloadedState: it=void 0, enhancers: st=void 0} = _e || {};
    let at;
    if (typeof tt == "function")
        at = tt;
    else if (isPlainObject$2(tt))
        at = combineReducers(tt);
    else
        throw new Error(formatProdErrorMessage(1));
    let ot;
    typeof rt == "function" ? ot = rt(et) : ot = et();
    let lt = compose;
    nt && (lt = composeWithDevTools({
        trace: !IS_PRODUCTION,
        ...typeof nt == "object" && nt
    }));
    const dt = applyMiddleware(...ot)
      , ct = buildGetDefaultEnhancers(dt);
    let ut = typeof st == "function" ? st(ct) : ct();
    const ft = lt(...ut);
    return createStore(at, it, ft)
}
function executeReducerBuilderCallback(_e) {
    const et = {}
      , tt = [];
    let rt;
    const nt = {
        addCase(it, st) {
            const at = typeof it == "string" ? it : it.type;
            if (!at)
                throw new Error(formatProdErrorMessage(28));
            if (at in et)
                throw new Error(formatProdErrorMessage(29));
            return et[at] = st,
            nt
        },
        addMatcher(it, st) {
            return tt.push({
                matcher: it,
                reducer: st
            }),
            nt
        },
        addDefaultCase(it) {
            return rt = it,
            nt
        }
    };
    return _e(nt),
    [et, tt, rt]
}
function isStateFunction(_e) {
    return typeof _e == "function"
}
function createReducer(_e, et) {
    let[tt,rt,nt] = executeReducerBuilderCallback(et), it;
    if (isStateFunction(_e))
        it = ()=>freezeDraftable(_e());
    else {
        const at = freezeDraftable(_e);
        it = ()=>at
    }
    function st(at=it(), ot) {
        let lt = [tt[ot.type], ...rt.filter(({matcher: dt})=>dt(ot)).map(({reducer: dt})=>dt)];
        return lt.filter(dt=>!!dt).length === 0 && (lt = [nt]),
        lt.reduce((dt,ct)=>{
            if (ct)
                if (isDraft(dt)) {
                    const ft = ct(dt, ot);
                    return ft === void 0 ? dt : ft
                } else {
                    if (isDraftable(dt))
                        return produce(dt, ut=>ct(ut, ot));
                    {
                        const ut = ct(dt, ot);
                        if (ut === void 0) {
                            if (dt === null)
                                return dt;
                            throw new Error(formatProdErrorMessage(9))
                        }
                        return ut
                    }
                }
            return dt
        }
        , at)
    }
    return st.getInitialState = it,
    st
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"
  , nanoid = (_e=21)=>{
    let et = ""
      , tt = _e;
    for (; tt--; )
        et += urlAlphabet[Math.random() * 64 | 0];
    return et
}
  , matches = (_e,et)=>hasMatchFunction(_e) ? _e.match(et) : _e(et);
function isAnyOf(..._e) {
    return et=>_e.some(tt=>matches(tt, et))
}
function isAllOf(..._e) {
    return et=>_e.every(tt=>matches(tt, et))
}
function hasExpectedRequestMetadata(_e, et) {
    if (!_e || !_e.meta)
        return !1;
    const tt = typeof _e.meta.requestId == "string"
      , rt = et.indexOf(_e.meta.requestStatus) > -1;
    return tt && rt
}
function isAsyncThunkArray(_e) {
    return typeof _e[0] == "function" && "pending"in _e[0] && "fulfilled"in _e[0] && "rejected"in _e[0]
}
function isPending(..._e) {
    return _e.length === 0 ? et=>hasExpectedRequestMetadata(et, ["pending"]) : isAsyncThunkArray(_e) ? et=>{
        const tt = _e.map(nt=>nt.pending);
        return isAnyOf(...tt)(et)
    }
    : isPending()(_e[0])
}
function isRejected(..._e) {
    return _e.length === 0 ? et=>hasExpectedRequestMetadata(et, ["rejected"]) : isAsyncThunkArray(_e) ? et=>{
        const tt = _e.map(nt=>nt.rejected);
        return isAnyOf(...tt)(et)
    }
    : isRejected()(_e[0])
}
function isRejectedWithValue(..._e) {
    const et = tt=>tt && tt.meta && tt.meta.rejectedWithValue;
    return _e.length === 0 ? tt=>isAllOf(isRejected(..._e), et)(tt) : isAsyncThunkArray(_e) ? tt=>isAllOf(isRejected(..._e), et)(tt) : isRejectedWithValue()(_e[0])
}
function isFulfilled(..._e) {
    return _e.length === 0 ? et=>hasExpectedRequestMetadata(et, ["fulfilled"]) : isAsyncThunkArray(_e) ? et=>{
        const tt = _e.map(nt=>nt.fulfilled);
        return isAnyOf(...tt)(et)
    }
    : isFulfilled()(_e[0])
}
function isAsyncThunkAction(..._e) {
    return _e.length === 0 ? et=>hasExpectedRequestMetadata(et, ["pending", "fulfilled", "rejected"]) : isAsyncThunkArray(_e) ? et=>{
        const tt = [];
        for (const nt of _e)
            tt.push(nt.pending, nt.rejected, nt.fulfilled);
        return isAnyOf(...tt)(et)
    }
    : isAsyncThunkAction()(_e[0])
}
var commonProperties = ["name", "message", "stack", "code"]
  , RejectWithValue = class {
    constructor(_e, et) {
        oo(this, "_type");
        this.payload = _e,
        this.meta = et
    }
}
  , FulfillWithMeta = class {
    constructor(_e, et) {
        oo(this, "_type");
        this.payload = _e,
        this.meta = et
    }
}
  , miniSerializeError = _e=>{
    if (typeof _e == "object" && _e !== null) {
        const et = {};
        for (const tt of commonProperties)
            typeof _e[tt] == "string" && (et[tt] = _e[tt]);
        return et
    }
    return {
        message: String(_e)
    }
}
  , createAsyncThunk = (()=>{
    function _e(et, tt, rt) {
        const nt = createAction(et + "/fulfilled", (ot,lt,dt,ct)=>({
            payload: ot,
            meta: {
                ...ct || {},
                arg: dt,
                requestId: lt,
                requestStatus: "fulfilled"
            }
        }))
          , it = createAction(et + "/pending", (ot,lt,dt)=>({
            payload: void 0,
            meta: {
                ...dt || {},
                arg: lt,
                requestId: ot,
                requestStatus: "pending"
            }
        }))
          , st = createAction(et + "/rejected", (ot,lt,dt,ct,ut)=>({
            payload: ct,
            error: (rt && rt.serializeError || miniSerializeError)(ot || "Rejected"),
            meta: {
                ...ut || {},
                arg: dt,
                requestId: lt,
                rejectedWithValue: !!ct,
                requestStatus: "rejected",
                aborted: (ot == null ? void 0 : ot.name) === "AbortError",
                condition: (ot == null ? void 0 : ot.name) === "ConditionError"
            }
        }));
        function at(ot) {
            return (lt,dt,ct)=>{
                const ut = rt != null && rt.idGenerator ? rt.idGenerator(ot) : nanoid()
                  , ft = new AbortController;
                let ht, gt;
                function bt(mt) {
                    gt = mt,
                    ft.abort()
                }
                const pt = async function() {
                    var vt, wt;
                    let mt;
                    try {
                        let _t = (vt = rt == null ? void 0 : rt.condition) == null ? void 0 : vt.call(rt, ot, {
                            getState: dt,
                            extra: ct
                        });
                        if (isThenable(_t) && (_t = await _t),
                        _t === !1 || ft.signal.aborted)
                            throw {
                                name: "ConditionError",
                                message: "Aborted due to condition callback returning false."
                            };
                        const Et = new Promise((xt,Ct)=>{
                            ht = ()=>{
                                Ct({
                                    name: "AbortError",
                                    message: gt || "Aborted"
                                })
                            }
                            ,
                            ft.signal.addEventListener("abort", ht)
                        }
                        );
                        lt(it(ut, ot, (wt = rt == null ? void 0 : rt.getPendingMeta) == null ? void 0 : wt.call(rt, {
                            requestId: ut,
                            arg: ot
                        }, {
                            getState: dt,
                            extra: ct
                        }))),
                        mt = await Promise.race([Et, Promise.resolve(tt(ot, {
                            dispatch: lt,
                            getState: dt,
                            extra: ct,
                            requestId: ut,
                            signal: ft.signal,
                            abort: bt,
                            rejectWithValue: (xt,Ct)=>new RejectWithValue(xt,Ct),
                            fulfillWithValue: (xt,Ct)=>new FulfillWithMeta(xt,Ct)
                        })).then(xt=>{
                            if (xt instanceof RejectWithValue)
                                throw xt;
                            return xt instanceof FulfillWithMeta ? nt(xt.payload, ut, ot, xt.meta) : nt(xt, ut, ot)
                        }
                        )])
                    } catch (_t) {
                        mt = _t instanceof RejectWithValue ? st(null, ut, ot, _t.payload, _t.meta) : st(_t, ut, ot)
                    } finally {
                        ht && ft.signal.removeEventListener("abort", ht)
                    }
                    return rt && !rt.dispatchConditionRejection && st.match(mt) && mt.meta.condition || lt(mt),
                    mt
                }();
                return Object.assign(pt, {
                    abort: bt,
                    requestId: ut,
                    arg: ot,
                    unwrap() {
                        return pt.then(unwrapResult)
                    }
                })
            }
        }
        return Object.assign(at, {
            pending: it,
            rejected: st,
            fulfilled: nt,
            settled: isAnyOf(st, nt),
            typePrefix: et
        })
    }
    return _e.withTypes = ()=>_e,
    _e
}
)();
function unwrapResult(_e) {
    if (_e.meta && _e.meta.rejectedWithValue)
        throw _e.payload;
    if (_e.error)
        throw _e.error;
    return _e.payload
}
function isThenable(_e) {
    return _e !== null && typeof _e == "object" && typeof _e.then == "function"
}
var asyncThunkSymbol = Symbol.for("rtk-slice-createasyncthunk");
function getType(_e, et) {
    return `${_e}/${et}`
}
function buildCreateSlice({creators: _e}={}) {
    var tt;
    const et = (tt = _e == null ? void 0 : _e.asyncThunk) == null ? void 0 : tt[asyncThunkSymbol];
    return function(nt) {
        const {name: it, reducerPath: st=it} = nt;
        if (!it)
            throw new Error(formatProdErrorMessage(11));
        typeof process < "u";
        const at = (typeof nt.reducers == "function" ? nt.reducers(buildReducerCreators()) : nt.reducers) || {}
          , ot = Object.keys(at)
          , lt = {
            sliceCaseReducersByName: {},
            sliceCaseReducersByType: {},
            actionCreators: {},
            sliceMatchers: []
        }
          , dt = {
            addCase(yt, vt) {
                const wt = typeof yt == "string" ? yt : yt.type;
                if (!wt)
                    throw new Error(formatProdErrorMessage(12));
                if (wt in lt.sliceCaseReducersByType)
                    throw new Error(formatProdErrorMessage(13));
                return lt.sliceCaseReducersByType[wt] = vt,
                dt
            },
            addMatcher(yt, vt) {
                return lt.sliceMatchers.push({
                    matcher: yt,
                    reducer: vt
                }),
                dt
            },
            exposeAction(yt, vt) {
                return lt.actionCreators[yt] = vt,
                dt
            },
            exposeCaseReducer(yt, vt) {
                return lt.sliceCaseReducersByName[yt] = vt,
                dt
            }
        };
        ot.forEach(yt=>{
            const vt = at[yt]
              , wt = {
                reducerName: yt,
                type: getType(it, yt),
                createNotation: typeof nt.reducers == "function"
            };
            isAsyncThunkSliceReducerDefinition(vt) ? handleThunkCaseReducerDefinition(wt, vt, dt, et) : handleNormalReducerDefinition(wt, vt, dt)
        }
        );
        function ct() {
            const [yt={},vt=[],wt=void 0] = typeof nt.extraReducers == "function" ? executeReducerBuilderCallback(nt.extraReducers) : [nt.extraReducers]
              , _t = {
                ...yt,
                ...lt.sliceCaseReducersByType
            };
            return createReducer(nt.initialState, Et=>{
                for (let xt in _t)
                    Et.addCase(xt, _t[xt]);
                for (let xt of lt.sliceMatchers)
                    Et.addMatcher(xt.matcher, xt.reducer);
                for (let xt of vt)
                    Et.addMatcher(xt.matcher, xt.reducer);
                wt && Et.addDefaultCase(wt)
            }
            )
        }
        const ut = yt=>yt
          , ft = new Map;
        let ht;
        function gt(yt, vt) {
            return ht || (ht = ct()),
            ht(yt, vt)
        }
        function bt() {
            return ht || (ht = ct()),
            ht.getInitialState()
        }
        function pt(yt, vt=!1) {
            function wt(Et) {
                let xt = Et[yt];
                return typeof xt > "u" && vt && (xt = bt()),
                xt
            }
            function _t(Et=ut) {
                const xt = emplace(ft, vt, {
                    insert: ()=>new WeakMap
                });
                return emplace(xt, Et, {
                    insert: ()=>{
                        const Ct = {};
                        for (const [Tt,It] of Object.entries(nt.selectors ?? {}))
                            Ct[Tt] = wrapSelector(It, Et, bt, vt);
                        return Ct
                    }
                })
            }
            return {
                reducerPath: yt,
                getSelectors: _t,
                get selectors() {
                    return _t(wt)
                },
                selectSlice: wt
            }
        }
        const mt = {
            name: it,
            reducer: gt,
            actions: lt.actionCreators,
            caseReducers: lt.sliceCaseReducersByName,
            getInitialState: bt,
            ...pt(st),
            injectInto(yt, {reducerPath: vt, ...wt}={}) {
                const _t = vt ?? st;
                return yt.inject({
                    reducerPath: _t,
                    reducer: gt
                }, wt),
                {
                    ...mt,
                    ...pt(_t, !0)
                }
            }
        };
        return mt
    }
}
function wrapSelector(_e, et, tt, rt) {
    function nt(it, ...st) {
        let at = et(it);
        return typeof at > "u" && rt && (at = tt()),
        _e(at, ...st)
    }
    return nt.unwrapped = _e,
    nt
}
var createSlice = buildCreateSlice();
function buildReducerCreators() {
    function _e(et, tt) {
        return {
            _reducerDefinitionType: "asyncThunk",
            payloadCreator: et,
            ...tt
        }
    }
    return _e.withTypes = ()=>_e,
    {
        reducer(et) {
            return Object.assign({
                [et.name](...tt) {
                    return et(...tt)
                }
            }[et.name], {
                _reducerDefinitionType: "reducer"
            })
        },
        preparedReducer(et, tt) {
            return {
                _reducerDefinitionType: "reducerWithPrepare",
                prepare: et,
                reducer: tt
            }
        },
        asyncThunk: _e
    }
}
function handleNormalReducerDefinition({type: _e, reducerName: et, createNotation: tt}, rt, nt) {
    let it, st;
    if ("reducer"in rt) {
        if (tt && !isCaseReducerWithPrepareDefinition(rt))
            throw new Error(formatProdErrorMessage(17));
        it = rt.reducer,
        st = rt.prepare
    } else
        it = rt;
    nt.addCase(_e, it).exposeCaseReducer(et, it).exposeAction(et, st ? createAction(_e, st) : createAction(_e))
}
function isAsyncThunkSliceReducerDefinition(_e) {
    return _e._reducerDefinitionType === "asyncThunk"
}
function isCaseReducerWithPrepareDefinition(_e) {
    return _e._reducerDefinitionType === "reducerWithPrepare"
}
function handleThunkCaseReducerDefinition({type: _e, reducerName: et}, tt, rt, nt) {
    if (!nt)
        throw new Error(formatProdErrorMessage(18));
    const {payloadCreator: it, fulfilled: st, pending: at, rejected: ot, settled: lt, options: dt} = tt
      , ct = nt(_e, it, dt);
    rt.exposeAction(et, ct),
    st && rt.addCase(ct.fulfilled, st),
    at && rt.addCase(ct.pending, at),
    ot && rt.addCase(ct.rejected, ot),
    lt && rt.addMatcher(ct.settled, lt),
    rt.exposeCaseReducer(et, {
        fulfilled: st || noop$1,
        pending: at || noop$1,
        rejected: ot || noop$1,
        settled: lt || noop$1
    })
}
function noop$1() {}
var assertFunction = (_e,et)=>{
    if (typeof _e != "function")
        throw new Error(formatProdErrorMessage(32))
}
  , alm = "listenerMiddleware"
  , getListenerEntryPropsFrom = _e=>{
    let {type: et, actionCreator: tt, matcher: rt, predicate: nt, effect: it} = _e;
    if (et)
        nt = createAction(et).match;
    else if (tt)
        et = tt.type,
        nt = tt.match;
    else if (rt)
        nt = rt;
    else if (!nt)
        throw new Error(formatProdErrorMessage(21));
    return assertFunction(it),
    {
        predicate: nt,
        type: et,
        effect: it
    }
}
  , createListenerEntry = Object.assign(_e=>{
    const {type: et, predicate: tt, effect: rt} = getListenerEntryPropsFrom(_e);
    return {
        id: nanoid(),
        effect: rt,
        type: et,
        predicate: tt,
        pending: new Set,
        unsubscribe: ()=>{
            throw new Error(formatProdErrorMessage(22))
        }
    }
}
, {
    withTypes: ()=>createListenerEntry
})
  , addListener = Object.assign(createAction(`${alm}/add`), {
    withTypes: ()=>addListener
});
createAction(`${alm}/removeAll`);
var removeListener = Object.assign(createAction(`${alm}/remove`), {
    withTypes: ()=>removeListener
});
function formatProdErrorMessage(_e) {
    return `Minified Redux Toolkit error #${_e}; visit https://redux-toolkit.js.org/Errors?code=${_e} for the full message or use the non-minified dev environment for full errors. `
}
var QueryStatus = (_e=>(_e.uninitialized = "uninitialized",
_e.pending = "pending",
_e.fulfilled = "fulfilled",
_e.rejected = "rejected",
_e))(QueryStatus || {});
function getRequestStatusFlags(_e) {
    return {
        status: _e,
        isUninitialized: _e === "uninitialized",
        isLoading: _e === "pending",
        isSuccess: _e === "fulfilled",
        isError: _e === "rejected"
    }
}
function isAbsoluteUrl(_e) {
    return new RegExp("(^|:)//").test(_e)
}
var withoutTrailingSlash = _e=>_e.replace(/\/$/, "")
  , withoutLeadingSlash = _e=>_e.replace(/^\//, "");
function joinUrls(_e, et) {
    if (!_e)
        return et;
    if (!et)
        return _e;
    if (isAbsoluteUrl(et))
        return et;
    const tt = _e.endsWith("/") || !et.startsWith("?") ? "/" : "";
    return _e = withoutTrailingSlash(_e),
    et = withoutLeadingSlash(et),
    `${_e}${tt}${et}`
}
var flatten = _e=>[].concat(..._e);
function isOnline() {
    return typeof navigator > "u" || navigator.onLine === void 0 ? !0 : navigator.onLine
}
function isDocumentVisible() {
    return typeof document > "u" ? !0 : document.visibilityState !== "hidden"
}
var isPlainObject2 = isPlainObject$2;
function copyWithStructuralSharing(_e, et) {
    if (_e === et || !(isPlainObject2(_e) && isPlainObject2(et) || Array.isArray(_e) && Array.isArray(et)))
        return et;
    const tt = Object.keys(et)
      , rt = Object.keys(_e);
    let nt = tt.length === rt.length;
    const it = Array.isArray(et) ? [] : {};
    for (const st of tt)
        it[st] = copyWithStructuralSharing(_e[st], et[st]),
        nt && (nt = _e[st] === it[st]);
    return nt ? _e : it
}
var defaultFetchFn = (..._e)=>fetch(..._e)
  , defaultValidateStatus = _e=>_e.status >= 200 && _e.status <= 299
  , defaultIsJsonContentType = _e=>/ion\/(vnd\.api\+)?json/.test(_e.get("content-type") || "");
function stripUndefined(_e) {
    if (!isPlainObject$2(_e))
        return _e;
    const et = {
        ..._e
    };
    for (const [tt,rt] of Object.entries(et))
        rt === void 0 && delete et[tt];
    return et
}
function fetchBaseQuery({baseUrl: _e, prepareHeaders: et=ct=>ct, fetchFn: tt=defaultFetchFn, paramsSerializer: rt, isJsonContentType: nt=defaultIsJsonContentType, jsonContentType: it="application/json", jsonReplacer: st, timeout: at, responseHandler: ot, validateStatus: lt, ...dt}={}) {
    return typeof fetch > "u" && tt === defaultFetchFn && console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),
    async(ut,ft)=>{
        const {signal: ht, getState: gt, extra: bt, endpoint: pt, forced: mt, type: yt} = ft;
        let vt, {url: wt, headers: _t=new Headers(dt.headers), params: Et=void 0, responseHandler: xt=ot ?? "json", validateStatus: Ct=lt ?? defaultValidateStatus, timeout: Tt=at, ...It} = typeof ut == "string" ? {
            url: ut
        } : ut, Nt = {
            ...dt,
            signal: ht,
            ...It
        };
        _t = new Headers(stripUndefined(_t)),
        Nt.headers = await et(_t, {
            getState: gt,
            extra: bt,
            endpoint: pt,
            forced: mt,
            type: yt
        }) || _t;
        const Ft = zt=>typeof zt == "object" && (isPlainObject$2(zt) || Array.isArray(zt) || typeof zt.toJSON == "function");
        if (!Nt.headers.has("content-type") && Ft(Nt.body) && Nt.headers.set("content-type", it),
        Ft(Nt.body) && nt(Nt.headers) && (Nt.body = JSON.stringify(Nt.body, st)),
        Et) {
            const zt = ~wt.indexOf("?") ? "&" : "?"
              , Yt = rt ? rt(Et) : new URLSearchParams(stripUndefined(Et));
            wt += zt + Yt
        }
        wt = joinUrls(_e, wt);
        const Lt = new Request(wt,Nt);
        vt = {
            request: new Request(wt,Nt)
        };
        let $t, kt = !1, At = Tt && setTimeout(()=>{
            kt = !0,
            ft.abort()
        }
        , Tt);
        try {
            $t = await tt(Lt)
        } catch (zt) {
            return {
                error: {
                    status: kt ? "TIMEOUT_ERROR" : "FETCH_ERROR",
                    error: String(zt)
                },
                meta: vt
            }
        } finally {
            At && clearTimeout(At)
        }
        const Pt = $t.clone();
        vt.response = Pt;
        let Dt, Bt = "";
        try {
            let zt;
            if (await Promise.all([ct($t, xt).then(Yt=>Dt = Yt, Yt=>zt = Yt), Pt.text().then(Yt=>Bt = Yt, ()=>{}
            )]),
            zt)
                throw zt
        } catch (zt) {
            return {
                error: {
                    status: "PARSING_ERROR",
                    originalStatus: $t.status,
                    data: Bt,
                    error: String(zt)
                },
                meta: vt
            }
        }
        return Ct($t, Dt) ? {
            data: Dt,
            meta: vt
        } : {
            error: {
                status: $t.status,
                data: Dt
            },
            meta: vt
        }
    }
    ;
    async function ct(ut, ft) {
        if (typeof ft == "function")
            return ft(ut);
        if (ft === "content-type" && (ft = nt(ut.headers) ? "json" : "text"),
        ft === "json") {
            const ht = await ut.text();
            return ht.length ? JSON.parse(ht) : null
        }
        return ut.text()
    }
}
var HandledError = class {
    constructor(_e, et=void 0) {
        this.value = _e,
        this.meta = et
    }
}
  , onFocus = createAction("__rtkq/focused")
  , onFocusLost = createAction("__rtkq/unfocused")
  , onOnline = createAction("__rtkq/online")
  , onOffline = createAction("__rtkq/offline");
function isQueryDefinition$1(_e) {
    return _e.type === "query"
}
function isMutationDefinition$1(_e) {
    return _e.type === "mutation"
}
function calculateProvidedBy(_e, et, tt, rt, nt, it) {
    return isFunction$1(_e) ? _e(et, tt, rt, nt).map(expandTagDescription).map(it) : Array.isArray(_e) ? _e.map(expandTagDescription).map(it) : []
}
function isFunction$1(_e) {
    return typeof _e == "function"
}
function expandTagDescription(_e) {
    return typeof _e == "string" ? {
        type: _e
    } : _e
}
function isNotNullish(_e) {
    return _e != null
}
function countObjectKeys(_e) {
    let et = 0;
    for (const tt in _e)
        et++;
    return et
}
function asSafePromise(_e, et) {
    return _e.catch(et)
}
var forceQueryFnSymbol = Symbol("forceQueryFn")
  , isUpsertQuery = _e=>typeof _e[forceQueryFnSymbol] == "function";
function buildInitiate({serializeQueryArgs: _e, queryThunk: et, mutationThunk: tt, api: rt, context: nt}) {
    const it = new Map
      , st = new Map
      , {unsubscribeQueryResult: at, removeMutationResult: ot, updateSubscriptionOptions: lt} = rt.internalActions;
    return {
        buildInitiateQuery: ht,
        buildInitiateMutation: gt,
        getRunningQueryThunk: dt,
        getRunningMutationThunk: ct,
        getRunningQueriesThunk: ut,
        getRunningMutationsThunk: ft
    };
    function dt(bt, pt) {
        return mt=>{
            var wt;
            const yt = nt.endpointDefinitions[bt]
              , vt = _e({
                queryArgs: pt,
                endpointDefinition: yt,
                endpointName: bt
            });
            return (wt = it.get(mt)) == null ? void 0 : wt[vt]
        }
    }
    function ct(bt, pt) {
        return mt=>{
            var yt;
            return (yt = st.get(mt)) == null ? void 0 : yt[pt]
        }
    }
    function ut() {
        return bt=>Object.values(it.get(bt) || {}).filter(isNotNullish)
    }
    function ft() {
        return bt=>Object.values(st.get(bt) || {}).filter(isNotNullish)
    }
    function ht(bt, pt) {
        const mt = (yt,{subscribe: vt=!0, forceRefetch: wt, subscriptionOptions: _t, [forceQueryFnSymbol]: Et, ...xt}={})=>(Ct,Tt)=>{
            var zt;
            const It = _e({
                queryArgs: yt,
                endpointDefinition: pt,
                endpointName: bt
            })
              , Nt = et({
                ...xt,
                type: "query",
                subscribe: vt,
                forceRefetch: wt,
                subscriptionOptions: _t,
                endpointName: bt,
                originalArgs: yt,
                queryCacheKey: It,
                [forceQueryFnSymbol]: Et
            })
              , Ft = rt.endpoints[bt].select(yt)
              , Lt = Ct(Nt)
              , Mt = Ft(Tt())
              , {requestId: $t, abort: kt} = Lt
              , At = Mt.requestId !== $t
              , Pt = (zt = it.get(Ct)) == null ? void 0 : zt[It]
              , Dt = ()=>Ft(Tt())
              , Bt = Object.assign(Et ? Lt.then(Dt) : At && !Pt ? Promise.resolve(Mt) : Promise.all([Pt, Lt]).then(Dt), {
                arg: yt,
                requestId: $t,
                subscriptionOptions: _t,
                queryCacheKey: It,
                abort: kt,
                async unwrap() {
                    const Yt = await Bt;
                    if (Yt.isError)
                        throw Yt.error;
                    return Yt.data
                },
                refetch: ()=>Ct(mt(yt, {
                    subscribe: !1,
                    forceRefetch: !0
                })),
                unsubscribe() {
                    vt && Ct(at({
                        queryCacheKey: It,
                        requestId: $t
                    }))
                },
                updateSubscriptionOptions(Yt) {
                    Bt.subscriptionOptions = Yt,
                    Ct(lt({
                        endpointName: bt,
                        requestId: $t,
                        queryCacheKey: It,
                        options: Yt
                    }))
                }
            });
            if (!Pt && !At && !Et) {
                const Yt = it.get(Ct) || {};
                Yt[It] = Bt,
                it.set(Ct, Yt),
                Bt.then(()=>{
                    delete Yt[It],
                    countObjectKeys(Yt) || it.delete(Ct)
                }
                )
            }
            return Bt
        }
        ;
        return mt
    }
    function gt(bt) {
        return (pt,{track: mt=!0, fixedCacheKey: yt}={})=>(vt,wt)=>{
            const _t = tt({
                type: "mutation",
                endpointName: bt,
                originalArgs: pt,
                track: mt,
                fixedCacheKey: yt
            })
              , Et = vt(_t)
              , {requestId: xt, abort: Ct, unwrap: Tt} = Et
              , It = asSafePromise(Et.unwrap().then(Mt=>({
                data: Mt
            })), Mt=>({
                error: Mt
            }))
              , Nt = ()=>{
                vt(ot({
                    requestId: xt,
                    fixedCacheKey: yt
                }))
            }
              , Ft = Object.assign(It, {
                arg: Et.arg,
                requestId: xt,
                abort: Ct,
                unwrap: Tt,
                reset: Nt
            })
              , Lt = st.get(vt) || {};
            return st.set(vt, Lt),
            Lt[xt] = Ft,
            Ft.then(()=>{
                delete Lt[xt],
                countObjectKeys(Lt) || st.delete(vt)
            }
            ),
            yt && (Lt[yt] = Ft,
            Ft.then(()=>{
                Lt[yt] === Ft && (delete Lt[yt],
                countObjectKeys(Lt) || st.delete(vt))
            }
            )),
            Ft
        }
    }
}
function defaultTransformResponse(_e) {
    return _e
}
function buildThunks({reducerPath: _e, baseQuery: et, context: {endpointDefinitions: tt}, serializeQueryArgs: rt, api: nt, assertTagType: it}) {
    const st = (mt,yt,vt,wt)=>(_t,Et)=>{
        const xt = tt[mt]
          , Ct = rt({
            queryArgs: yt,
            endpointDefinition: xt,
            endpointName: mt
        });
        if (_t(nt.internalActions.queryResultPatched({
            queryCacheKey: Ct,
            patches: vt
        })),
        !wt)
            return;
        const Tt = nt.endpoints[mt].select(yt)(Et())
          , It = calculateProvidedBy(xt.providesTags, Tt.data, void 0, yt, {}, it);
        _t(nt.internalActions.updateProvidedBy({
            queryCacheKey: Ct,
            providedTags: It
        }))
    }
      , at = (mt,yt,vt,wt=!0)=>(_t,Et)=>{
        const Ct = nt.endpoints[mt].select(yt)(Et());
        let Tt = {
            patches: [],
            inversePatches: [],
            undo: ()=>_t(nt.util.patchQueryData(mt, yt, Tt.inversePatches, wt))
        };
        if (Ct.status === "uninitialized")
            return Tt;
        let It;
        if ("data"in Ct)
            if (isDraftable(Ct.data)) {
                const [Nt,Ft,Lt] = produceWithPatches(Ct.data, vt);
                Tt.patches.push(...Ft),
                Tt.inversePatches.push(...Lt),
                It = Nt
            } else
                It = vt(Ct.data),
                Tt.patches.push({
                    op: "replace",
                    path: [],
                    value: It
                }),
                Tt.inversePatches.push({
                    op: "replace",
                    path: [],
                    value: Ct.data
                });
        return _t(nt.util.patchQueryData(mt, yt, Tt.patches, wt)),
        Tt
    }
      , ot = (mt,yt,vt)=>wt=>wt(nt.endpoints[mt].initiate(yt, {
        subscribe: !1,
        forceRefetch: !0,
        [forceQueryFnSymbol]: ()=>({
            data: vt
        })
    }))
      , lt = async(mt,{signal: yt, abort: vt, rejectWithValue: wt, fulfillWithValue: _t, dispatch: Et, getState: xt, extra: Ct})=>{
        const Tt = tt[mt.endpointName];
        try {
            let It = defaultTransformResponse, Nt;
            const Ft = {
                signal: yt,
                abort: vt,
                dispatch: Et,
                getState: xt,
                extra: Ct,
                endpoint: mt.endpointName,
                type: mt.type,
                forced: mt.type === "query" ? dt(mt, xt()) : void 0
            }
              , Lt = mt.type === "query" ? mt[forceQueryFnSymbol] : void 0;
            if (Lt ? Nt = Lt() : Tt.query ? (Nt = await et(Tt.query(mt.originalArgs), Ft, Tt.extraOptions),
            Tt.transformResponse && (It = Tt.transformResponse)) : Nt = await Tt.queryFn(mt.originalArgs, Ft, Tt.extraOptions, Mt=>et(Mt, Ft, Tt.extraOptions)),
            typeof process < "u",
            Nt.error)
                throw new HandledError(Nt.error,Nt.meta);
            return _t(await It(Nt.data, Nt.meta, mt.originalArgs), {
                fulfilledTimeStamp: Date.now(),
                baseQueryMeta: Nt.meta,
                [SHOULD_AUTOBATCH]: !0
            })
        } catch (It) {
            let Nt = It;
            if (Nt instanceof HandledError) {
                let Ft = defaultTransformResponse;
                Tt.query && Tt.transformErrorResponse && (Ft = Tt.transformErrorResponse);
                try {
                    return wt(await Ft(Nt.value, Nt.meta, mt.originalArgs), {
                        baseQueryMeta: Nt.meta,
                        [SHOULD_AUTOBATCH]: !0
                    })
                } catch (Lt) {
                    Nt = Lt
                }
            }
            throw typeof process < "u",
            console.error(Nt),
            Nt
        }
    }
    ;
    function dt(mt, yt) {
        var xt, Ct, Tt;
        const vt = (Ct = (xt = yt[_e]) == null ? void 0 : xt.queries) == null ? void 0 : Ct[mt.queryCacheKey]
          , wt = (Tt = yt[_e]) == null ? void 0 : Tt.config.refetchOnMountOrArgChange
          , _t = vt == null ? void 0 : vt.fulfilledTimeStamp
          , Et = mt.forceRefetch ?? (mt.subscribe && wt);
        return Et ? Et === !0 || (Number(new Date) - Number(_t)) / 1e3 >= Et : !1
    }
    const ct = createAsyncThunk(`${_e}/executeQuery`, lt, {
        getPendingMeta() {
            return {
                startedTimeStamp: Date.now(),
                [SHOULD_AUTOBATCH]: !0
            }
        },
        condition(mt, {getState: yt}) {
            var Tt, It, Nt;
            const vt = yt()
              , wt = (It = (Tt = vt[_e]) == null ? void 0 : Tt.queries) == null ? void 0 : It[mt.queryCacheKey]
              , _t = wt == null ? void 0 : wt.fulfilledTimeStamp
              , Et = mt.originalArgs
              , xt = wt == null ? void 0 : wt.originalArgs
              , Ct = tt[mt.endpointName];
            return isUpsertQuery(mt) ? !0 : (wt == null ? void 0 : wt.status) === "pending" ? !1 : dt(mt, vt) || isQueryDefinition$1(Ct) && ((Nt = Ct == null ? void 0 : Ct.forceRefetch) != null && Nt.call(Ct, {
                currentArg: Et,
                previousArg: xt,
                endpointState: wt,
                state: vt
            })) ? !0 : !_t
        },
        dispatchConditionRejection: !0
    })
      , ut = createAsyncThunk(`${_e}/executeMutation`, lt, {
        getPendingMeta() {
            return {
                startedTimeStamp: Date.now(),
                [SHOULD_AUTOBATCH]: !0
            }
        }
    })
      , ft = mt=>"force"in mt
      , ht = mt=>"ifOlderThan"in mt
      , gt = (mt,yt,vt)=>(wt,_t)=>{
        const Et = ft(vt) && vt.force
          , xt = ht(vt) && vt.ifOlderThan
          , Ct = (It=!0)=>{
            const Nt = {
                forceRefetch: It,
                isPrefetch: !0
            };
            return nt.endpoints[mt].initiate(yt, Nt)
        }
          , Tt = nt.endpoints[mt].select(yt)(_t());
        if (Et)
            wt(Ct());
        else if (xt) {
            const It = Tt == null ? void 0 : Tt.fulfilledTimeStamp;
            if (!It) {
                wt(Ct());
                return
            }
            (Number(new Date) - Number(new Date(It))) / 1e3 >= xt && wt(Ct())
        } else
            wt(Ct(!1))
    }
    ;
    function bt(mt) {
        return yt=>{
            var vt, wt;
            return ((wt = (vt = yt == null ? void 0 : yt.meta) == null ? void 0 : vt.arg) == null ? void 0 : wt.endpointName) === mt
        }
    }
    function pt(mt, yt) {
        return {
            matchPending: isAllOf(isPending(mt), bt(yt)),
            matchFulfilled: isAllOf(isFulfilled(mt), bt(yt)),
            matchRejected: isAllOf(isRejected(mt), bt(yt))
        }
    }
    return {
        queryThunk: ct,
        mutationThunk: ut,
        prefetch: gt,
        updateQueryData: at,
        upsertQueryData: ot,
        patchQueryData: st,
        buildMatchThunkActions: pt
    }
}
function calculateProvidedByThunk(_e, et, tt, rt) {
    return calculateProvidedBy(tt[_e.meta.arg.endpointName][et], isFulfilled(_e) ? _e.payload : void 0, isRejectedWithValue(_e) ? _e.payload : void 0, _e.meta.arg.originalArgs, "baseQueryMeta"in _e.meta ? _e.meta.baseQueryMeta : void 0, rt)
}
function updateQuerySubstateIfExists(_e, et, tt) {
    const rt = _e[et];
    rt && tt(rt)
}
function getMutationCacheKey(_e) {
    return ("arg"in _e ? _e.arg.fixedCacheKey : _e.fixedCacheKey) ?? _e.requestId
}
function updateMutationSubstateIfExists(_e, et, tt) {
    const rt = _e[getMutationCacheKey(et)];
    rt && tt(rt)
}
var initialState = {};
function buildSlice({reducerPath: _e, queryThunk: et, mutationThunk: tt, context: {endpointDefinitions: rt, apiUid: nt, extractRehydrationInfo: it, hasRehydrationInfo: st}, assertTagType: at, config: ot}) {
    const lt = createAction(`${_e}/resetApiState`)
      , dt = createSlice({
        name: `${_e}/queries`,
        initialState,
        reducers: {
            removeQueryResult: {
                reducer(yt, {payload: {queryCacheKey: vt}}) {
                    delete yt[vt]
                },
                prepare: prepareAutoBatched()
            },
            queryResultPatched: {
                reducer(yt, {payload: {queryCacheKey: vt, patches: wt}}) {
                    updateQuerySubstateIfExists(yt, vt, _t=>{
                        _t.data = applyPatches(_t.data, wt.concat())
                    }
                    )
                },
                prepare: prepareAutoBatched()
            }
        },
        extraReducers(yt) {
            yt.addCase(et.pending, (vt,{meta: wt, meta: {arg: _t}})=>{
                var xt;
                const Et = isUpsertQuery(_t);
                vt[xt = _t.queryCacheKey] ?? (vt[xt] = {
                    status: "uninitialized",
                    endpointName: _t.endpointName
                }),
                updateQuerySubstateIfExists(vt, _t.queryCacheKey, Ct=>{
                    Ct.status = "pending",
                    Ct.requestId = Et && Ct.requestId ? Ct.requestId : wt.requestId,
                    _t.originalArgs !== void 0 && (Ct.originalArgs = _t.originalArgs),
                    Ct.startedTimeStamp = wt.startedTimeStamp
                }
                )
            }
            ).addCase(et.fulfilled, (vt,{meta: wt, payload: _t})=>{
                updateQuerySubstateIfExists(vt, wt.arg.queryCacheKey, Et=>{
                    if (Et.requestId !== wt.requestId && !isUpsertQuery(wt.arg))
                        return;
                    const {merge: xt} = rt[wt.arg.endpointName];
                    if (Et.status = "fulfilled",
                    xt)
                        if (Et.data !== void 0) {
                            const {fulfilledTimeStamp: Ct, arg: Tt, baseQueryMeta: It, requestId: Nt} = wt;
                            let Ft = produce(Et.data, Lt=>xt(Lt, _t, {
                                arg: Tt.originalArgs,
                                baseQueryMeta: It,
                                fulfilledTimeStamp: Ct,
                                requestId: Nt
                            }));
                            Et.data = Ft
                        } else
                            Et.data = _t;
                    else
                        Et.data = rt[wt.arg.endpointName].structuralSharing ?? !0 ? copyWithStructuralSharing(isDraft(Et.data) ? original(Et.data) : Et.data, _t) : _t;
                    delete Et.error,
                    Et.fulfilledTimeStamp = wt.fulfilledTimeStamp
                }
                )
            }
            ).addCase(et.rejected, (vt,{meta: {condition: wt, arg: _t, requestId: Et}, error: xt, payload: Ct})=>{
                updateQuerySubstateIfExists(vt, _t.queryCacheKey, Tt=>{
                    if (!wt) {
                        if (Tt.requestId !== Et)
                            return;
                        Tt.status = "rejected",
                        Tt.error = Ct ?? xt
                    }
                }
                )
            }
            ).addMatcher(st, (vt,wt)=>{
                const {queries: _t} = it(wt);
                for (const [Et,xt] of Object.entries(_t))
                    ((xt == null ? void 0 : xt.status) === "fulfilled" || (xt == null ? void 0 : xt.status) === "rejected") && (vt[Et] = xt)
            }
            )
        }
    })
      , ct = createSlice({
        name: `${_e}/mutations`,
        initialState,
        reducers: {
            removeMutationResult: {
                reducer(yt, {payload: vt}) {
                    const wt = getMutationCacheKey(vt);
                    wt in yt && delete yt[wt]
                },
                prepare: prepareAutoBatched()
            }
        },
        extraReducers(yt) {
            yt.addCase(tt.pending, (vt,{meta: wt, meta: {requestId: _t, arg: Et, startedTimeStamp: xt}})=>{
                Et.track && (vt[getMutationCacheKey(wt)] = {
                    requestId: _t,
                    status: "pending",
                    endpointName: Et.endpointName,
                    startedTimeStamp: xt
                })
            }
            ).addCase(tt.fulfilled, (vt,{payload: wt, meta: _t})=>{
                _t.arg.track && updateMutationSubstateIfExists(vt, _t, Et=>{
                    Et.requestId === _t.requestId && (Et.status = "fulfilled",
                    Et.data = wt,
                    Et.fulfilledTimeStamp = _t.fulfilledTimeStamp)
                }
                )
            }
            ).addCase(tt.rejected, (vt,{payload: wt, error: _t, meta: Et})=>{
                Et.arg.track && updateMutationSubstateIfExists(vt, Et, xt=>{
                    xt.requestId === Et.requestId && (xt.status = "rejected",
                    xt.error = wt ?? _t)
                }
                )
            }
            ).addMatcher(st, (vt,wt)=>{
                const {mutations: _t} = it(wt);
                for (const [Et,xt] of Object.entries(_t))
                    ((xt == null ? void 0 : xt.status) === "fulfilled" || (xt == null ? void 0 : xt.status) === "rejected") && Et !== (xt == null ? void 0 : xt.requestId) && (vt[Et] = xt)
            }
            )
        }
    })
      , ut = createSlice({
        name: `${_e}/invalidation`,
        initialState,
        reducers: {
            updateProvidedBy: {
                reducer(yt, vt) {
                    var Et, xt;
                    const {queryCacheKey: wt, providedTags: _t} = vt.payload;
                    for (const Ct of Object.values(yt))
                        for (const Tt of Object.values(Ct)) {
                            const It = Tt.indexOf(wt);
                            It !== -1 && Tt.splice(It, 1)
                        }
                    for (const {type: Ct, id: Tt} of _t) {
                        const It = (Et = yt[Ct] ?? (yt[Ct] = {}))[xt = Tt || "__internal_without_id"] ?? (Et[xt] = []);
                        It.includes(wt) || It.push(wt)
                    }
                },
                prepare: prepareAutoBatched()
            }
        },
        extraReducers(yt) {
            yt.addCase(dt.actions.removeQueryResult, (vt,{payload: {queryCacheKey: wt}})=>{
                for (const _t of Object.values(vt))
                    for (const Et of Object.values(_t)) {
                        const xt = Et.indexOf(wt);
                        xt !== -1 && Et.splice(xt, 1)
                    }
            }
            ).addMatcher(st, (vt,wt)=>{
                var Et, xt;
                const {provided: _t} = it(wt);
                for (const [Ct,Tt] of Object.entries(_t))
                    for (const [It,Nt] of Object.entries(Tt)) {
                        const Ft = (Et = vt[Ct] ?? (vt[Ct] = {}))[xt = It || "__internal_without_id"] ?? (Et[xt] = []);
                        for (const Lt of Nt)
                            Ft.includes(Lt) || Ft.push(Lt)
                    }
            }
            ).addMatcher(isAnyOf(isFulfilled(et), isRejectedWithValue(et)), (vt,wt)=>{
                const _t = calculateProvidedByThunk(wt, "providesTags", rt, at)
                  , {queryCacheKey: Et} = wt.meta.arg;
                ut.caseReducers.updateProvidedBy(vt, ut.actions.updateProvidedBy({
                    queryCacheKey: Et,
                    providedTags: _t
                }))
            }
            )
        }
    })
      , ft = createSlice({
        name: `${_e}/subscriptions`,
        initialState,
        reducers: {
            updateSubscriptionOptions(yt, vt) {},
            unsubscribeQueryResult(yt, vt) {},
            internal_getRTKQSubscriptions() {}
        }
    })
      , ht = createSlice({
        name: `${_e}/internalSubscriptions`,
        initialState,
        reducers: {
            subscriptionsUpdated: {
                reducer(yt, vt) {
                    return applyPatches(yt, vt.payload)
                },
                prepare: prepareAutoBatched()
            }
        }
    })
      , gt = createSlice({
        name: `${_e}/config`,
        initialState: {
            online: isOnline(),
            focused: isDocumentVisible(),
            middlewareRegistered: !1,
            ...ot
        },
        reducers: {
            middlewareRegistered(yt, {payload: vt}) {
                yt.middlewareRegistered = yt.middlewareRegistered === "conflict" || nt !== vt ? "conflict" : !0
            }
        },
        extraReducers: yt=>{
            yt.addCase(onOnline, vt=>{
                vt.online = !0
            }
            ).addCase(onOffline, vt=>{
                vt.online = !1
            }
            ).addCase(onFocus, vt=>{
                vt.focused = !0
            }
            ).addCase(onFocusLost, vt=>{
                vt.focused = !1
            }
            ).addMatcher(st, vt=>({
                ...vt
            }))
        }
    })
      , bt = combineReducers({
        queries: dt.reducer,
        mutations: ct.reducer,
        provided: ut.reducer,
        subscriptions: ht.reducer,
        config: gt.reducer
    })
      , pt = (yt,vt)=>bt(lt.match(vt) ? void 0 : yt, vt)
      , mt = {
        ...gt.actions,
        ...dt.actions,
        ...ft.actions,
        ...ht.actions,
        ...ct.actions,
        ...ut.actions,
        resetApiState: lt
    };
    return {
        reducer: pt,
        actions: mt
    }
}
var skipToken = Symbol.for("RTKQ/skipToken")
  , initialSubState = {
    status: "uninitialized"
}
  , defaultQuerySubState = produce(initialSubState, ()=>{}
)
  , defaultMutationSubState = produce(initialSubState, ()=>{}
);
function buildSelectors({serializeQueryArgs: _e, reducerPath: et, createSelector: tt}) {
    const rt = ct=>defaultQuerySubState
      , nt = ct=>defaultMutationSubState;
    return {
        buildQuerySelector: at,
        buildMutationSelector: ot,
        selectInvalidatedBy: lt,
        selectCachedArgsForQuery: dt
    };
    function it(ct) {
        return {
            ...ct,
            ...getRequestStatusFlags(ct.status)
        }
    }
    function st(ct) {
        return ct[et]
    }
    function at(ct, ut) {
        return ft=>{
            const ht = _e({
                queryArgs: ft,
                endpointDefinition: ut,
                endpointName: ct
            });
            return tt(ft === skipToken ? rt : pt=>{
                var mt, yt;
                return ((yt = (mt = st(pt)) == null ? void 0 : mt.queries) == null ? void 0 : yt[ht]) ?? defaultQuerySubState
            }
            , it)
        }
    }
    function ot() {
        return ct=>{
            let ut;
            return typeof ct == "object" ? ut = getMutationCacheKey(ct) ?? skipToken : ut = ct,
            tt(ut === skipToken ? nt : gt=>{
                var bt, pt;
                return ((pt = (bt = st(gt)) == null ? void 0 : bt.mutations) == null ? void 0 : pt[ut]) ?? defaultMutationSubState
            }
            , it)
        }
    }
    function lt(ct, ut) {
        const ft = ct[et]
          , ht = new Set;
        for (const gt of ut.map(expandTagDescription)) {
            const bt = ft.provided[gt.type];
            if (!bt)
                continue;
            let pt = (gt.id !== void 0 ? bt[gt.id] : flatten(Object.values(bt))) ?? [];
            for (const mt of pt)
                ht.add(mt)
        }
        return flatten(Array.from(ht.values()).map(gt=>{
            const bt = ft.queries[gt];
            return bt ? [{
                queryCacheKey: gt,
                endpointName: bt.endpointName,
                originalArgs: bt.originalArgs
            }] : []
        }
        ))
    }
    function dt(ct, ut) {
        return Object.values(ct[et].queries).filter(ft=>(ft == null ? void 0 : ft.endpointName) === ut && ft.status !== "uninitialized").map(ft=>ft.originalArgs)
    }
}
var cache$1 = WeakMap ? new WeakMap : void 0
  , defaultSerializeQueryArgs$1 = ({endpointName: _e, queryArgs: et})=>{
    let tt = "";
    const rt = cache$1 == null ? void 0 : cache$1.get(et);
    if (typeof rt == "string")
        tt = rt;
    else {
        const nt = JSON.stringify(et, (it,st)=>isPlainObject$2(st) ? Object.keys(st).sort().reduce((at,ot)=>(at[ot] = st[ot],
        at), {}) : st);
        isPlainObject$2(et) && (cache$1 == null || cache$1.set(et, nt)),
        tt = nt
    }
    return `${_e}(${tt})`
}
;
function buildCreateApi(..._e) {
    return function(tt) {
        const rt = weakMapMemoize(lt=>{
            var dt;
            return (dt = tt.extractRehydrationInfo) == null ? void 0 : dt.call(tt, lt, {
                reducerPath: tt.reducerPath ?? "api"
            })
        }
        )
          , nt = {
            reducerPath: "api",
            keepUnusedDataFor: 60,
            refetchOnMountOrArgChange: !1,
            refetchOnFocus: !1,
            refetchOnReconnect: !1,
            invalidationBehavior: "delayed",
            ...tt,
            extractRehydrationInfo: rt,
            serializeQueryArgs(lt) {
                let dt = defaultSerializeQueryArgs$1;
                if ("serializeQueryArgs"in lt.endpointDefinition) {
                    const ct = lt.endpointDefinition.serializeQueryArgs;
                    dt = ut=>{
                        const ft = ct(ut);
                        return typeof ft == "string" ? ft : defaultSerializeQueryArgs$1({
                            ...ut,
                            queryArgs: ft
                        })
                    }
                } else
                    tt.serializeQueryArgs && (dt = tt.serializeQueryArgs);
                return dt(lt)
            },
            tagTypes: [...tt.tagTypes || []]
        }
          , it = {
            endpointDefinitions: {},
            batch(lt) {
                lt()
            },
            apiUid: nanoid(),
            extractRehydrationInfo: rt,
            hasRehydrationInfo: weakMapMemoize(lt=>rt(lt) != null)
        }
          , st = {
            injectEndpoints: ot,
            enhanceEndpoints({addTagTypes: lt, endpoints: dt}) {
                if (lt)
                    for (const ct of lt)
                        nt.tagTypes.includes(ct) || nt.tagTypes.push(ct);
                if (dt)
                    for (const [ct,ut] of Object.entries(dt))
                        typeof ut == "function" ? ut(it.endpointDefinitions[ct]) : Object.assign(it.endpointDefinitions[ct] || {}, ut);
                return st
            }
        }
          , at = _e.map(lt=>lt.init(st, nt, it));
        function ot(lt) {
            const dt = lt.endpoints({
                query: ct=>({
                    ...ct,
                    type: "query"
                }),
                mutation: ct=>({
                    ...ct,
                    type: "mutation"
                })
            });
            for (const [ct,ut] of Object.entries(dt)) {
                if (lt.overrideExisting !== !0 && ct in it.endpointDefinitions) {
                    if (lt.overrideExisting === "throw")
                        throw new Error(formatProdErrorMessage(39));
                    typeof process < "u";
                    continue
                }
                it.endpointDefinitions[ct] = ut;
                for (const ft of at)
                    ft.injectEndpoint(ct, ut)
            }
            return st
        }
        return st.injectEndpoints({
            endpoints: tt.endpoints
        })
    }
}
function isObjectEmpty(_e) {
    for (let et in _e)
        return !1;
    return !0
}
var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1
  , buildCacheCollectionHandler = ({reducerPath: _e, api: et, context: tt, internalState: rt})=>{
    const {removeQueryResult: nt, unsubscribeQueryResult: it} = et.internalActions;
    function st(dt) {
        const ct = rt.currentSubscriptions[dt];
        return !!ct && !isObjectEmpty(ct)
    }
    const at = {}
      , ot = (dt,ct,ut)=>{
        var ft;
        if (it.match(dt)) {
            const ht = ct.getState()[_e]
              , {queryCacheKey: gt} = dt.payload;
            lt(gt, (ft = ht.queries[gt]) == null ? void 0 : ft.endpointName, ct, ht.config)
        }
        if (et.util.resetApiState.match(dt))
            for (const [ht,gt] of Object.entries(at))
                gt && clearTimeout(gt),
                delete at[ht];
        if (tt.hasRehydrationInfo(dt)) {
            const ht = ct.getState()[_e]
              , {queries: gt} = tt.extractRehydrationInfo(dt);
            for (const [bt,pt] of Object.entries(gt))
                lt(bt, pt == null ? void 0 : pt.endpointName, ct, ht.config)
        }
    }
    ;
    function lt(dt, ct, ut, ft) {
        const ht = tt.endpointDefinitions[ct]
          , gt = (ht == null ? void 0 : ht.keepUnusedDataFor) ?? ft.keepUnusedDataFor;
        if (gt === 1 / 0)
            return;
        const bt = Math.max(0, Math.min(gt, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
        if (!st(dt)) {
            const pt = at[dt];
            pt && clearTimeout(pt),
            at[dt] = setTimeout(()=>{
                st(dt) || ut.dispatch(nt({
                    queryCacheKey: dt
                })),
                delete at[dt]
            }
            , bt * 1e3)
        }
    }
    return ot
}
  , buildInvalidationByTagsHandler = ({reducerPath: _e, context: et, context: {endpointDefinitions: tt}, mutationThunk: rt, queryThunk: nt, api: it, assertTagType: st, refetchQuery: at, internalState: ot})=>{
    const {removeQueryResult: lt} = it.internalActions
      , dt = isAnyOf(isFulfilled(rt), isRejectedWithValue(rt))
      , ct = isAnyOf(isFulfilled(rt, nt), isRejected(rt, nt));
    let ut = [];
    const ft = (bt,pt)=>{
        dt(bt) ? gt(calculateProvidedByThunk(bt, "invalidatesTags", tt, st), pt) : ct(bt) ? gt([], pt) : it.util.invalidateTags.match(bt) && gt(calculateProvidedBy(bt.payload, void 0, void 0, void 0, void 0, st), pt)
    }
    ;
    function ht(bt) {
        var pt, mt;
        for (const yt in bt.queries)
            if (((pt = bt.queries[yt]) == null ? void 0 : pt.status) === "pending")
                return !0;
        for (const yt in bt.mutations)
            if (((mt = bt.mutations[yt]) == null ? void 0 : mt.status) === "pending")
                return !0;
        return !1
    }
    function gt(bt, pt) {
        const mt = pt.getState()
          , yt = mt[_e];
        if (ut.push(...bt),
        yt.config.invalidationBehavior === "delayed" && ht(yt))
            return;
        const vt = ut;
        if (ut = [],
        vt.length === 0)
            return;
        const wt = it.util.selectInvalidatedBy(mt, vt);
        et.batch(()=>{
            const _t = Array.from(wt.values());
            for (const {queryCacheKey: Et} of _t) {
                const xt = yt.queries[Et]
                  , Ct = ot.currentSubscriptions[Et] ?? {};
                xt && (countObjectKeys(Ct) === 0 ? pt.dispatch(lt({
                    queryCacheKey: Et
                })) : xt.status !== "uninitialized" && pt.dispatch(at(xt, Et)))
            }
        }
        )
    }
    return ft
}
  , buildPollingHandler = ({reducerPath: _e, queryThunk: et, api: tt, refetchQuery: rt, internalState: nt})=>{
    const it = {}
      , st = (ut,ft)=>{
        (tt.internalActions.updateSubscriptionOptions.match(ut) || tt.internalActions.unsubscribeQueryResult.match(ut)) && ot(ut.payload, ft),
        (et.pending.match(ut) || et.rejected.match(ut) && ut.meta.condition) && ot(ut.meta.arg, ft),
        (et.fulfilled.match(ut) || et.rejected.match(ut) && !ut.meta.condition) && at(ut.meta.arg, ft),
        tt.util.resetApiState.match(ut) && dt()
    }
    ;
    function at({queryCacheKey: ut}, ft) {
        const ht = ft.getState()[_e]
          , gt = ht.queries[ut]
          , bt = nt.currentSubscriptions[ut];
        if (!gt || gt.status === "uninitialized")
            return;
        const {lowestPollingInterval: pt, skipPollingIfUnfocused: mt} = ct(bt);
        if (!Number.isFinite(pt))
            return;
        const yt = it[ut];
        yt != null && yt.timeout && (clearTimeout(yt.timeout),
        yt.timeout = void 0);
        const vt = Date.now() + pt;
        it[ut] = {
            nextPollTimestamp: vt,
            pollingInterval: pt,
            timeout: setTimeout(()=>{
                (ht.config.focused || !mt) && ft.dispatch(rt(gt, ut)),
                at({
                    queryCacheKey: ut
                }, ft)
            }
            , pt)
        }
    }
    function ot({queryCacheKey: ut}, ft) {
        const gt = ft.getState()[_e].queries[ut]
          , bt = nt.currentSubscriptions[ut];
        if (!gt || gt.status === "uninitialized")
            return;
        const {lowestPollingInterval: pt} = ct(bt);
        if (!Number.isFinite(pt)) {
            lt(ut);
            return
        }
        const mt = it[ut]
          , yt = Date.now() + pt;
        (!mt || yt < mt.nextPollTimestamp) && at({
            queryCacheKey: ut
        }, ft)
    }
    function lt(ut) {
        const ft = it[ut];
        ft != null && ft.timeout && clearTimeout(ft.timeout),
        delete it[ut]
    }
    function dt() {
        for (const ut of Object.keys(it))
            lt(ut)
    }
    function ct(ut={}) {
        let ft = !1
          , ht = Number.POSITIVE_INFINITY;
        for (let gt in ut)
            ut[gt].pollingInterval && (ht = Math.min(ut[gt].pollingInterval, ht),
            ft = ut[gt].skipPollingIfUnfocused || ft);
        return {
            lowestPollingInterval: ht,
            skipPollingIfUnfocused: ft
        }
    }
    return st
}
  , buildWindowEventHandler = ({reducerPath: _e, context: et, api: tt, refetchQuery: rt, internalState: nt})=>{
    const {removeQueryResult: it} = tt.internalActions
      , st = (ot,lt)=>{
        onFocus.match(ot) && at(lt, "refetchOnFocus"),
        onOnline.match(ot) && at(lt, "refetchOnReconnect")
    }
    ;
    function at(ot, lt) {
        const dt = ot.getState()[_e]
          , ct = dt.queries
          , ut = nt.currentSubscriptions;
        et.batch(()=>{
            for (const ft of Object.keys(ut)) {
                const ht = ct[ft]
                  , gt = ut[ft];
                if (!gt || !ht)
                    continue;
                (Object.values(gt).some(pt=>pt[lt] === !0) || Object.values(gt).every(pt=>pt[lt] === void 0) && dt.config[lt]) && (countObjectKeys(gt) === 0 ? ot.dispatch(it({
                    queryCacheKey: ft
                })) : ht.status !== "uninitialized" && ot.dispatch(rt(ht, ft)))
            }
        }
        )
    }
    return st
}
  , neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.")
  , buildCacheLifecycleHandler = ({api: _e, reducerPath: et, context: tt, queryThunk: rt, mutationThunk: nt, internalState: it})=>{
    const st = isAsyncThunkAction(rt)
      , at = isAsyncThunkAction(nt)
      , ot = isFulfilled(rt, nt)
      , lt = {}
      , dt = (ft,ht,gt)=>{
        const bt = ct(ft);
        if (rt.pending.match(ft)) {
            const pt = gt[et].queries[bt]
              , mt = ht.getState()[et].queries[bt];
            !pt && mt && ut(ft.meta.arg.endpointName, ft.meta.arg.originalArgs, bt, ht, ft.meta.requestId)
        } else if (nt.pending.match(ft))
            ht.getState()[et].mutations[bt] && ut(ft.meta.arg.endpointName, ft.meta.arg.originalArgs, bt, ht, ft.meta.requestId);
        else if (ot(ft)) {
            const pt = lt[bt];
            pt != null && pt.valueResolved && (pt.valueResolved({
                data: ft.payload,
                meta: ft.meta.baseQueryMeta
            }),
            delete pt.valueResolved)
        } else if (_e.internalActions.removeQueryResult.match(ft) || _e.internalActions.removeMutationResult.match(ft)) {
            const pt = lt[bt];
            pt && (delete lt[bt],
            pt.cacheEntryRemoved())
        } else if (_e.util.resetApiState.match(ft))
            for (const [pt,mt] of Object.entries(lt))
                delete lt[pt],
                mt.cacheEntryRemoved()
    }
    ;
    function ct(ft) {
        return st(ft) ? ft.meta.arg.queryCacheKey : at(ft) ? ft.meta.arg.fixedCacheKey ?? ft.meta.requestId : _e.internalActions.removeQueryResult.match(ft) ? ft.payload.queryCacheKey : _e.internalActions.removeMutationResult.match(ft) ? getMutationCacheKey(ft.payload) : ""
    }
    function ut(ft, ht, gt, bt, pt) {
        const mt = tt.endpointDefinitions[ft]
          , yt = mt == null ? void 0 : mt.onCacheEntryAdded;
        if (!yt)
            return;
        let vt = {};
        const wt = new Promise(It=>{
            vt.cacheEntryRemoved = It
        }
        )
          , _t = Promise.race([new Promise(It=>{
            vt.valueResolved = It
        }
        ), wt.then(()=>{
            throw neverResolvedError
        }
        )]);
        _t.catch(()=>{}
        ),
        lt[gt] = vt;
        const Et = _e.endpoints[ft].select(mt.type === "query" ? ht : gt)
          , xt = bt.dispatch((It,Nt,Ft)=>Ft)
          , Ct = {
            ...bt,
            getCacheEntry: ()=>Et(bt.getState()),
            requestId: pt,
            extra: xt,
            updateCachedData: mt.type === "query" ? It=>bt.dispatch(_e.util.updateQueryData(ft, ht, It)) : void 0,
            cacheDataLoaded: _t,
            cacheEntryRemoved: wt
        }
          , Tt = yt(ht, Ct);
        Promise.resolve(Tt).catch(It=>{
            if (It !== neverResolvedError)
                throw It
        }
        )
    }
    return dt
}
  , buildQueryLifecycleHandler = ({api: _e, context: et, queryThunk: tt, mutationThunk: rt})=>{
    const nt = isPending(tt, rt)
      , it = isRejected(tt, rt)
      , st = isFulfilled(tt, rt)
      , at = {};
    return (lt,dt)=>{
        var ct, ut;
        if (nt(lt)) {
            const {requestId: ft, arg: {endpointName: ht, originalArgs: gt}} = lt.meta
              , bt = et.endpointDefinitions[ht]
              , pt = bt == null ? void 0 : bt.onQueryStarted;
            if (pt) {
                const mt = {}
                  , yt = new Promise((Et,xt)=>{
                    mt.resolve = Et,
                    mt.reject = xt
                }
                );
                yt.catch(()=>{}
                ),
                at[ft] = mt;
                const vt = _e.endpoints[ht].select(bt.type === "query" ? gt : ft)
                  , wt = dt.dispatch((Et,xt,Ct)=>Ct)
                  , _t = {
                    ...dt,
                    getCacheEntry: ()=>vt(dt.getState()),
                    requestId: ft,
                    extra: wt,
                    updateCachedData: bt.type === "query" ? Et=>dt.dispatch(_e.util.updateQueryData(ht, gt, Et)) : void 0,
                    queryFulfilled: yt
                };
                pt(gt, _t)
            }
        } else if (st(lt)) {
            const {requestId: ft, baseQueryMeta: ht} = lt.meta;
            (ct = at[ft]) == null || ct.resolve({
                data: lt.payload,
                meta: ht
            }),
            delete at[ft]
        } else if (it(lt)) {
            const {requestId: ft, rejectedWithValue: ht, baseQueryMeta: gt} = lt.meta;
            (ut = at[ft]) == null || ut.reject({
                error: lt.payload ?? lt.error,
                isUnhandledError: !ht,
                meta: gt
            }),
            delete at[ft]
        }
    }
}
  , buildDevCheckHandler = ({api: _e, context: {apiUid: et}, reducerPath: tt})=>(rt,nt)=>{
    _e.util.resetApiState.match(rt) && nt.dispatch(_e.internalActions.middlewareRegistered(et)),
    typeof process < "u"
}
  , buildBatchedActionsHandler = ({api: _e, queryThunk: et, internalState: tt})=>{
    const rt = `${_e.reducerPath}/subscriptions`;
    let nt = null
      , it = null;
    const {updateSubscriptionOptions: st, unsubscribeQueryResult: at} = _e.internalActions
      , ot = (ft,ht)=>{
        var bt, pt, mt;
        if (st.match(ht)) {
            const {queryCacheKey: yt, requestId: vt, options: wt} = ht.payload;
            return (bt = ft == null ? void 0 : ft[yt]) != null && bt[vt] && (ft[yt][vt] = wt),
            !0
        }
        if (at.match(ht)) {
            const {queryCacheKey: yt, requestId: vt} = ht.payload;
            return ft[yt] && delete ft[yt][vt],
            !0
        }
        if (_e.internalActions.removeQueryResult.match(ht))
            return delete ft[ht.payload.queryCacheKey],
            !0;
        if (et.pending.match(ht)) {
            const {meta: {arg: yt, requestId: vt}} = ht
              , wt = ft[pt = yt.queryCacheKey] ?? (ft[pt] = {});
            return wt[`${vt}_running`] = {},
            yt.subscribe && (wt[vt] = yt.subscriptionOptions ?? wt[vt] ?? {}),
            !0
        }
        let gt = !1;
        if (et.fulfilled.match(ht) || et.rejected.match(ht)) {
            const yt = ft[ht.meta.arg.queryCacheKey] || {}
              , vt = `${ht.meta.requestId}_running`;
            gt || (gt = !!yt[vt]),
            delete yt[vt]
        }
        if (et.rejected.match(ht)) {
            const {meta: {condition: yt, arg: vt, requestId: wt}} = ht;
            if (yt && vt.subscribe) {
                const _t = ft[mt = vt.queryCacheKey] ?? (ft[mt] = {});
                _t[wt] = vt.subscriptionOptions ?? _t[wt] ?? {},
                gt = !0
            }
        }
        return gt
    }
      , lt = ()=>tt.currentSubscriptions
      , ut = {
        getSubscriptions: lt,
        getSubscriptionCount: ft=>{
            const gt = lt()[ft] ?? {};
            return countObjectKeys(gt)
        }
        ,
        isRequestSubscribed: (ft,ht)=>{
            var bt;
            const gt = lt();
            return !!((bt = gt == null ? void 0 : gt[ft]) != null && bt[ht])
        }
    };
    return (ft,ht)=>{
        if (nt || (nt = JSON.parse(JSON.stringify(tt.currentSubscriptions))),
        _e.util.resetApiState.match(ft))
            return nt = tt.currentSubscriptions = {},
            it = null,
            [!0, !1];
        if (_e.internalActions.internal_getRTKQSubscriptions.match(ft))
            return [!1, ut];
        const gt = ot(tt.currentSubscriptions, ft);
        let bt = !0;
        if (gt) {
            it || (it = setTimeout(()=>{
                const yt = JSON.parse(JSON.stringify(tt.currentSubscriptions))
                  , [,vt] = produceWithPatches(nt, ()=>yt);
                ht.next(_e.internalActions.subscriptionsUpdated(vt)),
                nt = yt,
                it = null
            }
            , 500));
            const pt = typeof ft.type == "string" && !!ft.type.startsWith(rt)
              , mt = et.rejected.match(ft) && ft.meta.condition && !!ft.meta.arg.subscribe;
            bt = !pt && !mt
        }
        return [bt, !1]
    }
}
;
function buildMiddleware(_e) {
    const {reducerPath: et, queryThunk: tt, api: rt, context: nt} = _e
      , {apiUid: it} = nt
      , st = {
        invalidateTags: createAction(`${et}/invalidateTags`)
    }
      , at = ct=>ct.type.startsWith(`${et}/`)
      , ot = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];
    return {
        middleware: ct=>{
            let ut = !1;
            const ht = {
                ..._e,
                internalState: {
                    currentSubscriptions: {}
                },
                refetchQuery: dt,
                isThisApiSliceAction: at
            }
              , gt = ot.map(mt=>mt(ht))
              , bt = buildBatchedActionsHandler(ht)
              , pt = buildWindowEventHandler(ht);
            return mt=>yt=>{
                if (!isAction(yt))
                    return mt(yt);
                ut || (ut = !0,
                ct.dispatch(rt.internalActions.middlewareRegistered(it)));
                const vt = {
                    ...ct,
                    next: mt
                }
                  , wt = ct.getState()
                  , [_t,Et] = bt(yt, vt, wt);
                let xt;
                if (_t ? xt = mt(yt) : xt = Et,
                ct.getState()[et] && (pt(yt, vt, wt),
                at(yt) || nt.hasRehydrationInfo(yt)))
                    for (let Ct of gt)
                        Ct(yt, vt, wt);
                return xt
            }
        }
        ,
        actions: st
    };
    function dt(ct, ut, ft={}) {
        return tt({
            type: "query",
            endpointName: ct.endpointName,
            originalArgs: ct.originalArgs,
            subscribe: !1,
            forceRefetch: !0,
            queryCacheKey: ut,
            ...ft
        })
    }
}
function safeAssign$1(_e, ...et) {
    return Object.assign(_e, ...et)
}
var coreModuleName = Symbol()
  , coreModule = ({createSelector: _e=createSelector}={})=>({
    name: coreModuleName,
    init(et, {baseQuery: tt, tagTypes: rt, reducerPath: nt, serializeQueryArgs: it, keepUnusedDataFor: st, refetchOnMountOrArgChange: at, refetchOnFocus: ot, refetchOnReconnect: lt, invalidationBehavior: dt}, ct) {
        enablePatches();
        const ut = At=>(typeof process < "u",
        At);
        Object.assign(et, {
            reducerPath: nt,
            endpoints: {},
            internalActions: {
                onOnline,
                onOffline,
                onFocus,
                onFocusLost
            },
            util: {}
        });
        const {queryThunk: ft, mutationThunk: ht, patchQueryData: gt, updateQueryData: bt, upsertQueryData: pt, prefetch: mt, buildMatchThunkActions: yt} = buildThunks({
            baseQuery: tt,
            reducerPath: nt,
            context: ct,
            api: et,
            serializeQueryArgs: it,
            assertTagType: ut
        })
          , {reducer: vt, actions: wt} = buildSlice({
            context: ct,
            queryThunk: ft,
            mutationThunk: ht,
            reducerPath: nt,
            assertTagType: ut,
            config: {
                refetchOnFocus: ot,
                refetchOnReconnect: lt,
                refetchOnMountOrArgChange: at,
                keepUnusedDataFor: st,
                reducerPath: nt,
                invalidationBehavior: dt
            }
        });
        safeAssign$1(et.util, {
            patchQueryData: gt,
            updateQueryData: bt,
            upsertQueryData: pt,
            prefetch: mt,
            resetApiState: wt.resetApiState
        }),
        safeAssign$1(et.internalActions, wt);
        const {middleware: _t, actions: Et} = buildMiddleware({
            reducerPath: nt,
            context: ct,
            queryThunk: ft,
            mutationThunk: ht,
            api: et,
            assertTagType: ut
        });
        safeAssign$1(et.util, Et),
        safeAssign$1(et, {
            reducer: vt,
            middleware: _t
        });
        const {buildQuerySelector: xt, buildMutationSelector: Ct, selectInvalidatedBy: Tt, selectCachedArgsForQuery: It} = buildSelectors({
            serializeQueryArgs: it,
            reducerPath: nt,
            createSelector: _e
        });
        safeAssign$1(et.util, {
            selectInvalidatedBy: Tt,
            selectCachedArgsForQuery: It
        });
        const {buildInitiateQuery: Nt, buildInitiateMutation: Ft, getRunningMutationThunk: Lt, getRunningMutationsThunk: Mt, getRunningQueriesThunk: $t, getRunningQueryThunk: kt} = buildInitiate({
            queryThunk: ft,
            mutationThunk: ht,
            api: et,
            serializeQueryArgs: it,
            context: ct
        });
        return safeAssign$1(et.util, {
            getRunningMutationThunk: Lt,
            getRunningMutationsThunk: Mt,
            getRunningQueryThunk: kt,
            getRunningQueriesThunk: $t
        }),
        {
            name: coreModuleName,
            injectEndpoint(At, Pt) {
                var Bt;
                const Dt = et;
                (Bt = Dt.endpoints)[At] ?? (Bt[At] = {}),
                isQueryDefinition$1(Pt) ? safeAssign$1(Dt.endpoints[At], {
                    name: At,
                    select: xt(At, Pt),
                    initiate: Nt(At, Pt)
                }, yt(ft, At)) : isMutationDefinition$1(Pt) && safeAssign$1(Dt.endpoints[At], {
                    name: At,
                    select: Ct(),
                    initiate: Ft(At)
                }, yt(ht, At))
            }
        }
    }
})
  , withSelector = {
    exports: {}
}
  , useSyncExternalStoreWithSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var g = reactExports;
function n(_e, et) {
    return _e === et && (_e !== 0 || 1 / _e === 1 / et) || _e !== _e && et !== et
}
var p = typeof Object.is == "function" ? Object.is : n
  , q = g.useSyncExternalStore
  , r = g.useRef
  , t = g.useEffect
  , u = g.useMemo
  , v$1 = g.useDebugValue;
useSyncExternalStoreWithSelector_production_min.useSyncExternalStoreWithSelector = function(_e, et, tt, rt, nt) {
    var it = r(null);
    if (it.current === null) {
        var st = {
            hasValue: !1,
            value: null
        };
        it.current = st
    } else
        st = it.current;
    it = u(function() {
        function ot(ft) {
            if (!lt) {
                if (lt = !0,
                dt = ft,
                ft = rt(ft),
                nt !== void 0 && st.hasValue) {
                    var ht = st.value;
                    if (nt(ht, ft))
                        return ct = ht
                }
                return ct = ft
            }
            if (ht = ct,
            p(dt, ft))
                return ht;
            var gt = rt(ft);
            return nt !== void 0 && nt(ht, gt) ? ht : (dt = ft,
            ct = gt)
        }
        var lt = !1, dt, ct, ut = tt === void 0 ? null : tt;
        return [function() {
            return ot(et())
        }
        , ut === null ? void 0 : function() {
            return ot(ut())
        }
        ]
    }, [et, tt, rt, nt]);
    var at = q(_e, it[0], it[1]);
    return t(function() {
        st.hasValue = !0,
        st.value = at
    }, [at]),
    v$1(at),
    at
}
;
withSelector.exports = useSyncExternalStoreWithSelector_production_min;
var withSelectorExports = withSelector.exports
  , React = "default"in ReactOriginal ? React$1 : ReactOriginal
  , ContextKey = Symbol.for("react-redux-context")
  , gT = typeof globalThis < "u" ? globalThis : {};
function getContext() {
    if (!React.createContext)
        return {};
    const _e = gT[ContextKey] ?? (gT[ContextKey] = new Map);
    let et = _e.get(React.createContext);
    return et || (et = React.createContext(null),
    _e.set(React.createContext, et)),
    et
}
var ReactReduxContext = getContext()
  , notInitialized = ()=>{
    throw new Error("uSES not initialized!")
}
;
function createReduxContextHook(_e=ReactReduxContext) {
    return function() {
        return React.useContext(_e)
    }
}
var useReduxContext = createReduxContextHook()
  , useSyncExternalStoreWithSelector = notInitialized
  , initializeUseSelector = _e=>{
    useSyncExternalStoreWithSelector = _e
}
  , refEquality = (_e,et)=>_e === et;
function createSelectorHook(_e=ReactReduxContext) {
    const et = _e === ReactReduxContext ? useReduxContext : createReduxContextHook(_e)
      , tt = (rt,nt={})=>{
        const {equalityFn: it=refEquality, devModeChecks: st={}} = typeof nt == "function" ? {
            equalityFn: nt
        } : nt
          , {store: at, subscription: ot, getServerState: lt, stabilityCheck: dt, identityFunctionCheck: ct} = et();
        React.useRef(!0);
        const ut = React.useCallback({
            [rt.name](ht) {
                return rt(ht)
            }
        }[rt.name], [rt, dt, st.stabilityCheck])
          , ft = useSyncExternalStoreWithSelector(ot.addNestedSub, at.getState, lt || at.getState, ut, it);
        return React.useDebugValue(ft),
        ft
    }
    ;
    return Object.assign(tt, {
        withTypes: ()=>tt
    }),
    tt
}
var useSelector = createSelectorHook();
function defaultNoopBatch(_e) {
    _e()
}
function createListenerCollection() {
    let _e = null
      , et = null;
    return {
        clear() {
            _e = null,
            et = null
        },
        notify() {
            defaultNoopBatch(()=>{
                let tt = _e;
                for (; tt; )
                    tt.callback(),
                    tt = tt.next
            }
            )
        },
        get() {
            const tt = [];
            let rt = _e;
            for (; rt; )
                tt.push(rt),
                rt = rt.next;
            return tt
        },
        subscribe(tt) {
            let rt = !0;
            const nt = et = {
                callback: tt,
                next: null,
                prev: et
            };
            return nt.prev ? nt.prev.next = nt : _e = nt,
            function() {
                !rt || _e === null || (rt = !1,
                nt.next ? nt.next.prev = nt.prev : et = nt.prev,
                nt.prev ? nt.prev.next = nt.next : _e = nt.next)
            }
        }
    }
}
var nullListeners = {
    notify() {},
    get: ()=>[]
};
function createSubscription(_e, et) {
    let tt, rt = nullListeners, nt = 0, it = !1;
    function st(gt) {
        dt();
        const bt = rt.subscribe(gt);
        let pt = !1;
        return ()=>{
            pt || (pt = !0,
            bt(),
            ct())
        }
    }
    function at() {
        rt.notify()
    }
    function ot() {
        ht.onStateChange && ht.onStateChange()
    }
    function lt() {
        return it
    }
    function dt() {
        nt++,
        tt || (tt = et ? et.addNestedSub(ot) : _e.subscribe(ot),
        rt = createListenerCollection())
    }
    function ct() {
        nt--,
        tt && nt === 0 && (tt(),
        tt = void 0,
        rt.clear(),
        rt = nullListeners)
    }
    function ut() {
        it || (it = !0,
        dt())
    }
    function ft() {
        it && (it = !1,
        ct())
    }
    const ht = {
        addNestedSub: st,
        notifyNestedSubs: at,
        handleChangeWrapper: ot,
        isSubscribed: lt,
        trySubscribe: ut,
        tryUnsubscribe: ft,
        getListeners: ()=>rt
    };
    return ht
}
var canUseDOM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , useIsomorphicLayoutEffect$2 = canUseDOM ? React.useLayoutEffect : React.useEffect;
function is(_e, et) {
    return _e === et ? _e !== 0 || et !== 0 || 1 / _e === 1 / et : _e !== _e && et !== et
}
function shallowEqual(_e, et) {
    if (is(_e, et))
        return !0;
    if (typeof _e != "object" || _e === null || typeof et != "object" || et === null)
        return !1;
    const tt = Object.keys(_e)
      , rt = Object.keys(et);
    if (tt.length !== rt.length)
        return !1;
    for (let nt = 0; nt < tt.length; nt++)
        if (!Object.prototype.hasOwnProperty.call(et, tt[nt]) || !is(_e[tt[nt]], et[tt[nt]]))
            return !1;
    return !0
}
function Provider({store: _e, context: et, children: tt, serverState: rt, stabilityCheck: nt="once", identityFunctionCheck: it="once"}) {
    const st = React.useMemo(()=>{
        const lt = createSubscription(_e);
        return {
            store: _e,
            subscription: lt,
            getServerState: rt ? ()=>rt : void 0,
            stabilityCheck: nt,
            identityFunctionCheck: it
        }
    }
    , [_e, rt, nt, it])
      , at = React.useMemo(()=>_e.getState(), [_e]);
    useIsomorphicLayoutEffect$2(()=>{
        const {subscription: lt} = st;
        return lt.onStateChange = lt.notifyNestedSubs,
        lt.trySubscribe(),
        at !== _e.getState() && lt.notifyNestedSubs(),
        ()=>{
            lt.tryUnsubscribe(),
            lt.onStateChange = void 0
        }
    }
    , [st, at]);
    const ot = et || ReactReduxContext;
    return React.createElement(ot.Provider, {
        value: st
    }, tt)
}
var Provider_default = Provider;
function createStoreHook(_e=ReactReduxContext) {
    const et = _e === ReactReduxContext ? useReduxContext : createReduxContextHook(_e)
      , tt = ()=>{
        const {store: rt} = et();
        return rt
    }
    ;
    return Object.assign(tt, {
        withTypes: ()=>tt
    }),
    tt
}
var useStore = createStoreHook();
function createDispatchHook(_e=ReactReduxContext) {
    const et = _e === ReactReduxContext ? useStore : createStoreHook(_e)
      , tt = ()=>et().dispatch;
    return Object.assign(tt, {
        withTypes: ()=>tt
    }),
    tt
}
var useDispatch = createDispatchHook()
  , batch = defaultNoopBatch;
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
function isQueryDefinition(_e) {
    return _e.type === "query"
}
function isMutationDefinition(_e) {
    return _e.type === "mutation"
}
function safeAssign(_e, ...et) {
    return Object.assign(_e, ...et)
}
function capitalize(_e) {
    return _e.replace(_e[0], _e[0].toUpperCase())
}
var cache = WeakMap ? new WeakMap : void 0
  , defaultSerializeQueryArgs = ({endpointName: _e, queryArgs: et})=>{
    let tt = "";
    const rt = cache == null ? void 0 : cache.get(et);
    if (typeof rt == "string")
        tt = rt;
    else {
        const nt = JSON.stringify(et, (it,st)=>isPlainObject$2(st) ? Object.keys(st).sort().reduce((at,ot)=>(at[ot] = st[ot],
        at), {}) : st);
        isPlainObject$2(et) && (cache == null || cache.set(et, nt)),
        tt = nt
    }
    return `${_e}(${tt})`
}
  , UNINITIALIZED_VALUE = Symbol();
function useStableQueryArgs(_e, et, tt, rt) {
    const nt = reactExports.useMemo(()=>({
        queryArgs: _e,
        serialized: typeof _e == "object" ? et({
            queryArgs: _e,
            endpointDefinition: tt,
            endpointName: rt
        }) : _e
    }), [_e, et, tt, rt])
      , it = reactExports.useRef(nt);
    return reactExports.useEffect(()=>{
        it.current.serialized !== nt.serialized && (it.current = nt)
    }
    , [nt]),
    it.current.serialized === nt.serialized ? it.current.queryArgs : _e
}
function useShallowStableValue(_e) {
    const et = reactExports.useRef(_e);
    return reactExports.useEffect(()=>{
        shallowEqual(et.current, _e) || (et.current = _e)
    }
    , [_e]),
    shallowEqual(et.current, _e) ? et.current : _e
}
var useIsomorphicLayoutEffect$1 = typeof window < "u" && window.document && window.document.createElement ? reactExports.useLayoutEffect : reactExports.useEffect
  , noPendingQueryStateSelector = _e=>_e.isUninitialized ? {
    ..._e,
    isUninitialized: !1,
    isFetching: !0,
    isLoading: _e.data === void 0,
    status: QueryStatus.pending
} : _e;
function buildHooks({api: _e, moduleOptions: {batch: et, hooks: {useDispatch: tt, useSelector: rt, useStore: nt}, unstable__sideEffectsInRender: it, createSelector: st}, serializeQueryArgs: at, context: ot}) {
    const lt = it ? ht=>ht() : reactExports.useEffect;
    return {
        buildQueryHooks: ut,
        buildMutationHook: ft,
        usePrefetch: ct
    };
    function dt(ht, gt, bt) {
        if (gt != null && gt.endpointName && ht.isUninitialized) {
            const {endpointName: _t} = gt
              , Et = ot.endpointDefinitions[_t];
            at({
                queryArgs: gt.originalArgs,
                endpointDefinition: Et,
                endpointName: _t
            }) === at({
                queryArgs: bt,
                endpointDefinition: Et,
                endpointName: _t
            }) && (gt = void 0)
        }
        let pt = ht.isSuccess ? ht.data : gt == null ? void 0 : gt.data;
        pt === void 0 && (pt = ht.data);
        const mt = pt !== void 0
          , yt = ht.isLoading
          , vt = !mt && yt
          , wt = ht.isSuccess || yt && mt;
        return {
            ...ht,
            data: pt,
            currentData: ht.data,
            isFetching: yt,
            isLoading: vt,
            isSuccess: wt
        }
    }
    function ct(ht, gt) {
        const bt = tt()
          , pt = useShallowStableValue(gt);
        return reactExports.useCallback((mt,yt)=>bt(_e.util.prefetch(ht, mt, {
            ...pt,
            ...yt
        })), [ht, bt, pt])
    }
    function ut(ht) {
        const gt = (mt,{refetchOnReconnect: yt, refetchOnFocus: vt, refetchOnMountOrArgChange: wt, skip: _t=!1, pollingInterval: Et=0, skipPollingIfUnfocused: xt=!1}={})=>{
            const {initiate: Ct} = _e.endpoints[ht]
              , Tt = tt()
              , It = reactExports.useRef();
            if (!It.current) {
                const Dt = Tt(_e.internalActions.internal_getRTKQSubscriptions());
                It.current = Dt
            }
            const Nt = useStableQueryArgs(_t ? skipToken : mt, defaultSerializeQueryArgs, ot.endpointDefinitions[ht], ht)
              , Ft = useShallowStableValue({
                refetchOnReconnect: yt,
                refetchOnFocus: vt,
                pollingInterval: Et,
                skipPollingIfUnfocused: xt
            })
              , Lt = reactExports.useRef(!1)
              , Mt = reactExports.useRef();
            let {queryCacheKey: $t, requestId: kt} = Mt.current || {}
              , At = !1;
            $t && kt && (At = It.current.isRequestSubscribed($t, kt));
            const Pt = !At && Lt.current;
            return lt(()=>{
                Lt.current = At
            }
            ),
            lt(()=>{
                Pt && (Mt.current = void 0)
            }
            , [Pt]),
            lt(()=>{
                var zt;
                const Dt = Mt.current;
                if (typeof process < "u",
                Nt === skipToken) {
                    Dt == null || Dt.unsubscribe(),
                    Mt.current = void 0;
                    return
                }
                const Bt = (zt = Mt.current) == null ? void 0 : zt.subscriptionOptions;
                if (!Dt || Dt.arg !== Nt) {
                    Dt == null || Dt.unsubscribe();
                    const Yt = Tt(Ct(Nt, {
                        subscriptionOptions: Ft,
                        forceRefetch: wt
                    }));
                    Mt.current = Yt
                } else
                    Ft !== Bt && Dt.updateSubscriptionOptions(Ft)
            }
            , [Tt, Ct, wt, Nt, Ft, Pt]),
            reactExports.useEffect(()=>()=>{
                var Dt;
                (Dt = Mt.current) == null || Dt.unsubscribe(),
                Mt.current = void 0
            }
            , []),
            reactExports.useMemo(()=>({
                refetch: ()=>{
                    var Dt;
                    if (!Mt.current)
                        throw new Error(formatProdErrorMessage(38));
                    return (Dt = Mt.current) == null ? void 0 : Dt.refetch()
                }
            }), [])
        }
          , bt = ({refetchOnReconnect: mt, refetchOnFocus: yt, pollingInterval: vt=0, skipPollingIfUnfocused: wt=!1}={})=>{
            const {initiate: _t} = _e.endpoints[ht]
              , Et = tt()
              , [xt,Ct] = reactExports.useState(UNINITIALIZED_VALUE)
              , Tt = reactExports.useRef()
              , It = useShallowStableValue({
                refetchOnReconnect: mt,
                refetchOnFocus: yt,
                pollingInterval: vt,
                skipPollingIfUnfocused: wt
            });
            lt(()=>{
                var Mt, $t;
                const Lt = (Mt = Tt.current) == null ? void 0 : Mt.subscriptionOptions;
                It !== Lt && (($t = Tt.current) == null || $t.updateSubscriptionOptions(It))
            }
            , [It]);
            const Nt = reactExports.useRef(It);
            lt(()=>{
                Nt.current = It
            }
            , [It]);
            const Ft = reactExports.useCallback(function(Lt, Mt=!1) {
                let $t;
                return et(()=>{
                    var kt;
                    (kt = Tt.current) == null || kt.unsubscribe(),
                    Tt.current = $t = Et(_t(Lt, {
                        subscriptionOptions: Nt.current,
                        forceRefetch: !Mt
                    })),
                    Ct(Lt)
                }
                ),
                $t
            }, [Et, _t]);
            return reactExports.useEffect(()=>()=>{
                var Lt;
                (Lt = Tt == null ? void 0 : Tt.current) == null || Lt.unsubscribe()
            }
            , []),
            reactExports.useEffect(()=>{
                xt !== UNINITIALIZED_VALUE && !Tt.current && Ft(xt, !0)
            }
            , [xt, Ft]),
            reactExports.useMemo(()=>[Ft, xt], [Ft, xt])
        }
          , pt = (mt,{skip: yt=!1, selectFromResult: vt}={})=>{
            const {select: wt} = _e.endpoints[ht]
              , _t = useStableQueryArgs(yt ? skipToken : mt, at, ot.endpointDefinitions[ht], ht)
              , Et = reactExports.useRef()
              , xt = reactExports.useMemo(()=>st([wt(_t), (Ft,Lt)=>Lt, Ft=>_t], dt, {
                memoizeOptions: {
                    resultEqualityCheck: shallowEqual
                }
            }), [wt, _t])
              , Ct = reactExports.useMemo(()=>vt ? st([xt], vt, {
                devModeChecks: {
                    identityFunctionCheck: "never"
                }
            }) : xt, [xt, vt])
              , Tt = rt(Ft=>Ct(Ft, Et.current), shallowEqual)
              , It = nt()
              , Nt = xt(It.getState(), Et.current);
            return useIsomorphicLayoutEffect$1(()=>{
                Et.current = Nt
            }
            , [Nt]),
            Tt
        }
        ;
        return {
            useQueryState: pt,
            useQuerySubscription: gt,
            useLazyQuerySubscription: bt,
            useLazyQuery(mt) {
                const [yt,vt] = bt(mt)
                  , wt = pt(vt, {
                    ...mt,
                    skip: vt === UNINITIALIZED_VALUE
                })
                  , _t = reactExports.useMemo(()=>({
                    lastArg: vt
                }), [vt]);
                return reactExports.useMemo(()=>[yt, wt, _t], [yt, wt, _t])
            },
            useQuery(mt, yt) {
                const vt = gt(mt, yt)
                  , wt = pt(mt, {
                    selectFromResult: mt === skipToken || yt != null && yt.skip ? void 0 : noPendingQueryStateSelector,
                    ...yt
                })
                  , {data: _t, status: Et, isLoading: xt, isSuccess: Ct, isError: Tt, error: It} = wt;
                return reactExports.useDebugValue({
                    data: _t,
                    status: Et,
                    isLoading: xt,
                    isSuccess: Ct,
                    isError: Tt,
                    error: It
                }),
                reactExports.useMemo(()=>({
                    ...wt,
                    ...vt
                }), [wt, vt])
            }
        }
    }
    function ft(ht) {
        return ({selectFromResult: gt, fixedCacheKey: bt}={})=>{
            const {select: pt, initiate: mt} = _e.endpoints[ht]
              , yt = tt()
              , [vt,wt] = reactExports.useState();
            reactExports.useEffect(()=>()=>{
                vt != null && vt.arg.fixedCacheKey || vt == null || vt.reset()
            }
            , [vt]);
            const _t = reactExports.useCallback(function(Bt) {
                const zt = yt(mt(Bt, {
                    fixedCacheKey: bt
                }));
                return wt(zt),
                zt
            }, [yt, mt, bt])
              , {requestId: Et} = vt || {}
              , xt = reactExports.useMemo(()=>pt({
                fixedCacheKey: bt,
                requestId: vt == null ? void 0 : vt.requestId
            }), [bt, vt, pt])
              , Ct = reactExports.useMemo(()=>gt ? st([xt], gt) : xt, [gt, xt])
              , Tt = rt(Ct, shallowEqual)
              , It = bt == null ? vt == null ? void 0 : vt.arg.originalArgs : void 0
              , Nt = reactExports.useCallback(()=>{
                et(()=>{
                    vt && wt(void 0),
                    bt && yt(_e.internalActions.removeMutationResult({
                        requestId: Et,
                        fixedCacheKey: bt
                    }))
                }
                )
            }
            , [yt, bt, vt, Et])
              , {endpointName: Ft, data: Lt, status: Mt, isLoading: $t, isSuccess: kt, isError: At, error: Pt} = Tt;
            reactExports.useDebugValue({
                endpointName: Ft,
                data: Lt,
                status: Mt,
                isLoading: $t,
                isSuccess: kt,
                isError: At,
                error: Pt
            });
            const Dt = reactExports.useMemo(()=>({
                ...Tt,
                originalArgs: It,
                reset: Nt
            }), [Tt, It, Nt]);
            return reactExports.useMemo(()=>[_t, Dt], [_t, Dt])
        }
    }
}
var reactHooksModuleName = Symbol()
  , reactHooksModule = ({batch: _e=batch, hooks: et={
    useDispatch,
    useSelector,
    useStore
}, createSelector: tt=createSelector, unstable__sideEffectsInRender: rt=!1, ...nt}={})=>({
    name: reactHooksModuleName,
    init(it, {serializeQueryArgs: st}, at) {
        const ot = it
          , {buildQueryHooks: lt, buildMutationHook: dt, usePrefetch: ct} = buildHooks({
            api: it,
            moduleOptions: {
                batch: _e,
                hooks: et,
                unstable__sideEffectsInRender: rt,
                createSelector: tt
            },
            serializeQueryArgs: st,
            context: at
        });
        return safeAssign(ot, {
            usePrefetch: ct
        }),
        safeAssign(at, {
            batch: _e
        }),
        {
            injectEndpoint(ut, ft) {
                if (isQueryDefinition(ft)) {
                    const {useQuery: ht, useLazyQuery: gt, useLazyQuerySubscription: bt, useQueryState: pt, useQuerySubscription: mt} = lt(ut);
                    safeAssign(ot.endpoints[ut], {
                        useQuery: ht,
                        useLazyQuery: gt,
                        useLazyQuerySubscription: bt,
                        useQueryState: pt,
                        useQuerySubscription: mt
                    }),
                    it[`use${capitalize(ut)}Query`] = ht,
                    it[`useLazy${capitalize(ut)}Query`] = gt
                } else if (isMutationDefinition(ft)) {
                    const ht = dt(ut);
                    safeAssign(ot.endpoints[ut], {
                        useMutation: ht
                    }),
                    it[`use${capitalize(ut)}Mutation`] = ht
                }
            }
        }
    }
})
  , createApi = buildCreateApi(coreModule(), reactHooksModule());
const baseQuery = fetchBaseQuery({
    baseUrl: "https://cloudbtc.io/api"
})
  , apiSlice = createApi({
    baseQuery,
    endpoints: _e=>({
        createReferral: _e.mutation({
            query: et=>({
                url: "/address/create-referral",
                method: "POST",
                body: et
            })
        }),
        updateReferral: _e.mutation({
            query: et=>({
                url: "/address/update-referral",
                method: "PATCH",
                body: et
            })
        }),
        countReferral: _e.query({
            query: et=>({
                url: `/address/count/${et}`,
                method: "GET"
            })
        })
    })
})
  , {useCreateReferralMutation, useCountReferralQuery, useUpdateReferralMutation} = apiSlice;
ReactModal.setAppElement("#root");
const openNav = ()=>{
    document.getElementById("navigationSideBar").style.width = "100%"
}
  , closeNav = ()=>{
    document.getElementById("navigationSideBar").style.width = "0"
}
  , Header = ()=>{
    var ft;
    const {open: _e} = useWeb3Modal()
      , {address: et, isConnected: tt} = useAccount()
      , [rt,nt] = reactExports.useState(!1)
      , {data: it, isLoading: st, refetch: at} = useCountReferralQuery(et, {
        skip: !tt
    })
      , ot = useChainId()
      , {switchChainAsync: lt} = useSwitchChain()
      , dt = useNavigate()
      , ct = ht=>{
        ht.preventDefault(),
        _e()
    }
      , ut = async ht=>{
        ht.preventDefault(),
        ot !== 1 && await lt({
            chainId: 1
        }),
        dt("/staking")
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(ReactModal, {
            isOpen: rt,
            closeTimeoutMS: 500,
            className: "referralModal",
            overlayClassName: "referralModalOverlay",
            onRequestClose: ()=>{
                nt(!1)
            }
            ,
            children: jsxRuntimeExports.jsxs("div", {
                className: "text-center referralWrapperModel",
                children: [jsxRuntimeExports.jsxs("h2", {
                    children: ["Referred Users", " ", jsxRuntimeExports.jsx("span", {
                        children: jsxRuntimeExports.jsx(VscReferences, {})
                    })]
                }), jsxRuntimeExports.jsx("h1", {
                    children: !st && (((ft = it == null ? void 0 : it.data) == null ? void 0 : ft.count) ?? 0)
                })]
            })
        }), jsxRuntimeExports.jsx("header", {
            className: "mainHeader container-fluid mainNav sticky-top top-0",
            children: jsxRuntimeExports.jsx("div", {
                className: "row",
                children: jsxRuntimeExports.jsx("div", {
                    className: "col-11 mx-auto  py-4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "headerContentWrap container-fluid",
                        children: [jsxRuntimeExports.jsx("a", {
                            href: "/",
                            className: "logoWrap",
                            children: jsxRuntimeExports.jsx("img", {
                                src: logo,
                                alt: "logo",
                                title: "Baby Halving"
                            })
                        }), jsxRuntimeExports.jsxs("ul", {
                            id: "navigationSideBar",
                            className: "headerNav",
                            children: [jsxRuntimeExports.jsx("span", {
                                onClick: ()=>closeNav(),
                                className: "navClose text-light",
                                children: "✖"
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx(NavLink, {
                                    to: "/",
                                    children: "Home"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "#benefits",
                                    children: "About"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "#tokenomics",
                                    children: "Tokenomics"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "#presale",
                                    children: "Roadmap"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "#",
                                    onClick: ht=>{
                                        ut(ht)
                                    }
                                    ,
                                    children: "staking"
                                })
                            }), jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    href: "https://cyberscope.io/audits/cbtc",
                                    target: "_blank",
                                    children: "Audit"
                                })
                            }), tt && jsxRuntimeExports.jsx("li", {
                                children: jsxRuntimeExports.jsx("a", {
                                    className: "referralLink",
                                    onClick: ()=>{
                                        at(),
                                        nt(!0)
                                    }
                                    ,
                                    children: "Referrals"
                                })
                            }), jsxRuntimeExports.jsx(Link, {
                                to: "/",
                                onClick: ht=>{
                                    ct(ht)
                                }
                                ,
                                className: "btn signinBtn",
                                children: tt ? "Disconnect" : "Connect Now"
                            }), jsxRuntimeExports.jsx(Link, {
                                to: "how",
                                className: "btn signinBtn ms-xl-2 mt-2 mt-xl-0",
                                children: "How to Buy"
                            })]
                        }), jsxRuntimeExports.jsx("span", {
                            onClick: ()=>openNav(),
                            className: "headerMenuBtn",
                            children: jsxRuntimeExports.jsx("i", {
                                className: "bi bi-list"
                            })
                        })]
                    })
                })
            })
        })]
    })
}
;
var joiBrowser_min = {
    exports: {}
};
(function(_e, et) {
    (function(tt, rt) {
        _e.exports = rt()
    }
    )(self, ()=>{
        return tt = {
            7629: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(9474)
                  , dt = st(1687)
                  , ct = st(8652)
                  , ut = st(8160)
                  , ft = st(3292)
                  , ht = st(6354)
                  , gt = st(8901)
                  , bt = st(9708)
                  , pt = st(6914)
                  , mt = st(2294)
                  , yt = st(6133)
                  , vt = st(1152)
                  , wt = st(8863)
                  , _t = st(2036)
                  , Et = {
                    Base: class {
                        constructor(xt) {
                            this.type = xt,
                            this.$_root = null,
                            this._definition = {},
                            this._reset()
                        }
                        _reset() {
                            this._ids = new mt.Ids,
                            this._preferences = null,
                            this._refs = new yt.Manager,
                            this._cache = null,
                            this._valids = null,
                            this._invalids = null,
                            this._flags = {},
                            this._rules = [],
                            this._singleRules = new Map,
                            this.$_terms = {},
                            this.$_temp = {
                                ruleset: null,
                                whens: {}
                            }
                        }
                        describe() {
                            return at(typeof bt.describe == "function", "Manifest functionality disabled"),
                            bt.describe(this)
                        }
                        allow(...xt) {
                            return ut.verifyFlat(xt, "allow"),
                            this._values(xt, "_valids")
                        }
                        alter(xt) {
                            at(xt && typeof xt == "object" && !Array.isArray(xt), "Invalid targets argument"),
                            at(!this._inRuleset(), "Cannot set alterations inside a ruleset");
                            const Ct = this.clone();
                            Ct.$_terms.alterations = Ct.$_terms.alterations || [];
                            for (const Tt in xt) {
                                const It = xt[Tt];
                                at(typeof It == "function", "Alteration adjuster for", Tt, "must be a function"),
                                Ct.$_terms.alterations.push({
                                    target: Tt,
                                    adjuster: It
                                })
                            }
                            return Ct.$_temp.ruleset = !1,
                            Ct
                        }
                        artifact(xt) {
                            return at(xt !== void 0, "Artifact cannot be undefined"),
                            at(!this._cache, "Cannot set an artifact with a rule cache"),
                            this.$_setFlag("artifact", xt)
                        }
                        cast(xt) {
                            return at(xt === !1 || typeof xt == "string", "Invalid to value"),
                            at(xt === !1 || this._definition.cast[xt], "Type", this.type, "does not support casting to", xt),
                            this.$_setFlag("cast", xt === !1 ? void 0 : xt)
                        }
                        default(xt, Ct) {
                            return this._default("default", xt, Ct)
                        }
                        description(xt) {
                            return at(xt && typeof xt == "string", "Description must be a non-empty string"),
                            this.$_setFlag("description", xt)
                        }
                        empty(xt) {
                            const Ct = this.clone();
                            return xt !== void 0 && (xt = Ct.$_compile(xt, {
                                override: !1
                            })),
                            Ct.$_setFlag("empty", xt, {
                                clone: !1
                            })
                        }
                        error(xt) {
                            return at(xt, "Missing error"),
                            at(xt instanceof Error || typeof xt == "function", "Must provide a valid Error object or a function"),
                            this.$_setFlag("error", xt)
                        }
                        example(xt, Ct={}) {
                            return at(xt !== void 0, "Missing example"),
                            ut.assertOptions(Ct, ["override"]),
                            this._inner("examples", xt, {
                                single: !0,
                                override: Ct.override
                            })
                        }
                        external(xt, Ct) {
                            return typeof xt == "object" && (at(!Ct, "Cannot combine options with description"),
                            Ct = xt.description,
                            xt = xt.method),
                            at(typeof xt == "function", "Method must be a function"),
                            at(Ct === void 0 || Ct && typeof Ct == "string", "Description must be a non-empty string"),
                            this._inner("externals", {
                                method: xt,
                                description: Ct
                            }, {
                                single: !0
                            })
                        }
                        failover(xt, Ct) {
                            return this._default("failover", xt, Ct)
                        }
                        forbidden() {
                            return this.presence("forbidden")
                        }
                        id(xt) {
                            return xt ? (at(typeof xt == "string", "id must be a non-empty string"),
                            at(/^[^\.]+$/.test(xt), "id cannot contain period character"),
                            this.$_setFlag("id", xt)) : this.$_setFlag("id", void 0)
                        }
                        invalid(...xt) {
                            return this._values(xt, "_invalids")
                        }
                        label(xt) {
                            return at(xt && typeof xt == "string", "Label name must be a non-empty string"),
                            this.$_setFlag("label", xt)
                        }
                        meta(xt) {
                            return at(xt !== void 0, "Meta cannot be undefined"),
                            this._inner("metas", xt, {
                                single: !0
                            })
                        }
                        note(...xt) {
                            at(xt.length, "Missing notes");
                            for (const Ct of xt)
                                at(Ct && typeof Ct == "string", "Notes must be non-empty strings");
                            return this._inner("notes", xt)
                        }
                        only(xt=!0) {
                            return at(typeof xt == "boolean", "Invalid mode:", xt),
                            this.$_setFlag("only", xt)
                        }
                        optional() {
                            return this.presence("optional")
                        }
                        prefs(xt) {
                            at(xt, "Missing preferences"),
                            at(xt.context === void 0, "Cannot override context"),
                            at(xt.externals === void 0, "Cannot override externals"),
                            at(xt.warnings === void 0, "Cannot override warnings"),
                            at(xt.debug === void 0, "Cannot override debug"),
                            ut.checkPreferences(xt);
                            const Ct = this.clone();
                            return Ct._preferences = ut.preferences(Ct._preferences, xt),
                            Ct
                        }
                        presence(xt) {
                            return at(["optional", "required", "forbidden"].includes(xt), "Unknown presence mode", xt),
                            this.$_setFlag("presence", xt)
                        }
                        raw(xt=!0) {
                            return this.$_setFlag("result", xt ? "raw" : void 0)
                        }
                        result(xt) {
                            return at(["raw", "strip"].includes(xt), "Unknown result mode", xt),
                            this.$_setFlag("result", xt)
                        }
                        required() {
                            return this.presence("required")
                        }
                        strict(xt) {
                            const Ct = this.clone()
                              , Tt = xt !== void 0 && !xt;
                            return Ct._preferences = ut.preferences(Ct._preferences, {
                                convert: Tt
                            }),
                            Ct
                        }
                        strip(xt=!0) {
                            return this.$_setFlag("result", xt ? "strip" : void 0)
                        }
                        tag(...xt) {
                            at(xt.length, "Missing tags");
                            for (const Ct of xt)
                                at(Ct && typeof Ct == "string", "Tags must be non-empty strings");
                            return this._inner("tags", xt)
                        }
                        unit(xt) {
                            return at(xt && typeof xt == "string", "Unit name must be a non-empty string"),
                            this.$_setFlag("unit", xt)
                        }
                        valid(...xt) {
                            ut.verifyFlat(xt, "valid");
                            const Ct = this.allow(...xt);
                            return Ct.$_setFlag("only", !!Ct._valids, {
                                clone: !1
                            }),
                            Ct
                        }
                        when(xt, Ct) {
                            const Tt = this.clone();
                            Tt.$_terms.whens || (Tt.$_terms.whens = []);
                            const It = ft.when(Tt, xt, Ct);
                            if (!["any", "link"].includes(Tt.type)) {
                                const Nt = It.is ? [It] : It.switch;
                                for (const Ft of Nt)
                                    at(!Ft.then || Ft.then.type === "any" || Ft.then.type === Tt.type, "Cannot combine", Tt.type, "with", Ft.then && Ft.then.type),
                                    at(!Ft.otherwise || Ft.otherwise.type === "any" || Ft.otherwise.type === Tt.type, "Cannot combine", Tt.type, "with", Ft.otherwise && Ft.otherwise.type)
                            }
                            return Tt.$_terms.whens.push(It),
                            Tt.$_mutateRebuild()
                        }
                        cache(xt) {
                            at(!this._inRuleset(), "Cannot set caching inside a ruleset"),
                            at(!this._cache, "Cannot override schema cache"),
                            at(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
                            const Ct = this.clone();
                            return Ct._cache = xt || ct.provider.provision(),
                            Ct.$_temp.ruleset = !1,
                            Ct
                        }
                        clone() {
                            const xt = Object.create(Object.getPrototypeOf(this));
                            return this._assign(xt)
                        }
                        concat(xt) {
                            at(ut.isSchema(xt), "Invalid schema object"),
                            at(this.type === "any" || xt.type === "any" || xt.type === this.type, "Cannot merge type", this.type, "with another type:", xt.type),
                            at(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset"),
                            at(!xt._inRuleset(), "Cannot concatenate a schema with open ruleset");
                            let Ct = this.clone();
                            if (this.type === "any" && xt.type !== "any") {
                                const Tt = xt.clone();
                                for (const It of Object.keys(Ct))
                                    It !== "type" && (Tt[It] = Ct[It]);
                                Ct = Tt
                            }
                            Ct._ids.concat(xt._ids),
                            Ct._refs.register(xt, yt.toSibling),
                            Ct._preferences = Ct._preferences ? ut.preferences(Ct._preferences, xt._preferences) : xt._preferences,
                            Ct._valids = _t.merge(Ct._valids, xt._valids, xt._invalids),
                            Ct._invalids = _t.merge(Ct._invalids, xt._invalids, xt._valids);
                            for (const Tt of xt._singleRules.keys())
                                Ct._singleRules.has(Tt) && (Ct._rules = Ct._rules.filter(It=>It.keep || It.name !== Tt),
                                Ct._singleRules.delete(Tt));
                            for (const Tt of xt._rules)
                                xt._definition.rules[Tt.method].multi || Ct._singleRules.set(Tt.name, Tt),
                                Ct._rules.push(Tt);
                            if (Ct._flags.empty && xt._flags.empty) {
                                Ct._flags.empty = Ct._flags.empty.concat(xt._flags.empty);
                                const Tt = Object.assign({}, xt._flags);
                                delete Tt.empty,
                                dt(Ct._flags, Tt)
                            } else if (xt._flags.empty) {
                                Ct._flags.empty = xt._flags.empty;
                                const Tt = Object.assign({}, xt._flags);
                                delete Tt.empty,
                                dt(Ct._flags, Tt)
                            } else
                                dt(Ct._flags, xt._flags);
                            for (const Tt in xt.$_terms) {
                                const It = xt.$_terms[Tt];
                                It ? Ct.$_terms[Tt] ? Ct.$_terms[Tt] = Ct.$_terms[Tt].concat(It) : Ct.$_terms[Tt] = It.slice() : Ct.$_terms[Tt] || (Ct.$_terms[Tt] = It)
                            }
                            return this.$_root._tracer && this.$_root._tracer._combine(Ct, [this, xt]),
                            Ct.$_mutateRebuild()
                        }
                        extend(xt) {
                            return at(!xt.base, "Cannot extend type with another base"),
                            gt.type(this, xt)
                        }
                        extract(xt) {
                            return xt = Array.isArray(xt) ? xt : xt.split("."),
                            this._ids.reach(xt)
                        }
                        fork(xt, Ct) {
                            at(!this._inRuleset(), "Cannot fork inside a ruleset");
                            let Tt = this;
                            for (let It of [].concat(xt))
                                It = Array.isArray(It) ? It : It.split("."),
                                Tt = Tt._ids.fork(It, Ct, Tt);
                            return Tt.$_temp.ruleset = !1,
                            Tt
                        }
                        rule(xt) {
                            const Ct = this._definition;
                            ut.assertOptions(xt, Object.keys(Ct.modifiers)),
                            at(this.$_temp.ruleset !== !1, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
                            const Tt = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
                            at(Tt >= 0 && Tt < this._rules.length, "Cannot apply rules to empty ruleset");
                            const It = this.clone();
                            for (let Nt = Tt; Nt < It._rules.length; ++Nt) {
                                const Ft = It._rules[Nt]
                                  , Lt = ot(Ft);
                                for (const Mt in xt)
                                    Ct.modifiers[Mt](Lt, xt[Mt]),
                                    at(Lt.name === Ft.name, "Cannot change rule name");
                                It._rules[Nt] = Lt,
                                It._singleRules.get(Lt.name) === Ft && It._singleRules.set(Lt.name, Lt)
                            }
                            return It.$_temp.ruleset = !1,
                            It.$_mutateRebuild()
                        }
                        get ruleset() {
                            at(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
                            const xt = this.clone();
                            return xt.$_temp.ruleset = xt._rules.length,
                            xt
                        }
                        get $() {
                            return this.ruleset
                        }
                        tailor(xt) {
                            xt = [].concat(xt),
                            at(!this._inRuleset(), "Cannot tailor inside a ruleset");
                            let Ct = this;
                            if (this.$_terms.alterations)
                                for (const {target: Tt, adjuster: It} of this.$_terms.alterations)
                                    xt.includes(Tt) && (Ct = It(Ct),
                                    at(ut.isSchema(Ct), "Alteration adjuster for", Tt, "failed to return a schema object"));
                            return Ct = Ct.$_modify({
                                each: Tt=>Tt.tailor(xt),
                                ref: !1
                            }),
                            Ct.$_temp.ruleset = !1,
                            Ct.$_mutateRebuild()
                        }
                        tracer() {
                            return vt.location ? vt.location(this) : this
                        }
                        validate(xt, Ct) {
                            return wt.entry(xt, this, Ct)
                        }
                        validateAsync(xt, Ct) {
                            return wt.entryAsync(xt, this, Ct)
                        }
                        $_addRule(xt) {
                            typeof xt == "string" && (xt = {
                                name: xt
                            }),
                            at(xt && typeof xt == "object", "Invalid options"),
                            at(xt.name && typeof xt.name == "string", "Invalid rule name");
                            for (const Ft in xt)
                                at(Ft[0] !== "_", "Cannot set private rule properties");
                            const Ct = Object.assign({}, xt);
                            Ct._resolve = [],
                            Ct.method = Ct.method || Ct.name;
                            const Tt = this._definition.rules[Ct.method]
                              , It = Ct.args;
                            at(Tt, "Unknown rule", Ct.method);
                            const Nt = this.clone();
                            if (It) {
                                at(Object.keys(It).length === 1 || Object.keys(It).length === this._definition.rules[Ct.name].args.length, "Invalid rule definition for", this.type, Ct.name);
                                for (const Ft in It) {
                                    let Lt = It[Ft];
                                    if (Tt.argsByName) {
                                        const Mt = Tt.argsByName.get(Ft);
                                        if (Mt.ref && ut.isResolvable(Lt))
                                            Ct._resolve.push(Ft),
                                            Nt.$_mutateRegister(Lt);
                                        else if (Mt.normalize && (Lt = Mt.normalize(Lt),
                                        It[Ft] = Lt),
                                        Mt.assert) {
                                            const $t = ut.validateArg(Lt, Ft, Mt);
                                            at(!$t, $t, "or reference")
                                        }
                                    }
                                    Lt !== void 0 ? It[Ft] = Lt : delete It[Ft]
                                }
                            }
                            return Tt.multi || (Nt._ruleRemove(Ct.name, {
                                clone: !1
                            }),
                            Nt._singleRules.set(Ct.name, Ct)),
                            Nt.$_temp.ruleset === !1 && (Nt.$_temp.ruleset = null),
                            Tt.priority ? Nt._rules.unshift(Ct) : Nt._rules.push(Ct),
                            Nt
                        }
                        $_compile(xt, Ct) {
                            return ft.schema(this.$_root, xt, Ct)
                        }
                        $_createError(xt, Ct, Tt, It, Nt, Ft={}) {
                            const Lt = Ft.flags !== !1 ? this._flags : {}
                              , Mt = Ft.messages ? pt.merge(this._definition.messages, Ft.messages) : this._definition.messages;
                            return new ht.Report(xt,Ct,Tt,Lt,Mt,It,Nt)
                        }
                        $_getFlag(xt) {
                            return this._flags[xt]
                        }
                        $_getRule(xt) {
                            return this._singleRules.get(xt)
                        }
                        $_mapLabels(xt) {
                            return xt = Array.isArray(xt) ? xt : xt.split("."),
                            this._ids.labels(xt)
                        }
                        $_match(xt, Ct, Tt, It) {
                            (Tt = Object.assign({}, Tt)).abortEarly = !0,
                            Tt._externals = !1,
                            Ct.snapshot();
                            const Nt = !wt.validate(xt, this, Ct, Tt, It).errors;
                            return Ct.restore(),
                            Nt
                        }
                        $_modify(xt) {
                            return ut.assertOptions(xt, ["each", "once", "ref", "schema"]),
                            mt.schema(this, xt) || this
                        }
                        $_mutateRebuild() {
                            return at(!this._inRuleset(), "Cannot add this rule inside a ruleset"),
                            this._refs.reset(),
                            this._ids.reset(),
                            this.$_modify({
                                each: (xt,{source: Ct, name: Tt, path: It, key: Nt})=>{
                                    const Ft = this._definition[Ct][Tt] && this._definition[Ct][Tt].register;
                                    Ft !== !1 && this.$_mutateRegister(xt, {
                                        family: Ft,
                                        key: Nt
                                    })
                                }
                            }),
                            this._definition.rebuild && this._definition.rebuild(this),
                            this.$_temp.ruleset = !1,
                            this
                        }
                        $_mutateRegister(xt, {family: Ct, key: Tt}={}) {
                            this._refs.register(xt, Ct),
                            this._ids.register(xt, {
                                key: Tt
                            })
                        }
                        $_property(xt) {
                            return this._definition.properties[xt]
                        }
                        $_reach(xt) {
                            return this._ids.reach(xt)
                        }
                        $_rootReferences() {
                            return this._refs.roots()
                        }
                        $_setFlag(xt, Ct, Tt={}) {
                            at(xt[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
                            const It = this._definition.flags[xt] || {};
                            if (lt(Ct, It.default) && (Ct = void 0),
                            lt(Ct, this._flags[xt]))
                                return this;
                            const Nt = Tt.clone !== !1 ? this.clone() : this;
                            return Ct !== void 0 ? (Nt._flags[xt] = Ct,
                            Nt.$_mutateRegister(Ct)) : delete Nt._flags[xt],
                            xt[0] !== "_" && (Nt.$_temp.ruleset = !1),
                            Nt
                        }
                        $_parent(xt, ...Ct) {
                            return this[xt][ut.symbols.parent].call(this, ...Ct)
                        }
                        $_validate(xt, Ct, Tt) {
                            return wt.validate(xt, this, Ct, Tt)
                        }
                        _assign(xt) {
                            xt.type = this.type,
                            xt.$_root = this.$_root,
                            xt.$_temp = Object.assign({}, this.$_temp),
                            xt.$_temp.whens = {},
                            xt._ids = this._ids.clone(),
                            xt._preferences = this._preferences,
                            xt._valids = this._valids && this._valids.clone(),
                            xt._invalids = this._invalids && this._invalids.clone(),
                            xt._rules = this._rules.slice(),
                            xt._singleRules = ot(this._singleRules, {
                                shallow: !0
                            }),
                            xt._refs = this._refs.clone(),
                            xt._flags = Object.assign({}, this._flags),
                            xt._cache = null,
                            xt.$_terms = {};
                            for (const Ct in this.$_terms)
                                xt.$_terms[Ct] = this.$_terms[Ct] ? this.$_terms[Ct].slice() : null;
                            xt.$_super = {};
                            for (const Ct in this.$_super)
                                xt.$_super[Ct] = this._super[Ct].bind(xt);
                            return xt
                        }
                        _bare() {
                            const xt = this.clone();
                            xt._reset();
                            const Ct = xt._definition.terms;
                            for (const Tt in Ct) {
                                const It = Ct[Tt];
                                xt.$_terms[Tt] = It.init
                            }
                            return xt.$_mutateRebuild()
                        }
                        _default(xt, Ct, Tt={}) {
                            return ut.assertOptions(Tt, "literal"),
                            at(Ct !== void 0, "Missing", xt, "value"),
                            at(typeof Ct == "function" || !Tt.literal, "Only function value supports literal option"),
                            typeof Ct == "function" && Tt.literal && (Ct = {
                                [ut.symbols.literal]: !0,
                                literal: Ct
                            }),
                            this.$_setFlag(xt, Ct)
                        }
                        _generate(xt, Ct, Tt) {
                            if (!this.$_terms.whens)
                                return {
                                    schema: this
                                };
                            const It = []
                              , Nt = [];
                            for (let Mt = 0; Mt < this.$_terms.whens.length; ++Mt) {
                                const $t = this.$_terms.whens[Mt];
                                if ($t.concat) {
                                    It.push($t.concat),
                                    Nt.push(`${Mt}.concat`);
                                    continue
                                }
                                const kt = $t.ref ? $t.ref.resolve(xt, Ct, Tt) : xt
                                  , At = $t.is ? [$t] : $t.switch
                                  , Pt = Nt.length;
                                for (let Dt = 0; Dt < At.length; ++Dt) {
                                    const {is: Bt, then: zt, otherwise: Yt} = At[Dt]
                                      , rr = `${Mt}${$t.switch ? "." + Dt : ""}`;
                                    if (Bt.$_match(kt, Ct.nest(Bt, `${rr}.is`), Tt)) {
                                        if (zt) {
                                            const ar = Ct.localize([...Ct.path, `${rr}.then`], Ct.ancestors, Ct.schemas)
                                              , {schema: or, id: pr} = zt._generate(xt, ar, Tt);
                                            It.push(or),
                                            Nt.push(`${rr}.then${pr ? `(${pr})` : ""}`);
                                            break
                                        }
                                    } else if (Yt) {
                                        const ar = Ct.localize([...Ct.path, `${rr}.otherwise`], Ct.ancestors, Ct.schemas)
                                          , {schema: or, id: pr} = Yt._generate(xt, ar, Tt);
                                        It.push(or),
                                        Nt.push(`${rr}.otherwise${pr ? `(${pr})` : ""}`);
                                        break
                                    }
                                }
                                if ($t.break && Nt.length > Pt)
                                    break
                            }
                            const Ft = Nt.join(", ");
                            if (Ct.mainstay.tracer.debug(Ct, "rule", "when", Ft),
                            !Ft)
                                return {
                                    schema: this
                                };
                            if (!Ct.mainstay.tracer.active && this.$_temp.whens[Ft])
                                return {
                                    schema: this.$_temp.whens[Ft],
                                    id: Ft
                                };
                            let Lt = this;
                            this._definition.generate && (Lt = this._definition.generate(this, xt, Ct, Tt));
                            for (const Mt of It)
                                Lt = Lt.concat(Mt);
                            return this.$_root._tracer && this.$_root._tracer._combine(Lt, [this, ...It]),
                            this.$_temp.whens[Ft] = Lt,
                            {
                                schema: Lt,
                                id: Ft
                            }
                        }
                        _inner(xt, Ct, Tt={}) {
                            at(!this._inRuleset(), `Cannot set ${xt} inside a ruleset`);
                            const It = this.clone();
                            return It.$_terms[xt] && !Tt.override || (It.$_terms[xt] = []),
                            Tt.single ? It.$_terms[xt].push(Ct) : It.$_terms[xt].push(...Ct),
                            It.$_temp.ruleset = !1,
                            It
                        }
                        _inRuleset() {
                            return this.$_temp.ruleset !== null && this.$_temp.ruleset !== !1
                        }
                        _ruleRemove(xt, Ct={}) {
                            if (!this._singleRules.has(xt))
                                return this;
                            const Tt = Ct.clone !== !1 ? this.clone() : this;
                            Tt._singleRules.delete(xt);
                            const It = [];
                            for (let Nt = 0; Nt < Tt._rules.length; ++Nt) {
                                const Ft = Tt._rules[Nt];
                                Ft.name !== xt || Ft.keep ? It.push(Ft) : Tt._inRuleset() && Nt < Tt.$_temp.ruleset && --Tt.$_temp.ruleset
                            }
                            return Tt._rules = It,
                            Tt
                        }
                        _values(xt, Ct) {
                            ut.verifyFlat(xt, Ct.slice(1, -1));
                            const Tt = this.clone()
                              , It = xt[0] === ut.symbols.override;
                            if (It && (xt = xt.slice(1)),
                            !Tt[Ct] && xt.length ? Tt[Ct] = new _t : It && (Tt[Ct] = xt.length ? new _t : null,
                            Tt.$_mutateRebuild()),
                            !Tt[Ct])
                                return Tt;
                            It && Tt[Ct].override();
                            for (const Nt of xt) {
                                at(Nt !== void 0, "Cannot call allow/valid/invalid with undefined"),
                                at(Nt !== ut.symbols.override, "Override must be the first value");
                                const Ft = Ct === "_invalids" ? "_valids" : "_invalids";
                                Tt[Ft] && (Tt[Ft].remove(Nt),
                                Tt[Ft].length || (at(Ct === "_valids" || !Tt._flags.only, "Setting invalid value", Nt, "leaves schema rejecting all values due to previous valid rule"),
                                Tt[Ft] = null)),
                                Tt[Ct].add(Nt, Tt._refs)
                            }
                            return Tt
                        }
                    }
                };
                Et.Base.prototype[ut.symbols.any] = {
                    version: ut.version,
                    compile: ft.compile,
                    root: "$_root"
                },
                Et.Base.prototype.isImmutable = !0,
                Et.Base.prototype.deny = Et.Base.prototype.invalid,
                Et.Base.prototype.disallow = Et.Base.prototype.invalid,
                Et.Base.prototype.equal = Et.Base.prototype.valid,
                Et.Base.prototype.exist = Et.Base.prototype.required,
                Et.Base.prototype.not = Et.Base.prototype.invalid,
                Et.Base.prototype.options = Et.Base.prototype.prefs,
                Et.Base.prototype.preferences = Et.Base.prototype.prefs,
                nt.exports = new Et.Base
            }
            ,
            8652: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(8160)
                  , dt = {
                    max: 1e3,
                    supported: new Set(["undefined", "boolean", "number", "string"])
                };
                it.provider = {
                    provision: ct=>new dt.Cache(ct)
                },
                dt.Cache = class {
                    constructor(ct={}) {
                        lt.assertOptions(ct, ["max"]),
                        at(ct.max === void 0 || ct.max && ct.max > 0 && isFinite(ct.max), "Invalid max cache size"),
                        this._max = ct.max || dt.max,
                        this._map = new Map,
                        this._list = new dt.List
                    }
                    get length() {
                        return this._map.size
                    }
                    set(ct, ut) {
                        if (ct !== null && !dt.supported.has(typeof ct))
                            return;
                        let ft = this._map.get(ct);
                        if (ft)
                            return ft.value = ut,
                            void this._list.first(ft);
                        ft = this._list.unshift({
                            key: ct,
                            value: ut
                        }),
                        this._map.set(ct, ft),
                        this._compact()
                    }
                    get(ct) {
                        const ut = this._map.get(ct);
                        if (ut)
                            return this._list.first(ut),
                            ot(ut.value)
                    }
                    _compact() {
                        if (this._map.size > this._max) {
                            const ct = this._list.pop();
                            this._map.delete(ct.key)
                        }
                    }
                }
                ,
                dt.List = class {
                    constructor() {
                        this.tail = null,
                        this.head = null
                    }
                    unshift(ct) {
                        return ct.next = null,
                        ct.prev = this.head,
                        this.head && (this.head.next = ct),
                        this.head = ct,
                        this.tail || (this.tail = ct),
                        ct
                    }
                    first(ct) {
                        ct !== this.head && (this._remove(ct),
                        this.unshift(ct))
                    }
                    pop() {
                        return this._remove(this.tail)
                    }
                    _remove(ct) {
                        const {next: ut, prev: ft} = ct;
                        return ut.prev = ft,
                        ft && (ft.next = ut),
                        ct === this.tail && (this.tail = ut),
                        ct.prev = null,
                        ct.next = null,
                        ct
                    }
                }
            }
            ,
            8160: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(7916)
                  , lt = st(5934);
                let dt, ct;
                const ut = {
                    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
                };
                it.version = lt.version,
                it.defaults = {
                    abortEarly: !0,
                    allowUnknown: !1,
                    artifacts: !1,
                    cache: !0,
                    context: null,
                    convert: !0,
                    dateFormat: "iso",
                    errors: {
                        escapeHtml: !1,
                        label: "path",
                        language: null,
                        render: !0,
                        stack: !1,
                        wrap: {
                            label: '"',
                            array: "[]"
                        }
                    },
                    externals: !0,
                    messages: {},
                    nonEnumerables: !1,
                    noDefaults: !1,
                    presence: "optional",
                    skipFunctions: !1,
                    stripUnknown: !1,
                    warnings: !1
                },
                it.symbols = {
                    any: Symbol.for("@hapi/joi/schema"),
                    arraySingle: Symbol("arraySingle"),
                    deepDefault: Symbol("deepDefault"),
                    errors: Symbol("errors"),
                    literal: Symbol("literal"),
                    override: Symbol("override"),
                    parent: Symbol("parent"),
                    prefs: Symbol("prefs"),
                    ref: Symbol("ref"),
                    template: Symbol("template"),
                    values: Symbol("values")
                },
                it.assertOptions = function(ft, ht, gt="Options") {
                    at(ft && typeof ft == "object" && !Array.isArray(ft), "Options must be of type object");
                    const bt = Object.keys(ft).filter(pt=>!ht.includes(pt));
                    at(bt.length === 0, `${gt} contain unknown keys: ${bt}`)
                }
                ,
                it.checkPreferences = function(ft) {
                    ct = ct || st(3378);
                    const ht = ct.preferences.validate(ft);
                    if (ht.error)
                        throw new ot([ht.error.details[0].message])
                }
                ,
                it.compare = function(ft, ht, gt) {
                    switch (gt) {
                    case "=":
                        return ft === ht;
                    case ">":
                        return ft > ht;
                    case "<":
                        return ft < ht;
                    case ">=":
                        return ft >= ht;
                    case "<=":
                        return ft <= ht
                    }
                }
                ,
                it.default = function(ft, ht) {
                    return ft === void 0 ? ht : ft
                }
                ,
                it.isIsoDate = function(ft) {
                    return ut.isoDate.test(ft)
                }
                ,
                it.isNumber = function(ft) {
                    return typeof ft == "number" && !isNaN(ft)
                }
                ,
                it.isResolvable = function(ft) {
                    return !!ft && (ft[it.symbols.ref] || ft[it.symbols.template])
                }
                ,
                it.isSchema = function(ft, ht={}) {
                    const gt = ft && ft[it.symbols.any];
                    return !!gt && (at(ht.legacy || gt.version === it.version, "Cannot mix different versions of joi schemas"),
                    !0)
                }
                ,
                it.isValues = function(ft) {
                    return ft[it.symbols.values]
                }
                ,
                it.limit = function(ft) {
                    return Number.isSafeInteger(ft) && ft >= 0
                }
                ,
                it.preferences = function(ft, ht) {
                    dt = dt || st(6914),
                    ft = ft || {},
                    ht = ht || {};
                    const gt = Object.assign({}, ft, ht);
                    return ht.errors && ft.errors && (gt.errors = Object.assign({}, ft.errors, ht.errors),
                    gt.errors.wrap = Object.assign({}, ft.errors.wrap, ht.errors.wrap)),
                    ht.messages && (gt.messages = dt.compile(ht.messages, ft.messages)),
                    delete gt[it.symbols.prefs],
                    gt
                }
                ,
                it.tryWithPath = function(ft, ht, gt={}) {
                    try {
                        return ft()
                    } catch (bt) {
                        throw bt.path !== void 0 ? bt.path = ht + "." + bt.path : bt.path = ht,
                        gt.append && (bt.message = `${bt.message} (${bt.path})`),
                        bt
                    }
                }
                ,
                it.validateArg = function(ft, ht, {assert: gt, message: bt}) {
                    if (it.isSchema(gt)) {
                        const pt = gt.validate(ft);
                        return pt.error ? pt.error.message : void 0
                    }
                    if (!gt(ft))
                        return ht ? `${ht} ${bt}` : bt
                }
                ,
                it.verifyFlat = function(ft, ht) {
                    for (const gt of ft)
                        at(!Array.isArray(gt), "Method no longer accepts array arguments:", ht)
                }
            }
            ,
            3292: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8160)
                  , lt = st(6133)
                  , dt = {};
                it.schema = function(ct, ut, ft={}) {
                    ot.assertOptions(ft, ["appendPath", "override"]);
                    try {
                        return dt.schema(ct, ut, ft)
                    } catch (ht) {
                        throw ft.appendPath && ht.path !== void 0 && (ht.message = `${ht.message} (${ht.path})`),
                        ht
                    }
                }
                ,
                dt.schema = function(ct, ut, ft) {
                    at(ut !== void 0, "Invalid undefined schema"),
                    Array.isArray(ut) && (at(ut.length, "Invalid empty array schema"),
                    ut.length === 1 && (ut = ut[0]));
                    const ht = (gt,...bt)=>ft.override !== !1 ? gt.valid(ct.override, ...bt) : gt.valid(...bt);
                    if (dt.simple(ut))
                        return ht(ct, ut);
                    if (typeof ut == "function")
                        return ct.custom(ut);
                    if (at(typeof ut == "object", "Invalid schema content:", typeof ut),
                    ot.isResolvable(ut))
                        return ht(ct, ut);
                    if (ot.isSchema(ut))
                        return ut;
                    if (Array.isArray(ut)) {
                        for (const gt of ut)
                            if (!dt.simple(gt))
                                return ct.alternatives().try(...ut);
                        return ht(ct, ...ut)
                    }
                    return ut instanceof RegExp ? ct.string().regex(ut) : ut instanceof Date ? ht(ct.date(), ut) : (at(Object.getPrototypeOf(ut) === Object.getPrototypeOf({}), "Schema can only contain plain objects"),
                    ct.object().keys(ut))
                }
                ,
                it.ref = function(ct, ut) {
                    return lt.isRef(ct) ? ct : lt.create(ct, ut)
                }
                ,
                it.compile = function(ct, ut, ft={}) {
                    ot.assertOptions(ft, ["legacy"]);
                    const ht = ut && ut[ot.symbols.any];
                    if (ht)
                        return at(ft.legacy || ht.version === ot.version, "Cannot mix different versions of joi schemas:", ht.version, ot.version),
                        ut;
                    if (typeof ut != "object" || !ft.legacy)
                        return it.schema(ct, ut, {
                            appendPath: !0
                        });
                    const gt = dt.walk(ut);
                    return gt ? gt.compile(gt.root, ut) : it.schema(ct, ut, {
                        appendPath: !0
                    })
                }
                ,
                dt.walk = function(ct) {
                    if (typeof ct != "object")
                        return null;
                    if (Array.isArray(ct)) {
                        for (const ft of ct) {
                            const ht = dt.walk(ft);
                            if (ht)
                                return ht
                        }
                        return null
                    }
                    const ut = ct[ot.symbols.any];
                    if (ut)
                        return {
                            root: ct[ut.root],
                            compile: ut.compile
                        };
                    at(Object.getPrototypeOf(ct) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
                    for (const ft in ct) {
                        const ht = dt.walk(ct[ft]);
                        if (ht)
                            return ht
                    }
                    return null
                }
                ,
                dt.simple = function(ct) {
                    return ct === null || ["boolean", "string", "number"].includes(typeof ct)
                }
                ,
                it.when = function(ct, ut, ft) {
                    if (ft === void 0 && (at(ut && typeof ut == "object", "Missing options"),
                    ft = ut,
                    ut = lt.create(".")),
                    Array.isArray(ft) && (ft = {
                        switch: ft
                    }),
                    ot.assertOptions(ft, ["is", "not", "then", "otherwise", "switch", "break"]),
                    ot.isSchema(ut))
                        return at(ft.is === void 0, '"is" can not be used with a schema condition'),
                        at(ft.not === void 0, '"not" can not be used with a schema condition'),
                        at(ft.switch === void 0, '"switch" can not be used with a schema condition'),
                        dt.condition(ct, {
                            is: ut,
                            then: ft.then,
                            otherwise: ft.otherwise,
                            break: ft.break
                        });
                    if (at(lt.isRef(ut) || typeof ut == "string", "Invalid condition:", ut),
                    at(ft.not === void 0 || ft.is === void 0, 'Cannot combine "is" with "not"'),
                    ft.switch === void 0) {
                        let gt = ft;
                        ft.not !== void 0 && (gt = {
                            is: ft.not,
                            then: ft.otherwise,
                            otherwise: ft.then,
                            break: ft.break
                        });
                        let bt = gt.is !== void 0 ? ct.$_compile(gt.is) : ct.$_root.invalid(null, !1, 0, "").required();
                        return at(gt.then !== void 0 || gt.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"'),
                        at(gt.break === void 0 || gt.then === void 0 || gt.otherwise === void 0, "Cannot specify then, otherwise, and break all together"),
                        ft.is === void 0 || lt.isRef(ft.is) || ot.isSchema(ft.is) || (bt = bt.required()),
                        dt.condition(ct, {
                            ref: it.ref(ut),
                            is: bt,
                            then: gt.then,
                            otherwise: gt.otherwise,
                            break: gt.break
                        })
                    }
                    at(Array.isArray(ft.switch), '"switch" must be an array'),
                    at(ft.is === void 0, 'Cannot combine "switch" with "is"'),
                    at(ft.not === void 0, 'Cannot combine "switch" with "not"'),
                    at(ft.then === void 0, 'Cannot combine "switch" with "then"');
                    const ht = {
                        ref: it.ref(ut),
                        switch: [],
                        break: ft.break
                    };
                    for (let gt = 0; gt < ft.switch.length; ++gt) {
                        const bt = ft.switch[gt]
                          , pt = gt === ft.switch.length - 1;
                        ot.assertOptions(bt, pt ? ["is", "then", "otherwise"] : ["is", "then"]),
                        at(bt.is !== void 0, 'Switch statement missing "is"'),
                        at(bt.then !== void 0, 'Switch statement missing "then"');
                        const mt = {
                            is: ct.$_compile(bt.is),
                            then: ct.$_compile(bt.then)
                        };
                        if (lt.isRef(bt.is) || ot.isSchema(bt.is) || (mt.is = mt.is.required()),
                        pt) {
                            at(ft.otherwise === void 0 || bt.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
                            const yt = ft.otherwise !== void 0 ? ft.otherwise : bt.otherwise;
                            yt !== void 0 && (at(ht.break === void 0, "Cannot specify both otherwise and break"),
                            mt.otherwise = ct.$_compile(yt))
                        }
                        ht.switch.push(mt)
                    }
                    return ht
                }
                ,
                dt.condition = function(ct, ut) {
                    for (const ft of ["then", "otherwise"])
                        ut[ft] === void 0 ? delete ut[ft] : ut[ft] = ct.$_compile(ut[ft]);
                    return ut
                }
            }
            ,
            6354: (nt,it,st)=>{
                const at = st(5688)
                  , ot = st(8160)
                  , lt = st(3328);
                it.Report = class {
                    constructor(dt, ct, ut, ft, ht, gt, bt) {
                        if (this.code = dt,
                        this.flags = ft,
                        this.messages = ht,
                        this.path = gt.path,
                        this.prefs = bt,
                        this.state = gt,
                        this.value = ct,
                        this.message = null,
                        this.template = null,
                        this.local = ut || {},
                        this.local.label = it.label(this.flags, this.state, this.prefs, this.messages),
                        this.value === void 0 || this.local.hasOwnProperty("value") || (this.local.value = this.value),
                        this.path.length) {
                            const pt = this.path[this.path.length - 1];
                            typeof pt != "object" && (this.local.key = pt)
                        }
                    }
                    _setTemplate(dt) {
                        if (this.template = dt,
                        !this.flags.label && this.path.length === 0) {
                            const ct = this._template(this.template, "root");
                            ct && (this.local.label = ct)
                        }
                    }
                    toString() {
                        if (this.message)
                            return this.message;
                        const dt = this.code;
                        if (!this.prefs.errors.render)
                            return this.code;
                        const ct = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
                        return ct === void 0 ? `Error code "${dt}" is not defined, your custom type is missing the correct messages definition` : (this.message = ct.render(this.value, this.state, this.prefs, this.local, {
                            errors: this.prefs.errors,
                            messages: [this.prefs.messages, this.messages]
                        }),
                        this.prefs.errors.label || (this.message = this.message.replace(/^"" /, "").trim()),
                        this.message)
                    }
                    _template(dt, ct) {
                        return it.template(this.value, dt, ct || this.code, this.state, this.prefs)
                    }
                }
                ,
                it.path = function(dt) {
                    let ct = "";
                    for (const ut of dt)
                        typeof ut != "object" && (typeof ut == "string" ? (ct && (ct += "."),
                        ct += ut) : ct += `[${ut}]`);
                    return ct
                }
                ,
                it.template = function(dt, ct, ut, ft, ht) {
                    if (!ct)
                        return;
                    if (lt.isTemplate(ct))
                        return ut !== "root" ? ct : null;
                    let gt = ht.errors.language;
                    if (ot.isResolvable(gt) && (gt = gt.resolve(dt, ft, ht)),
                    gt && ct[gt]) {
                        if (ct[gt][ut] !== void 0)
                            return ct[gt][ut];
                        if (ct[gt]["*"] !== void 0)
                            return ct[gt]["*"]
                    }
                    return ct[ut] ? ct[ut] : ct["*"]
                }
                ,
                it.label = function(dt, ct, ut, ft) {
                    if (dt.label)
                        return dt.label;
                    if (!ut.errors.label)
                        return "";
                    let ht = ct.path;
                    return ut.errors.label === "key" && ct.path.length > 1 && (ht = ct.path.slice(-1)),
                    it.path(ht) || it.template(null, ut.messages, "root", ct, ut) || ft && it.template(null, ft, "root", ct, ut) || "value"
                }
                ,
                it.process = function(dt, ct, ut) {
                    if (!dt)
                        return null;
                    const {override: ft, message: ht, details: gt} = it.details(dt);
                    if (ft)
                        return ft;
                    if (ut.errors.stack)
                        return new it.ValidationError(ht,gt,ct);
                    const bt = Error.stackTraceLimit;
                    Error.stackTraceLimit = 0;
                    const pt = new it.ValidationError(ht,gt,ct);
                    return Error.stackTraceLimit = bt,
                    pt
                }
                ,
                it.details = function(dt, ct={}) {
                    let ut = [];
                    const ft = [];
                    for (const ht of dt) {
                        if (ht instanceof Error) {
                            if (ct.override !== !1)
                                return {
                                    override: ht
                                };
                            const bt = ht.toString();
                            ut.push(bt),
                            ft.push({
                                message: bt,
                                type: "override",
                                context: {
                                    error: ht
                                }
                            });
                            continue
                        }
                        const gt = ht.toString();
                        ut.push(gt),
                        ft.push({
                            message: gt,
                            path: ht.path.filter(bt=>typeof bt != "object"),
                            type: ht.code,
                            context: ht.local
                        })
                    }
                    return ut.length > 1 && (ut = [...new Set(ut)]),
                    {
                        message: ut.join(". "),
                        details: ft
                    }
                }
                ,
                it.ValidationError = class extends Error {
                    constructor(dt, ct, ut) {
                        super(dt),
                        this._original = ut,
                        this.details = ct
                    }
                    static isError(dt) {
                        return dt instanceof it.ValidationError
                    }
                }
                ,
                it.ValidationError.prototype.isJoi = !0,
                it.ValidationError.prototype.name = "ValidationError",
                it.ValidationError.prototype.annotate = at.error
            }
            ,
            8901: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(8160)
                  , dt = st(6914)
                  , ct = {};
                it.type = function(ut, ft) {
                    const ht = Object.getPrototypeOf(ut)
                      , gt = ot(ht)
                      , bt = ut._assign(Object.create(gt))
                      , pt = Object.assign({}, ft);
                    delete pt.base,
                    gt._definition = pt;
                    const mt = ht._definition || {};
                    pt.messages = dt.merge(mt.messages, pt.messages),
                    pt.properties = Object.assign({}, mt.properties, pt.properties),
                    bt.type = pt.type,
                    pt.flags = Object.assign({}, mt.flags, pt.flags);
                    const yt = Object.assign({}, mt.terms);
                    if (pt.terms)
                        for (const Et in pt.terms) {
                            const xt = pt.terms[Et];
                            at(bt.$_terms[Et] === void 0, "Invalid term override for", pt.type, Et),
                            bt.$_terms[Et] = xt.init,
                            yt[Et] = xt
                        }
                    pt.terms = yt,
                    pt.args || (pt.args = mt.args),
                    pt.prepare = ct.prepare(pt.prepare, mt.prepare),
                    pt.coerce && (typeof pt.coerce == "function" && (pt.coerce = {
                        method: pt.coerce
                    }),
                    pt.coerce.from && !Array.isArray(pt.coerce.from) && (pt.coerce = {
                        method: pt.coerce.method,
                        from: [].concat(pt.coerce.from)
                    })),
                    pt.coerce = ct.coerce(pt.coerce, mt.coerce),
                    pt.validate = ct.validate(pt.validate, mt.validate);
                    const vt = Object.assign({}, mt.rules);
                    if (pt.rules)
                        for (const Et in pt.rules) {
                            const xt = pt.rules[Et];
                            at(typeof xt == "object", "Invalid rule definition for", pt.type, Et);
                            let Ct = xt.method;
                            if (Ct === void 0 && (Ct = function() {
                                return this.$_addRule(Et)
                            }
                            ),
                            Ct && (at(!gt[Et], "Rule conflict in", pt.type, Et),
                            gt[Et] = Ct),
                            at(!vt[Et], "Rule conflict in", pt.type, Et),
                            vt[Et] = xt,
                            xt.alias) {
                                const Tt = [].concat(xt.alias);
                                for (const It of Tt)
                                    gt[It] = xt.method
                            }
                            xt.args && (xt.argsByName = new Map,
                            xt.args = xt.args.map(Tt=>(typeof Tt == "string" && (Tt = {
                                name: Tt
                            }),
                            at(!xt.argsByName.has(Tt.name), "Duplicated argument name", Tt.name),
                            lt.isSchema(Tt.assert) && (Tt.assert = Tt.assert.strict().label(Tt.name)),
                            xt.argsByName.set(Tt.name, Tt),
                            Tt)))
                        }
                    pt.rules = vt;
                    const wt = Object.assign({}, mt.modifiers);
                    if (pt.modifiers)
                        for (const Et in pt.modifiers) {
                            at(!gt[Et], "Rule conflict in", pt.type, Et);
                            const xt = pt.modifiers[Et];
                            at(typeof xt == "function", "Invalid modifier definition for", pt.type, Et);
                            const Ct = function(Tt) {
                                return this.rule({
                                    [Et]: Tt
                                })
                            };
                            gt[Et] = Ct,
                            wt[Et] = xt
                        }
                    if (pt.modifiers = wt,
                    pt.overrides) {
                        gt._super = ht,
                        bt.$_super = {};
                        for (const Et in pt.overrides)
                            at(ht[Et], "Cannot override missing", Et),
                            pt.overrides[Et][lt.symbols.parent] = ht[Et],
                            bt.$_super[Et] = ht[Et].bind(bt);
                        Object.assign(gt, pt.overrides)
                    }
                    pt.cast = Object.assign({}, mt.cast, pt.cast);
                    const _t = Object.assign({}, mt.manifest, pt.manifest);
                    return _t.build = ct.build(pt.manifest && pt.manifest.build, mt.manifest && mt.manifest.build),
                    pt.manifest = _t,
                    pt.rebuild = ct.rebuild(pt.rebuild, mt.rebuild),
                    bt
                }
                ,
                ct.build = function(ut, ft) {
                    return ut && ft ? function(ht, gt) {
                        return ft(ut(ht, gt), gt)
                    }
                    : ut || ft
                }
                ,
                ct.coerce = function(ut, ft) {
                    return ut && ft ? {
                        from: ut.from && ft.from ? [...new Set([...ut.from, ...ft.from])] : null,
                        method(ht, gt) {
                            let bt;
                            if ((!ft.from || ft.from.includes(typeof ht)) && (bt = ft.method(ht, gt),
                            bt)) {
                                if (bt.errors || bt.value === void 0)
                                    return bt;
                                ht = bt.value
                            }
                            if (!ut.from || ut.from.includes(typeof ht)) {
                                const pt = ut.method(ht, gt);
                                if (pt)
                                    return pt
                            }
                            return bt
                        }
                    } : ut || ft
                }
                ,
                ct.prepare = function(ut, ft) {
                    return ut && ft ? function(ht, gt) {
                        const bt = ut(ht, gt);
                        if (bt) {
                            if (bt.errors || bt.value === void 0)
                                return bt;
                            ht = bt.value
                        }
                        return ft(ht, gt) || bt
                    }
                    : ut || ft
                }
                ,
                ct.rebuild = function(ut, ft) {
                    return ut && ft ? function(ht) {
                        ft(ht),
                        ut(ht)
                    }
                    : ut || ft
                }
                ,
                ct.validate = function(ut, ft) {
                    return ut && ft ? function(ht, gt) {
                        const bt = ft(ht, gt);
                        if (bt) {
                            if (bt.errors && (!Array.isArray(bt.errors) || bt.errors.length))
                                return bt;
                            ht = bt.value
                        }
                        return ut(ht, gt) || bt
                    }
                    : ut || ft
                }
            }
            ,
            5107: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(8652)
                  , dt = st(8160)
                  , ct = st(3292)
                  , ut = st(6354)
                  , ft = st(8901)
                  , ht = st(9708)
                  , gt = st(6133)
                  , bt = st(3328)
                  , pt = st(1152);
                let mt;
                const yt = {
                    types: {
                        alternatives: st(4946),
                        any: st(8068),
                        array: st(546),
                        boolean: st(4937),
                        date: st(7500),
                        function: st(390),
                        link: st(8785),
                        number: st(3832),
                        object: st(8966),
                        string: st(7417),
                        symbol: st(8826)
                    },
                    aliases: {
                        alt: "alternatives",
                        bool: "boolean",
                        func: "function"
                    },
                    root: function() {
                        const vt = {
                            _types: new Set(Object.keys(yt.types))
                        };
                        for (const wt of vt._types)
                            vt[wt] = function(..._t) {
                                return at(!_t.length || ["alternatives", "link", "object"].includes(wt), "The", wt, "type does not allow arguments"),
                                yt.generate(this, yt.types[wt], _t)
                            }
                            ;
                        for (const wt of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"])
                            vt[wt] = function(..._t) {
                                return this.any()[wt](..._t)
                            }
                            ;
                        Object.assign(vt, yt.methods);
                        for (const wt in yt.aliases) {
                            const _t = yt.aliases[wt];
                            vt[wt] = vt[_t]
                        }
                        return vt.x = vt.expression,
                        pt.setup && pt.setup(vt),
                        vt
                    }
                };
                yt.methods = {
                    ValidationError: ut.ValidationError,
                    version: dt.version,
                    cache: lt.provider,
                    assert(vt, wt, ..._t) {
                        yt.assert(vt, wt, !0, _t)
                    },
                    attempt: (vt,wt,..._t)=>yt.assert(vt, wt, !1, _t),
                    build(vt) {
                        return at(typeof ht.build == "function", "Manifest functionality disabled"),
                        ht.build(this, vt)
                    },
                    checkPreferences(vt) {
                        dt.checkPreferences(vt)
                    },
                    compile(vt, wt) {
                        return ct.compile(this, vt, wt)
                    },
                    defaults(vt) {
                        at(typeof vt == "function", "modifier must be a function");
                        const wt = Object.assign({}, this);
                        for (const _t of wt._types) {
                            const Et = vt(wt[_t]());
                            at(dt.isSchema(Et), "modifier must return a valid schema object"),
                            wt[_t] = function(...xt) {
                                return yt.generate(this, Et, xt)
                            }
                        }
                        return wt
                    },
                    expression: (...vt)=>new bt(...vt),
                    extend(...vt) {
                        dt.verifyFlat(vt, "extend"),
                        mt = mt || st(3378),
                        at(vt.length, "You need to provide at least one extension"),
                        this.assert(vt, mt.extensions);
                        const wt = Object.assign({}, this);
                        wt._types = new Set(wt._types);
                        for (let _t of vt) {
                            typeof _t == "function" && (_t = _t(wt)),
                            this.assert(_t, mt.extension);
                            const Et = yt.expandExtension(_t, wt);
                            for (const xt of Et) {
                                at(wt[xt.type] === void 0 || wt._types.has(xt.type), "Cannot override name", xt.type);
                                const Ct = xt.base || this.any()
                                  , Tt = ft.type(Ct, xt);
                                wt._types.add(xt.type),
                                wt[xt.type] = function(...It) {
                                    return yt.generate(this, Tt, It)
                                }
                            }
                        }
                        return wt
                    },
                    isError: ut.ValidationError.isError,
                    isExpression: bt.isTemplate,
                    isRef: gt.isRef,
                    isSchema: dt.isSchema,
                    in: (...vt)=>gt.in(...vt),
                    override: dt.symbols.override,
                    ref: (...vt)=>gt.create(...vt),
                    types() {
                        const vt = {};
                        for (const wt of this._types)
                            vt[wt] = this[wt]();
                        for (const wt in yt.aliases)
                            vt[wt] = this[wt]();
                        return vt
                    }
                },
                yt.assert = function(vt, wt, _t, Et) {
                    const xt = Et[0]instanceof Error || typeof Et[0] == "string" ? Et[0] : null
                      , Ct = xt !== null ? Et[1] : Et[0]
                      , Tt = wt.validate(vt, dt.preferences({
                        errors: {
                            stack: !0
                        }
                    }, Ct || {}));
                    let It = Tt.error;
                    if (!It)
                        return Tt.value;
                    if (xt instanceof Error)
                        throw xt;
                    const Nt = _t && typeof It.annotate == "function" ? It.annotate() : It.message;
                    throw It instanceof ut.ValidationError == 0 && (It = ot(It)),
                    It.message = xt ? `${xt} ${Nt}` : Nt,
                    It
                }
                ,
                yt.generate = function(vt, wt, _t) {
                    return at(vt, "Must be invoked on a Joi instance."),
                    wt.$_root = vt,
                    wt._definition.args && _t.length ? wt._definition.args(wt, ..._t) : wt
                }
                ,
                yt.expandExtension = function(vt, wt) {
                    if (typeof vt.type == "string")
                        return [vt];
                    const _t = [];
                    for (const Et of wt._types)
                        if (vt.type.test(Et)) {
                            const xt = Object.assign({}, vt);
                            xt.type = Et,
                            xt.base = wt[Et](),
                            _t.push(xt)
                        }
                    return _t
                }
                ,
                nt.exports = yt.root()
            }
            ,
            6914: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(3328);
                it.compile = function(dt, ct) {
                    if (typeof dt == "string")
                        return at(!ct, "Cannot set single message string"),
                        new lt(dt);
                    if (lt.isTemplate(dt))
                        return at(!ct, "Cannot set single message template"),
                        dt;
                    at(typeof dt == "object" && !Array.isArray(dt), "Invalid message options"),
                    ct = ct ? ot(ct) : {};
                    for (let ut in dt) {
                        const ft = dt[ut];
                        if (ut === "root" || lt.isTemplate(ft)) {
                            ct[ut] = ft;
                            continue
                        }
                        if (typeof ft == "string") {
                            ct[ut] = new lt(ft);
                            continue
                        }
                        at(typeof ft == "object" && !Array.isArray(ft), "Invalid message for", ut);
                        const ht = ut;
                        for (ut in ct[ht] = ct[ht] || {},
                        ft) {
                            const gt = ft[ut];
                            ut === "root" || lt.isTemplate(gt) ? ct[ht][ut] = gt : (at(typeof gt == "string", "Invalid message for", ut, "in", ht),
                            ct[ht][ut] = new lt(gt))
                        }
                    }
                    return ct
                }
                ,
                it.decompile = function(dt) {
                    const ct = {};
                    for (let ut in dt) {
                        const ft = dt[ut];
                        if (ut === "root") {
                            ct.root = ft;
                            continue
                        }
                        if (lt.isTemplate(ft)) {
                            ct[ut] = ft.describe({
                                compact: !0
                            });
                            continue
                        }
                        const ht = ut;
                        for (ut in ct[ht] = {},
                        ft) {
                            const gt = ft[ut];
                            ut !== "root" ? ct[ht][ut] = gt.describe({
                                compact: !0
                            }) : ct[ht].root = gt
                        }
                    }
                    return ct
                }
                ,
                it.merge = function(dt, ct) {
                    if (!dt)
                        return it.compile(ct);
                    if (!ct)
                        return dt;
                    if (typeof ct == "string")
                        return new lt(ct);
                    if (lt.isTemplate(ct))
                        return ct;
                    const ut = ot(dt);
                    for (let ft in ct) {
                        const ht = ct[ft];
                        if (ft === "root" || lt.isTemplate(ht)) {
                            ut[ft] = ht;
                            continue
                        }
                        if (typeof ht == "string") {
                            ut[ft] = new lt(ht);
                            continue
                        }
                        at(typeof ht == "object" && !Array.isArray(ht), "Invalid message for", ft);
                        const gt = ft;
                        for (ft in ut[gt] = ut[gt] || {},
                        ht) {
                            const bt = ht[ft];
                            ft === "root" || lt.isTemplate(bt) ? ut[gt][ft] = bt : (at(typeof bt == "string", "Invalid message for", ft, "in", gt),
                            ut[gt][ft] = new lt(bt))
                        }
                    }
                    return ut
                }
            }
            ,
            2294: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8160)
                  , lt = st(6133)
                  , dt = {};
                it.Ids = dt.Ids = class {
                    constructor() {
                        this._byId = new Map,
                        this._byKey = new Map,
                        this._schemaChain = !1
                    }
                    clone() {
                        const ct = new dt.Ids;
                        return ct._byId = new Map(this._byId),
                        ct._byKey = new Map(this._byKey),
                        ct._schemaChain = this._schemaChain,
                        ct
                    }
                    concat(ct) {
                        ct._schemaChain && (this._schemaChain = !0);
                        for (const [ut,ft] of ct._byId.entries())
                            at(!this._byKey.has(ut), "Schema id conflicts with existing key:", ut),
                            this._byId.set(ut, ft);
                        for (const [ut,ft] of ct._byKey.entries())
                            at(!this._byId.has(ut), "Schema key conflicts with existing id:", ut),
                            this._byKey.set(ut, ft)
                    }
                    fork(ct, ut, ft) {
                        const ht = this._collect(ct);
                        ht.push({
                            schema: ft
                        });
                        const gt = ht.shift();
                        let bt = {
                            id: gt.id,
                            schema: ut(gt.schema)
                        };
                        at(ot.isSchema(bt.schema), "adjuster function failed to return a joi schema type");
                        for (const pt of ht)
                            bt = {
                                id: pt.id,
                                schema: dt.fork(pt.schema, bt.id, bt.schema)
                            };
                        return bt.schema
                    }
                    labels(ct, ut=[]) {
                        const ft = ct[0]
                          , ht = this._get(ft);
                        if (!ht)
                            return [...ut, ...ct].join(".");
                        const gt = ct.slice(1);
                        return ut = [...ut, ht.schema._flags.label || ft],
                        gt.length ? ht.schema._ids.labels(gt, ut) : ut.join(".")
                    }
                    reach(ct, ut=[]) {
                        const ft = ct[0]
                          , ht = this._get(ft);
                        at(ht, "Schema does not contain path", [...ut, ...ct].join("."));
                        const gt = ct.slice(1);
                        return gt.length ? ht.schema._ids.reach(gt, [...ut, ft]) : ht.schema
                    }
                    register(ct, {key: ut}={}) {
                        if (!ct || !ot.isSchema(ct))
                            return;
                        (ct.$_property("schemaChain") || ct._ids._schemaChain) && (this._schemaChain = !0);
                        const ft = ct._flags.id;
                        if (ft) {
                            const ht = this._byId.get(ft);
                            at(!ht || ht.schema === ct, "Cannot add different schemas with the same id:", ft),
                            at(!this._byKey.has(ft), "Schema id conflicts with existing key:", ft),
                            this._byId.set(ft, {
                                schema: ct,
                                id: ft
                            })
                        }
                        ut && (at(!this._byKey.has(ut), "Schema already contains key:", ut),
                        at(!this._byId.has(ut), "Schema key conflicts with existing id:", ut),
                        this._byKey.set(ut, {
                            schema: ct,
                            id: ut
                        }))
                    }
                    reset() {
                        this._byId = new Map,
                        this._byKey = new Map,
                        this._schemaChain = !1
                    }
                    _collect(ct, ut=[], ft=[]) {
                        const ht = ct[0]
                          , gt = this._get(ht);
                        at(gt, "Schema does not contain path", [...ut, ...ct].join(".")),
                        ft = [gt, ...ft];
                        const bt = ct.slice(1);
                        return bt.length ? gt.schema._ids._collect(bt, [...ut, ht], ft) : ft
                    }
                    _get(ct) {
                        return this._byId.get(ct) || this._byKey.get(ct)
                    }
                }
                ,
                dt.fork = function(ct, ut, ft) {
                    const ht = it.schema(ct, {
                        each: (gt,{key: bt})=>{
                            if (ut === (gt._flags.id || bt))
                                return ft
                        }
                        ,
                        ref: !1
                    });
                    return ht ? ht.$_mutateRebuild() : ct
                }
                ,
                it.schema = function(ct, ut) {
                    let ft;
                    for (const ht in ct._flags) {
                        if (ht[0] === "_")
                            continue;
                        const gt = dt.scan(ct._flags[ht], {
                            source: "flags",
                            name: ht
                        }, ut);
                        gt !== void 0 && (ft = ft || ct.clone(),
                        ft._flags[ht] = gt)
                    }
                    for (let ht = 0; ht < ct._rules.length; ++ht) {
                        const gt = ct._rules[ht]
                          , bt = dt.scan(gt.args, {
                            source: "rules",
                            name: gt.name
                        }, ut);
                        if (bt !== void 0) {
                            ft = ft || ct.clone();
                            const pt = Object.assign({}, gt);
                            pt.args = bt,
                            ft._rules[ht] = pt,
                            ft._singleRules.get(gt.name) === gt && ft._singleRules.set(gt.name, pt)
                        }
                    }
                    for (const ht in ct.$_terms) {
                        if (ht[0] === "_")
                            continue;
                        const gt = dt.scan(ct.$_terms[ht], {
                            source: "terms",
                            name: ht
                        }, ut);
                        gt !== void 0 && (ft = ft || ct.clone(),
                        ft.$_terms[ht] = gt)
                    }
                    return ft
                }
                ,
                dt.scan = function(ct, ut, ft, ht, gt) {
                    const bt = ht || [];
                    if (ct === null || typeof ct != "object")
                        return;
                    let pt;
                    if (Array.isArray(ct)) {
                        for (let mt = 0; mt < ct.length; ++mt) {
                            const yt = ut.source === "terms" && ut.name === "keys" && ct[mt].key
                              , vt = dt.scan(ct[mt], ut, ft, [mt, ...bt], yt);
                            vt !== void 0 && (pt = pt || ct.slice(),
                            pt[mt] = vt)
                        }
                        return pt
                    }
                    if (ft.schema !== !1 && ot.isSchema(ct) || ft.ref !== !1 && lt.isRef(ct)) {
                        const mt = ft.each(ct, {
                            ...ut,
                            path: bt,
                            key: gt
                        });
                        return mt === ct ? void 0 : mt
                    }
                    for (const mt in ct) {
                        if (mt[0] === "_")
                            continue;
                        const yt = dt.scan(ct[mt], ut, ft, [mt, ...bt], gt);
                        yt !== void 0 && (pt = pt || Object.assign({}, ct),
                        pt[mt] = yt)
                    }
                    return pt
                }
            }
            ,
            6133: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(9621)
                  , dt = st(8160);
                let ct;
                const ut = {
                    symbol: Symbol("ref"),
                    defaults: {
                        adjust: null,
                        in: !1,
                        iterables: null,
                        map: null,
                        separator: ".",
                        type: "value"
                    }
                };
                it.create = function(ft, ht={}) {
                    at(typeof ft == "string", "Invalid reference key:", ft),
                    dt.assertOptions(ht, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]),
                    at(!ht.prefix || typeof ht.prefix == "object", "options.prefix must be of type object");
                    const gt = Object.assign({}, ut.defaults, ht);
                    delete gt.prefix;
                    const bt = gt.separator
                      , pt = ut.context(ft, bt, ht.prefix);
                    if (gt.type = pt.type,
                    ft = pt.key,
                    gt.type === "value")
                        if (pt.root && (at(!bt || ft[0] !== bt, "Cannot specify relative path with root prefix"),
                        gt.ancestor = "root",
                        ft || (ft = null)),
                        bt && bt === ft)
                            ft = null,
                            gt.ancestor = 0;
                        else if (gt.ancestor !== void 0)
                            at(!bt || !ft || ft[0] !== bt, "Cannot combine prefix with ancestor option");
                        else {
                            const [mt,yt] = ut.ancestor(ft, bt);
                            yt && (ft = ft.slice(yt)) === "" && (ft = null),
                            gt.ancestor = mt
                        }
                    return gt.path = bt ? ft === null ? [] : ft.split(bt) : [ft],
                    new ut.Ref(gt)
                }
                ,
                it.in = function(ft, ht={}) {
                    return it.create(ft, {
                        ...ht,
                        in: !0
                    })
                }
                ,
                it.isRef = function(ft) {
                    return !!ft && !!ft[dt.symbols.ref]
                }
                ,
                ut.Ref = class {
                    constructor(ft) {
                        at(typeof ft == "object", "Invalid reference construction"),
                        dt.assertOptions(ft, ["adjust", "ancestor", "in", "iterables", "map", "path", "render", "separator", "type", "depth", "key", "root", "display"]),
                        at([!1, void 0].includes(ft.separator) || typeof ft.separator == "string" && ft.separator.length === 1, "Invalid separator"),
                        at(!ft.adjust || typeof ft.adjust == "function", "options.adjust must be a function"),
                        at(!ft.map || Array.isArray(ft.map), "options.map must be an array"),
                        at(!ft.map || !ft.adjust, "Cannot set both map and adjust options"),
                        Object.assign(this, ut.defaults, ft),
                        at(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors"),
                        Array.isArray(this.map) && (this.map = new Map(this.map)),
                        this.depth = this.path.length,
                        this.key = this.path.length ? this.path.join(this.separator) : null,
                        this.root = this.path[0],
                        this.updateDisplay()
                    }
                    resolve(ft, ht, gt, bt, pt={}) {
                        return at(!this.in || pt.in, "Invalid in() reference usage"),
                        this.type === "global" ? this._resolve(gt.context, ht, pt) : this.type === "local" ? this._resolve(bt, ht, pt) : this.ancestor ? this.ancestor === "root" ? this._resolve(ht.ancestors[ht.ancestors.length - 1], ht, pt) : (at(this.ancestor <= ht.ancestors.length, "Invalid reference exceeds the schema root:", this.display),
                        this._resolve(ht.ancestors[this.ancestor - 1], ht, pt)) : this._resolve(ft, ht, pt)
                    }
                    _resolve(ft, ht, gt) {
                        let bt;
                        if (this.type === "value" && ht.mainstay.shadow && gt.shadow !== !1 && (bt = ht.mainstay.shadow.get(this.absolute(ht))),
                        bt === void 0 && (bt = lt(ft, this.path, {
                            iterables: this.iterables,
                            functions: !0
                        })),
                        this.adjust && (bt = this.adjust(bt)),
                        this.map) {
                            const pt = this.map.get(bt);
                            pt !== void 0 && (bt = pt)
                        }
                        return ht.mainstay && ht.mainstay.tracer.resolve(ht, this, bt),
                        bt
                    }
                    toString() {
                        return this.display
                    }
                    absolute(ft) {
                        return [...ft.path.slice(0, -this.ancestor), ...this.path]
                    }
                    clone() {
                        return new ut.Ref(this)
                    }
                    describe() {
                        const ft = {
                            path: this.path
                        };
                        this.type !== "value" && (ft.type = this.type),
                        this.separator !== "." && (ft.separator = this.separator),
                        this.type === "value" && this.ancestor !== 1 && (ft.ancestor = this.ancestor),
                        this.map && (ft.map = [...this.map]);
                        for (const ht of ["adjust", "iterables", "render"])
                            this[ht] !== null && this[ht] !== void 0 && (ft[ht] = this[ht]);
                        return this.in !== !1 && (ft.in = !0),
                        {
                            ref: ft
                        }
                    }
                    updateDisplay() {
                        const ft = this.key !== null ? this.key : "";
                        if (this.type !== "value")
                            return void (this.display = `ref:${this.type}:${ft}`);
                        if (!this.separator)
                            return void (this.display = `ref:${ft}`);
                        if (!this.ancestor)
                            return void (this.display = `ref:${this.separator}${ft}`);
                        if (this.ancestor === "root")
                            return void (this.display = `ref:root:${ft}`);
                        if (this.ancestor === 1)
                            return void (this.display = `ref:${ft || ".."}`);
                        const ht = new Array(this.ancestor + 1).fill(this.separator).join("");
                        this.display = `ref:${ht}${ft || ""}`
                    }
                }
                ,
                ut.Ref.prototype[dt.symbols.ref] = !0,
                it.build = function(ft) {
                    return (ft = Object.assign({}, ut.defaults, ft)).type === "value" && ft.ancestor === void 0 && (ft.ancestor = 1),
                    new ut.Ref(ft)
                }
                ,
                ut.context = function(ft, ht, gt={}) {
                    if (ft = ft.trim(),
                    gt) {
                        const bt = gt.global === void 0 ? "$" : gt.global;
                        if (bt !== ht && ft.startsWith(bt))
                            return {
                                key: ft.slice(bt.length),
                                type: "global"
                            };
                        const pt = gt.local === void 0 ? "#" : gt.local;
                        if (pt !== ht && ft.startsWith(pt))
                            return {
                                key: ft.slice(pt.length),
                                type: "local"
                            };
                        const mt = gt.root === void 0 ? "/" : gt.root;
                        if (mt !== ht && ft.startsWith(mt))
                            return {
                                key: ft.slice(mt.length),
                                type: "value",
                                root: !0
                            }
                    }
                    return {
                        key: ft,
                        type: "value"
                    }
                }
                ,
                ut.ancestor = function(ft, ht) {
                    if (!ht)
                        return [1, 0];
                    if (ft[0] !== ht)
                        return [1, 0];
                    if (ft[1] !== ht)
                        return [0, 1];
                    let gt = 2;
                    for (; ft[gt] === ht; )
                        ++gt;
                    return [gt - 1, gt]
                }
                ,
                it.toSibling = 0,
                it.toParent = 1,
                it.Manager = class {
                    constructor() {
                        this.refs = []
                    }
                    register(ft, ht) {
                        if (ft)
                            if (ht = ht === void 0 ? it.toParent : ht,
                            Array.isArray(ft))
                                for (const gt of ft)
                                    this.register(gt, ht);
                            else if (dt.isSchema(ft))
                                for (const gt of ft._refs.refs)
                                    gt.ancestor - ht >= 0 && this.refs.push({
                                        ancestor: gt.ancestor - ht,
                                        root: gt.root
                                    });
                            else
                                it.isRef(ft) && ft.type === "value" && ft.ancestor - ht >= 0 && this.refs.push({
                                    ancestor: ft.ancestor - ht,
                                    root: ft.root
                                }),
                                ct = ct || st(3328),
                                ct.isTemplate(ft) && this.register(ft.refs(), ht)
                    }
                    get length() {
                        return this.refs.length
                    }
                    clone() {
                        const ft = new it.Manager;
                        return ft.refs = ot(this.refs),
                        ft
                    }
                    reset() {
                        this.refs = []
                    }
                    roots() {
                        return this.refs.filter(ft=>!ft.ancestor).map(ft=>ft.root)
                    }
                }
            }
            ,
            3378: (nt,it,st)=>{
                const at = st(5107)
                  , ot = {};
                ot.wrap = at.string().min(1).max(2).allow(!1),
                it.preferences = at.object({
                    allowUnknown: at.boolean(),
                    abortEarly: at.boolean(),
                    artifacts: at.boolean(),
                    cache: at.boolean(),
                    context: at.object(),
                    convert: at.boolean(),
                    dateFormat: at.valid("date", "iso", "string", "time", "utc"),
                    debug: at.boolean(),
                    errors: {
                        escapeHtml: at.boolean(),
                        label: at.valid("path", "key", !1),
                        language: [at.string(), at.object().ref()],
                        render: at.boolean(),
                        stack: at.boolean(),
                        wrap: {
                            label: ot.wrap,
                            array: ot.wrap,
                            string: ot.wrap
                        }
                    },
                    externals: at.boolean(),
                    messages: at.object(),
                    noDefaults: at.boolean(),
                    nonEnumerables: at.boolean(),
                    presence: at.valid("required", "optional", "forbidden"),
                    skipFunctions: at.boolean(),
                    stripUnknown: at.object({
                        arrays: at.boolean(),
                        objects: at.boolean()
                    }).or("arrays", "objects").allow(!0, !1),
                    warnings: at.boolean()
                }).strict(),
                ot.nameRx = /^[a-zA-Z0-9]\w*$/,
                ot.rule = at.object({
                    alias: at.array().items(at.string().pattern(ot.nameRx)).single(),
                    args: at.array().items(at.string(), at.object({
                        name: at.string().pattern(ot.nameRx).required(),
                        ref: at.boolean(),
                        assert: at.alternatives([at.function(), at.object().schema()]).conditional("ref", {
                            is: !0,
                            then: at.required()
                        }),
                        normalize: at.function(),
                        message: at.string().when("assert", {
                            is: at.function(),
                            then: at.required()
                        })
                    })),
                    convert: at.boolean(),
                    manifest: at.boolean(),
                    method: at.function().allow(!1),
                    multi: at.boolean(),
                    validate: at.function()
                }),
                it.extension = at.object({
                    type: at.alternatives([at.string(), at.object().regex()]).required(),
                    args: at.function(),
                    cast: at.object().pattern(ot.nameRx, at.object({
                        from: at.function().maxArity(1).required(),
                        to: at.function().minArity(1).maxArity(2).required()
                    })),
                    base: at.object().schema().when("type", {
                        is: at.object().regex(),
                        then: at.forbidden()
                    }),
                    coerce: [at.function().maxArity(3), at.object({
                        method: at.function().maxArity(3).required(),
                        from: at.array().items(at.string()).single()
                    })],
                    flags: at.object().pattern(ot.nameRx, at.object({
                        setter: at.string(),
                        default: at.any()
                    })),
                    manifest: {
                        build: at.function().arity(2)
                    },
                    messages: [at.object(), at.string()],
                    modifiers: at.object().pattern(ot.nameRx, at.function().minArity(1).maxArity(2)),
                    overrides: at.object().pattern(ot.nameRx, at.function()),
                    prepare: at.function().maxArity(3),
                    rebuild: at.function().arity(1),
                    rules: at.object().pattern(ot.nameRx, ot.rule),
                    terms: at.object().pattern(ot.nameRx, at.object({
                        init: at.array().allow(null).required(),
                        manifest: at.object().pattern(/.+/, [at.valid("schema", "single"), at.object({
                            mapped: at.object({
                                from: at.string().required(),
                                to: at.string().required()
                            }).required()
                        })])
                    })),
                    validate: at.function().maxArity(3)
                }).strict(),
                it.extensions = at.array().items(at.object(), at.function().arity(1)).strict(),
                ot.desc = {
                    buffer: at.object({
                        buffer: at.string()
                    }),
                    func: at.object({
                        function: at.function().required(),
                        options: {
                            literal: !0
                        }
                    }),
                    override: at.object({
                        override: !0
                    }),
                    ref: at.object({
                        ref: at.object({
                            type: at.valid("value", "global", "local"),
                            path: at.array().required(),
                            separator: at.string().length(1).allow(!1),
                            ancestor: at.number().min(0).integer().allow("root"),
                            map: at.array().items(at.array().length(2)).min(1),
                            adjust: at.function(),
                            iterables: at.boolean(),
                            in: at.boolean(),
                            render: at.boolean()
                        }).required()
                    }),
                    regex: at.object({
                        regex: at.string().min(3)
                    }),
                    special: at.object({
                        special: at.valid("deep").required()
                    }),
                    template: at.object({
                        template: at.string().required(),
                        options: at.object()
                    }),
                    value: at.object({
                        value: at.alternatives([at.object(), at.array()]).required()
                    })
                },
                ot.desc.entity = at.alternatives([at.array().items(at.link("...")), at.boolean(), at.function(), at.number(), at.string(), ot.desc.buffer, ot.desc.func, ot.desc.ref, ot.desc.regex, ot.desc.special, ot.desc.template, ot.desc.value, at.link("/")]),
                ot.desc.values = at.array().items(null, at.boolean(), at.function(), at.number().allow(1 / 0, -1 / 0), at.string().allow(""), at.symbol(), ot.desc.buffer, ot.desc.func, ot.desc.override, ot.desc.ref, ot.desc.regex, ot.desc.template, ot.desc.value),
                ot.desc.messages = at.object().pattern(/.+/, [at.string(), ot.desc.template, at.object().pattern(/.+/, [at.string(), ot.desc.template])]),
                it.description = at.object({
                    type: at.string().required(),
                    flags: at.object({
                        cast: at.string(),
                        default: at.any(),
                        description: at.string(),
                        empty: at.link("/"),
                        failover: ot.desc.entity,
                        id: at.string(),
                        label: at.string(),
                        only: !0,
                        presence: ["optional", "required", "forbidden"],
                        result: ["raw", "strip"],
                        strip: at.boolean(),
                        unit: at.string()
                    }).unknown(),
                    preferences: {
                        allowUnknown: at.boolean(),
                        abortEarly: at.boolean(),
                        artifacts: at.boolean(),
                        cache: at.boolean(),
                        convert: at.boolean(),
                        dateFormat: ["date", "iso", "string", "time", "utc"],
                        errors: {
                            escapeHtml: at.boolean(),
                            label: ["path", "key"],
                            language: [at.string(), ot.desc.ref],
                            wrap: {
                                label: ot.wrap,
                                array: ot.wrap
                            }
                        },
                        externals: at.boolean(),
                        messages: ot.desc.messages,
                        noDefaults: at.boolean(),
                        nonEnumerables: at.boolean(),
                        presence: ["required", "optional", "forbidden"],
                        skipFunctions: at.boolean(),
                        stripUnknown: at.object({
                            arrays: at.boolean(),
                            objects: at.boolean()
                        }).or("arrays", "objects").allow(!0, !1),
                        warnings: at.boolean()
                    },
                    allow: ot.desc.values,
                    invalid: ot.desc.values,
                    rules: at.array().min(1).items({
                        name: at.string().required(),
                        args: at.object().min(1),
                        keep: at.boolean(),
                        message: [at.string(), ot.desc.messages],
                        warn: at.boolean()
                    }),
                    keys: at.object().pattern(/.*/, at.link("/")),
                    link: ot.desc.ref
                }).pattern(/^[a-z]\w*$/, at.any())
            }
            ,
            493: (nt,it,st)=>{
                const at = st(8571)
                  , ot = st(9621)
                  , lt = st(8160)
                  , dt = {
                    value: Symbol("value")
                };
                nt.exports = dt.State = class {
                    constructor(ct, ut, ft) {
                        this.path = ct,
                        this.ancestors = ut,
                        this.mainstay = ft.mainstay,
                        this.schemas = ft.schemas,
                        this.debug = null
                    }
                    localize(ct, ut=null, ft=null) {
                        const ht = new dt.State(ct,ut,this);
                        return ft && ht.schemas && (ht.schemas = [dt.schemas(ft), ...ht.schemas]),
                        ht
                    }
                    nest(ct, ut) {
                        const ft = new dt.State(this.path,this.ancestors,this);
                        return ft.schemas = ft.schemas && [dt.schemas(ct), ...ft.schemas],
                        ft.debug = ut,
                        ft
                    }
                    shadow(ct, ut) {
                        this.mainstay.shadow = this.mainstay.shadow || new dt.Shadow,
                        this.mainstay.shadow.set(this.path, ct, ut)
                    }
                    snapshot() {
                        this.mainstay.shadow && (this._snapshot = at(this.mainstay.shadow.node(this.path))),
                        this.mainstay.snapshot()
                    }
                    restore() {
                        this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot),
                        this._snapshot = void 0),
                        this.mainstay.restore()
                    }
                    commit() {
                        this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot),
                        this._snapshot = void 0),
                        this.mainstay.commit()
                    }
                }
                ,
                dt.schemas = function(ct) {
                    return lt.isSchema(ct) ? {
                        schema: ct
                    } : ct
                }
                ,
                dt.Shadow = class {
                    constructor() {
                        this._values = null
                    }
                    set(ct, ut, ft) {
                        if (!ct.length || ft === "strip" && typeof ct[ct.length - 1] == "number")
                            return;
                        this._values = this._values || new Map;
                        let ht = this._values;
                        for (let gt = 0; gt < ct.length; ++gt) {
                            const bt = ct[gt];
                            let pt = ht.get(bt);
                            pt || (pt = new Map,
                            ht.set(bt, pt)),
                            ht = pt
                        }
                        ht[dt.value] = ut
                    }
                    get(ct) {
                        const ut = this.node(ct);
                        if (ut)
                            return ut[dt.value]
                    }
                    node(ct) {
                        if (this._values)
                            return ot(this._values, ct, {
                                iterables: !0
                            })
                    }
                    override(ct, ut) {
                        if (!this._values)
                            return;
                        const ft = ct.slice(0, -1)
                          , ht = ct[ct.length - 1]
                          , gt = ot(this._values, ft, {
                            iterables: !0
                        });
                        ut ? gt.set(ht, ut) : gt && gt.delete(ht)
                    }
                }
            }
            ,
            3328: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(5277)
                  , dt = st(1447)
                  , ct = st(8160)
                  , ut = st(6354)
                  , ft = st(6133)
                  , ht = {
                    symbol: Symbol("template"),
                    opens: new Array(1e3).join("\0"),
                    closes: new Array(1e3).join(""),
                    dateFormat: {
                        date: Date.prototype.toDateString,
                        iso: Date.prototype.toISOString,
                        string: Date.prototype.toString,
                        time: Date.prototype.toTimeString,
                        utc: Date.prototype.toUTCString
                    }
                };
                nt.exports = ht.Template = class {
                    constructor(gt, bt) {
                        if (at(typeof gt == "string", "Template source must be a string"),
                        at(!gt.includes("\0") && !gt.includes(""), "Template source cannot contain reserved control characters"),
                        this.source = gt,
                        this.rendered = gt,
                        this._template = null,
                        bt) {
                            const {functions: pt, ...mt} = bt;
                            this._settings = Object.keys(mt).length ? ot(mt) : void 0,
                            this._functions = pt,
                            this._functions && (at(Object.keys(this._functions).every(yt=>typeof yt == "string"), "Functions keys must be strings"),
                            at(Object.values(this._functions).every(yt=>typeof yt == "function"), "Functions values must be functions"))
                        } else
                            this._settings = void 0,
                            this._functions = void 0;
                        this._parse()
                    }
                    _parse() {
                        if (!this.source.includes("{"))
                            return;
                        const gt = ht.encode(this.source)
                          , bt = ht.split(gt);
                        let pt = !1;
                        const mt = []
                          , yt = bt.shift();
                        yt && mt.push(yt);
                        for (const vt of bt) {
                            const wt = vt[0] !== "{"
                              , _t = wt ? "}" : "}}"
                              , Et = vt.indexOf(_t);
                            if (Et === -1 || vt[1] === "{") {
                                mt.push(`{${ht.decode(vt)}`);
                                continue
                            }
                            let xt = vt.slice(wt ? 0 : 1, Et);
                            const Ct = xt[0] === ":";
                            Ct && (xt = xt.slice(1));
                            const Tt = this._ref(ht.decode(xt), {
                                raw: wt,
                                wrapped: Ct
                            });
                            mt.push(Tt),
                            typeof Tt != "string" && (pt = !0);
                            const It = vt.slice(Et + _t.length);
                            It && mt.push(ht.decode(It))
                        }
                        pt ? this._template = mt : this.rendered = mt.join("")
                    }
                    static date(gt, bt) {
                        return ht.dateFormat[bt.dateFormat].call(gt)
                    }
                    describe(gt={}) {
                        if (!this._settings && gt.compact)
                            return this.source;
                        const bt = {
                            template: this.source
                        };
                        return this._settings && (bt.options = this._settings),
                        this._functions && (bt.functions = this._functions),
                        bt
                    }
                    static build(gt) {
                        return new ht.Template(gt.template,gt.options || gt.functions ? {
                            ...gt.options,
                            functions: gt.functions
                        } : void 0)
                    }
                    isDynamic() {
                        return !!this._template
                    }
                    static isTemplate(gt) {
                        return !!gt && !!gt[ct.symbols.template]
                    }
                    refs() {
                        if (!this._template)
                            return;
                        const gt = [];
                        for (const bt of this._template)
                            typeof bt != "string" && gt.push(...bt.refs);
                        return gt
                    }
                    resolve(gt, bt, pt, mt) {
                        return this._template && this._template.length === 1 ? this._part(this._template[0], gt, bt, pt, mt, {}) : this.render(gt, bt, pt, mt)
                    }
                    _part(gt, ...bt) {
                        return gt.ref ? gt.ref.resolve(...bt) : gt.formula.evaluate(bt)
                    }
                    render(gt, bt, pt, mt, yt={}) {
                        if (!this.isDynamic())
                            return this.rendered;
                        const vt = [];
                        for (const wt of this._template)
                            if (typeof wt == "string")
                                vt.push(wt);
                            else {
                                const _t = this._part(wt, gt, bt, pt, mt, yt)
                                  , Et = ht.stringify(_t, gt, bt, pt, mt, yt);
                                if (Et !== void 0) {
                                    const xt = wt.raw || (yt.errors && yt.errors.escapeHtml) === !1 ? Et : lt(Et);
                                    vt.push(ht.wrap(xt, wt.wrapped && pt.errors.wrap.label))
                                }
                            }
                        return vt.join("")
                    }
                    _ref(gt, {raw: bt, wrapped: pt}) {
                        const mt = []
                          , yt = wt=>{
                            const _t = ft.create(wt, this._settings);
                            return mt.push(_t),
                            Et=>{
                                const xt = _t.resolve(...Et);
                                return xt !== void 0 ? xt : null
                            }
                        }
                        ;
                        try {
                            const wt = this._functions ? {
                                ...ht.functions,
                                ...this._functions
                            } : ht.functions;
                            var vt = new dt.Parser(gt,{
                                reference: yt,
                                functions: wt,
                                constants: ht.constants
                            })
                        } catch (wt) {
                            throw wt.message = `Invalid template variable "${gt}" fails due to: ${wt.message}`,
                            wt
                        }
                        if (vt.single) {
                            if (vt.single.type === "reference") {
                                const wt = mt[0];
                                return {
                                    ref: wt,
                                    raw: bt,
                                    refs: mt,
                                    wrapped: pt || wt.type === "local" && wt.key === "label"
                                }
                            }
                            return ht.stringify(vt.single.value)
                        }
                        return {
                            formula: vt,
                            raw: bt,
                            refs: mt
                        }
                    }
                    toString() {
                        return this.source
                    }
                }
                ,
                ht.Template.prototype[ct.symbols.template] = !0,
                ht.Template.prototype.isImmutable = !0,
                ht.encode = function(gt) {
                    return gt.replace(/\\(\{+)/g, (bt,pt)=>ht.opens.slice(0, pt.length)).replace(/\\(\}+)/g, (bt,pt)=>ht.closes.slice(0, pt.length))
                }
                ,
                ht.decode = function(gt) {
                    return gt.replace(/\u0000/g, "{").replace(/\u0001/g, "}")
                }
                ,
                ht.split = function(gt) {
                    const bt = [];
                    let pt = "";
                    for (let mt = 0; mt < gt.length; ++mt) {
                        const yt = gt[mt];
                        if (yt === "{") {
                            let vt = "";
                            for (; mt + 1 < gt.length && gt[mt + 1] === "{"; )
                                vt += "{",
                                ++mt;
                            bt.push(pt),
                            pt = vt
                        } else
                            pt += yt
                    }
                    return bt.push(pt),
                    bt
                }
                ,
                ht.wrap = function(gt, bt) {
                    return bt ? bt.length === 1 ? `${bt}${gt}${bt}` : `${bt[0]}${gt}${bt[1]}` : gt
                }
                ,
                ht.stringify = function(gt, bt, pt, mt, yt, vt={}) {
                    const wt = typeof gt
                      , _t = mt && mt.errors && mt.errors.wrap || {};
                    let Et = !1;
                    if (ft.isRef(gt) && gt.render && (Et = gt.in,
                    gt = gt.resolve(bt, pt, mt, yt, {
                        in: gt.in,
                        ...vt
                    })),
                    gt === null)
                        return "null";
                    if (wt === "string")
                        return ht.wrap(gt, vt.arrayItems && _t.string);
                    if (wt === "number" || wt === "function" || wt === "symbol")
                        return gt.toString();
                    if (wt !== "object")
                        return JSON.stringify(gt);
                    if (gt instanceof Date)
                        return ht.Template.date(gt, mt);
                    if (gt instanceof Map) {
                        const Ct = [];
                        for (const [Tt,It] of gt.entries())
                            Ct.push(`${Tt.toString()} -> ${It.toString()}`);
                        gt = Ct
                    }
                    if (!Array.isArray(gt))
                        return gt.toString();
                    const xt = [];
                    for (const Ct of gt)
                        xt.push(ht.stringify(Ct, bt, pt, mt, yt, {
                            arrayItems: !0,
                            ...vt
                        }));
                    return ht.wrap(xt.join(", "), !Et && _t.array)
                }
                ,
                ht.constants = {
                    true: !0,
                    false: !1,
                    null: null,
                    second: 1e3,
                    minute: 6e4,
                    hour: 36e5,
                    day: 864e5
                },
                ht.functions = {
                    if: (gt,bt,pt)=>gt ? bt : pt,
                    length: gt=>typeof gt == "string" ? gt.length : gt && typeof gt == "object" ? Array.isArray(gt) ? gt.length : Object.keys(gt).length : null,
                    msg(gt) {
                        const [bt,pt,mt,yt,vt] = this
                          , wt = vt.messages;
                        if (!wt)
                            return "";
                        const _t = ut.template(bt, wt[0], gt, pt, mt) || ut.template(bt, wt[1], gt, pt, mt);
                        return _t ? _t.render(bt, pt, mt, yt, vt) : ""
                    },
                    number: gt=>typeof gt == "number" ? gt : typeof gt == "string" ? parseFloat(gt) : typeof gt == "boolean" ? gt ? 1 : 0 : gt instanceof Date ? gt.getTime() : null
                }
            }
            ,
            4946: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(1687)
                  , lt = st(8068)
                  , dt = st(8160)
                  , ct = st(3292)
                  , ut = st(6354)
                  , ft = st(6133)
                  , ht = {};
                nt.exports = lt.extend({
                    type: "alternatives",
                    flags: {
                        match: {
                            default: "any"
                        }
                    },
                    terms: {
                        matches: {
                            init: [],
                            register: ft.toSibling
                        }
                    },
                    args: (gt,...bt)=>bt.length === 1 && Array.isArray(bt[0]) ? gt.try(...bt[0]) : gt.try(...bt),
                    validate(gt, bt) {
                        const {schema: pt, error: mt, state: yt, prefs: vt} = bt;
                        if (pt._flags.match) {
                            const _t = []
                              , Et = [];
                            for (let Ct = 0; Ct < pt.$_terms.matches.length; ++Ct) {
                                const Tt = pt.$_terms.matches[Ct]
                                  , It = yt.nest(Tt.schema, `match.${Ct}`);
                                It.snapshot();
                                const Nt = Tt.schema.$_validate(gt, It, vt);
                                Nt.errors ? (Et.push(Nt.errors),
                                It.restore()) : (_t.push(Nt.value),
                                It.commit())
                            }
                            if (_t.length === 0)
                                return {
                                    errors: mt("alternatives.any", {
                                        details: Et.map(Ct=>ut.details(Ct, {
                                            override: !1
                                        }))
                                    })
                                };
                            if (pt._flags.match === "one")
                                return _t.length === 1 ? {
                                    value: _t[0]
                                } : {
                                    errors: mt("alternatives.one")
                                };
                            if (_t.length !== pt.$_terms.matches.length)
                                return {
                                    errors: mt("alternatives.all", {
                                        details: Et.map(Ct=>ut.details(Ct, {
                                            override: !1
                                        }))
                                    })
                                };
                            const xt = Ct=>Ct.$_terms.matches.some(Tt=>Tt.schema.type === "object" || Tt.schema.type === "alternatives" && xt(Tt.schema));
                            return xt(pt) ? {
                                value: _t.reduce((Ct,Tt)=>ot(Ct, Tt, {
                                    mergeArrays: !1
                                }))
                            } : {
                                value: _t[_t.length - 1]
                            }
                        }
                        const wt = [];
                        for (let _t = 0; _t < pt.$_terms.matches.length; ++_t) {
                            const Et = pt.$_terms.matches[_t];
                            if (Et.schema) {
                                const Tt = yt.nest(Et.schema, `match.${_t}`);
                                Tt.snapshot();
                                const It = Et.schema.$_validate(gt, Tt, vt);
                                if (!It.errors)
                                    return Tt.commit(),
                                    It;
                                Tt.restore(),
                                wt.push({
                                    schema: Et.schema,
                                    reports: It.errors
                                });
                                continue
                            }
                            const xt = Et.ref ? Et.ref.resolve(gt, yt, vt) : gt
                              , Ct = Et.is ? [Et] : Et.switch;
                            for (let Tt = 0; Tt < Ct.length; ++Tt) {
                                const It = Ct[Tt]
                                  , {is: Nt, then: Ft, otherwise: Lt} = It
                                  , Mt = `match.${_t}${Et.switch ? "." + Tt : ""}`;
                                if (Nt.$_match(xt, yt.nest(Nt, `${Mt}.is`), vt)) {
                                    if (Ft)
                                        return Ft.$_validate(gt, yt.nest(Ft, `${Mt}.then`), vt)
                                } else if (Lt)
                                    return Lt.$_validate(gt, yt.nest(Lt, `${Mt}.otherwise`), vt)
                            }
                        }
                        return ht.errors(wt, bt)
                    },
                    rules: {
                        conditional: {
                            method(gt, bt) {
                                at(!this._flags._endedSwitch, "Unreachable condition"),
                                at(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule"),
                                at(bt.break === void 0, "Cannot use break option with alternatives conditional");
                                const pt = this.clone()
                                  , mt = ct.when(pt, gt, bt)
                                  , yt = mt.is ? [mt] : mt.switch;
                                for (const vt of yt)
                                    if (vt.then && vt.otherwise) {
                                        pt.$_setFlag("_endedSwitch", !0, {
                                            clone: !1
                                        });
                                        break
                                    }
                                return pt.$_terms.matches.push(mt),
                                pt.$_mutateRebuild()
                            }
                        },
                        match: {
                            method(gt) {
                                if (at(["any", "one", "all"].includes(gt), "Invalid alternatives match mode", gt),
                                gt !== "any")
                                    for (const bt of this.$_terms.matches)
                                        at(bt.schema, "Cannot combine match mode", gt, "with conditional rules");
                                return this.$_setFlag("match", gt)
                            }
                        },
                        try: {
                            method(...gt) {
                                at(gt.length, "Missing alternative schemas"),
                                dt.verifyFlat(gt, "try"),
                                at(!this._flags._endedSwitch, "Unreachable condition");
                                const bt = this.clone();
                                for (const pt of gt)
                                    bt.$_terms.matches.push({
                                        schema: bt.$_compile(pt)
                                    });
                                return bt.$_mutateRebuild()
                            }
                        }
                    },
                    overrides: {
                        label(gt) {
                            return this.$_parent("label", gt).$_modify({
                                each: (bt,pt)=>pt.path[0] !== "is" && typeof bt._flags.label != "string" ? bt.label(gt) : void 0,
                                ref: !1
                            })
                        }
                    },
                    rebuild(gt) {
                        gt.$_modify({
                            each: bt=>{
                                dt.isSchema(bt) && bt.type === "array" && gt.$_setFlag("_arrayItems", !0, {
                                    clone: !1
                                })
                            }
                        })
                    },
                    manifest: {
                        build(gt, bt) {
                            if (bt.matches)
                                for (const pt of bt.matches) {
                                    const {schema: mt, ref: yt, is: vt, not: wt, then: _t, otherwise: Et} = pt;
                                    gt = mt ? gt.try(mt) : yt ? gt.conditional(yt, {
                                        is: vt,
                                        then: _t,
                                        not: wt,
                                        otherwise: Et,
                                        switch: pt.switch
                                    }) : gt.conditional(vt, {
                                        then: _t,
                                        otherwise: Et
                                    })
                                }
                            return gt
                        }
                    },
                    messages: {
                        "alternatives.all": "{{#label}} does not match all of the required types",
                        "alternatives.any": "{{#label}} does not match any of the allowed types",
                        "alternatives.match": "{{#label}} does not match any of the allowed types",
                        "alternatives.one": "{{#label}} matches more than one allowed type",
                        "alternatives.types": "{{#label}} must be one of {{#types}}"
                    }
                }),
                ht.errors = function(gt, {error: bt, state: pt}) {
                    if (!gt.length)
                        return {
                            errors: bt("alternatives.any")
                        };
                    if (gt.length === 1)
                        return {
                            errors: gt[0].reports
                        };
                    const mt = new Set
                      , yt = [];
                    for (const {reports: vt, schema: wt} of gt) {
                        if (vt.length > 1)
                            return ht.unmatched(gt, bt);
                        const _t = vt[0];
                        if (_t instanceof ut.Report == 0)
                            return ht.unmatched(gt, bt);
                        if (_t.state.path.length !== pt.path.length) {
                            yt.push({
                                type: wt.type,
                                report: _t
                            });
                            continue
                        }
                        if (_t.code === "any.only") {
                            for (const Ct of _t.local.valids)
                                mt.add(Ct);
                            continue
                        }
                        const [Et,xt] = _t.code.split(".");
                        xt === "base" ? mt.add(Et) : yt.push({
                            type: wt.type,
                            report: _t
                        })
                    }
                    return yt.length ? yt.length === 1 ? {
                        errors: yt[0].report
                    } : ht.unmatched(gt, bt) : {
                        errors: bt("alternatives.types", {
                            types: [...mt]
                        })
                    }
                }
                ,
                ht.unmatched = function(gt, bt) {
                    const pt = [];
                    for (const mt of gt)
                        pt.push(...mt.reports);
                    return {
                        errors: bt("alternatives.match", ut.details(pt, {
                            override: !1
                        }))
                    }
                }
            }
            ,
            8068: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(7629)
                  , lt = st(8160)
                  , dt = st(6914);
                nt.exports = ot.extend({
                    type: "any",
                    flags: {
                        only: {
                            default: !1
                        }
                    },
                    terms: {
                        alterations: {
                            init: null
                        },
                        examples: {
                            init: null
                        },
                        externals: {
                            init: null
                        },
                        metas: {
                            init: []
                        },
                        notes: {
                            init: []
                        },
                        shared: {
                            init: null
                        },
                        tags: {
                            init: []
                        },
                        whens: {
                            init: null
                        }
                    },
                    rules: {
                        custom: {
                            method(ct, ut) {
                                return at(typeof ct == "function", "Method must be a function"),
                                at(ut === void 0 || ut && typeof ut == "string", "Description must be a non-empty string"),
                                this.$_addRule({
                                    name: "custom",
                                    args: {
                                        method: ct,
                                        description: ut
                                    }
                                })
                            },
                            validate(ct, ut, {method: ft}) {
                                try {
                                    return ft(ct, ut)
                                } catch (ht) {
                                    return ut.error("any.custom", {
                                        error: ht
                                    })
                                }
                            },
                            args: ["method", "description"],
                            multi: !0
                        },
                        messages: {
                            method(ct) {
                                return this.prefs({
                                    messages: ct
                                })
                            }
                        },
                        shared: {
                            method(ct) {
                                at(lt.isSchema(ct) && ct._flags.id, "Schema must be a schema with an id");
                                const ut = this.clone();
                                return ut.$_terms.shared = ut.$_terms.shared || [],
                                ut.$_terms.shared.push(ct),
                                ut.$_mutateRegister(ct),
                                ut
                            }
                        },
                        warning: {
                            method(ct, ut) {
                                return at(ct && typeof ct == "string", "Invalid warning code"),
                                this.$_addRule({
                                    name: "warning",
                                    args: {
                                        code: ct,
                                        local: ut
                                    },
                                    warn: !0
                                })
                            },
                            validate: (ct,ut,{code: ft, local: ht})=>ut.error(ft, ht),
                            args: ["code", "local"],
                            multi: !0
                        }
                    },
                    modifiers: {
                        keep(ct, ut=!0) {
                            ct.keep = ut
                        },
                        message(ct, ut) {
                            ct.message = dt.compile(ut)
                        },
                        warn(ct, ut=!0) {
                            ct.warn = ut
                        }
                    },
                    manifest: {
                        build(ct, ut) {
                            for (const ft in ut) {
                                const ht = ut[ft];
                                if (["examples", "externals", "metas", "notes", "tags"].includes(ft))
                                    for (const gt of ht)
                                        ct = ct[ft.slice(0, -1)](gt);
                                else if (ft !== "alterations")
                                    if (ft !== "whens") {
                                        if (ft === "shared")
                                            for (const gt of ht)
                                                ct = ct.shared(gt)
                                    } else
                                        for (const gt of ht) {
                                            const {ref: bt, is: pt, not: mt, then: yt, otherwise: vt, concat: wt} = gt;
                                            ct = wt ? ct.concat(wt) : bt ? ct.when(bt, {
                                                is: pt,
                                                not: mt,
                                                then: yt,
                                                otherwise: vt,
                                                switch: gt.switch,
                                                break: gt.break
                                            }) : ct.when(pt, {
                                                then: yt,
                                                otherwise: vt,
                                                break: gt.break
                                            })
                                        }
                                else {
                                    const gt = {};
                                    for (const {target: bt, adjuster: pt} of ht)
                                        gt[bt] = pt;
                                    ct = ct.alter(gt)
                                }
                            }
                            return ct
                        }
                    },
                    messages: {
                        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
                        "any.default": "{{#label}} threw an error when running default method",
                        "any.failover": "{{#label}} threw an error when running failover method",
                        "any.invalid": "{{#label}} contains an invalid value",
                        "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
                        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
                        "any.required": "{{#label}} is required",
                        "any.unknown": "{{#label}} is not allowed"
                    }
                })
            }
            ,
            546: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(9474)
                  , lt = st(9621)
                  , dt = st(8068)
                  , ct = st(8160)
                  , ut = st(3292)
                  , ft = {};
                nt.exports = dt.extend({
                    type: "array",
                    flags: {
                        single: {
                            default: !1
                        },
                        sparse: {
                            default: !1
                        }
                    },
                    terms: {
                        items: {
                            init: [],
                            manifest: "schema"
                        },
                        ordered: {
                            init: [],
                            manifest: "schema"
                        },
                        _exclusions: {
                            init: []
                        },
                        _inclusions: {
                            init: []
                        },
                        _requireds: {
                            init: []
                        }
                    },
                    coerce: {
                        from: "object",
                        method(ht, {schema: gt, state: bt, prefs: pt}) {
                            if (!Array.isArray(ht))
                                return;
                            const mt = gt.$_getRule("sort");
                            return mt ? ft.sort(gt, ht, mt.args.options, bt, pt) : void 0
                        }
                    },
                    validate(ht, {schema: gt, error: bt}) {
                        if (!Array.isArray(ht)) {
                            if (gt._flags.single) {
                                const pt = [ht];
                                return pt[ct.symbols.arraySingle] = !0,
                                {
                                    value: pt
                                }
                            }
                            return {
                                errors: bt("array.base")
                            }
                        }
                        if (gt.$_getRule("items") || gt.$_terms.externals)
                            return {
                                value: ht.slice()
                            }
                    },
                    rules: {
                        has: {
                            method(ht) {
                                ht = this.$_compile(ht, {
                                    appendPath: !0
                                });
                                const gt = this.$_addRule({
                                    name: "has",
                                    args: {
                                        schema: ht
                                    }
                                });
                                return gt.$_mutateRegister(ht),
                                gt
                            },
                            validate(ht, {state: gt, prefs: bt, error: pt}, {schema: mt}) {
                                const yt = [ht, ...gt.ancestors];
                                for (let wt = 0; wt < ht.length; ++wt) {
                                    const _t = gt.localize([...gt.path, wt], yt, mt);
                                    if (mt.$_match(ht[wt], _t, bt))
                                        return ht
                                }
                                const vt = mt._flags.label;
                                return vt ? pt("array.hasKnown", {
                                    patternLabel: vt
                                }) : pt("array.hasUnknown", null)
                            },
                            multi: !0
                        },
                        items: {
                            method(...ht) {
                                ct.verifyFlat(ht, "items");
                                const gt = this.$_addRule("items");
                                for (let bt = 0; bt < ht.length; ++bt) {
                                    const pt = ct.tryWithPath(()=>this.$_compile(ht[bt]), bt, {
                                        append: !0
                                    });
                                    gt.$_terms.items.push(pt)
                                }
                                return gt.$_mutateRebuild()
                            },
                            validate(ht, {schema: gt, error: bt, state: pt, prefs: mt, errorsArray: yt}) {
                                const vt = gt.$_terms._requireds.slice()
                                  , wt = gt.$_terms.ordered.slice()
                                  , _t = [...gt.$_terms._inclusions, ...vt]
                                  , Et = !ht[ct.symbols.arraySingle];
                                delete ht[ct.symbols.arraySingle];
                                const xt = yt();
                                let Ct = ht.length;
                                for (let Tt = 0; Tt < Ct; ++Tt) {
                                    const It = ht[Tt];
                                    let Nt = !1
                                      , Ft = !1;
                                    const Lt = Et ? Tt : new Number(Tt)
                                      , Mt = [...pt.path, Lt];
                                    if (!gt._flags.sparse && It === void 0) {
                                        if (xt.push(bt("array.sparse", {
                                            key: Lt,
                                            path: Mt,
                                            pos: Tt,
                                            value: void 0
                                        }, pt.localize(Mt))),
                                        mt.abortEarly)
                                            return xt;
                                        wt.shift();
                                        continue
                                    }
                                    const $t = [ht, ...pt.ancestors];
                                    for (const Dt of gt.$_terms._exclusions)
                                        if (Dt.$_match(It, pt.localize(Mt, $t, Dt), mt, {
                                            presence: "ignore"
                                        })) {
                                            if (xt.push(bt("array.excludes", {
                                                pos: Tt,
                                                value: It
                                            }, pt.localize(Mt))),
                                            mt.abortEarly)
                                                return xt;
                                            Nt = !0,
                                            wt.shift();
                                            break
                                        }
                                    if (Nt)
                                        continue;
                                    if (gt.$_terms.ordered.length) {
                                        if (wt.length) {
                                            const Dt = wt.shift()
                                              , Bt = Dt.$_validate(It, pt.localize(Mt, $t, Dt), mt);
                                            if (Bt.errors) {
                                                if (xt.push(...Bt.errors),
                                                mt.abortEarly)
                                                    return xt
                                            } else if (Dt._flags.result === "strip")
                                                ft.fastSplice(ht, Tt),
                                                --Tt,
                                                --Ct;
                                            else {
                                                if (!gt._flags.sparse && Bt.value === void 0) {
                                                    if (xt.push(bt("array.sparse", {
                                                        key: Lt,
                                                        path: Mt,
                                                        pos: Tt,
                                                        value: void 0
                                                    }, pt.localize(Mt))),
                                                    mt.abortEarly)
                                                        return xt;
                                                    continue
                                                }
                                                ht[Tt] = Bt.value
                                            }
                                            continue
                                        }
                                        if (!gt.$_terms.items.length) {
                                            if (xt.push(bt("array.orderedLength", {
                                                pos: Tt,
                                                limit: gt.$_terms.ordered.length
                                            })),
                                            mt.abortEarly)
                                                return xt;
                                            break
                                        }
                                    }
                                    const kt = [];
                                    let At = vt.length;
                                    for (let Dt = 0; Dt < At; ++Dt) {
                                        const Bt = pt.localize(Mt, $t, vt[Dt]);
                                        Bt.snapshot();
                                        const zt = vt[Dt].$_validate(It, Bt, mt);
                                        if (kt[Dt] = zt,
                                        !zt.errors) {
                                            if (Bt.commit(),
                                            ht[Tt] = zt.value,
                                            Ft = !0,
                                            ft.fastSplice(vt, Dt),
                                            --Dt,
                                            --At,
                                            !gt._flags.sparse && zt.value === void 0 && (xt.push(bt("array.sparse", {
                                                key: Lt,
                                                path: Mt,
                                                pos: Tt,
                                                value: void 0
                                            }, pt.localize(Mt))),
                                            mt.abortEarly))
                                                return xt;
                                            break
                                        }
                                        Bt.restore()
                                    }
                                    if (Ft)
                                        continue;
                                    const Pt = mt.stripUnknown && !!mt.stripUnknown.arrays || !1;
                                    At = _t.length;
                                    for (const Dt of _t) {
                                        let Bt;
                                        const zt = vt.indexOf(Dt);
                                        if (zt !== -1)
                                            Bt = kt[zt];
                                        else {
                                            const Yt = pt.localize(Mt, $t, Dt);
                                            if (Yt.snapshot(),
                                            Bt = Dt.$_validate(It, Yt, mt),
                                            !Bt.errors) {
                                                Yt.commit(),
                                                Dt._flags.result === "strip" ? (ft.fastSplice(ht, Tt),
                                                --Tt,
                                                --Ct) : gt._flags.sparse || Bt.value !== void 0 ? ht[Tt] = Bt.value : (xt.push(bt("array.sparse", {
                                                    key: Lt,
                                                    path: Mt,
                                                    pos: Tt,
                                                    value: void 0
                                                }, pt.localize(Mt))),
                                                Nt = !0),
                                                Ft = !0;
                                                break
                                            }
                                            Yt.restore()
                                        }
                                        if (At === 1) {
                                            if (Pt) {
                                                ft.fastSplice(ht, Tt),
                                                --Tt,
                                                --Ct,
                                                Ft = !0;
                                                break
                                            }
                                            if (xt.push(...Bt.errors),
                                            mt.abortEarly)
                                                return xt;
                                            Nt = !0;
                                            break
                                        }
                                    }
                                    if (!Nt && (gt.$_terms._inclusions.length || gt.$_terms._requireds.length) && !Ft) {
                                        if (Pt) {
                                            ft.fastSplice(ht, Tt),
                                            --Tt,
                                            --Ct;
                                            continue
                                        }
                                        if (xt.push(bt("array.includes", {
                                            pos: Tt,
                                            value: It
                                        }, pt.localize(Mt))),
                                        mt.abortEarly)
                                            return xt
                                    }
                                }
                                return vt.length && ft.fillMissedErrors(gt, xt, vt, ht, pt, mt),
                                wt.length && (ft.fillOrderedErrors(gt, xt, wt, ht, pt, mt),
                                xt.length || ft.fillDefault(wt, ht, pt, mt)),
                                xt.length ? xt : ht
                            },
                            priority: !0,
                            manifest: !1
                        },
                        length: {
                            method(ht) {
                                return this.$_addRule({
                                    name: "length",
                                    args: {
                                        limit: ht
                                    },
                                    operator: "="
                                })
                            },
                            validate: (ht,gt,{limit: bt},{name: pt, operator: mt, args: yt})=>ct.compare(ht.length, bt, mt) ? ht : gt.error("array." + pt, {
                                limit: yt.limit,
                                value: ht
                            }),
                            args: [{
                                name: "limit",
                                ref: !0,
                                assert: ct.limit,
                                message: "must be a positive integer"
                            }]
                        },
                        max: {
                            method(ht) {
                                return this.$_addRule({
                                    name: "max",
                                    method: "length",
                                    args: {
                                        limit: ht
                                    },
                                    operator: "<="
                                })
                            }
                        },
                        min: {
                            method(ht) {
                                return this.$_addRule({
                                    name: "min",
                                    method: "length",
                                    args: {
                                        limit: ht
                                    },
                                    operator: ">="
                                })
                            }
                        },
                        ordered: {
                            method(...ht) {
                                ct.verifyFlat(ht, "ordered");
                                const gt = this.$_addRule("items");
                                for (let bt = 0; bt < ht.length; ++bt) {
                                    const pt = ct.tryWithPath(()=>this.$_compile(ht[bt]), bt, {
                                        append: !0
                                    });
                                    ft.validateSingle(pt, gt),
                                    gt.$_mutateRegister(pt),
                                    gt.$_terms.ordered.push(pt)
                                }
                                return gt.$_mutateRebuild()
                            }
                        },
                        single: {
                            method(ht) {
                                const gt = ht === void 0 || !!ht;
                                return at(!gt || !this._flags._arrayItems, "Cannot specify single rule when array has array items"),
                                this.$_setFlag("single", gt)
                            }
                        },
                        sort: {
                            method(ht={}) {
                                ct.assertOptions(ht, ["by", "order"]);
                                const gt = {
                                    order: ht.order || "ascending"
                                };
                                return ht.by && (gt.by = ut.ref(ht.by, {
                                    ancestor: 0
                                }),
                                at(!gt.by.ancestor, "Cannot sort by ancestor")),
                                this.$_addRule({
                                    name: "sort",
                                    args: {
                                        options: gt
                                    }
                                })
                            },
                            validate(ht, {error: gt, state: bt, prefs: pt, schema: mt}, {options: yt}) {
                                const {value: vt, errors: wt} = ft.sort(mt, ht, yt, bt, pt);
                                if (wt)
                                    return wt;
                                for (let _t = 0; _t < ht.length; ++_t)
                                    if (ht[_t] !== vt[_t])
                                        return gt("array.sort", {
                                            order: yt.order,
                                            by: yt.by ? yt.by.key : "value"
                                        });
                                return ht
                            },
                            convert: !0
                        },
                        sparse: {
                            method(ht) {
                                const gt = ht === void 0 || !!ht;
                                return this._flags.sparse === gt ? this : (gt ? this.clone() : this.$_addRule("items")).$_setFlag("sparse", gt, {
                                    clone: !1
                                })
                            }
                        },
                        unique: {
                            method(ht, gt={}) {
                                at(!ht || typeof ht == "function" || typeof ht == "string", "comparator must be a function or a string"),
                                ct.assertOptions(gt, ["ignoreUndefined", "separator"]);
                                const bt = {
                                    name: "unique",
                                    args: {
                                        options: gt,
                                        comparator: ht
                                    }
                                };
                                if (ht)
                                    if (typeof ht == "string") {
                                        const pt = ct.default(gt.separator, ".");
                                        bt.path = pt ? ht.split(pt) : [ht]
                                    } else
                                        bt.comparator = ht;
                                return this.$_addRule(bt)
                            },
                            validate(ht, {state: gt, error: bt, schema: pt}, {comparator: mt, options: yt}, {comparator: vt, path: wt}) {
                                const _t = {
                                    string: Object.create(null),
                                    number: Object.create(null),
                                    undefined: Object.create(null),
                                    boolean: Object.create(null),
                                    object: new Map,
                                    function: new Map,
                                    custom: new Map
                                }
                                  , Et = vt || ot
                                  , xt = yt.ignoreUndefined;
                                for (let Ct = 0; Ct < ht.length; ++Ct) {
                                    const Tt = wt ? lt(ht[Ct], wt) : ht[Ct]
                                      , It = vt ? _t.custom : _t[typeof Tt];
                                    if (at(It, "Failed to find unique map container for type", typeof Tt),
                                    It instanceof Map) {
                                        const Nt = It.entries();
                                        let Ft;
                                        for (; !(Ft = Nt.next()).done; )
                                            if (Et(Ft.value[0], Tt)) {
                                                const Lt = gt.localize([...gt.path, Ct], [ht, ...gt.ancestors])
                                                  , Mt = {
                                                    pos: Ct,
                                                    value: ht[Ct],
                                                    dupePos: Ft.value[1],
                                                    dupeValue: ht[Ft.value[1]]
                                                };
                                                return wt && (Mt.path = mt),
                                                bt("array.unique", Mt, Lt)
                                            }
                                        It.set(Tt, Ct)
                                    } else {
                                        if ((!xt || Tt !== void 0) && It[Tt] !== void 0) {
                                            const Nt = {
                                                pos: Ct,
                                                value: ht[Ct],
                                                dupePos: It[Tt],
                                                dupeValue: ht[It[Tt]]
                                            };
                                            return wt && (Nt.path = mt),
                                            bt("array.unique", Nt, gt.localize([...gt.path, Ct], [ht, ...gt.ancestors]))
                                        }
                                        It[Tt] = Ct
                                    }
                                }
                                return ht
                            },
                            args: ["comparator", "options"],
                            multi: !0
                        }
                    },
                    cast: {
                        set: {
                            from: Array.isArray,
                            to: (ht,gt)=>new Set(ht)
                        }
                    },
                    rebuild(ht) {
                        ht.$_terms._inclusions = [],
                        ht.$_terms._exclusions = [],
                        ht.$_terms._requireds = [];
                        for (const gt of ht.$_terms.items)
                            ft.validateSingle(gt, ht),
                            gt._flags.presence === "required" ? ht.$_terms._requireds.push(gt) : gt._flags.presence === "forbidden" ? ht.$_terms._exclusions.push(gt) : ht.$_terms._inclusions.push(gt);
                        for (const gt of ht.$_terms.ordered)
                            ft.validateSingle(gt, ht)
                    },
                    manifest: {
                        build: (ht,gt)=>(gt.items && (ht = ht.items(...gt.items)),
                        gt.ordered && (ht = ht.ordered(...gt.ordered)),
                        ht)
                    },
                    messages: {
                        "array.base": "{{#label}} must be an array",
                        "array.excludes": "{{#label}} contains an excluded value",
                        "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
                        "array.hasUnknown": "{{#label}} does not contain at least one required match",
                        "array.includes": "{{#label}} does not match any of the allowed types",
                        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
                        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
                        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
                        "array.length": "{{#label}} must contain {{#limit}} items",
                        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
                        "array.min": "{{#label}} must contain at least {{#limit}} items",
                        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
                        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
                        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
                        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
                        "array.sparse": "{{#label}} must not be a sparse array item",
                        "array.unique": "{{#label}} contains a duplicate value"
                    }
                }),
                ft.fillMissedErrors = function(ht, gt, bt, pt, mt, yt) {
                    const vt = [];
                    let wt = 0;
                    for (const _t of bt) {
                        const Et = _t._flags.label;
                        Et ? vt.push(Et) : ++wt
                    }
                    vt.length ? wt ? gt.push(ht.$_createError("array.includesRequiredBoth", pt, {
                        knownMisses: vt,
                        unknownMisses: wt
                    }, mt, yt)) : gt.push(ht.$_createError("array.includesRequiredKnowns", pt, {
                        knownMisses: vt
                    }, mt, yt)) : gt.push(ht.$_createError("array.includesRequiredUnknowns", pt, {
                        unknownMisses: wt
                    }, mt, yt))
                }
                ,
                ft.fillOrderedErrors = function(ht, gt, bt, pt, mt, yt) {
                    const vt = [];
                    for (const wt of bt)
                        wt._flags.presence === "required" && vt.push(wt);
                    vt.length && ft.fillMissedErrors(ht, gt, vt, pt, mt, yt)
                }
                ,
                ft.fillDefault = function(ht, gt, bt, pt) {
                    const mt = [];
                    let yt = !0;
                    for (let vt = ht.length - 1; vt >= 0; --vt) {
                        const wt = ht[vt]
                          , _t = [gt, ...bt.ancestors]
                          , Et = wt.$_validate(void 0, bt.localize(bt.path, _t, wt), pt).value;
                        if (yt) {
                            if (Et === void 0)
                                continue;
                            yt = !1
                        }
                        mt.unshift(Et)
                    }
                    mt.length && gt.push(...mt)
                }
                ,
                ft.fastSplice = function(ht, gt) {
                    let bt = gt;
                    for (; bt < ht.length; )
                        ht[bt++] = ht[bt];
                    --ht.length
                }
                ,
                ft.validateSingle = function(ht, gt) {
                    (ht.type === "array" || ht._flags._arrayItems) && (at(!gt._flags.single, "Cannot specify array item with single rule enabled"),
                    gt.$_setFlag("_arrayItems", !0, {
                        clone: !1
                    }))
                }
                ,
                ft.sort = function(ht, gt, bt, pt, mt) {
                    const yt = bt.order === "ascending" ? 1 : -1
                      , vt = -1 * yt
                      , wt = yt
                      , _t = (Et,xt)=>{
                        let Ct = ft.compare(Et, xt, vt, wt);
                        if (Ct !== null || (bt.by && (Et = bt.by.resolve(Et, pt, mt),
                        xt = bt.by.resolve(xt, pt, mt)),
                        Ct = ft.compare(Et, xt, vt, wt),
                        Ct !== null))
                            return Ct;
                        const Tt = typeof Et;
                        if (Tt !== typeof xt)
                            throw ht.$_createError("array.sort.mismatching", gt, null, pt, mt);
                        if (Tt !== "number" && Tt !== "string")
                            throw ht.$_createError("array.sort.unsupported", gt, {
                                type: Tt
                            }, pt, mt);
                        return Tt === "number" ? (Et - xt) * yt : Et < xt ? vt : wt
                    }
                    ;
                    try {
                        return {
                            value: gt.slice().sort(_t)
                        }
                    } catch (Et) {
                        return {
                            errors: Et
                        }
                    }
                }
                ,
                ft.compare = function(ht, gt, bt, pt) {
                    return ht === gt ? 0 : ht === void 0 ? 1 : gt === void 0 ? -1 : ht === null ? pt : gt === null ? bt : null
                }
            }
            ,
            4937: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8068)
                  , lt = st(8160)
                  , dt = st(2036)
                  , ct = {
                    isBool: function(ut) {
                        return typeof ut == "boolean"
                    }
                };
                nt.exports = ot.extend({
                    type: "boolean",
                    flags: {
                        sensitive: {
                            default: !1
                        }
                    },
                    terms: {
                        falsy: {
                            init: null,
                            manifest: "values"
                        },
                        truthy: {
                            init: null,
                            manifest: "values"
                        }
                    },
                    coerce(ut, {schema: ft}) {
                        if (typeof ut != "boolean") {
                            if (typeof ut == "string") {
                                const ht = ft._flags.sensitive ? ut : ut.toLowerCase();
                                ut = ht === "true" || ht !== "false" && ut
                            }
                            return typeof ut != "boolean" && (ut = ft.$_terms.truthy && ft.$_terms.truthy.has(ut, null, null, !ft._flags.sensitive) || (!ft.$_terms.falsy || !ft.$_terms.falsy.has(ut, null, null, !ft._flags.sensitive)) && ut),
                            {
                                value: ut
                            }
                        }
                    },
                    validate(ut, {error: ft}) {
                        if (typeof ut != "boolean")
                            return {
                                value: ut,
                                errors: ft("boolean.base")
                            }
                    },
                    rules: {
                        truthy: {
                            method(...ut) {
                                lt.verifyFlat(ut, "truthy");
                                const ft = this.clone();
                                ft.$_terms.truthy = ft.$_terms.truthy || new dt;
                                for (let ht = 0; ht < ut.length; ++ht) {
                                    const gt = ut[ht];
                                    at(gt !== void 0, "Cannot call truthy with undefined"),
                                    ft.$_terms.truthy.add(gt)
                                }
                                return ft
                            }
                        },
                        falsy: {
                            method(...ut) {
                                lt.verifyFlat(ut, "falsy");
                                const ft = this.clone();
                                ft.$_terms.falsy = ft.$_terms.falsy || new dt;
                                for (let ht = 0; ht < ut.length; ++ht) {
                                    const gt = ut[ht];
                                    at(gt !== void 0, "Cannot call falsy with undefined"),
                                    ft.$_terms.falsy.add(gt)
                                }
                                return ft
                            }
                        },
                        sensitive: {
                            method(ut=!0) {
                                return this.$_setFlag("sensitive", ut)
                            }
                        }
                    },
                    cast: {
                        number: {
                            from: ct.isBool,
                            to: (ut,ft)=>ut ? 1 : 0
                        },
                        string: {
                            from: ct.isBool,
                            to: (ut,ft)=>ut ? "true" : "false"
                        }
                    },
                    manifest: {
                        build: (ut,ft)=>(ft.truthy && (ut = ut.truthy(...ft.truthy)),
                        ft.falsy && (ut = ut.falsy(...ft.falsy)),
                        ut)
                    },
                    messages: {
                        "boolean.base": "{{#label}} must be a boolean"
                    }
                })
            }
            ,
            7500: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8068)
                  , lt = st(8160)
                  , dt = st(3328)
                  , ct = {
                    isDate: function(ut) {
                        return ut instanceof Date
                    }
                };
                nt.exports = ot.extend({
                    type: "date",
                    coerce: {
                        from: ["number", "string"],
                        method: (ut,{schema: ft})=>({
                            value: ct.parse(ut, ft._flags.format) || ut
                        })
                    },
                    validate(ut, {schema: ft, error: ht, prefs: gt}) {
                        if (ut instanceof Date && !isNaN(ut.getTime()))
                            return;
                        const bt = ft._flags.format;
                        return gt.convert && bt && typeof ut == "string" ? {
                            value: ut,
                            errors: ht("date.format", {
                                format: bt
                            })
                        } : {
                            value: ut,
                            errors: ht("date.base")
                        }
                    },
                    rules: {
                        compare: {
                            method: !1,
                            validate(ut, ft, {date: ht}, {name: gt, operator: bt, args: pt}) {
                                const mt = ht === "now" ? Date.now() : ht.getTime();
                                return lt.compare(ut.getTime(), mt, bt) ? ut : ft.error("date." + gt, {
                                    limit: pt.date,
                                    value: ut
                                })
                            },
                            args: [{
                                name: "date",
                                ref: !0,
                                normalize: ut=>ut === "now" ? ut : ct.parse(ut),
                                assert: ut=>ut !== null,
                                message: "must have a valid date format"
                            }]
                        },
                        format: {
                            method(ut) {
                                return at(["iso", "javascript", "unix"].includes(ut), "Unknown date format", ut),
                                this.$_setFlag("format", ut)
                            }
                        },
                        greater: {
                            method(ut) {
                                return this.$_addRule({
                                    name: "greater",
                                    method: "compare",
                                    args: {
                                        date: ut
                                    },
                                    operator: ">"
                                })
                            }
                        },
                        iso: {
                            method() {
                                return this.format("iso")
                            }
                        },
                        less: {
                            method(ut) {
                                return this.$_addRule({
                                    name: "less",
                                    method: "compare",
                                    args: {
                                        date: ut
                                    },
                                    operator: "<"
                                })
                            }
                        },
                        max: {
                            method(ut) {
                                return this.$_addRule({
                                    name: "max",
                                    method: "compare",
                                    args: {
                                        date: ut
                                    },
                                    operator: "<="
                                })
                            }
                        },
                        min: {
                            method(ut) {
                                return this.$_addRule({
                                    name: "min",
                                    method: "compare",
                                    args: {
                                        date: ut
                                    },
                                    operator: ">="
                                })
                            }
                        },
                        timestamp: {
                            method(ut="javascript") {
                                return at(["javascript", "unix"].includes(ut), '"type" must be one of "javascript, unix"'),
                                this.format(ut)
                            }
                        }
                    },
                    cast: {
                        number: {
                            from: ct.isDate,
                            to: (ut,ft)=>ut.getTime()
                        },
                        string: {
                            from: ct.isDate,
                            to: (ut,{prefs: ft})=>dt.date(ut, ft)
                        }
                    },
                    messages: {
                        "date.base": "{{#label}} must be a valid date",
                        "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
                        "date.greater": "{{#label}} must be greater than {{:#limit}}",
                        "date.less": "{{#label}} must be less than {{:#limit}}",
                        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
                        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
                        "date.format.iso": "ISO 8601 date",
                        "date.format.javascript": "timestamp or number of milliseconds",
                        "date.format.unix": "timestamp or number of seconds"
                    }
                }),
                ct.parse = function(ut, ft) {
                    if (ut instanceof Date)
                        return ut;
                    if (typeof ut != "string" && (isNaN(ut) || !isFinite(ut)) || /^\s*$/.test(ut))
                        return null;
                    if (ft === "iso")
                        return lt.isIsoDate(ut) ? ct.date(ut.toString()) : null;
                    const ht = ut;
                    if (typeof ut == "string" && /^[+-]?\d+(\.\d+)?$/.test(ut) && (ut = parseFloat(ut)),
                    ft) {
                        if (ft === "javascript")
                            return ct.date(1 * ut);
                        if (ft === "unix")
                            return ct.date(1e3 * ut);
                        if (typeof ht == "string")
                            return null
                    }
                    return ct.date(ut)
                }
                ,
                ct.date = function(ut) {
                    const ft = new Date(ut);
                    return isNaN(ft.getTime()) ? null : ft
                }
            }
            ,
            390: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(7824);
                nt.exports = ot.extend({
                    type: "function",
                    properties: {
                        typeof: "function"
                    },
                    rules: {
                        arity: {
                            method(lt) {
                                return at(Number.isSafeInteger(lt) && lt >= 0, "n must be a positive integer"),
                                this.$_addRule({
                                    name: "arity",
                                    args: {
                                        n: lt
                                    }
                                })
                            },
                            validate: (lt,dt,{n: ct})=>lt.length === ct ? lt : dt.error("function.arity", {
                                n: ct
                            })
                        },
                        class: {
                            method() {
                                return this.$_addRule("class")
                            },
                            validate: (lt,dt)=>/^\s*class\s/.test(lt.toString()) ? lt : dt.error("function.class", {
                                value: lt
                            })
                        },
                        minArity: {
                            method(lt) {
                                return at(Number.isSafeInteger(lt) && lt > 0, "n must be a strict positive integer"),
                                this.$_addRule({
                                    name: "minArity",
                                    args: {
                                        n: lt
                                    }
                                })
                            },
                            validate: (lt,dt,{n: ct})=>lt.length >= ct ? lt : dt.error("function.minArity", {
                                n: ct
                            })
                        },
                        maxArity: {
                            method(lt) {
                                return at(Number.isSafeInteger(lt) && lt >= 0, "n must be a positive integer"),
                                this.$_addRule({
                                    name: "maxArity",
                                    args: {
                                        n: lt
                                    }
                                })
                            },
                            validate: (lt,dt,{n: ct})=>lt.length <= ct ? lt : dt.error("function.maxArity", {
                                n: ct
                            })
                        }
                    },
                    messages: {
                        "function.arity": "{{#label}} must have an arity of {{#n}}",
                        "function.class": "{{#label}} must be a class",
                        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
                        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
                    }
                })
            }
            ,
            7824: (nt,it,st)=>{
                const at = st(978)
                  , ot = st(375)
                  , lt = st(8571)
                  , dt = st(3652)
                  , ct = st(8068)
                  , ut = st(8160)
                  , ft = st(3292)
                  , ht = st(6354)
                  , gt = st(6133)
                  , bt = st(3328)
                  , pt = {
                    renameDefaults: {
                        alias: !1,
                        multiple: !1,
                        override: !1
                    }
                };
                nt.exports = ct.extend({
                    type: "_keys",
                    properties: {
                        typeof: "object"
                    },
                    flags: {
                        unknown: {
                            default: !1
                        }
                    },
                    terms: {
                        dependencies: {
                            init: null
                        },
                        keys: {
                            init: null,
                            manifest: {
                                mapped: {
                                    from: "schema",
                                    to: "key"
                                }
                            }
                        },
                        patterns: {
                            init: null
                        },
                        renames: {
                            init: null
                        }
                    },
                    args: (mt,yt)=>mt.keys(yt),
                    validate(mt, {schema: yt, error: vt, state: wt, prefs: _t}) {
                        if (!mt || typeof mt !== yt.$_property("typeof") || Array.isArray(mt))
                            return {
                                value: mt,
                                errors: vt("object.base", {
                                    type: yt.$_property("typeof")
                                })
                            };
                        if (!(yt.$_terms.renames || yt.$_terms.dependencies || yt.$_terms.keys || yt.$_terms.patterns || yt.$_terms.externals))
                            return;
                        mt = pt.clone(mt, _t);
                        const Et = [];
                        if (yt.$_terms.renames && !pt.rename(yt, mt, wt, _t, Et))
                            return {
                                value: mt,
                                errors: Et
                            };
                        if (!yt.$_terms.keys && !yt.$_terms.patterns && !yt.$_terms.dependencies)
                            return {
                                value: mt,
                                errors: Et
                            };
                        const xt = new Set(Object.keys(mt));
                        if (yt.$_terms.keys) {
                            const Ct = [mt, ...wt.ancestors];
                            for (const Tt of yt.$_terms.keys) {
                                const It = Tt.key
                                  , Nt = mt[It];
                                xt.delete(It);
                                const Ft = wt.localize([...wt.path, It], Ct, Tt)
                                  , Lt = Tt.schema.$_validate(Nt, Ft, _t);
                                if (Lt.errors) {
                                    if (_t.abortEarly)
                                        return {
                                            value: mt,
                                            errors: Lt.errors
                                        };
                                    Lt.value !== void 0 && (mt[It] = Lt.value),
                                    Et.push(...Lt.errors)
                                } else
                                    Tt.schema._flags.result === "strip" || Lt.value === void 0 && Nt !== void 0 ? delete mt[It] : Lt.value !== void 0 && (mt[It] = Lt.value)
                            }
                        }
                        if (xt.size || yt._flags._hasPatternMatch) {
                            const Ct = pt.unknown(yt, mt, xt, Et, wt, _t);
                            if (Ct)
                                return Ct
                        }
                        if (yt.$_terms.dependencies)
                            for (const Ct of yt.$_terms.dependencies) {
                                if (Ct.key !== null && pt.isPresent(Ct.options)(Ct.key.resolve(mt, wt, _t, null, {
                                    shadow: !1
                                })) === !1)
                                    continue;
                                const Tt = pt.dependencies[Ct.rel](yt, Ct, mt, wt, _t);
                                if (Tt) {
                                    const It = yt.$_createError(Tt.code, mt, Tt.context, wt, _t);
                                    if (_t.abortEarly)
                                        return {
                                            value: mt,
                                            errors: It
                                        };
                                    Et.push(It)
                                }
                            }
                        return {
                            value: mt,
                            errors: Et
                        }
                    },
                    rules: {
                        and: {
                            method(...mt) {
                                return ut.verifyFlat(mt, "and"),
                                pt.dependency(this, "and", null, mt)
                            }
                        },
                        append: {
                            method(mt) {
                                return mt == null || Object.keys(mt).length === 0 ? this : this.keys(mt)
                            }
                        },
                        assert: {
                            method(mt, yt, vt) {
                                bt.isTemplate(mt) || (mt = ft.ref(mt)),
                                ot(vt === void 0 || typeof vt == "string", "Message must be a string"),
                                yt = this.$_compile(yt, {
                                    appendPath: !0
                                });
                                const wt = this.$_addRule({
                                    name: "assert",
                                    args: {
                                        subject: mt,
                                        schema: yt,
                                        message: vt
                                    }
                                });
                                return wt.$_mutateRegister(mt),
                                wt.$_mutateRegister(yt),
                                wt
                            },
                            validate(mt, {error: yt, prefs: vt, state: wt}, {subject: _t, schema: Et, message: xt}) {
                                const Ct = _t.resolve(mt, wt, vt)
                                  , Tt = gt.isRef(_t) ? _t.absolute(wt) : [];
                                return Et.$_match(Ct, wt.localize(Tt, [mt, ...wt.ancestors], Et), vt) ? mt : yt("object.assert", {
                                    subject: _t,
                                    message: xt
                                })
                            },
                            args: ["subject", "schema", "message"],
                            multi: !0
                        },
                        instance: {
                            method(mt, yt) {
                                return ot(typeof mt == "function", "constructor must be a function"),
                                yt = yt || mt.name,
                                this.$_addRule({
                                    name: "instance",
                                    args: {
                                        constructor: mt,
                                        name: yt
                                    }
                                })
                            },
                            validate: (mt,yt,{constructor: vt, name: wt})=>mt instanceof vt ? mt : yt.error("object.instance", {
                                type: wt,
                                value: mt
                            }),
                            args: ["constructor", "name"]
                        },
                        keys: {
                            method(mt) {
                                ot(mt === void 0 || typeof mt == "object", "Object schema must be a valid object"),
                                ot(!ut.isSchema(mt), "Object schema cannot be a joi schema");
                                const yt = this.clone();
                                if (mt)
                                    if (Object.keys(mt).length) {
                                        yt.$_terms.keys = yt.$_terms.keys ? yt.$_terms.keys.filter(vt=>!mt.hasOwnProperty(vt.key)) : new pt.Keys;
                                        for (const vt in mt)
                                            ut.tryWithPath(()=>yt.$_terms.keys.push({
                                                key: vt,
                                                schema: this.$_compile(mt[vt])
                                            }), vt)
                                    } else
                                        yt.$_terms.keys = new pt.Keys;
                                else
                                    yt.$_terms.keys = null;
                                return yt.$_mutateRebuild()
                            }
                        },
                        length: {
                            method(mt) {
                                return this.$_addRule({
                                    name: "length",
                                    args: {
                                        limit: mt
                                    },
                                    operator: "="
                                })
                            },
                            validate: (mt,yt,{limit: vt},{name: wt, operator: _t, args: Et})=>ut.compare(Object.keys(mt).length, vt, _t) ? mt : yt.error("object." + wt, {
                                limit: Et.limit,
                                value: mt
                            }),
                            args: [{
                                name: "limit",
                                ref: !0,
                                assert: ut.limit,
                                message: "must be a positive integer"
                            }]
                        },
                        max: {
                            method(mt) {
                                return this.$_addRule({
                                    name: "max",
                                    method: "length",
                                    args: {
                                        limit: mt
                                    },
                                    operator: "<="
                                })
                            }
                        },
                        min: {
                            method(mt) {
                                return this.$_addRule({
                                    name: "min",
                                    method: "length",
                                    args: {
                                        limit: mt
                                    },
                                    operator: ">="
                                })
                            }
                        },
                        nand: {
                            method(...mt) {
                                return ut.verifyFlat(mt, "nand"),
                                pt.dependency(this, "nand", null, mt)
                            }
                        },
                        or: {
                            method(...mt) {
                                return ut.verifyFlat(mt, "or"),
                                pt.dependency(this, "or", null, mt)
                            }
                        },
                        oxor: {
                            method(...mt) {
                                return pt.dependency(this, "oxor", null, mt)
                            }
                        },
                        pattern: {
                            method(mt, yt, vt={}) {
                                const wt = mt instanceof RegExp;
                                wt || (mt = this.$_compile(mt, {
                                    appendPath: !0
                                })),
                                ot(yt !== void 0, "Invalid rule"),
                                ut.assertOptions(vt, ["fallthrough", "matches"]),
                                wt && ot(!mt.flags.includes("g") && !mt.flags.includes("y"), "pattern should not use global or sticky mode"),
                                yt = this.$_compile(yt, {
                                    appendPath: !0
                                });
                                const _t = this.clone();
                                _t.$_terms.patterns = _t.$_terms.patterns || [];
                                const Et = {
                                    [wt ? "regex" : "schema"]: mt,
                                    rule: yt
                                };
                                return vt.matches && (Et.matches = this.$_compile(vt.matches),
                                Et.matches.type !== "array" && (Et.matches = Et.matches.$_root.array().items(Et.matches)),
                                _t.$_mutateRegister(Et.matches),
                                _t.$_setFlag("_hasPatternMatch", !0, {
                                    clone: !1
                                })),
                                vt.fallthrough && (Et.fallthrough = !0),
                                _t.$_terms.patterns.push(Et),
                                _t.$_mutateRegister(yt),
                                _t
                            }
                        },
                        ref: {
                            method() {
                                return this.$_addRule("ref")
                            },
                            validate: (mt,yt)=>gt.isRef(mt) ? mt : yt.error("object.refType", {
                                value: mt
                            })
                        },
                        regex: {
                            method() {
                                return this.$_addRule("regex")
                            },
                            validate: (mt,yt)=>mt instanceof RegExp ? mt : yt.error("object.regex", {
                                value: mt
                            })
                        },
                        rename: {
                            method(mt, yt, vt={}) {
                                ot(typeof mt == "string" || mt instanceof RegExp, "Rename missing the from argument"),
                                ot(typeof yt == "string" || yt instanceof bt, "Invalid rename to argument"),
                                ot(yt !== mt, "Cannot rename key to same name:", mt),
                                ut.assertOptions(vt, ["alias", "ignoreUndefined", "override", "multiple"]);
                                const wt = this.clone();
                                wt.$_terms.renames = wt.$_terms.renames || [];
                                for (const _t of wt.$_terms.renames)
                                    ot(_t.from !== mt, "Cannot rename the same key multiple times");
                                return yt instanceof bt && wt.$_mutateRegister(yt),
                                wt.$_terms.renames.push({
                                    from: mt,
                                    to: yt,
                                    options: at(pt.renameDefaults, vt)
                                }),
                                wt
                            }
                        },
                        schema: {
                            method(mt="any") {
                                return this.$_addRule({
                                    name: "schema",
                                    args: {
                                        type: mt
                                    }
                                })
                            },
                            validate: (mt,yt,{type: vt})=>!ut.isSchema(mt) || vt !== "any" && mt.type !== vt ? yt.error("object.schema", {
                                type: vt
                            }) : mt
                        },
                        unknown: {
                            method(mt) {
                                return this.$_setFlag("unknown", mt !== !1)
                            }
                        },
                        with: {
                            method(mt, yt, vt={}) {
                                return pt.dependency(this, "with", mt, yt, vt)
                            }
                        },
                        without: {
                            method(mt, yt, vt={}) {
                                return pt.dependency(this, "without", mt, yt, vt)
                            }
                        },
                        xor: {
                            method(...mt) {
                                return ut.verifyFlat(mt, "xor"),
                                pt.dependency(this, "xor", null, mt)
                            }
                        }
                    },
                    overrides: {
                        default(mt, yt) {
                            return mt === void 0 && (mt = ut.symbols.deepDefault),
                            this.$_parent("default", mt, yt)
                        }
                    },
                    rebuild(mt) {
                        if (mt.$_terms.keys) {
                            const yt = new dt.Sorter;
                            for (const vt of mt.$_terms.keys)
                                ut.tryWithPath(()=>yt.add(vt, {
                                    after: vt.schema.$_rootReferences(),
                                    group: vt.key
                                }), vt.key);
                            mt.$_terms.keys = new pt.Keys(...yt.nodes)
                        }
                    },
                    manifest: {
                        build(mt, yt) {
                            if (yt.keys && (mt = mt.keys(yt.keys)),
                            yt.dependencies)
                                for (const {rel: vt, key: wt=null, peers: _t, options: Et} of yt.dependencies)
                                    mt = pt.dependency(mt, vt, wt, _t, Et);
                            if (yt.patterns)
                                for (const {regex: vt, schema: wt, rule: _t, fallthrough: Et, matches: xt} of yt.patterns)
                                    mt = mt.pattern(vt || wt, _t, {
                                        fallthrough: Et,
                                        matches: xt
                                    });
                            if (yt.renames)
                                for (const {from: vt, to: wt, options: _t} of yt.renames)
                                    mt = mt.rename(vt, wt, _t);
                            return mt
                        }
                    },
                    messages: {
                        "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
                        "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
                        "object.base": "{{#label}} must be of type {{#type}}",
                        "object.instance": "{{#label}} must be an instance of {{:#type}}",
                        "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
                        "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
                        "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
                        "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
                        "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
                        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
                        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
                        "object.refType": "{{#label}} must be a Joi reference",
                        "object.regex": "{{#label}} must be a RegExp object",
                        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
                        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
                        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
                        "object.unknown": "{{#label}} is not allowed",
                        "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
                        "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
                        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
                    }
                }),
                pt.clone = function(mt, yt) {
                    if (typeof mt == "object") {
                        if (yt.nonEnumerables)
                            return lt(mt, {
                                shallow: !0
                            });
                        const wt = Object.create(Object.getPrototypeOf(mt));
                        return Object.assign(wt, mt),
                        wt
                    }
                    const vt = function(...wt) {
                        return mt.apply(this, wt)
                    };
                    return vt.prototype = lt(mt.prototype),
                    Object.defineProperty(vt, "name", {
                        value: mt.name,
                        writable: !1
                    }),
                    Object.defineProperty(vt, "length", {
                        value: mt.length,
                        writable: !1
                    }),
                    Object.assign(vt, mt),
                    vt
                }
                ,
                pt.dependency = function(mt, yt, vt, wt, _t) {
                    ot(vt === null || typeof vt == "string", yt, "key must be a strings"),
                    _t || (_t = wt.length > 1 && typeof wt[wt.length - 1] == "object" ? wt.pop() : {}),
                    ut.assertOptions(_t, ["separator", "isPresent"]),
                    wt = [].concat(wt);
                    const Et = ut.default(_t.separator, ".")
                      , xt = [];
                    for (const Tt of wt)
                        ot(typeof Tt == "string", yt, "peers must be strings"),
                        xt.push(ft.ref(Tt, {
                            separator: Et,
                            ancestor: 0,
                            prefix: !1
                        }));
                    vt !== null && (vt = ft.ref(vt, {
                        separator: Et,
                        ancestor: 0,
                        prefix: !1
                    }));
                    const Ct = mt.clone();
                    return Ct.$_terms.dependencies = Ct.$_terms.dependencies || [],
                    Ct.$_terms.dependencies.push(new pt.Dependency(yt,vt,xt,wt,_t)),
                    Ct
                }
                ,
                pt.dependencies = {
                    and(mt, yt, vt, wt, _t) {
                        const Et = []
                          , xt = []
                          , Ct = yt.peers.length
                          , Tt = pt.isPresent(yt.options);
                        for (const It of yt.peers)
                            Tt(It.resolve(vt, wt, _t, null, {
                                shadow: !1
                            })) === !1 ? Et.push(It.key) : xt.push(It.key);
                        if (Et.length !== Ct && xt.length !== Ct)
                            return {
                                code: "object.and",
                                context: {
                                    present: xt,
                                    presentWithLabels: pt.keysToLabels(mt, xt),
                                    missing: Et,
                                    missingWithLabels: pt.keysToLabels(mt, Et)
                                }
                            }
                    },
                    nand(mt, yt, vt, wt, _t) {
                        const Et = []
                          , xt = pt.isPresent(yt.options);
                        for (const It of yt.peers)
                            xt(It.resolve(vt, wt, _t, null, {
                                shadow: !1
                            })) && Et.push(It.key);
                        if (Et.length !== yt.peers.length)
                            return;
                        const Ct = yt.paths[0]
                          , Tt = yt.paths.slice(1);
                        return {
                            code: "object.nand",
                            context: {
                                main: Ct,
                                mainWithLabel: pt.keysToLabels(mt, Ct),
                                peers: Tt,
                                peersWithLabels: pt.keysToLabels(mt, Tt)
                            }
                        }
                    },
                    or(mt, yt, vt, wt, _t) {
                        const Et = pt.isPresent(yt.options);
                        for (const xt of yt.peers)
                            if (Et(xt.resolve(vt, wt, _t, null, {
                                shadow: !1
                            })))
                                return;
                        return {
                            code: "object.missing",
                            context: {
                                peers: yt.paths,
                                peersWithLabels: pt.keysToLabels(mt, yt.paths)
                            }
                        }
                    },
                    oxor(mt, yt, vt, wt, _t) {
                        const Et = []
                          , xt = pt.isPresent(yt.options);
                        for (const Tt of yt.peers)
                            xt(Tt.resolve(vt, wt, _t, null, {
                                shadow: !1
                            })) && Et.push(Tt.key);
                        if (!Et.length || Et.length === 1)
                            return;
                        const Ct = {
                            peers: yt.paths,
                            peersWithLabels: pt.keysToLabels(mt, yt.paths)
                        };
                        return Ct.present = Et,
                        Ct.presentWithLabels = pt.keysToLabels(mt, Et),
                        {
                            code: "object.oxor",
                            context: Ct
                        }
                    },
                    with(mt, yt, vt, wt, _t) {
                        const Et = pt.isPresent(yt.options);
                        for (const xt of yt.peers)
                            if (Et(xt.resolve(vt, wt, _t, null, {
                                shadow: !1
                            })) === !1)
                                return {
                                    code: "object.with",
                                    context: {
                                        main: yt.key.key,
                                        mainWithLabel: pt.keysToLabels(mt, yt.key.key),
                                        peer: xt.key,
                                        peerWithLabel: pt.keysToLabels(mt, xt.key)
                                    }
                                }
                    },
                    without(mt, yt, vt, wt, _t) {
                        const Et = pt.isPresent(yt.options);
                        for (const xt of yt.peers)
                            if (Et(xt.resolve(vt, wt, _t, null, {
                                shadow: !1
                            })))
                                return {
                                    code: "object.without",
                                    context: {
                                        main: yt.key.key,
                                        mainWithLabel: pt.keysToLabels(mt, yt.key.key),
                                        peer: xt.key,
                                        peerWithLabel: pt.keysToLabels(mt, xt.key)
                                    }
                                }
                    },
                    xor(mt, yt, vt, wt, _t) {
                        const Et = []
                          , xt = pt.isPresent(yt.options);
                        for (const Tt of yt.peers)
                            xt(Tt.resolve(vt, wt, _t, null, {
                                shadow: !1
                            })) && Et.push(Tt.key);
                        if (Et.length === 1)
                            return;
                        const Ct = {
                            peers: yt.paths,
                            peersWithLabels: pt.keysToLabels(mt, yt.paths)
                        };
                        return Et.length === 0 ? {
                            code: "object.missing",
                            context: Ct
                        } : (Ct.present = Et,
                        Ct.presentWithLabels = pt.keysToLabels(mt, Et),
                        {
                            code: "object.xor",
                            context: Ct
                        })
                    }
                },
                pt.keysToLabels = function(mt, yt) {
                    return Array.isArray(yt) ? yt.map(vt=>mt.$_mapLabels(vt)) : mt.$_mapLabels(yt)
                }
                ,
                pt.isPresent = function(mt) {
                    return typeof mt.isPresent == "function" ? mt.isPresent : yt=>yt !== void 0
                }
                ,
                pt.rename = function(mt, yt, vt, wt, _t) {
                    const Et = {};
                    for (const xt of mt.$_terms.renames) {
                        const Ct = []
                          , Tt = typeof xt.from != "string";
                        if (Tt)
                            for (const It in yt) {
                                if (yt[It] === void 0 && xt.options.ignoreUndefined || It === xt.to)
                                    continue;
                                const Nt = xt.from.exec(It);
                                Nt && Ct.push({
                                    from: It,
                                    to: xt.to,
                                    match: Nt
                                })
                            }
                        else
                            !Object.prototype.hasOwnProperty.call(yt, xt.from) || yt[xt.from] === void 0 && xt.options.ignoreUndefined || Ct.push(xt);
                        for (const It of Ct) {
                            const Nt = It.from;
                            let Ft = It.to;
                            if (Ft instanceof bt && (Ft = Ft.render(yt, vt, wt, It.match)),
                            Nt !== Ft) {
                                if (!xt.options.multiple && Et[Ft] && (_t.push(mt.$_createError("object.rename.multiple", yt, {
                                    from: Nt,
                                    to: Ft,
                                    pattern: Tt
                                }, vt, wt)),
                                wt.abortEarly) || Object.prototype.hasOwnProperty.call(yt, Ft) && !xt.options.override && !Et[Ft] && (_t.push(mt.$_createError("object.rename.override", yt, {
                                    from: Nt,
                                    to: Ft,
                                    pattern: Tt
                                }, vt, wt)),
                                wt.abortEarly))
                                    return !1;
                                yt[Nt] === void 0 ? delete yt[Ft] : yt[Ft] = yt[Nt],
                                Et[Ft] = !0,
                                xt.options.alias || delete yt[Nt]
                            }
                        }
                    }
                    return !0
                }
                ,
                pt.unknown = function(mt, yt, vt, wt, _t, Et) {
                    if (mt.$_terms.patterns) {
                        let xt = !1;
                        const Ct = mt.$_terms.patterns.map(It=>{
                            if (It.matches)
                                return xt = !0,
                                []
                        }
                        )
                          , Tt = [yt, ..._t.ancestors];
                        for (const It of vt) {
                            const Nt = yt[It]
                              , Ft = [..._t.path, It];
                            for (let Lt = 0; Lt < mt.$_terms.patterns.length; ++Lt) {
                                const Mt = mt.$_terms.patterns[Lt];
                                if (Mt.regex) {
                                    const At = Mt.regex.test(It);
                                    if (_t.mainstay.tracer.debug(_t, "rule", `pattern.${Lt}`, At ? "pass" : "error"),
                                    !At)
                                        continue
                                } else if (!Mt.schema.$_match(It, _t.nest(Mt.schema, `pattern.${Lt}`), Et))
                                    continue;
                                vt.delete(It);
                                const $t = _t.localize(Ft, Tt, {
                                    schema: Mt.rule,
                                    key: It
                                })
                                  , kt = Mt.rule.$_validate(Nt, $t, Et);
                                if (kt.errors) {
                                    if (Et.abortEarly)
                                        return {
                                            value: yt,
                                            errors: kt.errors
                                        };
                                    wt.push(...kt.errors)
                                }
                                if (Mt.matches && Ct[Lt].push(It),
                                yt[It] = kt.value,
                                !Mt.fallthrough)
                                    break
                            }
                        }
                        if (xt)
                            for (let It = 0; It < Ct.length; ++It) {
                                const Nt = Ct[It];
                                if (!Nt)
                                    continue;
                                const Ft = mt.$_terms.patterns[It].matches
                                  , Lt = _t.localize(_t.path, Tt, Ft)
                                  , Mt = Ft.$_validate(Nt, Lt, Et);
                                if (Mt.errors) {
                                    const $t = ht.details(Mt.errors, {
                                        override: !1
                                    });
                                    $t.matches = Nt;
                                    const kt = mt.$_createError("object.pattern.match", yt, $t, _t, Et);
                                    if (Et.abortEarly)
                                        return {
                                            value: yt,
                                            errors: kt
                                        };
                                    wt.push(kt)
                                }
                            }
                    }
                    if (vt.size && (mt.$_terms.keys || mt.$_terms.patterns)) {
                        if (Et.stripUnknown && !mt._flags.unknown || Et.skipFunctions) {
                            const xt = !(!Et.stripUnknown || Et.stripUnknown !== !0 && !Et.stripUnknown.objects);
                            for (const Ct of vt)
                                xt ? (delete yt[Ct],
                                vt.delete(Ct)) : typeof yt[Ct] == "function" && vt.delete(Ct)
                        }
                        if (!ut.default(mt._flags.unknown, Et.allowUnknown))
                            for (const xt of vt) {
                                const Ct = _t.localize([..._t.path, xt], [])
                                  , Tt = mt.$_createError("object.unknown", yt[xt], {
                                    child: xt
                                }, Ct, Et, {
                                    flags: !1
                                });
                                if (Et.abortEarly)
                                    return {
                                        value: yt,
                                        errors: Tt
                                    };
                                wt.push(Tt)
                            }
                    }
                }
                ,
                pt.Dependency = class {
                    constructor(mt, yt, vt, wt, _t) {
                        this.rel = mt,
                        this.key = yt,
                        this.peers = vt,
                        this.paths = wt,
                        this.options = _t
                    }
                    describe() {
                        const mt = {
                            rel: this.rel,
                            peers: this.paths
                        };
                        return this.key !== null && (mt.key = this.key.key),
                        this.peers[0].separator !== "." && (mt.options = {
                            ...mt.options,
                            separator: this.peers[0].separator
                        }),
                        this.options.isPresent && (mt.options = {
                            ...mt.options,
                            isPresent: this.options.isPresent
                        }),
                        mt
                    }
                }
                ,
                pt.Keys = class extends Array {
                    concat(mt) {
                        const yt = this.slice()
                          , vt = new Map;
                        for (let wt = 0; wt < yt.length; ++wt)
                            vt.set(yt[wt].key, wt);
                        for (const wt of mt) {
                            const _t = wt.key
                              , Et = vt.get(_t);
                            Et !== void 0 ? yt[Et] = {
                                key: _t,
                                schema: yt[Et].schema.concat(wt.schema)
                            } : yt.push(wt)
                        }
                        return yt
                    }
                }
            }
            ,
            8785: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8068)
                  , lt = st(8160)
                  , dt = st(3292)
                  , ct = st(6354)
                  , ut = {};
                nt.exports = ot.extend({
                    type: "link",
                    properties: {
                        schemaChain: !0
                    },
                    terms: {
                        link: {
                            init: null,
                            manifest: "single",
                            register: !1
                        }
                    },
                    args: (ft,ht)=>ft.ref(ht),
                    validate(ft, {schema: ht, state: gt, prefs: bt}) {
                        at(ht.$_terms.link, "Uninitialized link schema");
                        const pt = ut.generate(ht, ft, gt, bt)
                          , mt = ht.$_terms.link[0].ref;
                        return pt.$_validate(ft, gt.nest(pt, `link:${mt.display}:${pt.type}`), bt)
                    },
                    generate: (ft,ht,gt,bt)=>ut.generate(ft, ht, gt, bt),
                    rules: {
                        ref: {
                            method(ft) {
                                at(!this.$_terms.link, "Cannot reinitialize schema"),
                                ft = dt.ref(ft),
                                at(ft.type === "value" || ft.type === "local", "Invalid reference type:", ft.type),
                                at(ft.type === "local" || ft.ancestor === "root" || ft.ancestor > 0, "Link cannot reference itself");
                                const ht = this.clone();
                                return ht.$_terms.link = [{
                                    ref: ft
                                }],
                                ht
                            }
                        },
                        relative: {
                            method(ft=!0) {
                                return this.$_setFlag("relative", ft)
                            }
                        }
                    },
                    overrides: {
                        concat(ft) {
                            at(this.$_terms.link, "Uninitialized link schema"),
                            at(lt.isSchema(ft), "Invalid schema object"),
                            at(ft.type !== "link", "Cannot merge type link with another link");
                            const ht = this.clone();
                            return ht.$_terms.whens || (ht.$_terms.whens = []),
                            ht.$_terms.whens.push({
                                concat: ft
                            }),
                            ht.$_mutateRebuild()
                        }
                    },
                    manifest: {
                        build: (ft,ht)=>(at(ht.link, "Invalid link description missing link"),
                        ft.ref(ht.link))
                    }
                }),
                ut.generate = function(ft, ht, gt, bt) {
                    let pt = gt.mainstay.links.get(ft);
                    if (pt)
                        return pt._generate(ht, gt, bt).schema;
                    const mt = ft.$_terms.link[0].ref
                      , {perspective: yt, path: vt} = ut.perspective(mt, gt);
                    ut.assert(yt, "which is outside of schema boundaries", mt, ft, gt, bt);
                    try {
                        pt = vt.length ? yt.$_reach(vt) : yt
                    } catch {
                        ut.assert(!1, "to non-existing schema", mt, ft, gt, bt)
                    }
                    return ut.assert(pt.type !== "link", "which is another link", mt, ft, gt, bt),
                    ft._flags.relative || gt.mainstay.links.set(ft, pt),
                    pt._generate(ht, gt, bt).schema
                }
                ,
                ut.perspective = function(ft, ht) {
                    if (ft.type === "local") {
                        for (const {schema: gt, key: bt} of ht.schemas) {
                            if ((gt._flags.id || bt) === ft.path[0])
                                return {
                                    perspective: gt,
                                    path: ft.path.slice(1)
                                };
                            if (gt.$_terms.shared) {
                                for (const pt of gt.$_terms.shared)
                                    if (pt._flags.id === ft.path[0])
                                        return {
                                            perspective: pt,
                                            path: ft.path.slice(1)
                                        }
                            }
                        }
                        return {
                            perspective: null,
                            path: null
                        }
                    }
                    return ft.ancestor === "root" ? {
                        perspective: ht.schemas[ht.schemas.length - 1].schema,
                        path: ft.path
                    } : {
                        perspective: ht.schemas[ft.ancestor] && ht.schemas[ft.ancestor].schema,
                        path: ft.path
                    }
                }
                ,
                ut.assert = function(ft, ht, gt, bt, pt, mt) {
                    ft || at(!1, `"${ct.label(bt._flags, pt, mt)}" contains link reference "${gt.display}" ${ht}`)
                }
            }
            ,
            3832: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8068)
                  , lt = st(8160)
                  , dt = {
                    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
                    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
                    exponentialPartRegex: /[eE][+-]?\d+$/,
                    leadingSignAndZerosRegex: /^[+-]?(0*)?/,
                    dotRegex: /\./,
                    trailingZerosRegex: /0+$/,
                    decimalPlaces(ct) {
                        const ut = ct.toString()
                          , ft = ut.indexOf(".")
                          , ht = ut.indexOf("e");
                        return (ft < 0 ? 0 : (ht < 0 ? ut.length : ht) - ft - 1) + (ht < 0 ? 0 : Math.max(0, -parseInt(ut.slice(ht + 1))))
                    }
                };
                nt.exports = ot.extend({
                    type: "number",
                    flags: {
                        unsafe: {
                            default: !1
                        }
                    },
                    coerce: {
                        from: "string",
                        method(ct, {schema: ut, error: ft}) {
                            if (!ct.match(dt.numberRx))
                                return;
                            ct = ct.trim();
                            const ht = {
                                value: parseFloat(ct)
                            };
                            if (ht.value === 0 && (ht.value = 0),
                            !ut._flags.unsafe)
                                if (ct.match(/e/i)) {
                                    if (dt.extractSignificantDigits(ct) !== dt.extractSignificantDigits(String(ht.value)))
                                        return ht.errors = ft("number.unsafe"),
                                        ht
                                } else {
                                    const gt = ht.value.toString();
                                    if (gt.match(/e/i))
                                        return ht;
                                    if (gt !== dt.normalizeDecimal(ct))
                                        return ht.errors = ft("number.unsafe"),
                                        ht
                                }
                            return ht
                        }
                    },
                    validate(ct, {schema: ut, error: ft, prefs: ht}) {
                        if (ct === 1 / 0 || ct === -1 / 0)
                            return {
                                value: ct,
                                errors: ft("number.infinity")
                            };
                        if (!lt.isNumber(ct))
                            return {
                                value: ct,
                                errors: ft("number.base")
                            };
                        const gt = {
                            value: ct
                        };
                        if (ht.convert) {
                            const bt = ut.$_getRule("precision");
                            if (bt) {
                                const pt = Math.pow(10, bt.args.limit);
                                gt.value = Math.round(gt.value * pt) / pt
                            }
                        }
                        return gt.value === 0 && (gt.value = 0),
                        !ut._flags.unsafe && (ct > Number.MAX_SAFE_INTEGER || ct < Number.MIN_SAFE_INTEGER) && (gt.errors = ft("number.unsafe")),
                        gt
                    },
                    rules: {
                        compare: {
                            method: !1,
                            validate: (ct,ut,{limit: ft},{name: ht, operator: gt, args: bt})=>lt.compare(ct, ft, gt) ? ct : ut.error("number." + ht, {
                                limit: bt.limit,
                                value: ct
                            }),
                            args: [{
                                name: "limit",
                                ref: !0,
                                assert: lt.isNumber,
                                message: "must be a number"
                            }]
                        },
                        greater: {
                            method(ct) {
                                return this.$_addRule({
                                    name: "greater",
                                    method: "compare",
                                    args: {
                                        limit: ct
                                    },
                                    operator: ">"
                                })
                            }
                        },
                        integer: {
                            method() {
                                return this.$_addRule("integer")
                            },
                            validate: (ct,ut)=>Math.trunc(ct) - ct == 0 ? ct : ut.error("number.integer")
                        },
                        less: {
                            method(ct) {
                                return this.$_addRule({
                                    name: "less",
                                    method: "compare",
                                    args: {
                                        limit: ct
                                    },
                                    operator: "<"
                                })
                            }
                        },
                        max: {
                            method(ct) {
                                return this.$_addRule({
                                    name: "max",
                                    method: "compare",
                                    args: {
                                        limit: ct
                                    },
                                    operator: "<="
                                })
                            }
                        },
                        min: {
                            method(ct) {
                                return this.$_addRule({
                                    name: "min",
                                    method: "compare",
                                    args: {
                                        limit: ct
                                    },
                                    operator: ">="
                                })
                            }
                        },
                        multiple: {
                            method(ct) {
                                const ut = typeof ct == "number" ? dt.decimalPlaces(ct) : null
                                  , ft = Math.pow(10, ut);
                                return this.$_addRule({
                                    name: "multiple",
                                    args: {
                                        base: ct,
                                        baseDecimalPlace: ut,
                                        pfactor: ft
                                    }
                                })
                            },
                            validate: (ct,ut,{base: ft, baseDecimalPlace: ht, pfactor: gt},bt)=>dt.decimalPlaces(ct) > ht ? ut.error("number.multiple", {
                                multiple: bt.args.base,
                                value: ct
                            }) : Math.round(gt * ct) % Math.round(gt * ft) == 0 ? ct : ut.error("number.multiple", {
                                multiple: bt.args.base,
                                value: ct
                            }),
                            args: [{
                                name: "base",
                                ref: !0,
                                assert: ct=>typeof ct == "number" && isFinite(ct) && ct > 0,
                                message: "must be a positive number"
                            }, "baseDecimalPlace", "pfactor"],
                            multi: !0
                        },
                        negative: {
                            method() {
                                return this.sign("negative")
                            }
                        },
                        port: {
                            method() {
                                return this.$_addRule("port")
                            },
                            validate: (ct,ut)=>Number.isSafeInteger(ct) && ct >= 0 && ct <= 65535 ? ct : ut.error("number.port")
                        },
                        positive: {
                            method() {
                                return this.sign("positive")
                            }
                        },
                        precision: {
                            method(ct) {
                                return at(Number.isSafeInteger(ct), "limit must be an integer"),
                                this.$_addRule({
                                    name: "precision",
                                    args: {
                                        limit: ct
                                    }
                                })
                            },
                            validate(ct, ut, {limit: ft}) {
                                const ht = ct.toString().match(dt.precisionRx);
                                return Math.max((ht[1] ? ht[1].length : 0) - (ht[2] ? parseInt(ht[2], 10) : 0), 0) <= ft ? ct : ut.error("number.precision", {
                                    limit: ft,
                                    value: ct
                                })
                            },
                            convert: !0
                        },
                        sign: {
                            method(ct) {
                                return at(["negative", "positive"].includes(ct), "Invalid sign", ct),
                                this.$_addRule({
                                    name: "sign",
                                    args: {
                                        sign: ct
                                    }
                                })
                            },
                            validate: (ct,ut,{sign: ft})=>ft === "negative" && ct < 0 || ft === "positive" && ct > 0 ? ct : ut.error(`number.${ft}`)
                        },
                        unsafe: {
                            method(ct=!0) {
                                return at(typeof ct == "boolean", "enabled must be a boolean"),
                                this.$_setFlag("unsafe", ct)
                            }
                        }
                    },
                    cast: {
                        string: {
                            from: ct=>typeof ct == "number",
                            to: (ct,ut)=>ct.toString()
                        }
                    },
                    messages: {
                        "number.base": "{{#label}} must be a number",
                        "number.greater": "{{#label}} must be greater than {{#limit}}",
                        "number.infinity": "{{#label}} cannot be infinity",
                        "number.integer": "{{#label}} must be an integer",
                        "number.less": "{{#label}} must be less than {{#limit}}",
                        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
                        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
                        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
                        "number.negative": "{{#label}} must be a negative number",
                        "number.port": "{{#label}} must be a valid port",
                        "number.positive": "{{#label}} must be a positive number",
                        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
                        "number.unsafe": "{{#label}} must be a safe number"
                    }
                }),
                dt.extractSignificantDigits = function(ct) {
                    return ct.replace(dt.exponentialPartRegex, "").replace(dt.dotRegex, "").replace(dt.trailingZerosRegex, "").replace(dt.leadingSignAndZerosRegex, "")
                }
                ,
                dt.normalizeDecimal = function(ct) {
                    return (ct = ct.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") && ct.endsWith("0") && (ct = ct.replace(/0+$/, "")),
                    ct === "-0" ? "0" : ct
                }
            }
            ,
            8966: (nt,it,st)=>{
                const at = st(7824);
                nt.exports = at.extend({
                    type: "object",
                    cast: {
                        map: {
                            from: ot=>ot && typeof ot == "object",
                            to: (ot,lt)=>new Map(Object.entries(ot))
                        }
                    }
                })
            }
            ,
            7417: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(5380)
                  , lt = st(1745)
                  , dt = st(9959)
                  , ct = st(6064)
                  , ut = st(9926)
                  , ft = st(5752)
                  , ht = st(8068)
                  , gt = st(8160)
                  , bt = {
                    tlds: ut instanceof Set && {
                        tlds: {
                            allow: ut,
                            deny: null
                        }
                    },
                    base64Regex: {
                        true: {
                            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
                            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
                        },
                        false: {
                            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
                            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
                        }
                    },
                    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
                    hexRegex: {
                        withPrefix: /^0x[0-9a-f]+$/i,
                        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
                        withoutPrefix: /^[0-9a-f]+$/i
                    },
                    ipRegex: dt.regex({
                        cidr: "forbidden"
                    }).regex,
                    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
                    guidBrackets: {
                        "{": "}",
                        "[": "]",
                        "(": ")",
                        "": ""
                    },
                    guidVersions: {
                        uuidv1: "1",
                        uuidv2: "2",
                        uuidv3: "3",
                        uuidv4: "4",
                        uuidv5: "5",
                        uuidv6: "6",
                        uuidv7: "7",
                        uuidv8: "8"
                    },
                    guidSeparators: new Set([void 0, !0, !1, "-", ":"]),
                    normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
                };
                nt.exports = ht.extend({
                    type: "string",
                    flags: {
                        insensitive: {
                            default: !1
                        },
                        truncate: {
                            default: !1
                        }
                    },
                    terms: {
                        replacements: {
                            init: null
                        }
                    },
                    coerce: {
                        from: "string",
                        method(pt, {schema: mt, state: yt, prefs: vt}) {
                            const wt = mt.$_getRule("normalize");
                            wt && (pt = pt.normalize(wt.args.form));
                            const _t = mt.$_getRule("case");
                            _t && (pt = _t.args.direction === "upper" ? pt.toLocaleUpperCase() : pt.toLocaleLowerCase());
                            const Et = mt.$_getRule("trim");
                            if (Et && Et.args.enabled && (pt = pt.trim()),
                            mt.$_terms.replacements)
                                for (const Ct of mt.$_terms.replacements)
                                    pt = pt.replace(Ct.pattern, Ct.replacement);
                            const xt = mt.$_getRule("hex");
                            if (xt && xt.args.options.byteAligned && pt.length % 2 != 0 && (pt = `0${pt}`),
                            mt.$_getRule("isoDate")) {
                                const Ct = bt.isoDate(pt);
                                Ct && (pt = Ct)
                            }
                            if (mt._flags.truncate) {
                                const Ct = mt.$_getRule("max");
                                if (Ct) {
                                    let Tt = Ct.args.limit;
                                    if (gt.isResolvable(Tt) && (Tt = Tt.resolve(pt, yt, vt),
                                    !gt.limit(Tt)))
                                        return {
                                            value: pt,
                                            errors: mt.$_createError("any.ref", Tt, {
                                                ref: Ct.args.limit,
                                                arg: "limit",
                                                reason: "must be a positive integer"
                                            }, yt, vt)
                                        };
                                    pt = pt.slice(0, Tt)
                                }
                            }
                            return {
                                value: pt
                            }
                        }
                    },
                    validate(pt, {schema: mt, error: yt}) {
                        if (typeof pt != "string")
                            return {
                                value: pt,
                                errors: yt("string.base")
                            };
                        if (pt === "") {
                            const vt = mt.$_getRule("min");
                            return vt && vt.args.limit === 0 ? void 0 : {
                                value: pt,
                                errors: yt("string.empty")
                            }
                        }
                    },
                    rules: {
                        alphanum: {
                            method() {
                                return this.$_addRule("alphanum")
                            },
                            validate: (pt,mt)=>/^[a-zA-Z0-9]+$/.test(pt) ? pt : mt.error("string.alphanum")
                        },
                        base64: {
                            method(pt={}) {
                                return gt.assertOptions(pt, ["paddingRequired", "urlSafe"]),
                                pt = {
                                    urlSafe: !1,
                                    paddingRequired: !0,
                                    ...pt
                                },
                                at(typeof pt.paddingRequired == "boolean", "paddingRequired must be boolean"),
                                at(typeof pt.urlSafe == "boolean", "urlSafe must be boolean"),
                                this.$_addRule({
                                    name: "base64",
                                    args: {
                                        options: pt
                                    }
                                })
                            },
                            validate: (pt,mt,{options: yt})=>bt.base64Regex[yt.paddingRequired][yt.urlSafe].test(pt) ? pt : mt.error("string.base64")
                        },
                        case: {
                            method(pt) {
                                return at(["lower", "upper"].includes(pt), "Invalid case:", pt),
                                this.$_addRule({
                                    name: "case",
                                    args: {
                                        direction: pt
                                    }
                                })
                            },
                            validate: (pt,mt,{direction: yt})=>yt === "lower" && pt === pt.toLocaleLowerCase() || yt === "upper" && pt === pt.toLocaleUpperCase() ? pt : mt.error(`string.${yt}case`),
                            convert: !0
                        },
                        creditCard: {
                            method() {
                                return this.$_addRule("creditCard")
                            },
                            validate(pt, mt) {
                                let yt = pt.length
                                  , vt = 0
                                  , wt = 1;
                                for (; yt--; ) {
                                    const _t = pt.charAt(yt) * wt;
                                    vt += _t - 9 * (_t > 9),
                                    wt ^= 3
                                }
                                return vt > 0 && vt % 10 == 0 ? pt : mt.error("string.creditCard")
                            }
                        },
                        dataUri: {
                            method(pt={}) {
                                return gt.assertOptions(pt, ["paddingRequired"]),
                                pt = {
                                    paddingRequired: !0,
                                    ...pt
                                },
                                at(typeof pt.paddingRequired == "boolean", "paddingRequired must be boolean"),
                                this.$_addRule({
                                    name: "dataUri",
                                    args: {
                                        options: pt
                                    }
                                })
                            },
                            validate(pt, mt, {options: yt}) {
                                const vt = pt.match(bt.dataUriRegex);
                                return vt && (!vt[2] || vt[2] !== "base64" || bt.base64Regex[yt.paddingRequired].false.test(vt[3])) ? pt : mt.error("string.dataUri")
                            }
                        },
                        domain: {
                            method(pt) {
                                pt && gt.assertOptions(pt, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
                                const mt = bt.addressOptions(pt);
                                return this.$_addRule({
                                    name: "domain",
                                    args: {
                                        options: pt
                                    },
                                    address: mt
                                })
                            },
                            validate: (pt,mt,yt,{address: vt})=>ot.isValid(pt, vt) ? pt : mt.error("string.domain")
                        },
                        email: {
                            method(pt={}) {
                                gt.assertOptions(pt, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]),
                                at(pt.multiple === void 0 || typeof pt.multiple == "boolean", "multiple option must be an boolean");
                                const mt = bt.addressOptions(pt)
                                  , yt = new RegExp(`\\s*[${pt.separator ? ct(pt.separator) : ","}]\\s*`);
                                return this.$_addRule({
                                    name: "email",
                                    args: {
                                        options: pt
                                    },
                                    regex: yt,
                                    address: mt
                                })
                            },
                            validate(pt, mt, {options: yt}, {regex: vt, address: wt}) {
                                const _t = yt.multiple ? pt.split(vt) : [pt]
                                  , Et = [];
                                for (const xt of _t)
                                    lt.isValid(xt, wt) || Et.push(xt);
                                return Et.length ? mt.error("string.email", {
                                    value: pt,
                                    invalids: Et
                                }) : pt
                            }
                        },
                        guid: {
                            alias: "uuid",
                            method(pt={}) {
                                gt.assertOptions(pt, ["version", "separator"]);
                                let mt = "";
                                if (pt.version) {
                                    const wt = [].concat(pt.version);
                                    at(wt.length >= 1, "version must have at least 1 valid version specified");
                                    const _t = new Set;
                                    for (let Et = 0; Et < wt.length; ++Et) {
                                        const xt = wt[Et];
                                        at(typeof xt == "string", "version at position " + Et + " must be a string");
                                        const Ct = bt.guidVersions[xt.toLowerCase()];
                                        at(Ct, "version at position " + Et + " must be one of " + Object.keys(bt.guidVersions).join(", ")),
                                        at(!_t.has(Ct), "version at position " + Et + " must not be a duplicate"),
                                        mt += Ct,
                                        _t.add(Ct)
                                    }
                                }
                                at(bt.guidSeparators.has(pt.separator), 'separator must be one of true, false, "-", or ":"');
                                const yt = pt.separator === void 0 ? "[:-]?" : pt.separator === !0 ? "[:-]" : pt.separator === !1 ? "[]?" : `\\${pt.separator}`
                                  , vt = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${yt})[0-9A-F]{4}\\2?[${mt || "0-9A-F"}][0-9A-F]{3}\\2?[${mt ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,"i");
                                return this.$_addRule({
                                    name: "guid",
                                    args: {
                                        options: pt
                                    },
                                    regex: vt
                                })
                            },
                            validate(pt, mt, yt, {regex: vt}) {
                                const wt = vt.exec(pt);
                                return wt ? bt.guidBrackets[wt[1]] !== wt[wt.length - 1] ? mt.error("string.guid") : pt : mt.error("string.guid")
                            }
                        },
                        hex: {
                            method(pt={}) {
                                return gt.assertOptions(pt, ["byteAligned", "prefix"]),
                                pt = {
                                    byteAligned: !1,
                                    prefix: !1,
                                    ...pt
                                },
                                at(typeof pt.byteAligned == "boolean", "byteAligned must be boolean"),
                                at(typeof pt.prefix == "boolean" || pt.prefix === "optional", 'prefix must be boolean or "optional"'),
                                this.$_addRule({
                                    name: "hex",
                                    args: {
                                        options: pt
                                    }
                                })
                            },
                            validate: (pt,mt,{options: yt})=>(yt.prefix === "optional" ? bt.hexRegex.withOptionalPrefix : yt.prefix === !0 ? bt.hexRegex.withPrefix : bt.hexRegex.withoutPrefix).test(pt) ? yt.byteAligned && pt.length % 2 != 0 ? mt.error("string.hexAlign") : pt : mt.error("string.hex")
                        },
                        hostname: {
                            method() {
                                return this.$_addRule("hostname")
                            },
                            validate: (pt,mt)=>ot.isValid(pt, {
                                minDomainSegments: 1
                            }) || bt.ipRegex.test(pt) ? pt : mt.error("string.hostname")
                        },
                        insensitive: {
                            method() {
                                return this.$_setFlag("insensitive", !0)
                            }
                        },
                        ip: {
                            method(pt={}) {
                                gt.assertOptions(pt, ["cidr", "version"]);
                                const {cidr: mt, versions: yt, regex: vt} = dt.regex(pt)
                                  , wt = pt.version ? yt : void 0;
                                return this.$_addRule({
                                    name: "ip",
                                    args: {
                                        options: {
                                            cidr: mt,
                                            version: wt
                                        }
                                    },
                                    regex: vt
                                })
                            },
                            validate: (pt,mt,{options: yt},{regex: vt})=>vt.test(pt) ? pt : yt.version ? mt.error("string.ipVersion", {
                                value: pt,
                                cidr: yt.cidr,
                                version: yt.version
                            }) : mt.error("string.ip", {
                                value: pt,
                                cidr: yt.cidr
                            })
                        },
                        isoDate: {
                            method() {
                                return this.$_addRule("isoDate")
                            },
                            validate: (pt,{error: mt})=>bt.isoDate(pt) ? pt : mt("string.isoDate")
                        },
                        isoDuration: {
                            method() {
                                return this.$_addRule("isoDuration")
                            },
                            validate: (pt,mt)=>bt.isoDurationRegex.test(pt) ? pt : mt.error("string.isoDuration")
                        },
                        length: {
                            method(pt, mt) {
                                return bt.length(this, "length", pt, "=", mt)
                            },
                            validate(pt, mt, {limit: yt, encoding: vt}, {name: wt, operator: _t, args: Et}) {
                                const xt = !vt && pt.length;
                                return gt.compare(xt, yt, _t) ? pt : mt.error("string." + wt, {
                                    limit: Et.limit,
                                    value: pt,
                                    encoding: vt
                                })
                            },
                            args: [{
                                name: "limit",
                                ref: !0,
                                assert: gt.limit,
                                message: "must be a positive integer"
                            }, "encoding"]
                        },
                        lowercase: {
                            method() {
                                return this.case("lower")
                            }
                        },
                        max: {
                            method(pt, mt) {
                                return bt.length(this, "max", pt, "<=", mt)
                            },
                            args: ["limit", "encoding"]
                        },
                        min: {
                            method(pt, mt) {
                                return bt.length(this, "min", pt, ">=", mt)
                            },
                            args: ["limit", "encoding"]
                        },
                        normalize: {
                            method(pt="NFC") {
                                return at(bt.normalizationForms.includes(pt), "normalization form must be one of " + bt.normalizationForms.join(", ")),
                                this.$_addRule({
                                    name: "normalize",
                                    args: {
                                        form: pt
                                    }
                                })
                            },
                            validate: (pt,{error: mt},{form: yt})=>pt === pt.normalize(yt) ? pt : mt("string.normalize", {
                                value: pt,
                                form: yt
                            }),
                            convert: !0
                        },
                        pattern: {
                            alias: "regex",
                            method(pt, mt={}) {
                                at(pt instanceof RegExp, "regex must be a RegExp"),
                                at(!pt.flags.includes("g") && !pt.flags.includes("y"), "regex should not use global or sticky mode"),
                                typeof mt == "string" && (mt = {
                                    name: mt
                                }),
                                gt.assertOptions(mt, ["invert", "name"]);
                                const yt = ["string.pattern", mt.invert ? ".invert" : "", mt.name ? ".name" : ".base"].join("");
                                return this.$_addRule({
                                    name: "pattern",
                                    args: {
                                        regex: pt,
                                        options: mt
                                    },
                                    errorCode: yt
                                })
                            },
                            validate: (pt,mt,{regex: yt, options: vt},{errorCode: wt})=>yt.test(pt) ^ vt.invert ? pt : mt.error(wt, {
                                name: vt.name,
                                regex: yt,
                                value: pt
                            }),
                            args: ["regex", "options"],
                            multi: !0
                        },
                        replace: {
                            method(pt, mt) {
                                typeof pt == "string" && (pt = new RegExp(ct(pt),"g")),
                                at(pt instanceof RegExp, "pattern must be a RegExp"),
                                at(typeof mt == "string", "replacement must be a String");
                                const yt = this.clone();
                                return yt.$_terms.replacements || (yt.$_terms.replacements = []),
                                yt.$_terms.replacements.push({
                                    pattern: pt,
                                    replacement: mt
                                }),
                                yt
                            }
                        },
                        token: {
                            method() {
                                return this.$_addRule("token")
                            },
                            validate: (pt,mt)=>/^\w+$/.test(pt) ? pt : mt.error("string.token")
                        },
                        trim: {
                            method(pt=!0) {
                                return at(typeof pt == "boolean", "enabled must be a boolean"),
                                this.$_addRule({
                                    name: "trim",
                                    args: {
                                        enabled: pt
                                    }
                                })
                            },
                            validate: (pt,mt,{enabled: yt})=>yt && pt !== pt.trim() ? mt.error("string.trim") : pt,
                            convert: !0
                        },
                        truncate: {
                            method(pt=!0) {
                                return at(typeof pt == "boolean", "enabled must be a boolean"),
                                this.$_setFlag("truncate", pt)
                            }
                        },
                        uppercase: {
                            method() {
                                return this.case("upper")
                            }
                        },
                        uri: {
                            method(pt={}) {
                                gt.assertOptions(pt, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]),
                                pt.domain && gt.assertOptions(pt.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
                                const {regex: mt, scheme: yt} = ft.regex(pt)
                                  , vt = pt.domain ? bt.addressOptions(pt.domain) : null;
                                return this.$_addRule({
                                    name: "uri",
                                    args: {
                                        options: pt
                                    },
                                    regex: mt,
                                    domain: vt,
                                    scheme: yt
                                })
                            },
                            validate(pt, mt, {options: yt}, {regex: vt, domain: wt, scheme: _t}) {
                                if (["http:/", "https:/"].includes(pt))
                                    return mt.error("string.uri");
                                const Et = vt.exec(pt);
                                if (Et) {
                                    const xt = Et[1] || Et[2];
                                    return !wt || yt.allowRelative && !xt || ot.isValid(xt, wt) ? pt : mt.error("string.domain", {
                                        value: xt
                                    })
                                }
                                return yt.relativeOnly ? mt.error("string.uriRelativeOnly") : yt.scheme ? mt.error("string.uriCustomScheme", {
                                    scheme: _t,
                                    value: pt
                                }) : mt.error("string.uri")
                            }
                        }
                    },
                    manifest: {
                        build(pt, mt) {
                            if (mt.replacements)
                                for (const {pattern: yt, replacement: vt} of mt.replacements)
                                    pt = pt.replace(yt, vt);
                            return pt
                        }
                    },
                    messages: {
                        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
                        "string.base": "{{#label}} must be a string",
                        "string.base64": "{{#label}} must be a valid base64 string",
                        "string.creditCard": "{{#label}} must be a credit card",
                        "string.dataUri": "{{#label}} must be a valid dataUri string",
                        "string.domain": "{{#label}} must contain a valid domain name",
                        "string.email": "{{#label}} must be a valid email",
                        "string.empty": "{{#label}} is not allowed to be empty",
                        "string.guid": "{{#label}} must be a valid GUID",
                        "string.hex": "{{#label}} must only contain hexadecimal characters",
                        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
                        "string.hostname": "{{#label}} must be a valid hostname",
                        "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
                        "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
                        "string.isoDate": "{{#label}} must be in iso format",
                        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
                        "string.length": "{{#label}} length must be {{#limit}} characters long",
                        "string.lowercase": "{{#label}} must only contain lowercase characters",
                        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
                        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
                        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
                        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
                        "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
                        "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
                        "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
                        "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
                        "string.trim": "{{#label}} must not have leading or trailing whitespace",
                        "string.uri": "{{#label}} must be a valid uri",
                        "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
                        "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
                        "string.uppercase": "{{#label}} must only contain uppercase characters"
                    }
                }),
                bt.addressOptions = function(pt) {
                    if (!pt)
                        return bt.tlds || pt;
                    if (at(pt.minDomainSegments === void 0 || Number.isSafeInteger(pt.minDomainSegments) && pt.minDomainSegments > 0, "minDomainSegments must be a positive integer"),
                    at(pt.maxDomainSegments === void 0 || Number.isSafeInteger(pt.maxDomainSegments) && pt.maxDomainSegments > 0, "maxDomainSegments must be a positive integer"),
                    pt.tlds === !1)
                        return pt;
                    if (pt.tlds === !0 || pt.tlds === void 0)
                        return at(bt.tlds, "Built-in TLD list disabled"),
                        Object.assign({}, pt, bt.tlds);
                    at(typeof pt.tlds == "object", "tlds must be true, false, or an object");
                    const mt = pt.tlds.deny;
                    if (mt)
                        return Array.isArray(mt) && (pt = Object.assign({}, pt, {
                            tlds: {
                                deny: new Set(mt)
                            }
                        })),
                        at(pt.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean"),
                        at(!pt.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists"),
                        bt.validateTlds(pt.tlds.deny, "tlds.deny"),
                        pt;
                    const yt = pt.tlds.allow;
                    return yt ? yt === !0 ? (at(bt.tlds, "Built-in TLD list disabled"),
                    Object.assign({}, pt, bt.tlds)) : (Array.isArray(yt) && (pt = Object.assign({}, pt, {
                        tlds: {
                            allow: new Set(yt)
                        }
                    })),
                    at(pt.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean"),
                    bt.validateTlds(pt.tlds.allow, "tlds.allow"),
                    pt) : pt
                }
                ,
                bt.validateTlds = function(pt, mt) {
                    for (const yt of pt)
                        at(ot.isValid(yt, {
                            minDomainSegments: 1,
                            maxDomainSegments: 1
                        }), `${mt} must contain valid top level domain names`)
                }
                ,
                bt.isoDate = function(pt) {
                    if (!gt.isIsoDate(pt))
                        return null;
                    /.*T.*[+-]\d\d$/.test(pt) && (pt += "00");
                    const mt = new Date(pt);
                    return isNaN(mt.getTime()) ? null : mt.toISOString()
                }
                ,
                bt.length = function(pt, mt, yt, vt, wt) {
                    return at(!wt || !1, "Invalid encoding:", wt),
                    pt.$_addRule({
                        name: mt,
                        method: "length",
                        args: {
                            limit: yt,
                            encoding: wt
                        },
                        operator: vt
                    })
                }
            }
            ,
            8826: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8068)
                  , lt = {};
                lt.Map = class extends Map {
                    slice() {
                        return new lt.Map(this)
                    }
                }
                ,
                nt.exports = ot.extend({
                    type: "symbol",
                    terms: {
                        map: {
                            init: new lt.Map
                        }
                    },
                    coerce: {
                        method(dt, {schema: ct, error: ut}) {
                            const ft = ct.$_terms.map.get(dt);
                            return ft && (dt = ft),
                            ct._flags.only && typeof dt != "symbol" ? {
                                value: dt,
                                errors: ut("symbol.map", {
                                    map: ct.$_terms.map
                                })
                            } : {
                                value: dt
                            }
                        }
                    },
                    validate(dt, {error: ct}) {
                        if (typeof dt != "symbol")
                            return {
                                value: dt,
                                errors: ct("symbol.base")
                            }
                    },
                    rules: {
                        map: {
                            method(dt) {
                                dt && !dt[Symbol.iterator] && typeof dt == "object" && (dt = Object.entries(dt)),
                                at(dt && dt[Symbol.iterator], "Iterable must be an iterable or object");
                                const ct = this.clone()
                                  , ut = [];
                                for (const ft of dt) {
                                    at(ft && ft[Symbol.iterator], "Entry must be an iterable");
                                    const [ht,gt] = ft;
                                    at(typeof ht != "object" && typeof ht != "function" && typeof ht != "symbol", "Key must not be of type object, function, or Symbol"),
                                    at(typeof gt == "symbol", "Value must be a Symbol"),
                                    ct.$_terms.map.set(ht, gt),
                                    ut.push(gt)
                                }
                                return ct.valid(...ut)
                            }
                        }
                    },
                    manifest: {
                        build: (dt,ct)=>(ct.map && (dt = dt.map(ct.map)),
                        dt)
                    },
                    messages: {
                        "symbol.base": "{{#label}} must be a symbol",
                        "symbol.map": "{{#label}} must be one of {{#map}}"
                    }
                })
            }
            ,
            8863: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(738)
                  , dt = st(9621)
                  , ct = st(8160)
                  , ut = st(6354)
                  , ft = st(493)
                  , ht = {
                    result: Symbol("result")
                };
                it.entry = function(gt, bt, pt) {
                    let mt = ct.defaults;
                    pt && (at(pt.warnings === void 0, "Cannot override warnings preference in synchronous validation"),
                    at(pt.artifacts === void 0, "Cannot override artifacts preference in synchronous validation"),
                    mt = ct.preferences(ct.defaults, pt));
                    const yt = ht.entry(gt, bt, mt);
                    at(!yt.mainstay.externals.length, "Schema with external rules must use validateAsync()");
                    const vt = {
                        value: yt.value
                    };
                    return yt.error && (vt.error = yt.error),
                    yt.mainstay.warnings.length && (vt.warning = ut.details(yt.mainstay.warnings)),
                    yt.mainstay.debug && (vt.debug = yt.mainstay.debug),
                    yt.mainstay.artifacts && (vt.artifacts = yt.mainstay.artifacts),
                    vt
                }
                ,
                it.entryAsync = async function(gt, bt, pt) {
                    let mt = ct.defaults;
                    pt && (mt = ct.preferences(ct.defaults, pt));
                    const yt = ht.entry(gt, bt, mt)
                      , vt = yt.mainstay;
                    if (yt.error)
                        throw vt.debug && (yt.error.debug = vt.debug),
                        yt.error;
                    if (vt.externals.length) {
                        let _t = yt.value;
                        const Et = [];
                        for (const xt of vt.externals) {
                            const Ct = xt.state.path
                              , Tt = xt.schema.type === "link" ? vt.links.get(xt.schema) : null;
                            let It, Nt, Ft = _t;
                            const Lt = Ct.length ? [_t] : []
                              , Mt = Ct.length ? dt(gt, Ct) : gt;
                            if (Ct.length) {
                                It = Ct[Ct.length - 1];
                                let $t = _t;
                                for (const kt of Ct.slice(0, -1))
                                    $t = $t[kt],
                                    Lt.unshift($t);
                                Nt = Lt[0],
                                Ft = Nt[It]
                            }
                            try {
                                const $t = (At,Pt)=>(Tt || xt.schema).$_createError(At, Ft, Pt, xt.state, mt)
                                  , kt = await xt.method(Ft, {
                                    schema: xt.schema,
                                    linked: Tt,
                                    state: xt.state,
                                    prefs: pt,
                                    original: Mt,
                                    error: $t,
                                    errorsArray: ht.errorsArray,
                                    warn: (At,Pt)=>vt.warnings.push((Tt || xt.schema).$_createError(At, Ft, Pt, xt.state, mt)),
                                    message: (At,Pt)=>(Tt || xt.schema).$_createError("external", Ft, Pt, xt.state, mt, {
                                        messages: At
                                    })
                                });
                                if (kt === void 0 || kt === Ft)
                                    continue;
                                if (kt instanceof ut.Report) {
                                    if (vt.tracer.log(xt.schema, xt.state, "rule", "external", "error"),
                                    Et.push(kt),
                                    mt.abortEarly)
                                        break;
                                    continue
                                }
                                if (Array.isArray(kt) && kt[ct.symbols.errors]) {
                                    if (vt.tracer.log(xt.schema, xt.state, "rule", "external", "error"),
                                    Et.push(...kt),
                                    mt.abortEarly)
                                        break;
                                    continue
                                }
                                Nt ? (vt.tracer.value(xt.state, "rule", Ft, kt, "external"),
                                Nt[It] = kt) : (vt.tracer.value(xt.state, "rule", _t, kt, "external"),
                                _t = kt)
                            } catch ($t) {
                                throw mt.errors.label && ($t.message += ` (${xt.label})`),
                                $t
                            }
                        }
                        if (yt.value = _t,
                        Et.length)
                            throw yt.error = ut.process(Et, gt, mt),
                            vt.debug && (yt.error.debug = vt.debug),
                            yt.error
                    }
                    if (!mt.warnings && !mt.debug && !mt.artifacts)
                        return yt.value;
                    const wt = {
                        value: yt.value
                    };
                    return vt.warnings.length && (wt.warning = ut.details(vt.warnings)),
                    vt.debug && (wt.debug = vt.debug),
                    vt.artifacts && (wt.artifacts = vt.artifacts),
                    wt
                }
                ,
                ht.Mainstay = class {
                    constructor(gt, bt, pt) {
                        this.externals = [],
                        this.warnings = [],
                        this.tracer = gt,
                        this.debug = bt,
                        this.links = pt,
                        this.shadow = null,
                        this.artifacts = null,
                        this._snapshots = []
                    }
                    snapshot() {
                        this._snapshots.push({
                            externals: this.externals.slice(),
                            warnings: this.warnings.slice()
                        })
                    }
                    restore() {
                        const gt = this._snapshots.pop();
                        this.externals = gt.externals,
                        this.warnings = gt.warnings
                    }
                    commit() {
                        this._snapshots.pop()
                    }
                }
                ,
                ht.entry = function(gt, bt, pt) {
                    const {tracer: mt, cleanup: yt} = ht.tracer(bt, pt)
                      , vt = pt.debug ? [] : null
                      , wt = bt._ids._schemaChain ? new Map : null
                      , _t = new ht.Mainstay(mt,vt,wt)
                      , Et = bt._ids._schemaChain ? [{
                        schema: bt
                    }] : null
                      , xt = new ft([],[],{
                        mainstay: _t,
                        schemas: Et
                    })
                      , Ct = it.validate(gt, bt, xt, pt);
                    yt && bt.$_root.untrace();
                    const Tt = ut.process(Ct.errors, gt, pt);
                    return {
                        value: Ct.value,
                        error: Tt,
                        mainstay: _t
                    }
                }
                ,
                ht.tracer = function(gt, bt) {
                    return gt.$_root._tracer ? {
                        tracer: gt.$_root._tracer._register(gt)
                    } : bt.debug ? (at(gt.$_root.trace, "Debug mode not supported"),
                    {
                        tracer: gt.$_root.trace()._register(gt),
                        cleanup: !0
                    }) : {
                        tracer: ht.ignore
                    }
                }
                ,
                it.validate = function(gt, bt, pt, mt, yt={}) {
                    if (bt.$_terms.whens && (bt = bt._generate(gt, pt, mt).schema),
                    bt._preferences && (mt = ht.prefs(bt, mt)),
                    bt._cache && mt.cache) {
                        const Tt = bt._cache.get(gt);
                        if (pt.mainstay.tracer.debug(pt, "validate", "cached", !!Tt),
                        Tt)
                            return Tt
                    }
                    const vt = (Tt,It,Nt)=>bt.$_createError(Tt, gt, It, Nt || pt, mt)
                      , wt = {
                        original: gt,
                        prefs: mt,
                        schema: bt,
                        state: pt,
                        error: vt,
                        errorsArray: ht.errorsArray,
                        warn: (Tt,It,Nt)=>pt.mainstay.warnings.push(vt(Tt, It, Nt)),
                        message: (Tt,It)=>bt.$_createError("custom", gt, It, pt, mt, {
                            messages: Tt
                        })
                    };
                    pt.mainstay.tracer.entry(bt, pt);
                    const _t = bt._definition;
                    if (_t.prepare && gt !== void 0 && mt.convert) {
                        const Tt = _t.prepare(gt, wt);
                        if (Tt) {
                            if (pt.mainstay.tracer.value(pt, "prepare", gt, Tt.value),
                            Tt.errors)
                                return ht.finalize(Tt.value, [].concat(Tt.errors), wt);
                            gt = Tt.value
                        }
                    }
                    if (_t.coerce && gt !== void 0 && mt.convert && (!_t.coerce.from || _t.coerce.from.includes(typeof gt))) {
                        const Tt = _t.coerce.method(gt, wt);
                        if (Tt) {
                            if (pt.mainstay.tracer.value(pt, "coerced", gt, Tt.value),
                            Tt.errors)
                                return ht.finalize(Tt.value, [].concat(Tt.errors), wt);
                            gt = Tt.value
                        }
                    }
                    const Et = bt._flags.empty;
                    Et && Et.$_match(ht.trim(gt, bt), pt.nest(Et), ct.defaults) && (pt.mainstay.tracer.value(pt, "empty", gt, void 0),
                    gt = void 0);
                    const xt = yt.presence || bt._flags.presence || (bt._flags._endedSwitch ? null : mt.presence);
                    if (gt === void 0) {
                        if (xt === "forbidden")
                            return ht.finalize(gt, null, wt);
                        if (xt === "required")
                            return ht.finalize(gt, [bt.$_createError("any.required", gt, null, pt, mt)], wt);
                        if (xt === "optional") {
                            if (bt._flags.default !== ct.symbols.deepDefault)
                                return ht.finalize(gt, null, wt);
                            pt.mainstay.tracer.value(pt, "default", gt, {}),
                            gt = {}
                        }
                    } else if (xt === "forbidden")
                        return ht.finalize(gt, [bt.$_createError("any.unknown", gt, null, pt, mt)], wt);
                    const Ct = [];
                    if (bt._valids) {
                        const Tt = bt._valids.get(gt, pt, mt, bt._flags.insensitive);
                        if (Tt)
                            return mt.convert && (pt.mainstay.tracer.value(pt, "valids", gt, Tt.value),
                            gt = Tt.value),
                            pt.mainstay.tracer.filter(bt, pt, "valid", Tt),
                            ht.finalize(gt, null, wt);
                        if (bt._flags.only) {
                            const It = bt.$_createError("any.only", gt, {
                                valids: bt._valids.values({
                                    display: !0
                                })
                            }, pt, mt);
                            if (mt.abortEarly)
                                return ht.finalize(gt, [It], wt);
                            Ct.push(It)
                        }
                    }
                    if (bt._invalids) {
                        const Tt = bt._invalids.get(gt, pt, mt, bt._flags.insensitive);
                        if (Tt) {
                            pt.mainstay.tracer.filter(bt, pt, "invalid", Tt);
                            const It = bt.$_createError("any.invalid", gt, {
                                invalids: bt._invalids.values({
                                    display: !0
                                })
                            }, pt, mt);
                            if (mt.abortEarly)
                                return ht.finalize(gt, [It], wt);
                            Ct.push(It)
                        }
                    }
                    if (_t.validate) {
                        const Tt = _t.validate(gt, wt);
                        if (Tt && (pt.mainstay.tracer.value(pt, "base", gt, Tt.value),
                        gt = Tt.value,
                        Tt.errors)) {
                            if (!Array.isArray(Tt.errors))
                                return Ct.push(Tt.errors),
                                ht.finalize(gt, Ct, wt);
                            if (Tt.errors.length)
                                return Ct.push(...Tt.errors),
                                ht.finalize(gt, Ct, wt)
                        }
                    }
                    return bt._rules.length ? ht.rules(gt, Ct, wt) : ht.finalize(gt, Ct, wt)
                }
                ,
                ht.rules = function(gt, bt, pt) {
                    const {schema: mt, state: yt, prefs: vt} = pt;
                    for (const wt of mt._rules) {
                        const _t = mt._definition.rules[wt.method];
                        if (_t.convert && vt.convert) {
                            yt.mainstay.tracer.log(mt, yt, "rule", wt.name, "full");
                            continue
                        }
                        let Et, xt = wt.args;
                        if (wt._resolve.length) {
                            xt = Object.assign({}, xt);
                            for (const Tt of wt._resolve) {
                                const It = _t.argsByName.get(Tt)
                                  , Nt = xt[Tt].resolve(gt, yt, vt)
                                  , Ft = It.normalize ? It.normalize(Nt) : Nt
                                  , Lt = ct.validateArg(Ft, null, It);
                                if (Lt) {
                                    Et = mt.$_createError("any.ref", Nt, {
                                        arg: Tt,
                                        ref: xt[Tt],
                                        reason: Lt
                                    }, yt, vt);
                                    break
                                }
                                xt[Tt] = Ft
                            }
                        }
                        Et = Et || _t.validate(gt, pt, xt, wt);
                        const Ct = ht.rule(Et, wt);
                        if (Ct.errors) {
                            if (yt.mainstay.tracer.log(mt, yt, "rule", wt.name, "error"),
                            wt.warn) {
                                yt.mainstay.warnings.push(...Ct.errors);
                                continue
                            }
                            if (vt.abortEarly)
                                return ht.finalize(gt, Ct.errors, pt);
                            bt.push(...Ct.errors)
                        } else
                            yt.mainstay.tracer.log(mt, yt, "rule", wt.name, "pass"),
                            yt.mainstay.tracer.value(yt, "rule", gt, Ct.value, wt.name),
                            gt = Ct.value
                    }
                    return ht.finalize(gt, bt, pt)
                }
                ,
                ht.rule = function(gt, bt) {
                    return gt instanceof ut.Report ? (ht.error(gt, bt),
                    {
                        errors: [gt],
                        value: null
                    }) : Array.isArray(gt) && gt[ct.symbols.errors] ? (gt.forEach(pt=>ht.error(pt, bt)),
                    {
                        errors: gt,
                        value: null
                    }) : {
                        errors: null,
                        value: gt
                    }
                }
                ,
                ht.error = function(gt, bt) {
                    return bt.message && gt._setTemplate(bt.message),
                    gt
                }
                ,
                ht.finalize = function(gt, bt, pt) {
                    bt = bt || [];
                    const {schema: mt, state: yt, prefs: vt} = pt;
                    if (bt.length) {
                        const _t = ht.default("failover", void 0, bt, pt);
                        _t !== void 0 && (yt.mainstay.tracer.value(yt, "failover", gt, _t),
                        gt = _t,
                        bt = [])
                    }
                    if (bt.length && mt._flags.error)
                        if (typeof mt._flags.error == "function") {
                            bt = mt._flags.error(bt),
                            Array.isArray(bt) || (bt = [bt]);
                            for (const _t of bt)
                                at(_t instanceof Error || _t instanceof ut.Report, "error() must return an Error object")
                        } else
                            bt = [mt._flags.error];
                    if (gt === void 0) {
                        const _t = ht.default("default", gt, bt, pt);
                        yt.mainstay.tracer.value(yt, "default", gt, _t),
                        gt = _t
                    }
                    if (mt._flags.cast && gt !== void 0) {
                        const _t = mt._definition.cast[mt._flags.cast];
                        if (_t.from(gt)) {
                            const Et = _t.to(gt, pt);
                            yt.mainstay.tracer.value(yt, "cast", gt, Et, mt._flags.cast),
                            gt = Et
                        }
                    }
                    if (mt.$_terms.externals && vt.externals && vt._externals !== !1)
                        for (const {method: _t} of mt.$_terms.externals)
                            yt.mainstay.externals.push({
                                method: _t,
                                schema: mt,
                                state: yt,
                                label: ut.label(mt._flags, yt, vt)
                            });
                    const wt = {
                        value: gt,
                        errors: bt.length ? bt : null
                    };
                    return mt._flags.result && (wt.value = mt._flags.result === "strip" ? void 0 : pt.original,
                    yt.mainstay.tracer.value(yt, mt._flags.result, gt, wt.value),
                    yt.shadow(gt, mt._flags.result)),
                    mt._cache && vt.cache !== !1 && !mt._refs.length && mt._cache.set(pt.original, wt),
                    gt === void 0 || wt.errors || mt._flags.artifact === void 0 || (yt.mainstay.artifacts = yt.mainstay.artifacts || new Map,
                    yt.mainstay.artifacts.has(mt._flags.artifact) || yt.mainstay.artifacts.set(mt._flags.artifact, []),
                    yt.mainstay.artifacts.get(mt._flags.artifact).push(yt.path)),
                    wt
                }
                ,
                ht.prefs = function(gt, bt) {
                    const pt = bt === ct.defaults;
                    return pt && gt._preferences[ct.symbols.prefs] ? gt._preferences[ct.symbols.prefs] : (bt = ct.preferences(bt, gt._preferences),
                    pt && (gt._preferences[ct.symbols.prefs] = bt),
                    bt)
                }
                ,
                ht.default = function(gt, bt, pt, mt) {
                    const {schema: yt, state: vt, prefs: wt} = mt
                      , _t = yt._flags[gt];
                    if (wt.noDefaults || _t === void 0)
                        return bt;
                    if (vt.mainstay.tracer.log(yt, vt, "rule", gt, "full"),
                    !_t)
                        return _t;
                    if (typeof _t == "function") {
                        const Et = _t.length ? [ot(vt.ancestors[0]), mt] : [];
                        try {
                            return _t(...Et)
                        } catch (xt) {
                            return void pt.push(yt.$_createError(`any.${gt}`, null, {
                                error: xt
                            }, vt, wt))
                        }
                    }
                    return typeof _t != "object" ? _t : _t[ct.symbols.literal] ? _t.literal : ct.isResolvable(_t) ? _t.resolve(bt, vt, wt) : ot(_t)
                }
                ,
                ht.trim = function(gt, bt) {
                    if (typeof gt != "string")
                        return gt;
                    const pt = bt.$_getRule("trim");
                    return pt && pt.args.enabled ? gt.trim() : gt
                }
                ,
                ht.ignore = {
                    active: !1,
                    debug: lt,
                    entry: lt,
                    filter: lt,
                    log: lt,
                    resolve: lt,
                    value: lt
                },
                ht.errorsArray = function() {
                    const gt = [];
                    return gt[ct.symbols.errors] = !0,
                    gt
                }
            }
            ,
            2036: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(9474)
                  , lt = st(8160)
                  , dt = {};
                nt.exports = dt.Values = class {
                    constructor(ct, ut) {
                        this._values = new Set(ct),
                        this._refs = new Set(ut),
                        this._lowercase = dt.lowercases(ct),
                        this._override = !1
                    }
                    get length() {
                        return this._values.size + this._refs.size
                    }
                    add(ct, ut) {
                        lt.isResolvable(ct) ? this._refs.has(ct) || (this._refs.add(ct),
                        ut && ut.register(ct)) : this.has(ct, null, null, !1) || (this._values.add(ct),
                        typeof ct == "string" && this._lowercase.set(ct.toLowerCase(), ct))
                    }
                    static merge(ct, ut, ft) {
                        if (ct = ct || new dt.Values,
                        ut) {
                            if (ut._override)
                                return ut.clone();
                            for (const ht of [...ut._values, ...ut._refs])
                                ct.add(ht)
                        }
                        if (ft)
                            for (const ht of [...ft._values, ...ft._refs])
                                ct.remove(ht);
                        return ct.length ? ct : null
                    }
                    remove(ct) {
                        lt.isResolvable(ct) ? this._refs.delete(ct) : (this._values.delete(ct),
                        typeof ct == "string" && this._lowercase.delete(ct.toLowerCase()))
                    }
                    has(ct, ut, ft, ht) {
                        return !!this.get(ct, ut, ft, ht)
                    }
                    get(ct, ut, ft, ht) {
                        if (!this.length)
                            return !1;
                        if (this._values.has(ct))
                            return {
                                value: ct
                            };
                        if (typeof ct == "string" && ct && ht) {
                            const gt = this._lowercase.get(ct.toLowerCase());
                            if (gt)
                                return {
                                    value: gt
                                }
                        }
                        if (!this._refs.size && typeof ct != "object")
                            return !1;
                        if (typeof ct == "object") {
                            for (const gt of this._values)
                                if (ot(gt, ct))
                                    return {
                                        value: gt
                                    }
                        }
                        if (ut)
                            for (const gt of this._refs) {
                                const bt = gt.resolve(ct, ut, ft, null, {
                                    in: !0
                                });
                                if (bt === void 0)
                                    continue;
                                const pt = gt.in && typeof bt == "object" ? Array.isArray(bt) ? bt : Object.keys(bt) : [bt];
                                for (const mt of pt)
                                    if (typeof mt == typeof ct) {
                                        if (ht && ct && typeof ct == "string") {
                                            if (mt.toLowerCase() === ct.toLowerCase())
                                                return {
                                                    value: mt,
                                                    ref: gt
                                                }
                                        } else if (ot(mt, ct))
                                            return {
                                                value: mt,
                                                ref: gt
                                            }
                                    }
                            }
                        return !1
                    }
                    override() {
                        this._override = !0
                    }
                    values(ct) {
                        if (ct && ct.display) {
                            const ut = [];
                            for (const ft of [...this._values, ...this._refs])
                                ft !== void 0 && ut.push(ft);
                            return ut
                        }
                        return Array.from([...this._values, ...this._refs])
                    }
                    clone() {
                        const ct = new dt.Values(this._values,this._refs);
                        return ct._override = this._override,
                        ct
                    }
                    concat(ct) {
                        at(!ct._override, "Cannot concat override set of values");
                        const ut = new dt.Values([...this._values, ...ct._values],[...this._refs, ...ct._refs]);
                        return ut._override = this._override,
                        ut
                    }
                    describe() {
                        const ct = [];
                        this._override && ct.push({
                            override: !0
                        });
                        for (const ut of this._values.values())
                            ct.push(ut && typeof ut == "object" ? {
                                value: ut
                            } : ut);
                        for (const ut of this._refs.values())
                            ct.push(ut.describe());
                        return ct
                    }
                }
                ,
                dt.Values.prototype[lt.symbols.values] = !0,
                dt.Values.prototype.slice = dt.Values.prototype.clone,
                dt.lowercases = function(ct) {
                    const ut = new Map;
                    if (ct)
                        for (const ft of ct)
                            typeof ft == "string" && ut.set(ft.toLowerCase(), ft);
                    return ut
                }
            }
            ,
            978: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(1687)
                  , dt = st(9621)
                  , ct = {};
                nt.exports = function(ut, ft, ht={}) {
                    if (at(ut && typeof ut == "object", "Invalid defaults value: must be an object"),
                    at(!ft || ft === !0 || typeof ft == "object", "Invalid source value: must be true, falsy or an object"),
                    at(typeof ht == "object", "Invalid options: must be an object"),
                    !ft)
                        return null;
                    if (ht.shallow)
                        return ct.applyToDefaultsWithShallow(ut, ft, ht);
                    const gt = ot(ut);
                    if (ft === !0)
                        return gt;
                    const bt = ht.nullOverride !== void 0 && ht.nullOverride;
                    return lt(gt, ft, {
                        nullOverride: bt,
                        mergeArrays: !1
                    })
                }
                ,
                ct.applyToDefaultsWithShallow = function(ut, ft, ht) {
                    const gt = ht.shallow;
                    at(Array.isArray(gt), "Invalid keys");
                    const bt = new Map
                      , pt = ft === !0 ? null : new Set;
                    for (let vt of gt) {
                        vt = Array.isArray(vt) ? vt : vt.split(".");
                        const wt = dt(ut, vt);
                        wt && typeof wt == "object" ? bt.set(wt, pt && dt(ft, vt) || wt) : pt && pt.add(vt)
                    }
                    const mt = ot(ut, {}, bt);
                    if (!pt)
                        return mt;
                    for (const vt of pt)
                        ct.reachCopy(mt, ft, vt);
                    const yt = ht.nullOverride !== void 0 && ht.nullOverride;
                    return lt(mt, ft, {
                        nullOverride: yt,
                        mergeArrays: !1
                    })
                }
                ,
                ct.reachCopy = function(ut, ft, ht) {
                    for (const pt of ht) {
                        if (!(pt in ft))
                            return;
                        const mt = ft[pt];
                        if (typeof mt != "object" || mt === null)
                            return;
                        ft = mt
                    }
                    const gt = ft;
                    let bt = ut;
                    for (let pt = 0; pt < ht.length - 1; ++pt) {
                        const mt = ht[pt];
                        typeof bt[mt] != "object" && (bt[mt] = {}),
                        bt = bt[mt]
                    }
                    bt[ht[ht.length - 1]] = gt
                }
            }
            ,
            375: (nt,it,st)=>{
                const at = st(7916);
                nt.exports = function(ot, ...lt) {
                    if (!ot)
                        throw lt.length === 1 && lt[0]instanceof Error ? lt[0] : new at(lt)
                }
            }
            ,
            8571: (nt,it,st)=>{
                const at = st(9621)
                  , ot = st(4277)
                  , lt = st(7043)
                  , dt = {
                    needsProtoHack: new Set([ot.set, ot.map, ot.weakSet, ot.weakMap])
                };
                nt.exports = dt.clone = function(ct, ut={}, ft=null) {
                    if (typeof ct != "object" || ct === null)
                        return ct;
                    let ht = dt.clone
                      , gt = ft;
                    if (ut.shallow) {
                        if (ut.shallow !== !0)
                            return dt.cloneWithShallow(ct, ut);
                        ht = yt=>yt
                    } else if (gt) {
                        const yt = gt.get(ct);
                        if (yt)
                            return yt
                    } else
                        gt = new Map;
                    const bt = ot.getInternalProto(ct);
                    if (bt === ot.buffer)
                        return !1;
                    if (bt === ot.date)
                        return new Date(ct.getTime());
                    if (bt === ot.regex)
                        return new RegExp(ct);
                    const pt = dt.base(ct, bt, ut);
                    if (pt === ct)
                        return ct;
                    if (gt && gt.set(ct, pt),
                    bt === ot.set)
                        for (const yt of ct)
                            pt.add(ht(yt, ut, gt));
                    else if (bt === ot.map)
                        for (const [yt,vt] of ct)
                            pt.set(yt, ht(vt, ut, gt));
                    const mt = lt.keys(ct, ut);
                    for (const yt of mt) {
                        if (yt === "__proto__")
                            continue;
                        if (bt === ot.array && yt === "length") {
                            pt.length = ct.length;
                            continue
                        }
                        const vt = Object.getOwnPropertyDescriptor(ct, yt);
                        vt ? vt.get || vt.set ? Object.defineProperty(pt, yt, vt) : vt.enumerable ? pt[yt] = ht(ct[yt], ut, gt) : Object.defineProperty(pt, yt, {
                            enumerable: !1,
                            writable: !0,
                            configurable: !0,
                            value: ht(ct[yt], ut, gt)
                        }) : Object.defineProperty(pt, yt, {
                            enumerable: !0,
                            writable: !0,
                            configurable: !0,
                            value: ht(ct[yt], ut, gt)
                        })
                    }
                    return pt
                }
                ,
                dt.cloneWithShallow = function(ct, ut) {
                    const ft = ut.shallow;
                    (ut = Object.assign({}, ut)).shallow = !1;
                    const ht = new Map;
                    for (const gt of ft) {
                        const bt = at(ct, gt);
                        typeof bt != "object" && typeof bt != "function" || ht.set(bt, bt)
                    }
                    return dt.clone(ct, ut, ht)
                }
                ,
                dt.base = function(ct, ut, ft) {
                    if (ft.prototype === !1)
                        return dt.needsProtoHack.has(ut) ? new ut.constructor : ut === ot.array ? [] : {};
                    const ht = Object.getPrototypeOf(ct);
                    if (ht && ht.isImmutable)
                        return ct;
                    if (ut === ot.array) {
                        const gt = [];
                        return ht !== ut && Object.setPrototypeOf(gt, ht),
                        gt
                    }
                    if (dt.needsProtoHack.has(ut)) {
                        const gt = new ht.constructor;
                        return ht !== ut && Object.setPrototypeOf(gt, ht),
                        gt
                    }
                    return Object.create(ht)
                }
            }
            ,
            9474: (nt,it,st)=>{
                const at = st(4277)
                  , ot = {
                    mismatched: null
                };
                nt.exports = function(lt, dt, ct) {
                    return ct = Object.assign({
                        prototype: !0
                    }, ct),
                    !!ot.isDeepEqual(lt, dt, ct, [])
                }
                ,
                ot.isDeepEqual = function(lt, dt, ct, ut) {
                    if (lt === dt)
                        return lt !== 0 || 1 / lt == 1 / dt;
                    const ft = typeof lt;
                    if (ft !== typeof dt || lt === null || dt === null)
                        return !1;
                    if (ft === "function") {
                        if (!ct.deepFunction || lt.toString() !== dt.toString())
                            return !1
                    } else if (ft !== "object")
                        return lt != lt && dt != dt;
                    const ht = ot.getSharedType(lt, dt, !!ct.prototype);
                    switch (ht) {
                    case at.buffer:
                        return !1;
                    case at.promise:
                        return lt === dt;
                    case at.regex:
                        return lt.toString() === dt.toString();
                    case ot.mismatched:
                        return !1
                    }
                    for (let gt = ut.length - 1; gt >= 0; --gt)
                        if (ut[gt].isSame(lt, dt))
                            return !0;
                    ut.push(new ot.SeenEntry(lt,dt));
                    try {
                        return !!ot.isDeepEqualObj(ht, lt, dt, ct, ut)
                    } finally {
                        ut.pop()
                    }
                }
                ,
                ot.getSharedType = function(lt, dt, ct) {
                    if (ct)
                        return Object.getPrototypeOf(lt) !== Object.getPrototypeOf(dt) ? ot.mismatched : at.getInternalProto(lt);
                    const ut = at.getInternalProto(lt);
                    return ut !== at.getInternalProto(dt) ? ot.mismatched : ut
                }
                ,
                ot.valueOf = function(lt) {
                    const dt = lt.valueOf;
                    if (dt === void 0)
                        return lt;
                    try {
                        return dt.call(lt)
                    } catch (ct) {
                        return ct
                    }
                }
                ,
                ot.hasOwnEnumerableProperty = function(lt, dt) {
                    return Object.prototype.propertyIsEnumerable.call(lt, dt)
                }
                ,
                ot.isSetSimpleEqual = function(lt, dt) {
                    for (const ct of Set.prototype.values.call(lt))
                        if (!Set.prototype.has.call(dt, ct))
                            return !1;
                    return !0
                }
                ,
                ot.isDeepEqualObj = function(lt, dt, ct, ut, ft) {
                    const {isDeepEqual: ht, valueOf: gt, hasOwnEnumerableProperty: bt} = ot
                      , {keys: pt, getOwnPropertySymbols: mt} = Object;
                    if (lt === at.array) {
                        if (!ut.part) {
                            if (dt.length !== ct.length)
                                return !1;
                            for (let Et = 0; Et < dt.length; ++Et)
                                if (!ht(dt[Et], ct[Et], ut, ft))
                                    return !1;
                            return !0
                        }
                        for (const Et of dt)
                            for (const xt of ct)
                                if (ht(Et, xt, ut, ft))
                                    return !0
                    } else if (lt === at.set) {
                        if (dt.size !== ct.size)
                            return !1;
                        if (!ot.isSetSimpleEqual(dt, ct)) {
                            const Et = new Set(Set.prototype.values.call(ct));
                            for (const xt of Set.prototype.values.call(dt)) {
                                if (Et.delete(xt))
                                    continue;
                                let Ct = !1;
                                for (const Tt of Et)
                                    if (ht(xt, Tt, ut, ft)) {
                                        Et.delete(Tt),
                                        Ct = !0;
                                        break
                                    }
                                if (!Ct)
                                    return !1
                            }
                        }
                    } else if (lt === at.map) {
                        if (dt.size !== ct.size)
                            return !1;
                        for (const [Et,xt] of Map.prototype.entries.call(dt))
                            if (xt === void 0 && !Map.prototype.has.call(ct, Et) || !ht(xt, Map.prototype.get.call(ct, Et), ut, ft))
                                return !1
                    } else if (lt === at.error && (dt.name !== ct.name || dt.message !== ct.message))
                        return !1;
                    const yt = gt(dt)
                      , vt = gt(ct);
                    if ((dt !== yt || ct !== vt) && !ht(yt, vt, ut, ft))
                        return !1;
                    const wt = pt(dt);
                    if (!ut.part && wt.length !== pt(ct).length && !ut.skip)
                        return !1;
                    let _t = 0;
                    for (const Et of wt)
                        if (ut.skip && ut.skip.includes(Et))
                            ct[Et] === void 0 && ++_t;
                        else if (!bt(ct, Et) || !ht(dt[Et], ct[Et], ut, ft))
                            return !1;
                    if (!ut.part && wt.length - _t !== pt(ct).length)
                        return !1;
                    if (ut.symbols !== !1) {
                        const Et = mt(dt)
                          , xt = new Set(mt(ct));
                        for (const Ct of Et) {
                            if (!ut.skip || !ut.skip.includes(Ct)) {
                                if (bt(dt, Ct)) {
                                    if (!bt(ct, Ct) || !ht(dt[Ct], ct[Ct], ut, ft))
                                        return !1
                                } else if (bt(ct, Ct))
                                    return !1
                            }
                            xt.delete(Ct)
                        }
                        for (const Ct of xt)
                            if (bt(ct, Ct))
                                return !1
                    }
                    return !0
                }
                ,
                ot.SeenEntry = class {
                    constructor(lt, dt) {
                        this.obj = lt,
                        this.ref = dt
                    }
                    isSame(lt, dt) {
                        return this.obj === lt && this.ref === dt
                    }
                }
            }
            ,
            7916: (nt,it,st)=>{
                const at = st(8761);
                nt.exports = class extends Error {
                    constructor(ot) {
                        super(ot.filter(lt=>lt !== "").map(lt=>typeof lt == "string" ? lt : lt instanceof Error ? lt.message : at(lt)).join(" ") || "Unknown error"),
                        typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, it.assert)
                    }
                }
            }
            ,
            5277: nt=>{
                const it = {};
                nt.exports = function(st) {
                    if (!st)
                        return "";
                    let at = "";
                    for (let ot = 0; ot < st.length; ++ot) {
                        const lt = st.charCodeAt(ot);
                        it.isSafe(lt) ? at += st[ot] : at += it.escapeHtmlChar(lt)
                    }
                    return at
                }
                ,
                it.escapeHtmlChar = function(st) {
                    return it.namedHtml.get(st) || (st >= 256 ? "&#" + st + ";" : `&#x${st.toString(16).padStart(2, "0")};`)
                }
                ,
                it.isSafe = function(st) {
                    return it.safeCharCodes.has(st)
                }
                ,
                it.namedHtml = new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [34, "&quot;"], [160, "&nbsp;"], [162, "&cent;"], [163, "&pound;"], [164, "&curren;"], [169, "&copy;"], [174, "&reg;"]]),
                it.safeCharCodes = function() {
                    const st = new Set;
                    for (let at = 32; at < 123; ++at)
                        (at >= 97 || at >= 65 && at <= 90 || at >= 48 && at <= 57 || at === 32 || at === 46 || at === 44 || at === 45 || at === 58 || at === 95) && st.add(at);
                    return st
                }()
            }
            ,
            6064: nt=>{
                nt.exports = function(it) {
                    return it.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&")
                }
            }
            ,
            738: nt=>{
                nt.exports = function() {}
            }
            ,
            1687: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(8571)
                  , lt = st(7043)
                  , dt = {};
                nt.exports = dt.merge = function(ct, ut, ft) {
                    if (at(ct && typeof ct == "object", "Invalid target value: must be an object"),
                    at(ut == null || typeof ut == "object", "Invalid source value: must be null, undefined, or an object"),
                    !ut)
                        return ct;
                    if (ft = Object.assign({
                        nullOverride: !0,
                        mergeArrays: !0
                    }, ft),
                    Array.isArray(ut)) {
                        at(Array.isArray(ct), "Cannot merge array onto an object"),
                        ft.mergeArrays || (ct.length = 0);
                        for (let gt = 0; gt < ut.length; ++gt)
                            ct.push(ot(ut[gt], {
                                symbols: ft.symbols
                            }));
                        return ct
                    }
                    const ht = lt.keys(ut, ft);
                    for (let gt = 0; gt < ht.length; ++gt) {
                        const bt = ht[gt];
                        if (bt === "__proto__" || !Object.prototype.propertyIsEnumerable.call(ut, bt))
                            continue;
                        const pt = ut[bt];
                        if (pt && typeof pt == "object") {
                            if (ct[bt] === pt)
                                continue;
                            !ct[bt] || typeof ct[bt] != "object" || Array.isArray(ct[bt]) !== Array.isArray(pt) || pt instanceof Date || pt instanceof RegExp ? ct[bt] = ot(pt, {
                                symbols: ft.symbols
                            }) : dt.merge(ct[bt], pt, ft)
                        } else
                            (pt != null || ft.nullOverride) && (ct[bt] = pt)
                    }
                    return ct
                }
            }
            ,
            9621: (nt,it,st)=>{
                const at = st(375)
                  , ot = {};
                nt.exports = function(lt, dt, ct) {
                    if (dt === !1 || dt == null)
                        return lt;
                    typeof (ct = ct || {}) == "string" && (ct = {
                        separator: ct
                    });
                    const ut = Array.isArray(dt);
                    at(!ut || !ct.separator, "Separator option is not valid for array-based chain");
                    const ft = ut ? dt : dt.split(ct.separator || ".");
                    let ht = lt;
                    for (let gt = 0; gt < ft.length; ++gt) {
                        let bt = ft[gt];
                        const pt = ct.iterables && ot.iterables(ht);
                        if (Array.isArray(ht) || pt === "set") {
                            const mt = Number(bt);
                            Number.isInteger(mt) && (bt = mt < 0 ? ht.length + mt : mt)
                        }
                        if (!ht || typeof ht == "function" && ct.functions === !1 || !pt && ht[bt] === void 0) {
                            at(!ct.strict || gt + 1 === ft.length, "Missing segment", bt, "in reach path ", dt),
                            at(typeof ht == "object" || ct.functions === !0 || typeof ht != "function", "Invalid segment", bt, "in reach path ", dt),
                            ht = ct.default;
                            break
                        }
                        ht = pt ? pt === "set" ? [...ht][bt] : ht.get(bt) : ht[bt]
                    }
                    return ht
                }
                ,
                ot.iterables = function(lt) {
                    return lt instanceof Set ? "set" : lt instanceof Map ? "map" : void 0
                }
            }
            ,
            8761: nt=>{
                nt.exports = function(...it) {
                    try {
                        return JSON.stringify(...it)
                    } catch (st) {
                        return "[Cannot display object: " + st.message + "]"
                    }
                }
            }
            ,
            4277: (nt,it)=>{
                const st = {};
                it = nt.exports = {
                    array: Array.prototype,
                    buffer: !1,
                    date: Date.prototype,
                    error: Error.prototype,
                    generic: Object.prototype,
                    map: Map.prototype,
                    promise: Promise.prototype,
                    regex: RegExp.prototype,
                    set: Set.prototype,
                    weakMap: WeakMap.prototype,
                    weakSet: WeakSet.prototype
                },
                st.typeMap = new Map([["[object Error]", it.error], ["[object Map]", it.map], ["[object Promise]", it.promise], ["[object Set]", it.set], ["[object WeakMap]", it.weakMap], ["[object WeakSet]", it.weakSet]]),
                it.getInternalProto = function(at) {
                    if (Array.isArray(at))
                        return it.array;
                    if (at instanceof Date)
                        return it.date;
                    if (at instanceof RegExp)
                        return it.regex;
                    if (at instanceof Error)
                        return it.error;
                    const ot = Object.prototype.toString.call(at);
                    return st.typeMap.get(ot) || it.generic
                }
            }
            ,
            7043: (nt,it)=>{
                it.keys = function(st, at={}) {
                    return at.symbols !== !1 ? Reflect.ownKeys(st) : Object.getOwnPropertyNames(st)
                }
            }
            ,
            3652: (nt,it,st)=>{
                const at = st(375)
                  , ot = {};
                it.Sorter = class {
                    constructor() {
                        this._items = [],
                        this.nodes = []
                    }
                    add(lt, dt) {
                        const ct = [].concat((dt = dt || {}).before || [])
                          , ut = [].concat(dt.after || [])
                          , ft = dt.group || "?"
                          , ht = dt.sort || 0;
                        at(!ct.includes(ft), `Item cannot come before itself: ${ft}`),
                        at(!ct.includes("?"), "Item cannot come before unassociated items"),
                        at(!ut.includes(ft), `Item cannot come after itself: ${ft}`),
                        at(!ut.includes("?"), "Item cannot come after unassociated items"),
                        Array.isArray(lt) || (lt = [lt]);
                        for (const gt of lt) {
                            const bt = {
                                seq: this._items.length,
                                sort: ht,
                                before: ct,
                                after: ut,
                                group: ft,
                                node: gt
                            };
                            this._items.push(bt)
                        }
                        if (!dt.manual) {
                            const gt = this._sort();
                            at(gt, "item", ft !== "?" ? `added into group ${ft}` : "", "created a dependencies error")
                        }
                        return this.nodes
                    }
                    merge(lt) {
                        Array.isArray(lt) || (lt = [lt]);
                        for (const ct of lt)
                            if (ct)
                                for (const ut of ct._items)
                                    this._items.push(Object.assign({}, ut));
                        this._items.sort(ot.mergeSort);
                        for (let ct = 0; ct < this._items.length; ++ct)
                            this._items[ct].seq = ct;
                        const dt = this._sort();
                        return at(dt, "merge created a dependencies error"),
                        this.nodes
                    }
                    sort() {
                        const lt = this._sort();
                        return at(lt, "sort created a dependencies error"),
                        this.nodes
                    }
                    _sort() {
                        const lt = {}
                          , dt = Object.create(null)
                          , ct = Object.create(null);
                        for (const bt of this._items) {
                            const pt = bt.seq
                              , mt = bt.group;
                            ct[mt] = ct[mt] || [],
                            ct[mt].push(pt),
                            lt[pt] = bt.before;
                            for (const yt of bt.after)
                                dt[yt] = dt[yt] || [],
                                dt[yt].push(pt)
                        }
                        for (const bt in lt) {
                            const pt = [];
                            for (const mt in lt[bt]) {
                                const yt = lt[bt][mt];
                                ct[yt] = ct[yt] || [],
                                pt.push(...ct[yt])
                            }
                            lt[bt] = pt
                        }
                        for (const bt in dt)
                            if (ct[bt])
                                for (const pt of ct[bt])
                                    lt[pt].push(...dt[bt]);
                        const ut = {};
                        for (const bt in lt) {
                            const pt = lt[bt];
                            for (const mt of pt)
                                ut[mt] = ut[mt] || [],
                                ut[mt].push(bt)
                        }
                        const ft = {}
                          , ht = [];
                        for (let bt = 0; bt < this._items.length; ++bt) {
                            let pt = bt;
                            if (ut[bt]) {
                                pt = null;
                                for (let mt = 0; mt < this._items.length; ++mt) {
                                    if (ft[mt] === !0)
                                        continue;
                                    ut[mt] || (ut[mt] = []);
                                    const yt = ut[mt].length;
                                    let vt = 0;
                                    for (let wt = 0; wt < yt; ++wt)
                                        ft[ut[mt][wt]] && ++vt;
                                    if (vt === yt) {
                                        pt = mt;
                                        break
                                    }
                                }
                            }
                            pt !== null && (ft[pt] = !0,
                            ht.push(pt))
                        }
                        if (ht.length !== this._items.length)
                            return !1;
                        const gt = {};
                        for (const bt of this._items)
                            gt[bt.seq] = bt;
                        this._items = [],
                        this.nodes = [];
                        for (const bt of ht) {
                            const pt = gt[bt];
                            this.nodes.push(pt.node),
                            this._items.push(pt)
                        }
                        return !0
                    }
                }
                ,
                ot.mergeSort = (lt,dt)=>lt.sort === dt.sort ? 0 : lt.sort < dt.sort ? -1 : 1
            }
            ,
            5380: (nt,it,st)=>{
                const at = st(443)
                  , ot = st(2178)
                  , lt = {
                    minDomainSegments: 2,
                    nonAsciiRx: /[^\x00-\x7f]/,
                    domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
                    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
                    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
                    URL: at.URL || URL
                };
                it.analyze = function(dt, ct={}) {
                    if (!dt)
                        return ot.code("DOMAIN_NON_EMPTY_STRING");
                    if (typeof dt != "string")
                        throw new Error("Invalid input: domain must be a string");
                    if (dt.length > 256)
                        return ot.code("DOMAIN_TOO_LONG");
                    if (lt.nonAsciiRx.test(dt)) {
                        if (ct.allowUnicode === !1)
                            return ot.code("DOMAIN_INVALID_UNICODE_CHARS");
                        dt = dt.normalize("NFC")
                    }
                    if (lt.domainControlRx.test(dt))
                        return ot.code("DOMAIN_INVALID_CHARS");
                    dt = lt.punycode(dt),
                    ct.allowFullyQualified && dt[dt.length - 1] === "." && (dt = dt.slice(0, -1));
                    const ut = ct.minDomainSegments || lt.minDomainSegments
                      , ft = dt.split(".");
                    if (ft.length < ut)
                        return ot.code("DOMAIN_SEGMENTS_COUNT");
                    if (ct.maxDomainSegments && ft.length > ct.maxDomainSegments)
                        return ot.code("DOMAIN_SEGMENTS_COUNT_MAX");
                    const ht = ct.tlds;
                    if (ht) {
                        const gt = ft[ft.length - 1].toLowerCase();
                        if (ht.deny && ht.deny.has(gt) || ht.allow && !ht.allow.has(gt))
                            return ot.code("DOMAIN_FORBIDDEN_TLDS")
                    }
                    for (let gt = 0; gt < ft.length; ++gt) {
                        const bt = ft[gt];
                        if (!bt.length)
                            return ot.code("DOMAIN_EMPTY_SEGMENT");
                        if (bt.length > 63)
                            return ot.code("DOMAIN_LONG_SEGMENT");
                        if (gt < ft.length - 1) {
                            if (!lt.domainSegmentRx.test(bt))
                                return ot.code("DOMAIN_INVALID_CHARS")
                        } else if (!lt.tldSegmentRx.test(bt))
                            return ot.code("DOMAIN_INVALID_TLDS_CHARS")
                    }
                    return null
                }
                ,
                it.isValid = function(dt, ct) {
                    return !it.analyze(dt, ct)
                }
                ,
                lt.punycode = function(dt) {
                    dt.includes("%") && (dt = dt.replace(/%/g, "%25"));
                    try {
                        return new lt.URL(`http://${dt}`).host
                    } catch {
                        return dt
                    }
                }
            }
            ,
            1745: (nt,it,st)=>{
                const at = st(9848)
                  , ot = st(5380)
                  , lt = st(2178)
                  , dt = {
                    nonAsciiRx: /[^\x00-\x7f]/,
                    encoder: new (at.TextEncoder || TextEncoder)
                };
                it.analyze = function(ct, ut) {
                    return dt.email(ct, ut)
                }
                ,
                it.isValid = function(ct, ut) {
                    return !dt.email(ct, ut)
                }
                ,
                dt.email = function(ct, ut={}) {
                    if (typeof ct != "string")
                        throw new Error("Invalid input: email must be a string");
                    if (!ct)
                        return lt.code("EMPTY_STRING");
                    const ft = !dt.nonAsciiRx.test(ct);
                    if (!ft) {
                        if (ut.allowUnicode === !1)
                            return lt.code("FORBIDDEN_UNICODE");
                        ct = ct.normalize("NFC")
                    }
                    const ht = ct.split("@");
                    if (ht.length !== 2)
                        return ht.length > 2 ? lt.code("MULTIPLE_AT_CHAR") : lt.code("MISSING_AT_CHAR");
                    const [gt,bt] = ht;
                    if (!gt)
                        return lt.code("EMPTY_LOCAL");
                    if (!ut.ignoreLength) {
                        if (ct.length > 254)
                            return lt.code("ADDRESS_TOO_LONG");
                        if (dt.encoder.encode(gt).length > 64)
                            return lt.code("LOCAL_TOO_LONG")
                    }
                    return dt.local(gt, ft) || ot.analyze(bt, ut)
                }
                ,
                dt.local = function(ct, ut) {
                    const ft = ct.split(".");
                    for (const ht of ft) {
                        if (!ht.length)
                            return lt.code("EMPTY_LOCAL_SEGMENT");
                        if (ut) {
                            if (!dt.atextRx.test(ht))
                                return lt.code("INVALID_LOCAL_CHARS")
                        } else
                            for (const gt of ht) {
                                if (dt.atextRx.test(gt))
                                    continue;
                                const bt = dt.binary(gt);
                                if (!dt.atomRx.test(bt))
                                    return lt.code("INVALID_LOCAL_CHARS")
                            }
                    }
                }
                ,
                dt.binary = function(ct) {
                    return Array.from(dt.encoder.encode(ct)).map(ut=>String.fromCharCode(ut)).join("")
                }
                ,
                dt.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,
                dt.atomRx = new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])", "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})", "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))
            }
            ,
            2178: (nt,it)=>{
                it.codes = {
                    EMPTY_STRING: "Address must be a non-empty string",
                    FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
                    MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
                    MISSING_AT_CHAR: "Address must contain one @ character",
                    EMPTY_LOCAL: "Address local part cannot be empty",
                    ADDRESS_TOO_LONG: "Address too long",
                    LOCAL_TOO_LONG: "Address local part too long",
                    EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
                    INVALID_LOCAL_CHARS: "Address local part contains invalid character",
                    DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
                    DOMAIN_TOO_LONG: "Domain too long",
                    DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
                    DOMAIN_INVALID_CHARS: "Domain contains invalid character",
                    DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
                    DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
                    DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
                    DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
                    DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
                    DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
                },
                it.code = function(st) {
                    return {
                        code: st,
                        error: it.codes[st]
                    }
                }
            }
            ,
            9959: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(5752);
                it.regex = function(lt={}) {
                    at(lt.cidr === void 0 || typeof lt.cidr == "string", "options.cidr must be a string");
                    const dt = lt.cidr ? lt.cidr.toLowerCase() : "optional";
                    at(["required", "optional", "forbidden"].includes(dt), "options.cidr must be one of required, optional, forbidden"),
                    at(lt.version === void 0 || typeof lt.version == "string" || Array.isArray(lt.version), "options.version must be a string or an array of string");
                    let ct = lt.version || ["ipv4", "ipv6", "ipvfuture"];
                    Array.isArray(ct) || (ct = [ct]),
                    at(ct.length >= 1, "options.version must have at least 1 version specified");
                    for (let ht = 0; ht < ct.length; ++ht)
                        at(typeof ct[ht] == "string", "options.version must only contain strings"),
                        ct[ht] = ct[ht].toLowerCase(),
                        at(["ipv4", "ipv6", "ipvfuture"].includes(ct[ht]), "options.version contains unknown version " + ct[ht] + " - must be one of ipv4, ipv6, ipvfuture");
                    ct = Array.from(new Set(ct));
                    const ut = `(?:${ct.map(ht=>{
                        if (dt === "forbidden")
                            return ot.ip[ht];
                        const gt = `\\/${ht === "ipv4" ? ot.ip.v4Cidr : ot.ip.v6Cidr}`;
                        return dt === "required" ? `${ot.ip[ht]}${gt}` : `${ot.ip[ht]}(?:${gt})?`
                    }
                    ).join("|")})`
                      , ft = new RegExp(`^${ut}$`);
                    return {
                        cidr: dt,
                        versions: ct,
                        regex: ft,
                        raw: ut
                    }
                }
            }
            ,
            5752: (nt,it,st)=>{
                const at = st(375)
                  , ot = st(6064)
                  , lt = {
                    generate: function() {
                        const dt = {}
                          , ct = "\\dA-Fa-f"
                          , ut = "[" + ct + "]"
                          , ft = "\\w-\\.~"
                          , ht = "!\\$&'\\(\\)\\*\\+,;="
                          , gt = "%" + ct
                          , bt = ft + gt + ht + ":@"
                          , pt = "[" + bt + "]"
                          , mt = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
                        dt.ipv4address = "(?:" + mt + "\\.){3}" + mt;
                        const yt = ut + "{1,4}"
                          , vt = "(?:" + yt + ":" + yt + "|" + dt.ipv4address + ")"
                          , wt = "(?:" + yt + ":){6}" + vt
                          , _t = "::(?:" + yt + ":){5}" + vt
                          , Et = "(?:" + yt + ")?::(?:" + yt + ":){4}" + vt
                          , xt = "(?:(?:" + yt + ":){0,1}" + yt + ")?::(?:" + yt + ":){3}" + vt
                          , Ct = "(?:(?:" + yt + ":){0,2}" + yt + ")?::(?:" + yt + ":){2}" + vt
                          , Tt = "(?:(?:" + yt + ":){0,3}" + yt + ")?::" + yt + ":" + vt
                          , It = "(?:(?:" + yt + ":){0,4}" + yt + ")?::" + vt
                          , Nt = "(?:(?:" + yt + ":){0,5}" + yt + ")?::" + yt
                          , Ft = "(?:(?:" + yt + ":){0,6}" + yt + ")?::";
                        dt.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])",
                        dt.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",
                        dt.ipv6address = "(?:" + wt + "|" + _t + "|" + Et + "|" + xt + "|" + Ct + "|" + Tt + "|" + It + "|" + Nt + "|" + Ft + ")",
                        dt.ipvFuture = "v" + ut + "+\\.[" + ft + ht + ":]+",
                        dt.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*",
                        dt.schemeRegex = new RegExp(dt.scheme);
                        const Lt = "[" + ft + gt + ht + ":]*"
                          , Mt = "[" + ft + gt + ht + "]{1,255}"
                          , $t = "(?:\\[(?:" + dt.ipv6address + "|" + dt.ipvFuture + ")\\]|" + dt.ipv4address + "|" + Mt + ")"
                          , kt = "(?:" + Lt + "@)?" + $t + "(?::\\d*)?"
                          , At = "(?:" + Lt + "@)?(" + $t + ")(?::\\d*)?"
                          , Pt = pt + "*"
                          , Dt = pt + "+"
                          , Bt = "(?:\\/" + Pt + ")*"
                          , zt = "\\/(?:" + Dt + Bt + ")?"
                          , Yt = Dt + Bt
                          , rr = "[" + ft + gt + ht + "@]+" + Bt
                          , ar = "(?:\\/\\/\\/" + Pt + Bt + ")";
                        return dt.hierPart = "(?:(?:\\/\\/" + kt + Bt + ")|" + zt + "|" + Yt + "|" + ar + ")",
                        dt.hierPartCapture = "(?:(?:\\/\\/" + At + Bt + ")|" + zt + "|" + Yt + ")",
                        dt.relativeRef = "(?:(?:\\/\\/" + kt + Bt + ")|" + zt + "|" + rr + "|)",
                        dt.relativeRefCapture = "(?:(?:\\/\\/" + At + Bt + ")|" + zt + "|" + rr + "|)",
                        dt.query = "[" + bt + "\\/\\?]*(?=#|$)",
                        dt.queryWithSquareBrackets = "[" + bt + "\\[\\]\\/\\?]*(?=#|$)",
                        dt.fragment = "[" + bt + "\\/\\?]*",
                        dt
                    }
                };
                lt.rfc3986 = lt.generate(),
                it.ip = {
                    v4Cidr: lt.rfc3986.ipv4Cidr,
                    v6Cidr: lt.rfc3986.ipv6Cidr,
                    ipv4: lt.rfc3986.ipv4address,
                    ipv6: lt.rfc3986.ipv6address,
                    ipvfuture: lt.rfc3986.ipvFuture
                },
                lt.createRegex = function(dt) {
                    const ct = lt.rfc3986
                      , ut = "(?:\\?" + (dt.allowQuerySquareBrackets ? ct.queryWithSquareBrackets : ct.query) + ")?(?:#" + ct.fragment + ")?"
                      , ft = dt.domain ? ct.relativeRefCapture : ct.relativeRef;
                    if (dt.relativeOnly)
                        return lt.wrap(ft + ut);
                    let ht = "";
                    if (dt.scheme) {
                        at(dt.scheme instanceof RegExp || typeof dt.scheme == "string" || Array.isArray(dt.scheme), "scheme must be a RegExp, String, or Array");
                        const pt = [].concat(dt.scheme);
                        at(pt.length >= 1, "scheme must have at least 1 scheme specified");
                        const mt = [];
                        for (let yt = 0; yt < pt.length; ++yt) {
                            const vt = pt[yt];
                            at(vt instanceof RegExp || typeof vt == "string", "scheme at position " + yt + " must be a RegExp or String"),
                            vt instanceof RegExp ? mt.push(vt.source.toString()) : (at(ct.schemeRegex.test(vt), "scheme at position " + yt + " must be a valid scheme"),
                            mt.push(ot(vt)))
                        }
                        ht = mt.join("|")
                    }
                    const gt = "(?:" + (ht ? "(?:" + ht + ")" : ct.scheme) + ":" + (dt.domain ? ct.hierPartCapture : ct.hierPart) + ")"
                      , bt = dt.allowRelative ? "(?:" + gt + "|" + ft + ")" : gt;
                    return lt.wrap(bt + ut, ht)
                }
                ,
                lt.wrap = function(dt, ct) {
                    return {
                        raw: dt = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${dt}`,
                        regex: new RegExp(`^${dt}$`),
                        scheme: ct
                    }
                }
                ,
                lt.uriRegex = lt.createRegex({}),
                it.regex = function(dt={}) {
                    return dt.scheme || dt.allowRelative || dt.relativeOnly || dt.allowQuerySquareBrackets || dt.domain ? lt.createRegex(dt) : lt.uriRegex
                }
            }
            ,
            1447: (nt,it)=>{
                const st = {
                    operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
                    operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
                    operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
                    operatorsPrefix: ["!", "n"],
                    literals: {
                        '"': '"',
                        "`": "`",
                        "'": "'",
                        "[": "]"
                    },
                    numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
                    tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
                    symbol: Symbol("formula"),
                    settings: Symbol("settings")
                };
                it.Parser = class {
                    constructor(at, ot={}) {
                        if (!ot[st.settings] && ot.constants)
                            for (const lt in ot.constants) {
                                const dt = ot.constants[lt];
                                if (dt !== null && !["boolean", "number", "string"].includes(typeof dt))
                                    throw new Error(`Formula constant ${lt} contains invalid ${typeof dt} value type`)
                            }
                        this.settings = ot[st.settings] ? ot : Object.assign({
                            [st.settings]: !0,
                            constants: {},
                            functions: {}
                        }, ot),
                        this.single = null,
                        this._parts = null,
                        this._parse(at)
                    }
                    _parse(at) {
                        let ot = []
                          , lt = ""
                          , dt = 0
                          , ct = !1;
                        const ut = ht=>{
                            if (dt)
                                throw new Error("Formula missing closing parenthesis");
                            const gt = ot.length ? ot[ot.length - 1] : null;
                            if (ct || lt || ht) {
                                if (gt && gt.type === "reference" && ht === ")")
                                    return gt.type = "function",
                                    gt.value = this._subFormula(lt, gt.value),
                                    void (lt = "");
                                if (ht === ")") {
                                    const bt = new it.Parser(lt,this.settings);
                                    ot.push({
                                        type: "segment",
                                        value: bt
                                    })
                                } else if (ct) {
                                    if (ct === "]")
                                        return ot.push({
                                            type: "reference",
                                            value: lt
                                        }),
                                        void (lt = "");
                                    ot.push({
                                        type: "literal",
                                        value: lt
                                    })
                                } else if (st.operatorCharacters.includes(lt))
                                    gt && gt.type === "operator" && st.operators.includes(gt.value + lt) ? gt.value += lt : ot.push({
                                        type: "operator",
                                        value: lt
                                    });
                                else if (lt.match(st.numberRx))
                                    ot.push({
                                        type: "constant",
                                        value: parseFloat(lt)
                                    });
                                else if (this.settings.constants[lt] !== void 0)
                                    ot.push({
                                        type: "constant",
                                        value: this.settings.constants[lt]
                                    });
                                else {
                                    if (!lt.match(st.tokenRx))
                                        throw new Error(`Formula contains invalid token: ${lt}`);
                                    ot.push({
                                        type: "reference",
                                        value: lt
                                    })
                                }
                                lt = ""
                            }
                        }
                        ;
                        for (const ht of at)
                            ct ? ht === ct ? (ut(),
                            ct = !1) : lt += ht : dt ? ht === "(" ? (lt += ht,
                            ++dt) : ht === ")" ? (--dt,
                            dt ? lt += ht : ut(ht)) : lt += ht : ht in st.literals ? ct = st.literals[ht] : ht === "(" ? (ut(),
                            ++dt) : st.operatorCharacters.includes(ht) ? (ut(),
                            lt = ht,
                            ut()) : ht !== " " ? lt += ht : ut();
                        ut(),
                        ot = ot.map((ht,gt)=>ht.type !== "operator" || ht.value !== "-" || gt && ot[gt - 1].type !== "operator" ? ht : {
                            type: "operator",
                            value: "n"
                        });
                        let ft = !1;
                        for (const ht of ot) {
                            if (ht.type === "operator") {
                                if (st.operatorsPrefix.includes(ht.value))
                                    continue;
                                if (!ft)
                                    throw new Error("Formula contains an operator in invalid position");
                                if (!st.operators.includes(ht.value))
                                    throw new Error(`Formula contains an unknown operator ${ht.value}`)
                            } else if (ft)
                                throw new Error("Formula missing expected operator");
                            ft = !ft
                        }
                        if (!ft)
                            throw new Error("Formula contains invalid trailing operator");
                        ot.length === 1 && ["reference", "literal", "constant"].includes(ot[0].type) && (this.single = {
                            type: ot[0].type === "reference" ? "reference" : "value",
                            value: ot[0].value
                        }),
                        this._parts = ot.map(ht=>{
                            if (ht.type === "operator")
                                return st.operatorsPrefix.includes(ht.value) ? ht : ht.value;
                            if (ht.type !== "reference")
                                return ht.value;
                            if (this.settings.tokenRx && !this.settings.tokenRx.test(ht.value))
                                throw new Error(`Formula contains invalid reference ${ht.value}`);
                            return this.settings.reference ? this.settings.reference(ht.value) : st.reference(ht.value)
                        }
                        )
                    }
                    _subFormula(at, ot) {
                        const lt = this.settings.functions[ot];
                        if (typeof lt != "function")
                            throw new Error(`Formula contains unknown function ${ot}`);
                        let dt = [];
                        if (at) {
                            let ct = ""
                              , ut = 0
                              , ft = !1;
                            const ht = ()=>{
                                if (!ct)
                                    throw new Error(`Formula contains function ${ot} with invalid arguments ${at}`);
                                dt.push(ct),
                                ct = ""
                            }
                            ;
                            for (let gt = 0; gt < at.length; ++gt) {
                                const bt = at[gt];
                                ft ? (ct += bt,
                                bt === ft && (ft = !1)) : bt in st.literals && !ut ? (ct += bt,
                                ft = st.literals[bt]) : bt !== "," || ut ? (ct += bt,
                                bt === "(" ? ++ut : bt === ")" && --ut) : ht()
                            }
                            ht()
                        }
                        return dt = dt.map(ct=>new it.Parser(ct,this.settings)),
                        function(ct) {
                            const ut = [];
                            for (const ft of dt)
                                ut.push(ft.evaluate(ct));
                            return lt.call(ct, ...ut)
                        }
                    }
                    evaluate(at) {
                        const ot = this._parts.slice();
                        for (let lt = ot.length - 2; lt >= 0; --lt) {
                            const dt = ot[lt];
                            if (dt && dt.type === "operator") {
                                const ct = ot[lt + 1];
                                ot.splice(lt + 1, 1);
                                const ut = st.evaluate(ct, at);
                                ot[lt] = st.single(dt.value, ut)
                            }
                        }
                        return st.operatorsOrder.forEach(lt=>{
                            for (let dt = 1; dt < ot.length - 1; )
                                if (lt.includes(ot[dt])) {
                                    const ct = ot[dt]
                                      , ut = st.evaluate(ot[dt - 1], at)
                                      , ft = st.evaluate(ot[dt + 1], at);
                                    ot.splice(dt, 2);
                                    const ht = st.calculate(ct, ut, ft);
                                    ot[dt - 1] = ht === 0 ? 0 : ht
                                } else
                                    dt += 2
                        }
                        ),
                        st.evaluate(ot[0], at)
                    }
                }
                ,
                it.Parser.prototype[st.symbol] = !0,
                st.reference = function(at) {
                    return function(ot) {
                        return ot && ot[at] !== void 0 ? ot[at] : null
                    }
                }
                ,
                st.evaluate = function(at, ot) {
                    return at === null ? null : typeof at == "function" ? at(ot) : at[st.symbol] ? at.evaluate(ot) : at
                }
                ,
                st.single = function(at, ot) {
                    if (at === "!")
                        return !ot;
                    const lt = -ot;
                    return lt === 0 ? 0 : lt
                }
                ,
                st.calculate = function(at, ot, lt) {
                    if (at === "??")
                        return st.exists(ot) ? ot : lt;
                    if (typeof ot == "string" || typeof lt == "string") {
                        if (at === "+")
                            return (ot = st.exists(ot) ? ot : "") + (st.exists(lt) ? lt : "")
                    } else
                        switch (at) {
                        case "^":
                            return Math.pow(ot, lt);
                        case "*":
                            return ot * lt;
                        case "/":
                            return ot / lt;
                        case "%":
                            return ot % lt;
                        case "+":
                            return ot + lt;
                        case "-":
                            return ot - lt
                        }
                    switch (at) {
                    case "<":
                        return ot < lt;
                    case "<=":
                        return ot <= lt;
                    case ">":
                        return ot > lt;
                    case ">=":
                        return ot >= lt;
                    case "==":
                        return ot === lt;
                    case "!=":
                        return ot !== lt;
                    case "&&":
                        return ot && lt;
                    case "||":
                        return ot || lt
                    }
                    return null
                }
                ,
                st.exists = function(at) {
                    return at != null
                }
            }
            ,
            9926: ()=>{}
            ,
            5688: ()=>{}
            ,
            9708: ()=>{}
            ,
            1152: ()=>{}
            ,
            443: ()=>{}
            ,
            9848: ()=>{}
            ,
            5934: nt=>{
                nt.exports = JSON.parse('{"version":"17.12.1"}')
            }
        },
        rt = {},
        function nt(it) {
            var st = rt[it];
            if (st !== void 0)
                return st.exports;
            var at = rt[it] = {
                exports: {}
            };
            return tt[it](at, at.exports, nt),
            at.exports
        }(5107);
        var tt, rt
    }
    )
}
)(joiBrowser_min);
var joiBrowser_minExports = joiBrowser_min.exports;
const Joi = getDefaultExportFromCjs(joiBrowser_minExports)
  , Layout = ()=>{
    const [_e,et] = reactExports.useState(!1)
      , {address: tt, isConnected: rt} = useAccount()
      , nt = useLocation()
      , [it,{isLoading: st}] = useCreateReferralMutation()
      , {refetch: at} = useCountReferralQuery(tt, {
        skip: !rt
    })
      , lt = new URLSearchParams(nt.search).get("referral");
    let dt = lt || "0x0000000000000000000000000000000000000000";
    const ct = Joi.string().pattern(/^0x[a-fA-F0-9]{40}$/).required().messages({
        "string.pattern": "Invalid smart contract address format. (Must start with 0x and be 40 hex characters)",
        "any.required": "Smart contract address is required"
    });
    return reactExports.useEffect(()=>{
        (async()=>{
            if (rt && !st) {
                at();
                try {
                    const {error: ut} = ct.validate(dt);
                    ut && (console.error(ut.details[0].message),
                    dt = "0x0000000000000000000000000000000000000000"),
                    await it({
                        userAddress: tt,
                        referral: dt
                    }).unwrap()
                } catch {}
            }
        }
        )()
    }
    , [rt]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(ReactModal, {
            isOpen: _e,
            closeTimeoutMS: 500,
            className: "startModal",
            overlayClassName: "startModalOverlay",
            onRequestClose: ()=>{
                et(!1)
            }
            ,
            children: jsxRuntimeExports.jsxs("div", {
                children: [jsxRuntimeExports.jsx("h6", {
                    className: "startMainPara",
                    children: "We hit a small bump recently - our Telegram groups were deleted due to reasons beyond our understanding. But, as always, we're turning challenges into opportunities. We're using this moment to enhance our launch, now rescheduled for February 14th, including a highly requested referral program."
                }), jsxRuntimeExports.jsx("h5", {
                    className: "startSubPara",
                    children: "Join our Telegram to stay updated. Your support fuels our progress, and we're excited to share this journey with you."
                }), jsxRuntimeExports.jsx("div", {
                    className: "text-center mt-5",
                    children: jsxRuntimeExports.jsx("a", {
                        href: "https://t.me/CloudBTC_Global",
                        target: "_blank",
                        className: "startJoinNow",
                        children: "Join Our Telegram"
                    })
                })]
            })
        }), jsxRuntimeExports.jsx(Header, {}), jsxRuntimeExports.jsx(Outlet, {}), jsxRuntimeExports.jsx(Footer, {})]
    })
}
  , useAppDispatch = useDispatch
  , useAppSelector = useSelector
  , initState = {
    referral: "0x0000000000000000000000000000000000000000"
}
  , pageSlice = createSlice({
    name: "pageSlice",
    initialState: initState,
    reducers: {
        setReferral: (_e,et)=>{
            const {referral: tt} = et.payload;
            _e.referral = tt
        }
    }
})
  , {setReferral} = pageSlice.actions
  , pageSlice$1 = pageSlice.reducer
  , CurrentUserReferral = _e=>_e.pageSlice.referral;
function CiEdit(_e) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "g",
            attr: {
                id: "Edit"
            },
            child: [{
                tag: "g",
                attr: {},
                child: [{
                    tag: "path",
                    attr: {
                        d: "M3.548,20.938h16.9a.5.5,0,0,0,0-1H3.548a.5.5,0,0,0,0,1Z"
                    },
                    child: []
                }, {
                    tag: "path",
                    attr: {
                        d: "M9.71,17.18a2.587,2.587,0,0,0,1.12-.65l9.54-9.54a1.75,1.75,0,0,0,0-2.47l-.94-.93a1.788,1.788,0,0,0-2.47,0L7.42,13.12a2.473,2.473,0,0,0-.64,1.12L6.04,17a.737.737,0,0,0,.19.72.767.767,0,0,0,.53.22Zm.41-1.36a1.468,1.468,0,0,1-.67.39l-.97.26-1-1,.26-.97a1.521,1.521,0,0,1,.39-.67l.38-.37,1.99,1.99Zm1.09-1.08L9.22,12.75l6.73-6.73,1.99,1.99Zm8.45-8.45L18.65,7.3,16.66,5.31l1.01-1.02a.748.748,0,0,1,1.06,0l.93.94A.754.754,0,0,1,19.66,6.29Z"
                    },
                    child: []
                }]
            }]
        }]
    })(_e)
}
var isCheckBoxInput = _e=>_e.type === "checkbox"
  , isDateObject = _e=>_e instanceof Date
  , isNullOrUndefined = _e=>_e == null;
const isObjectType = _e=>typeof _e == "object";
var isObject$3 = _e=>!isNullOrUndefined(_e) && !Array.isArray(_e) && isObjectType(_e) && !isDateObject(_e)
  , getEventValue = _e=>isObject$3(_e) && _e.target ? isCheckBoxInput(_e.target) ? _e.target.checked : _e.target.value : _e
  , getNodeParentName = _e=>_e.substring(0, _e.search(/\.\d+(\.|$)/)) || _e
  , isNameInFieldArray = (_e,et)=>_e.has(getNodeParentName(et))
  , isPlainObject = _e=>{
    const et = _e.constructor && _e.constructor.prototype;
    return isObject$3(et) && et.hasOwnProperty("isPrototypeOf")
}
  , isWeb = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function cloneObject(_e) {
    let et;
    const tt = Array.isArray(_e);
    if (_e instanceof Date)
        et = new Date(_e);
    else if (_e instanceof Set)
        et = new Set(_e);
    else if (!(isWeb && (_e instanceof Blob || _e instanceof FileList)) && (tt || isObject$3(_e)))
        if (et = tt ? [] : {},
        !tt && !isPlainObject(_e))
            et = _e;
        else
            for (const rt in _e)
                _e.hasOwnProperty(rt) && (et[rt] = cloneObject(_e[rt]));
    else
        return _e;
    return et
}
var compact = _e=>Array.isArray(_e) ? _e.filter(Boolean) : []
  , isUndefined = _e=>_e === void 0
  , get = (_e,et,tt)=>{
    if (!et || !isObject$3(_e))
        return tt;
    const rt = compact(et.split(/[,[\].]+?/)).reduce((nt,it)=>isNullOrUndefined(nt) ? nt : nt[it], _e);
    return isUndefined(rt) || rt === _e ? isUndefined(_e[et]) ? tt : _e[et] : rt
}
  , isBoolean = _e=>typeof _e == "boolean";
const EVENTS = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , VALIDATION_MODE = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , INPUT_VALIDATION_RULES = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
};
React$1.createContext(null);
var getProxyFormState = (_e,et,tt,rt=!0)=>{
    const nt = {
        defaultValues: et._defaultValues
    };
    for (const it in _e)
        Object.defineProperty(nt, it, {
            get: ()=>{
                const st = it;
                return et._proxyFormState[st] !== VALIDATION_MODE.all && (et._proxyFormState[st] = !rt || VALIDATION_MODE.all),
                tt && (tt[st] = !0),
                _e[st]
            }
        });
    return nt
}
  , isEmptyObject = _e=>isObject$3(_e) && !Object.keys(_e).length
  , shouldRenderFormState = (_e,et,tt,rt)=>{
    tt(_e);
    const {name: nt, ...it} = _e;
    return isEmptyObject(it) || Object.keys(it).length >= Object.keys(et).length || Object.keys(it).find(st=>et[st] === (!rt || VALIDATION_MODE.all))
}
  , convertToArrayPayload = _e=>Array.isArray(_e) ? _e : [_e];
function useSubscribe(_e) {
    const et = React$1.useRef(_e);
    et.current = _e,
    React$1.useEffect(()=>{
        const tt = !_e.disabled && et.current.subject && et.current.subject.subscribe({
            next: et.current.next
        });
        return ()=>{
            tt && tt.unsubscribe()
        }
    }
    , [_e.disabled])
}
var isString = _e=>typeof _e == "string"
  , generateWatchOutput = (_e,et,tt,rt,nt)=>isString(_e) ? (rt && et.watch.add(_e),
get(tt, _e, nt)) : Array.isArray(_e) ? _e.map(it=>(rt && et.watch.add(it),
get(tt, it))) : (rt && (et.watchAll = !0),
tt)
  , isKey = _e=>/^\w*$/.test(_e)
  , stringToPath = _e=>compact(_e.replace(/["|']|\]/g, "").split(/\.|\[/))
  , set = (_e,et,tt)=>{
    let rt = -1;
    const nt = isKey(et) ? [et] : stringToPath(et)
      , it = nt.length
      , st = it - 1;
    for (; ++rt < it; ) {
        const at = nt[rt];
        let ot = tt;
        if (rt !== st) {
            const lt = _e[at];
            ot = isObject$3(lt) || Array.isArray(lt) ? lt : isNaN(+nt[rt + 1]) ? {} : []
        }
        _e[at] = ot,
        _e = _e[at]
    }
    return _e
}
  , appendErrors = (_e,et,tt,rt,nt)=>et ? {
    ...tt[_e],
    types: {
        ...tt[_e] && tt[_e].types ? tt[_e].types : {},
        [rt]: nt || !0
    }
} : {}
  , getValidationModes = _e=>({
    isOnSubmit: !_e || _e === VALIDATION_MODE.onSubmit,
    isOnBlur: _e === VALIDATION_MODE.onBlur,
    isOnChange: _e === VALIDATION_MODE.onChange,
    isOnAll: _e === VALIDATION_MODE.all,
    isOnTouch: _e === VALIDATION_MODE.onTouched
})
  , isWatched = (_e,et,tt)=>!tt && (et.watchAll || et.watch.has(_e) || [...et.watch].some(rt=>_e.startsWith(rt) && /^\.\w+/.test(_e.slice(rt.length))));
const iterateFieldsByAction = (_e,et,tt,rt)=>{
    for (const nt of tt || Object.keys(_e)) {
        const it = get(_e, nt);
        if (it) {
            const {_f: st, ...at} = it;
            if (st) {
                if (st.refs && st.refs[0] && et(st.refs[0], nt) && !rt)
                    break;
                if (st.ref && et(st.ref, st.name) && !rt)
                    break;
                iterateFieldsByAction(at, et)
            } else
                isObject$3(at) && iterateFieldsByAction(at, et)
        }
    }
}
;
var updateFieldArrayRootError = (_e,et,tt)=>{
    const rt = compact(get(_e, tt));
    return set(rt, "root", et[tt]),
    set(_e, tt, rt),
    _e
}
  , isFileInput = _e=>_e.type === "file"
  , isFunction = _e=>typeof _e == "function"
  , isHTMLElement = _e=>{
    if (!isWeb)
        return !1;
    const et = _e ? _e.ownerDocument : 0;
    return _e instanceof (et && et.defaultView ? et.defaultView.HTMLElement : HTMLElement)
}
  , isMessage = _e=>isString(_e)
  , isRadioInput = _e=>_e.type === "radio"
  , isRegex = _e=>_e instanceof RegExp;
const defaultResult = {
    value: !1,
    isValid: !1
}
  , validResult = {
    value: !0,
    isValid: !0
};
var getCheckboxValue = _e=>{
    if (Array.isArray(_e)) {
        if (_e.length > 1) {
            const et = _e.filter(tt=>tt && tt.checked && !tt.disabled).map(tt=>tt.value);
            return {
                value: et,
                isValid: !!et.length
            }
        }
        return _e[0].checked && !_e[0].disabled ? _e[0].attributes && !isUndefined(_e[0].attributes.value) ? isUndefined(_e[0].value) || _e[0].value === "" ? validResult : {
            value: _e[0].value,
            isValid: !0
        } : validResult : defaultResult
    }
    return defaultResult
}
;
const defaultReturn = {
    isValid: !1,
    value: null
};
var getRadioValue = _e=>Array.isArray(_e) ? _e.reduce((et,tt)=>tt && tt.checked && !tt.disabled ? {
    isValid: !0,
    value: tt.value
} : et, defaultReturn) : defaultReturn;
function getValidateError(_e, et, tt="validate") {
    if (isMessage(_e) || Array.isArray(_e) && _e.every(isMessage) || isBoolean(_e) && !_e)
        return {
            type: tt,
            message: isMessage(_e) ? _e : "",
            ref: et
        }
}
var getValueAndMessage = _e=>isObject$3(_e) && !isRegex(_e) ? _e : {
    value: _e,
    message: ""
}
  , validateField = async(_e,et,tt,rt,nt)=>{
    const {ref: it, refs: st, required: at, maxLength: ot, minLength: lt, min: dt, max: ct, pattern: ut, validate: ft, name: ht, valueAsNumber: gt, mount: bt, disabled: pt} = _e._f
      , mt = get(et, ht);
    if (!bt || pt)
        return {};
    const yt = st ? st[0] : it
      , vt = Nt=>{
        rt && yt.reportValidity && (yt.setCustomValidity(isBoolean(Nt) ? "" : Nt || ""),
        yt.reportValidity())
    }
      , wt = {}
      , _t = isRadioInput(it)
      , Et = isCheckBoxInput(it)
      , xt = _t || Et
      , Ct = (gt || isFileInput(it)) && isUndefined(it.value) && isUndefined(mt) || isHTMLElement(it) && it.value === "" || mt === "" || Array.isArray(mt) && !mt.length
      , Tt = appendErrors.bind(null, ht, tt, wt)
      , It = (Nt,Ft,Lt,Mt=INPUT_VALIDATION_RULES.maxLength,$t=INPUT_VALIDATION_RULES.minLength)=>{
        const kt = Nt ? Ft : Lt;
        wt[ht] = {
            type: Nt ? Mt : $t,
            message: kt,
            ref: it,
            ...Tt(Nt ? Mt : $t, kt)
        }
    }
    ;
    if (nt ? !Array.isArray(mt) || !mt.length : at && (!xt && (Ct || isNullOrUndefined(mt)) || isBoolean(mt) && !mt || Et && !getCheckboxValue(st).isValid || _t && !getRadioValue(st).isValid)) {
        const {value: Nt, message: Ft} = isMessage(at) ? {
            value: !!at,
            message: at
        } : getValueAndMessage(at);
        if (Nt && (wt[ht] = {
            type: INPUT_VALIDATION_RULES.required,
            message: Ft,
            ref: yt,
            ...Tt(INPUT_VALIDATION_RULES.required, Ft)
        },
        !tt))
            return vt(Ft),
            wt
    }
    if (!Ct && (!isNullOrUndefined(dt) || !isNullOrUndefined(ct))) {
        let Nt, Ft;
        const Lt = getValueAndMessage(ct)
          , Mt = getValueAndMessage(dt);
        if (!isNullOrUndefined(mt) && !isNaN(mt)) {
            const $t = it.valueAsNumber || mt && +mt;
            isNullOrUndefined(Lt.value) || (Nt = $t > Lt.value),
            isNullOrUndefined(Mt.value) || (Ft = $t < Mt.value)
        } else {
            const $t = it.valueAsDate || new Date(mt)
              , kt = Dt=>new Date(new Date().toDateString() + " " + Dt)
              , At = it.type == "time"
              , Pt = it.type == "week";
            isString(Lt.value) && mt && (Nt = At ? kt(mt) > kt(Lt.value) : Pt ? mt > Lt.value : $t > new Date(Lt.value)),
            isString(Mt.value) && mt && (Ft = At ? kt(mt) < kt(Mt.value) : Pt ? mt < Mt.value : $t < new Date(Mt.value))
        }
        if ((Nt || Ft) && (It(!!Nt, Lt.message, Mt.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min),
        !tt))
            return vt(wt[ht].message),
            wt
    }
    if ((ot || lt) && !Ct && (isString(mt) || nt && Array.isArray(mt))) {
        const Nt = getValueAndMessage(ot)
          , Ft = getValueAndMessage(lt)
          , Lt = !isNullOrUndefined(Nt.value) && mt.length > +Nt.value
          , Mt = !isNullOrUndefined(Ft.value) && mt.length < +Ft.value;
        if ((Lt || Mt) && (It(Lt, Nt.message, Ft.message),
        !tt))
            return vt(wt[ht].message),
            wt
    }
    if (ut && !Ct && isString(mt)) {
        const {value: Nt, message: Ft} = getValueAndMessage(ut);
        if (isRegex(Nt) && !mt.match(Nt) && (wt[ht] = {
            type: INPUT_VALIDATION_RULES.pattern,
            message: Ft,
            ref: it,
            ...Tt(INPUT_VALIDATION_RULES.pattern, Ft)
        },
        !tt))
            return vt(Ft),
            wt
    }
    if (ft) {
        if (isFunction(ft)) {
            const Nt = await ft(mt, et)
              , Ft = getValidateError(Nt, yt);
            if (Ft && (wt[ht] = {
                ...Ft,
                ...Tt(INPUT_VALIDATION_RULES.validate, Ft.message)
            },
            !tt))
                return vt(Ft.message),
                wt
        } else if (isObject$3(ft)) {
            let Nt = {};
            for (const Ft in ft) {
                if (!isEmptyObject(Nt) && !tt)
                    break;
                const Lt = getValidateError(await ft[Ft](mt, et), yt, Ft);
                Lt && (Nt = {
                    ...Lt,
                    ...Tt(Ft, Lt.message)
                },
                vt(Lt.message),
                tt && (wt[ht] = Nt))
            }
            if (!isEmptyObject(Nt) && (wt[ht] = {
                ref: yt,
                ...Nt
            },
            !tt))
                return wt
        }
    }
    return vt(!0),
    wt
}
;
function baseGet(_e, et) {
    const tt = et.slice(0, -1).length;
    let rt = 0;
    for (; rt < tt; )
        _e = isUndefined(_e) ? rt++ : _e[et[rt++]];
    return _e
}
function isEmptyArray(_e) {
    for (const et in _e)
        if (_e.hasOwnProperty(et) && !isUndefined(_e[et]))
            return !1;
    return !0
}
function unset(_e, et) {
    const tt = Array.isArray(et) ? et : isKey(et) ? [et] : stringToPath(et)
      , rt = tt.length === 1 ? _e : baseGet(_e, tt)
      , nt = tt.length - 1
      , it = tt[nt];
    return rt && delete rt[it],
    nt !== 0 && (isObject$3(rt) && isEmptyObject(rt) || Array.isArray(rt) && isEmptyArray(rt)) && unset(_e, tt.slice(0, -1)),
    _e
}
var createSubject = ()=>{
    let _e = [];
    return {
        get observers() {
            return _e
        },
        next: nt=>{
            for (const it of _e)
                it.next && it.next(nt)
        }
        ,
        subscribe: nt=>(_e.push(nt),
        {
            unsubscribe: ()=>{
                _e = _e.filter(it=>it !== nt)
            }
        }),
        unsubscribe: ()=>{
            _e = []
        }
    }
}
  , isPrimitive = _e=>isNullOrUndefined(_e) || !isObjectType(_e);
function deepEqual(_e, et) {
    if (isPrimitive(_e) || isPrimitive(et))
        return _e === et;
    if (isDateObject(_e) && isDateObject(et))
        return _e.getTime() === et.getTime();
    const tt = Object.keys(_e)
      , rt = Object.keys(et);
    if (tt.length !== rt.length)
        return !1;
    for (const nt of tt) {
        const it = _e[nt];
        if (!rt.includes(nt))
            return !1;
        if (nt !== "ref") {
            const st = et[nt];
            if (isDateObject(it) && isDateObject(st) || isObject$3(it) && isObject$3(st) || Array.isArray(it) && Array.isArray(st) ? !deepEqual(it, st) : it !== st)
                return !1
        }
    }
    return !0
}
var isMultipleSelect = _e=>_e.type === "select-multiple"
  , isRadioOrCheckbox = _e=>isRadioInput(_e) || isCheckBoxInput(_e)
  , live = _e=>isHTMLElement(_e) && _e.isConnected
  , objectHasFunction = _e=>{
    for (const et in _e)
        if (isFunction(_e[et]))
            return !0;
    return !1
}
;
function markFieldsDirty(_e, et={}) {
    const tt = Array.isArray(_e);
    if (isObject$3(_e) || tt)
        for (const rt in _e)
            Array.isArray(_e[rt]) || isObject$3(_e[rt]) && !objectHasFunction(_e[rt]) ? (et[rt] = Array.isArray(_e[rt]) ? [] : {},
            markFieldsDirty(_e[rt], et[rt])) : isNullOrUndefined(_e[rt]) || (et[rt] = !0);
    return et
}
function getDirtyFieldsFromDefaultValues(_e, et, tt) {
    const rt = Array.isArray(_e);
    if (isObject$3(_e) || rt)
        for (const nt in _e)
            Array.isArray(_e[nt]) || isObject$3(_e[nt]) && !objectHasFunction(_e[nt]) ? isUndefined(et) || isPrimitive(tt[nt]) ? tt[nt] = Array.isArray(_e[nt]) ? markFieldsDirty(_e[nt], []) : {
                ...markFieldsDirty(_e[nt])
            } : getDirtyFieldsFromDefaultValues(_e[nt], isNullOrUndefined(et) ? {} : et[nt], tt[nt]) : tt[nt] = !deepEqual(_e[nt], et[nt]);
    return tt
}
var getDirtyFields = (_e,et)=>getDirtyFieldsFromDefaultValues(_e, et, markFieldsDirty(et))
  , getFieldValueAs = (_e,{valueAsNumber: et, valueAsDate: tt, setValueAs: rt})=>isUndefined(_e) ? _e : et ? _e === "" ? NaN : _e && +_e : tt && isString(_e) ? new Date(_e) : rt ? rt(_e) : _e;
function getFieldValue(_e) {
    const et = _e.ref;
    if (!(_e.refs ? _e.refs.every(tt=>tt.disabled) : et.disabled))
        return isFileInput(et) ? et.files : isRadioInput(et) ? getRadioValue(_e.refs).value : isMultipleSelect(et) ? [...et.selectedOptions].map(({value: tt})=>tt) : isCheckBoxInput(et) ? getCheckboxValue(_e.refs).value : getFieldValueAs(isUndefined(et.value) ? _e.ref.value : et.value, _e)
}
var getResolverOptions = (_e,et,tt,rt)=>{
    const nt = {};
    for (const it of _e) {
        const st = get(et, it);
        st && set(nt, it, st._f)
    }
    return {
        criteriaMode: tt,
        names: [..._e],
        fields: nt,
        shouldUseNativeValidation: rt
    }
}
  , getRuleValue = _e=>isUndefined(_e) ? _e : isRegex(_e) ? _e.source : isObject$3(_e) ? isRegex(_e.value) ? _e.value.source : _e.value : _e
  , hasValidation = _e=>_e.mount && (_e.required || _e.min || _e.max || _e.maxLength || _e.minLength || _e.pattern || _e.validate);
function schemaErrorLookup(_e, et, tt) {
    const rt = get(_e, tt);
    if (rt || isKey(tt))
        return {
            error: rt,
            name: tt
        };
    const nt = tt.split(".");
    for (; nt.length; ) {
        const it = nt.join(".")
          , st = get(et, it)
          , at = get(_e, it);
        if (st && !Array.isArray(st) && tt !== it)
            return {
                name: tt
            };
        if (at && at.type)
            return {
                name: it,
                error: at
            };
        nt.pop()
    }
    return {
        name: tt
    }
}
var skipValidation = (_e,et,tt,rt,nt)=>nt.isOnAll ? !1 : !tt && nt.isOnTouch ? !(et || _e) : (tt ? rt.isOnBlur : nt.isOnBlur) ? !_e : (tt ? rt.isOnChange : nt.isOnChange) ? _e : !0
  , unsetEmptyArray = (_e,et)=>!compact(get(_e, et)).length && unset(_e, et);
const defaultOptions$1 = {
    mode: VALIDATION_MODE.onSubmit,
    reValidateMode: VALIDATION_MODE.onChange,
    shouldFocusError: !0
};
function createFormControl(_e={}, et) {
    let tt = {
        ...defaultOptions$1,
        ..._e
    }, rt = {
        submitCount: 0,
        isDirty: !1,
        isLoading: isFunction(tt.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        errors: tt.errors || {},
        disabled: tt.disabled || !1
    }, nt = {}, it = isObject$3(tt.values) || isObject$3(tt.defaultValues) ? cloneObject(tt.values || tt.defaultValues) || {} : {}, st = tt.shouldUnregister ? {} : cloneObject(it), at = {
        action: !1,
        mount: !1,
        watch: !1
    }, ot = {
        mount: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, lt, dt = 0;
    const ct = {
        isDirty: !1,
        dirtyFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    }
      , ut = {
        values: createSubject(),
        array: createSubject(),
        state: createSubject()
    }
      , ft = getValidationModes(tt.mode)
      , ht = getValidationModes(tt.reValidateMode)
      , gt = tt.criteriaMode === VALIDATION_MODE.all
      , bt = Gt=>Jt=>{
        clearTimeout(dt),
        dt = setTimeout(Gt, Jt)
    }
      , pt = async Gt=>{
        if (ct.isValid || Gt) {
            const Jt = tt.resolver ? isEmptyObject((await Ct()).errors) : await It(nt, !0);
            Jt !== rt.isValid && ut.state.next({
                isValid: Jt
            })
        }
    }
      , mt = Gt=>ct.isValidating && ut.state.next({
        isValidating: Gt
    })
      , yt = (Gt,Jt=[],tr,lr,sr=!0,ir=!0)=>{
        if (lr && tr) {
            if (at.action = !0,
            ir && Array.isArray(get(nt, Gt))) {
                const ur = tr(get(nt, Gt), lr.argA, lr.argB);
                sr && set(nt, Gt, ur)
            }
            if (ir && Array.isArray(get(rt.errors, Gt))) {
                const ur = tr(get(rt.errors, Gt), lr.argA, lr.argB);
                sr && set(rt.errors, Gt, ur),
                unsetEmptyArray(rt.errors, Gt)
            }
            if (ct.touchedFields && ir && Array.isArray(get(rt.touchedFields, Gt))) {
                const ur = tr(get(rt.touchedFields, Gt), lr.argA, lr.argB);
                sr && set(rt.touchedFields, Gt, ur)
            }
            ct.dirtyFields && (rt.dirtyFields = getDirtyFields(it, st)),
            ut.state.next({
                name: Gt,
                isDirty: Ft(Gt, Jt),
                dirtyFields: rt.dirtyFields,
                errors: rt.errors,
                isValid: rt.isValid
            })
        } else
            set(st, Gt, Jt)
    }
      , vt = (Gt,Jt)=>{
        set(rt.errors, Gt, Jt),
        ut.state.next({
            errors: rt.errors
        })
    }
      , wt = Gt=>{
        rt.errors = Gt,
        ut.state.next({
            errors: rt.errors,
            isValid: !1
        })
    }
      , _t = (Gt,Jt,tr,lr)=>{
        const sr = get(nt, Gt);
        if (sr) {
            const ir = get(st, Gt, isUndefined(tr) ? get(it, Gt) : tr);
            isUndefined(ir) || lr && lr.defaultChecked || Jt ? set(st, Gt, Jt ? ir : getFieldValue(sr._f)) : $t(Gt, ir),
            at.mount && pt()
        }
    }
      , Et = (Gt,Jt,tr,lr,sr)=>{
        let ir = !1
          , ur = !1;
        const Cr = {
            name: Gt
        }
          , Wt = !!(get(nt, Gt) && get(nt, Gt)._f.disabled);
        if (!tr || lr) {
            ct.isDirty && (ur = rt.isDirty,
            rt.isDirty = Cr.isDirty = Ft(),
            ir = ur !== Cr.isDirty);
            const Rt = Wt || deepEqual(get(it, Gt), Jt);
            ur = !!(!Wt && get(rt.dirtyFields, Gt)),
            Rt || Wt ? unset(rt.dirtyFields, Gt) : set(rt.dirtyFields, Gt, !0),
            Cr.dirtyFields = rt.dirtyFields,
            ir = ir || ct.dirtyFields && ur !== !Rt
        }
        if (tr) {
            const Rt = get(rt.touchedFields, Gt);
            Rt || (set(rt.touchedFields, Gt, tr),
            Cr.touchedFields = rt.touchedFields,
            ir = ir || ct.touchedFields && Rt !== tr)
        }
        return ir && sr && ut.state.next(Cr),
        ir ? Cr : {}
    }
      , xt = (Gt,Jt,tr,lr)=>{
        const sr = get(rt.errors, Gt)
          , ir = ct.isValid && isBoolean(Jt) && rt.isValid !== Jt;
        if (_e.delayError && tr ? (lt = bt(()=>vt(Gt, tr)),
        lt(_e.delayError)) : (clearTimeout(dt),
        lt = null,
        tr ? set(rt.errors, Gt, tr) : unset(rt.errors, Gt)),
        (tr ? !deepEqual(sr, tr) : sr) || !isEmptyObject(lr) || ir) {
            const ur = {
                ...lr,
                ...ir && isBoolean(Jt) ? {
                    isValid: Jt
                } : {},
                errors: rt.errors,
                name: Gt
            };
            rt = {
                ...rt,
                ...ur
            },
            ut.state.next(ur)
        }
        mt(!1)
    }
      , Ct = async Gt=>tt.resolver(st, tt.context, getResolverOptions(Gt || ot.mount, nt, tt.criteriaMode, tt.shouldUseNativeValidation))
      , Tt = async Gt=>{
        const {errors: Jt} = await Ct(Gt);
        if (Gt)
            for (const tr of Gt) {
                const lr = get(Jt, tr);
                lr ? set(rt.errors, tr, lr) : unset(rt.errors, tr)
            }
        else
            rt.errors = Jt;
        return Jt
    }
      , It = async(Gt,Jt,tr={
        valid: !0
    })=>{
        for (const lr in Gt) {
            const sr = Gt[lr];
            if (sr) {
                const {_f: ir, ...ur} = sr;
                if (ir) {
                    const Cr = ot.array.has(ir.name)
                      , Wt = await validateField(sr, st, gt, tt.shouldUseNativeValidation && !Jt, Cr);
                    if (Wt[ir.name] && (tr.valid = !1,
                    Jt))
                        break;
                    !Jt && (get(Wt, ir.name) ? Cr ? updateFieldArrayRootError(rt.errors, Wt, ir.name) : set(rt.errors, ir.name, Wt[ir.name]) : unset(rt.errors, ir.name))
                }
                ur && await It(ur, Jt, tr)
            }
        }
        return tr.valid
    }
      , Nt = ()=>{
        for (const Gt of ot.unMount) {
            const Jt = get(nt, Gt);
            Jt && (Jt._f.refs ? Jt._f.refs.every(tr=>!live(tr)) : !live(Jt._f.ref)) && pr(Gt)
        }
        ot.unMount = new Set
    }
      , Ft = (Gt,Jt)=>(Gt && Jt && set(st, Gt, Jt),
    !deepEqual(zt(), it))
      , Lt = (Gt,Jt,tr)=>generateWatchOutput(Gt, ot, {
        ...at.mount ? st : isUndefined(Jt) ? it : isString(Gt) ? {
            [Gt]: Jt
        } : Jt
    }, tr, Jt)
      , Mt = Gt=>compact(get(at.mount ? st : it, Gt, _e.shouldUnregister ? get(it, Gt, []) : []))
      , $t = (Gt,Jt,tr={})=>{
        const lr = get(nt, Gt);
        let sr = Jt;
        if (lr) {
            const ir = lr._f;
            ir && (!ir.disabled && set(st, Gt, getFieldValueAs(Jt, ir)),
            sr = isHTMLElement(ir.ref) && isNullOrUndefined(Jt) ? "" : Jt,
            isMultipleSelect(ir.ref) ? [...ir.ref.options].forEach(ur=>ur.selected = sr.includes(ur.value)) : ir.refs ? isCheckBoxInput(ir.ref) ? ir.refs.length > 1 ? ir.refs.forEach(ur=>(!ur.defaultChecked || !ur.disabled) && (ur.checked = Array.isArray(sr) ? !!sr.find(Cr=>Cr === ur.value) : sr === ur.value)) : ir.refs[0] && (ir.refs[0].checked = !!sr) : ir.refs.forEach(ur=>ur.checked = ur.value === sr) : isFileInput(ir.ref) ? ir.ref.value = "" : (ir.ref.value = sr,
            ir.ref.type || ut.values.next({
                name: Gt,
                values: {
                    ...st
                }
            })))
        }
        (tr.shouldDirty || tr.shouldTouch) && Et(Gt, sr, tr.shouldTouch, tr.shouldDirty, !0),
        tr.shouldValidate && Bt(Gt)
    }
      , kt = (Gt,Jt,tr)=>{
        for (const lr in Jt) {
            const sr = Jt[lr]
              , ir = `${Gt}.${lr}`
              , ur = get(nt, ir);
            (ot.array.has(Gt) || !isPrimitive(sr) || ur && !ur._f) && !isDateObject(sr) ? kt(ir, sr, tr) : $t(ir, sr, tr)
        }
    }
      , At = (Gt,Jt,tr={})=>{
        const lr = get(nt, Gt)
          , sr = ot.array.has(Gt)
          , ir = cloneObject(Jt);
        set(st, Gt, ir),
        sr ? (ut.array.next({
            name: Gt,
            values: {
                ...st
            }
        }),
        (ct.isDirty || ct.dirtyFields) && tr.shouldDirty && ut.state.next({
            name: Gt,
            dirtyFields: getDirtyFields(it, st),
            isDirty: Ft(Gt, ir)
        })) : lr && !lr._f && !isNullOrUndefined(ir) ? kt(Gt, ir, tr) : $t(Gt, ir, tr),
        isWatched(Gt, ot) && ut.state.next({
            ...rt
        }),
        ut.values.next({
            name: Gt,
            values: {
                ...st
            }
        }),
        !at.mount && et()
    }
      , Pt = async Gt=>{
        const Jt = Gt.target;
        let tr = Jt.name
          , lr = !0;
        const sr = get(nt, tr)
          , ir = ()=>Jt.type ? getFieldValue(sr._f) : getEventValue(Gt)
          , ur = Cr=>{
            lr = Number.isNaN(Cr) || Cr === get(st, tr, Cr)
        }
        ;
        if (sr) {
            let Cr, Wt;
            const Rt = ir()
              , jt = Gt.type === EVENTS.BLUR || Gt.type === EVENTS.FOCUS_OUT
              , Ht = !hasValidation(sr._f) && !tt.resolver && !get(rt.errors, tr) && !sr._f.deps || skipValidation(jt, get(rt.touchedFields, tr), rt.isSubmitted, ht, ft)
              , qt = isWatched(tr, ot, jt);
            set(st, tr, Rt),
            jt ? (sr._f.onBlur && sr._f.onBlur(Gt),
            lt && lt(0)) : sr._f.onChange && sr._f.onChange(Gt);
            const Xt = Et(tr, Rt, jt, !1)
              , nr = !isEmptyObject(Xt) || qt;
            if (!jt && ut.values.next({
                name: tr,
                type: Gt.type,
                values: {
                    ...st
                }
            }),
            Ht)
                return ct.isValid && pt(),
                nr && ut.state.next({
                    name: tr,
                    ...qt ? {} : Xt
                });
            if (!jt && qt && ut.state.next({
                ...rt
            }),
            mt(!0),
            tt.resolver) {
                const {errors: Er} = await Ct([tr]);
                if (ur(Rt),
                lr) {
                    const Dr = schemaErrorLookup(rt.errors, nt, tr)
                      , kr = schemaErrorLookup(Er, nt, Dr.name || tr);
                    Cr = kr.error,
                    tr = kr.name,
                    Wt = isEmptyObject(Er)
                }
            } else
                Cr = (await validateField(sr, st, gt, tt.shouldUseNativeValidation))[tr],
                ur(Rt),
                lr && (Cr ? Wt = !1 : ct.isValid && (Wt = await It(nt, !0)));
            lr && (sr._f.deps && Bt(sr._f.deps),
            xt(tr, Wt, Cr, Xt))
        }
    }
      , Dt = (Gt,Jt)=>{
        if (get(rt.errors, Jt) && Gt.focus)
            return Gt.focus(),
            1
    }
      , Bt = async(Gt,Jt={})=>{
        let tr, lr;
        const sr = convertToArrayPayload(Gt);
        if (mt(!0),
        tt.resolver) {
            const ir = await Tt(isUndefined(Gt) ? Gt : sr);
            tr = isEmptyObject(ir),
            lr = Gt ? !sr.some(ur=>get(ir, ur)) : tr
        } else
            Gt ? (lr = (await Promise.all(sr.map(async ir=>{
                const ur = get(nt, ir);
                return await It(ur && ur._f ? {
                    [ir]: ur
                } : ur)
            }
            ))).every(Boolean),
            !(!lr && !rt.isValid) && pt()) : lr = tr = await It(nt);
        return ut.state.next({
            ...!isString(Gt) || ct.isValid && tr !== rt.isValid ? {} : {
                name: Gt
            },
            ...tt.resolver || !Gt ? {
                isValid: tr
            } : {},
            errors: rt.errors,
            isValidating: !1
        }),
        Jt.shouldFocus && !lr && iterateFieldsByAction(nt, Dt, Gt ? sr : ot.mount),
        lr
    }
      , zt = Gt=>{
        const Jt = {
            ...it,
            ...at.mount ? st : {}
        };
        return isUndefined(Gt) ? Jt : isString(Gt) ? get(Jt, Gt) : Gt.map(tr=>get(Jt, tr))
    }
      , Yt = (Gt,Jt)=>({
        invalid: !!get((Jt || rt).errors, Gt),
        isDirty: !!get((Jt || rt).dirtyFields, Gt),
        isTouched: !!get((Jt || rt).touchedFields, Gt),
        error: get((Jt || rt).errors, Gt)
    })
      , rr = Gt=>{
        Gt && convertToArrayPayload(Gt).forEach(Jt=>unset(rt.errors, Jt)),
        ut.state.next({
            errors: Gt ? rt.errors : {}
        })
    }
      , ar = (Gt,Jt,tr)=>{
        const lr = (get(nt, Gt, {
            _f: {}
        })._f || {}).ref;
        set(rt.errors, Gt, {
            ...Jt,
            ref: lr
        }),
        ut.state.next({
            name: Gt,
            errors: rt.errors,
            isValid: !1
        }),
        tr && tr.shouldFocus && lr && lr.focus && lr.focus()
    }
      , or = (Gt,Jt)=>isFunction(Gt) ? ut.values.subscribe({
        next: tr=>Gt(Lt(void 0, Jt), tr)
    }) : Lt(Gt, Jt, !0)
      , pr = (Gt,Jt={})=>{
        for (const tr of Gt ? convertToArrayPayload(Gt) : ot.mount)
            ot.mount.delete(tr),
            ot.array.delete(tr),
            Jt.keepValue || (unset(nt, tr),
            unset(st, tr)),
            !Jt.keepError && unset(rt.errors, tr),
            !Jt.keepDirty && unset(rt.dirtyFields, tr),
            !Jt.keepTouched && unset(rt.touchedFields, tr),
            !tt.shouldUnregister && !Jt.keepDefaultValue && unset(it, tr);
        ut.values.next({
            values: {
                ...st
            }
        }),
        ut.state.next({
            ...rt,
            ...Jt.keepDirty ? {
                isDirty: Ft()
            } : {}
        }),
        !Jt.keepIsValid && pt()
    }
      , gr = ({disabled: Gt, name: Jt, field: tr, fields: lr, value: sr})=>{
        if (isBoolean(Gt)) {
            const ir = Gt ? void 0 : isUndefined(sr) ? getFieldValue(tr ? tr._f : get(lr, Jt)._f) : sr;
            set(st, Jt, ir),
            Et(Jt, ir, !1, !1, !0)
        }
    }
      , Sr = (Gt,Jt={})=>{
        let tr = get(nt, Gt);
        const lr = isBoolean(Jt.disabled);
        return set(nt, Gt, {
            ...tr || {},
            _f: {
                ...tr && tr._f ? tr._f : {
                    ref: {
                        name: Gt
                    }
                },
                name: Gt,
                mount: !0,
                ...Jt
            }
        }),
        ot.mount.add(Gt),
        tr ? gr({
            field: tr,
            disabled: Jt.disabled,
            name: Gt,
            value: Jt.value
        }) : _t(Gt, !0, Jt.value),
        {
            ...lr ? {
                disabled: Jt.disabled
            } : {},
            ...tt.progressive ? {
                required: !!Jt.required,
                min: getRuleValue(Jt.min),
                max: getRuleValue(Jt.max),
                minLength: getRuleValue(Jt.minLength),
                maxLength: getRuleValue(Jt.maxLength),
                pattern: getRuleValue(Jt.pattern)
            } : {},
            name: Gt,
            onChange: Pt,
            onBlur: Pt,
            ref: sr=>{
                if (sr) {
                    Sr(Gt, Jt),
                    tr = get(nt, Gt);
                    const ir = isUndefined(sr.value) && sr.querySelectorAll && sr.querySelectorAll("input,select,textarea")[0] || sr
                      , ur = isRadioOrCheckbox(ir)
                      , Cr = tr._f.refs || [];
                    if (ur ? Cr.find(Wt=>Wt === ir) : ir === tr._f.ref)
                        return;
                    set(nt, Gt, {
                        _f: {
                            ...tr._f,
                            ...ur ? {
                                refs: [...Cr.filter(live), ir, ...Array.isArray(get(it, Gt)) ? [{}] : []],
                                ref: {
                                    type: ir.type,
                                    name: Gt
                                }
                            } : {
                                ref: ir
                            }
                        }
                    }),
                    _t(Gt, !1, void 0, ir)
                } else
                    tr = get(nt, Gt, {}),
                    tr._f && (tr._f.mount = !1),
                    (tt.shouldUnregister || Jt.shouldUnregister) && !(isNameInFieldArray(ot.array, Gt) && at.action) && ot.unMount.add(Gt)
            }
        }
    }
      , br = ()=>tt.shouldFocusError && iterateFieldsByAction(nt, Dt, ot.mount)
      , Pr = Gt=>{
        isBoolean(Gt) && (ut.state.next({
            disabled: Gt
        }),
        iterateFieldsByAction(nt, (Jt,tr)=>{
            let lr = Gt;
            const sr = get(nt, tr);
            sr && isBoolean(sr._f.disabled) && (lr || (lr = sr._f.disabled)),
            Jt.disabled = lr
        }
        , 0, !1))
    }
      , Wr = (Gt,Jt)=>async tr=>{
        let lr;
        tr && (tr.preventDefault && tr.preventDefault(),
        tr.persist && tr.persist());
        let sr = cloneObject(st);
        if (ut.state.next({
            isSubmitting: !0
        }),
        tt.resolver) {
            const {errors: ir, values: ur} = await Ct();
            rt.errors = ir,
            sr = ur
        } else
            await It(nt);
        if (unset(rt.errors, "root"),
        isEmptyObject(rt.errors)) {
            ut.state.next({
                errors: {}
            });
            try {
                await Gt(sr, tr)
            } catch (ir) {
                lr = ir
            }
        } else
            Jt && await Jt({
                ...rt.errors
            }, tr),
            br(),
            setTimeout(br);
        if (ut.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: isEmptyObject(rt.errors) && !lr,
            submitCount: rt.submitCount + 1,
            errors: rt.errors
        }),
        lr)
            throw lr
    }
      , _r = (Gt,Jt={})=>{
        get(nt, Gt) && (isUndefined(Jt.defaultValue) ? At(Gt, cloneObject(get(it, Gt))) : (At(Gt, Jt.defaultValue),
        set(it, Gt, cloneObject(Jt.defaultValue))),
        Jt.keepTouched || unset(rt.touchedFields, Gt),
        Jt.keepDirty || (unset(rt.dirtyFields, Gt),
        rt.isDirty = Jt.defaultValue ? Ft(Gt, cloneObject(get(it, Gt))) : Ft()),
        Jt.keepError || (unset(rt.errors, Gt),
        ct.isValid && pt()),
        ut.state.next({
            ...rt
        }))
    }
      , hr = (Gt,Jt={})=>{
        const tr = Gt ? cloneObject(Gt) : it
          , lr = cloneObject(tr)
          , sr = Gt && !isEmptyObject(Gt) ? lr : it;
        if (Jt.keepDefaultValues || (it = tr),
        !Jt.keepValues) {
            if (Jt.keepDirtyValues)
                for (const ir of ot.mount)
                    get(rt.dirtyFields, ir) ? set(sr, ir, get(st, ir)) : At(ir, get(sr, ir));
            else {
                if (isWeb && isUndefined(Gt))
                    for (const ir of ot.mount) {
                        const ur = get(nt, ir);
                        if (ur && ur._f) {
                            const Cr = Array.isArray(ur._f.refs) ? ur._f.refs[0] : ur._f.ref;
                            if (isHTMLElement(Cr)) {
                                const Wt = Cr.closest("form");
                                if (Wt) {
                                    Wt.reset();
                                    break
                                }
                            }
                        }
                    }
                nt = {}
            }
            st = _e.shouldUnregister ? Jt.keepDefaultValues ? cloneObject(it) : {} : cloneObject(sr),
            ut.array.next({
                values: {
                    ...sr
                }
            }),
            ut.values.next({
                values: {
                    ...sr
                }
            })
        }
        ot = {
            mount: new Set,
            unMount: new Set,
            array: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        !at.mount && et(),
        at.mount = !ct.isValid || !!Jt.keepIsValid || !!Jt.keepDirtyValues,
        at.watch = !!_e.shouldUnregister,
        ut.state.next({
            submitCount: Jt.keepSubmitCount ? rt.submitCount : 0,
            isDirty: Jt.keepDirty ? rt.isDirty : !!(Jt.keepDefaultValues && !deepEqual(Gt, it)),
            isSubmitted: Jt.keepIsSubmitted ? rt.isSubmitted : !1,
            dirtyFields: Jt.keepDirtyValues ? Jt.keepDefaultValues && st ? getDirtyFields(it, st) : rt.dirtyFields : Jt.keepDefaultValues && Gt ? getDirtyFields(it, Gt) : {},
            touchedFields: Jt.keepTouched ? rt.touchedFields : {},
            errors: Jt.keepErrors ? rt.errors : {},
            isSubmitSuccessful: Jt.keepIsSubmitSuccessful ? rt.isSubmitSuccessful : !1,
            isSubmitting: !1
        })
    }
      , Vr = (Gt,Jt)=>hr(isFunction(Gt) ? Gt(st) : Gt, Jt);
    return {
        control: {
            register: Sr,
            unregister: pr,
            getFieldState: Yt,
            handleSubmit: Wr,
            setError: ar,
            _executeSchema: Ct,
            _getWatch: Lt,
            _getDirty: Ft,
            _updateValid: pt,
            _removeUnmounted: Nt,
            _updateFieldArray: yt,
            _updateDisabledField: gr,
            _getFieldArray: Mt,
            _reset: hr,
            _resetDefaultValues: ()=>isFunction(tt.defaultValues) && tt.defaultValues().then(Gt=>{
                Vr(Gt, tt.resetOptions),
                ut.state.next({
                    isLoading: !1
                })
            }
            ),
            _updateFormState: Gt=>{
                rt = {
                    ...rt,
                    ...Gt
                }
            }
            ,
            _disableForm: Pr,
            _subjects: ut,
            _proxyFormState: ct,
            _setErrors: wt,
            get _fields() {
                return nt
            },
            get _formValues() {
                return st
            },
            get _state() {
                return at
            },
            set _state(Gt) {
                at = Gt
            },
            get _defaultValues() {
                return it
            },
            get _names() {
                return ot
            },
            set _names(Gt) {
                ot = Gt
            },
            get _formState() {
                return rt
            },
            set _formState(Gt) {
                rt = Gt
            },
            get _options() {
                return tt
            },
            set _options(Gt) {
                tt = {
                    ...tt,
                    ...Gt
                }
            }
        },
        trigger: Bt,
        register: Sr,
        handleSubmit: Wr,
        watch: or,
        setValue: At,
        getValues: zt,
        reset: Vr,
        resetField: _r,
        clearErrors: rr,
        unregister: pr,
        setError: ar,
        setFocus: (Gt,Jt={})=>{
            const tr = get(nt, Gt)
              , lr = tr && tr._f;
            if (lr) {
                const sr = lr.refs ? lr.refs[0] : lr.ref;
                sr.focus && (sr.focus(),
                Jt.shouldSelect && sr.select())
            }
        }
        ,
        getFieldState: Yt
    }
}
function useForm(_e={}) {
    const et = React$1.useRef()
      , tt = React$1.useRef()
      , [rt,nt] = React$1.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: isFunction(_e.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        errors: _e.errors || {},
        disabled: _e.disabled || !1,
        defaultValues: isFunction(_e.defaultValues) ? void 0 : _e.defaultValues
    });
    et.current || (et.current = {
        ...createFormControl(_e, ()=>nt(st=>({
            ...st
        }))),
        formState: rt
    });
    const it = et.current.control;
    return it._options = _e,
    useSubscribe({
        subject: it._subjects.state,
        next: st=>{
            shouldRenderFormState(st, it._proxyFormState, it._updateFormState, !0) && nt({
                ...it._formState
            })
        }
    }),
    React$1.useEffect(()=>it._disableForm(_e.disabled), [it, _e.disabled]),
    React$1.useEffect(()=>{
        if (it._proxyFormState.isDirty) {
            const st = it._getDirty();
            st !== rt.isDirty && it._subjects.state.next({
                isDirty: st
            })
        }
    }
    , [it, rt.isDirty]),
    React$1.useEffect(()=>{
        _e.values && !deepEqual(_e.values, tt.current) ? (it._reset(_e.values, it._options.resetOptions),
        tt.current = _e.values,
        nt(st=>({
            ...st
        }))) : it._resetDefaultValues()
    }
    , [_e.values, it]),
    React$1.useEffect(()=>{
        _e.errors && it._setErrors(_e.errors)
    }
    , [_e.errors, it]),
    React$1.useEffect(()=>{
        it._state.mount || (it._updateValid(),
        it._state.mount = !0),
        it._state.watch && (it._state.watch = !1,
        it._subjects.state.next({
            ...it._formState
        })),
        it._removeUnmounted()
    }
    ),
    React$1.useEffect(()=>{
        _e.shouldUnregister && it._subjects.values.next({
            values: it._getWatch()
        })
    }
    , [_e.shouldUnregister, it]),
    et.current.formState = getProxyFormState(rt, it),
    et.current
}
const toastFun = (_e,et)=>{
    _e === "error" ? B.error(et, {
        position: "top-right",
        autoClose: 4e3
    }) : B.info(et, {
        position: "top-right",
        autoClose: 4e3
    })
}
;
function _classCallCheck$1(_e, et) {
    if (!(_e instanceof et))
        throw new TypeError("Cannot call a class as a function")
}
function _defineProperties$1(_e, et) {
    for (var tt = 0; tt < et.length; tt++) {
        var rt = et[tt];
        rt.enumerable = rt.enumerable || !1,
        rt.configurable = !0,
        "value"in rt && (rt.writable = !0),
        Object.defineProperty(_e, rt.key, rt)
    }
}
function _createClass$1(_e, et, tt) {
    return et && _defineProperties$1(_e.prototype, et),
    tt && _defineProperties$1(_e, tt),
    _e
}
function _inherits$1(_e, et) {
    if (typeof et != "function" && et !== null)
        throw new TypeError("Super expression must either be null or a function");
    _e.prototype = Object.create(et && et.prototype, {
        constructor: {
            value: _e,
            writable: !0,
            configurable: !0
        }
    }),
    et && _setPrototypeOf$1(_e, et)
}
function _getPrototypeOf$1(_e) {
    return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(tt) {
        return tt.__proto__ || Object.getPrototypeOf(tt)
    }
    ,
    _getPrototypeOf$1(_e)
}
function _setPrototypeOf$1(_e, et) {
    return _setPrototypeOf$1 = Object.setPrototypeOf || function(rt, nt) {
        return rt.__proto__ = nt,
        rt
    }
    ,
    _setPrototypeOf$1(_e, et)
}
function _isNativeReflectConstruct$1() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function _assertThisInitialized$1(_e) {
    if (_e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return _e
}
function _possibleConstructorReturn$1(_e, et) {
    return et && (typeof et == "object" || typeof et == "function") ? et : _assertThisInitialized$1(_e)
}
function _createSuper$1(_e) {
    var et = _isNativeReflectConstruct$1();
    return function() {
        var rt = _getPrototypeOf$1(_e), nt;
        if (et) {
            var it = _getPrototypeOf$1(this).constructor;
            nt = Reflect.construct(rt, arguments, it)
        } else
            nt = rt.apply(this, arguments);
        return _possibleConstructorReturn$1(this, nt)
    }
}
function _toConsumableArray(_e) {
    return _arrayWithoutHoles(_e) || _iterableToArray(_e) || _unsupportedIterableToArray(_e) || _nonIterableSpread()
}
function _arrayWithoutHoles(_e) {
    if (Array.isArray(_e))
        return _arrayLikeToArray(_e)
}
function _iterableToArray(_e) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(_e))
        return Array.from(_e)
}
function _unsupportedIterableToArray(_e, et) {
    if (_e) {
        if (typeof _e == "string")
            return _arrayLikeToArray(_e, et);
        var tt = Object.prototype.toString.call(_e).slice(8, -1);
        if (tt === "Object" && _e.constructor && (tt = _e.constructor.name),
        tt === "Map" || tt === "Set")
            return Array.from(_e);
        if (tt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(tt))
            return _arrayLikeToArray(_e, et)
    }
}
function _arrayLikeToArray(_e, et) {
    (et == null || et > _e.length) && (et = _e.length);
    for (var tt = 0, rt = new Array(et); tt < et; tt++)
        rt[tt] = _e[tt];
    return rt
}
function _nonIterableSpread() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function zeroPad(_e) {
    var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2
      , tt = String(_e);
    if (et === 0)
        return tt;
    var rt = tt.match(/(.*?)([0-9]+)(.*)/)
      , nt = rt ? rt[1] : ""
      , it = rt ? rt[3] : ""
      , st = rt ? rt[2] : tt
      , at = st.length >= et ? st : (_toConsumableArray(Array(et)).map(function() {
        return "0"
    }).join("") + st).slice(et * -1);
    return "".concat(nt).concat(at).concat(it)
}
var timeDeltaFormatOptionsDefaults = {
    daysInHours: !1,
    zeroPadTime: 2
};
function calcTimeDelta(_e) {
    var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, tt = et.now, rt = tt === void 0 ? Date.now : tt, nt = et.precision, it = nt === void 0 ? 0 : nt, st = et.controlled, at = et.offsetTime, ot = at === void 0 ? 0 : at, lt = et.overtime, dt;
    typeof _e == "string" ? dt = new Date(_e).getTime() : _e instanceof Date ? dt = _e.getTime() : dt = _e,
    st || (dt += ot);
    var ct = st ? dt : dt - rt()
      , ut = Math.min(20, Math.max(0, it))
      , ft = Math.round(parseFloat(((lt ? ct : Math.max(0, ct)) / 1e3).toFixed(ut)) * 1e3)
      , ht = Math.abs(ft) / 1e3;
    return {
        total: ft,
        days: Math.floor(ht / (3600 * 24)),
        hours: Math.floor(ht / 3600 % 24),
        minutes: Math.floor(ht / 60 % 60),
        seconds: Math.floor(ht % 60),
        milliseconds: Number((ht % 1 * 1e3).toFixed()),
        completed: ft <= 0
    }
}
function formatTimeDelta(_e, et) {
    var tt = _e.days
      , rt = _e.hours
      , nt = _e.minutes
      , it = _e.seconds
      , st = Object.assign(Object.assign({}, timeDeltaFormatOptionsDefaults), et)
      , at = st.daysInHours
      , ot = st.zeroPadTime
      , lt = st.zeroPadDays
      , dt = lt === void 0 ? ot : lt
      , ct = Math.min(2, ot)
      , ut = at ? zeroPad(rt + tt * 24, ot) : zeroPad(rt, ct);
    return {
        days: at ? "" : zeroPad(tt, dt),
        hours: ut,
        minutes: zeroPad(nt, ct),
        seconds: zeroPad(it, ct)
    }
}
var Countdown = function(_e) {
    _inherits$1(tt, _e);
    var et = _createSuper$1(tt);
    function tt() {
        var rt;
        return _classCallCheck$1(this, tt),
        rt = et.apply(this, arguments),
        rt.state = {
            count: rt.props.count || 3
        },
        rt.startCountdown = function() {
            rt.interval = window.setInterval(function() {
                var nt = rt.state.count - 1;
                nt === 0 ? (rt.stopCountdown(),
                rt.props.onComplete && rt.props.onComplete()) : rt.setState(function(it) {
                    return {
                        count: it.count - 1
                    }
                })
            }, 1e3)
        }
        ,
        rt.stopCountdown = function() {
            clearInterval(rt.interval)
        }
        ,
        rt.addTime = function(nt) {
            rt.stopCountdown(),
            rt.setState(function(it) {
                return {
                    count: it.count + nt
                }
            }, rt.startCountdown)
        }
        ,
        rt
    }
    return _createClass$1(tt, [{
        key: "componentDidMount",
        value: function() {
            this.startCountdown()
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            clearInterval(this.interval)
        }
    }, {
        key: "render",
        value: function() {
            return this.props.children ? reactExports.cloneElement(this.props.children, {
                count: this.state.count
            }) : null
        }
    }]),
    tt
}(reactExports.Component);
Countdown.propTypes = {
    count: propTypesExports.number,
    children: propTypesExports.element,
    onComplete: propTypesExports.func
};
var Countdown$1 = function(_e) {
    _inherits$1(tt, _e);
    var et = _createSuper$1(tt);
    function tt(rt) {
        var nt;
        if (_classCallCheck$1(this, tt),
        nt = et.call(this, rt),
        nt.mounted = !1,
        nt.initialTimestamp = nt.calcOffsetStartTimestamp(),
        nt.offsetStartTimestamp = nt.props.autoStart ? 0 : nt.initialTimestamp,
        nt.offsetTime = 0,
        nt.legacyMode = !1,
        nt.legacyCountdownRef = reactExports.createRef(),
        nt.tick = function() {
            var st = nt.calcTimeDelta()
              , at = st.completed && !nt.props.overtime ? void 0 : nt.props.onTick;
            nt.setTimeDeltaState(st, void 0, at)
        }
        ,
        nt.start = function() {
            if (!nt.isStarted()) {
                var st = nt.offsetStartTimestamp;
                nt.offsetStartTimestamp = 0,
                nt.offsetTime += st ? nt.calcOffsetStartTimestamp() - st : 0;
                var at = nt.calcTimeDelta();
                nt.setTimeDeltaState(at, "STARTED", nt.props.onStart),
                !nt.props.controlled && (!at.completed || nt.props.overtime) && (nt.clearTimer(),
                nt.interval = window.setInterval(nt.tick, nt.props.intervalDelay))
            }
        }
        ,
        nt.pause = function() {
            nt.isPaused() || (nt.clearTimer(),
            nt.offsetStartTimestamp = nt.calcOffsetStartTimestamp(),
            nt.setTimeDeltaState(nt.state.timeDelta, "PAUSED", nt.props.onPause))
        }
        ,
        nt.stop = function() {
            nt.isStopped() || (nt.clearTimer(),
            nt.offsetStartTimestamp = nt.calcOffsetStartTimestamp(),
            nt.offsetTime = nt.offsetStartTimestamp - nt.initialTimestamp,
            nt.setTimeDeltaState(nt.calcTimeDelta(), "STOPPED", nt.props.onStop))
        }
        ,
        nt.isStarted = function() {
            return nt.isStatus("STARTED")
        }
        ,
        nt.isPaused = function() {
            return nt.isStatus("PAUSED")
        }
        ,
        nt.isStopped = function() {
            return nt.isStatus("STOPPED")
        }
        ,
        nt.isCompleted = function() {
            return nt.isStatus("COMPLETED")
        }
        ,
        rt.date) {
            var it = nt.calcTimeDelta();
            nt.state = {
                timeDelta: it,
                status: it.completed ? "COMPLETED" : "STOPPED"
            }
        } else
            nt.legacyMode = !0;
        return nt
    }
    return _createClass$1(tt, [{
        key: "componentDidMount",
        value: function() {
            this.legacyMode || (this.mounted = !0,
            this.props.onMount && this.props.onMount(this.calcTimeDelta()),
            this.props.autoStart && this.start())
        }
    }, {
        key: "componentDidUpdate",
        value: function(nt) {
            this.legacyMode || this.props.date !== nt.date && (this.initialTimestamp = this.calcOffsetStartTimestamp(),
            this.offsetStartTimestamp = this.initialTimestamp,
            this.offsetTime = 0,
            this.setTimeDeltaState(this.calcTimeDelta()))
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            this.legacyMode || (this.mounted = !1,
            this.clearTimer())
        }
    }, {
        key: "calcTimeDelta",
        value: function() {
            var nt = this.props
              , it = nt.date
              , st = nt.now
              , at = nt.precision
              , ot = nt.controlled
              , lt = nt.overtime;
            return calcTimeDelta(it, {
                now: st,
                precision: at,
                controlled: ot,
                offsetTime: this.offsetTime,
                overtime: lt
            })
        }
    }, {
        key: "calcOffsetStartTimestamp",
        value: function() {
            return Date.now()
        }
    }, {
        key: "addTime",
        value: function(nt) {
            this.legacyCountdownRef.current.addTime(nt)
        }
    }, {
        key: "clearTimer",
        value: function() {
            window.clearInterval(this.interval)
        }
    }, {
        key: "isStatus",
        value: function(nt) {
            return this.state.status === nt
        }
    }, {
        key: "setTimeDeltaState",
        value: function(nt, it, st) {
            var at = this;
            if (this.mounted) {
                var ot = nt.completed && !this.state.timeDelta.completed
                  , lt = nt.completed && it === "STARTED";
                ot && !this.props.overtime && this.clearTimer();
                var dt = function() {
                    st && st(at.state.timeDelta),
                    at.props.onComplete && (ot || lt) && at.props.onComplete(nt, lt)
                };
                return this.setState(function(ct) {
                    var ut = it || ct.status;
                    return nt.completed && !at.props.overtime ? ut = "COMPLETED" : !it && ut === "COMPLETED" && (ut = "STOPPED"),
                    {
                        timeDelta: nt,
                        status: ut
                    }
                }, dt)
            }
        }
    }, {
        key: "getApi",
        value: function() {
            return this.api = this.api || {
                start: this.start,
                pause: this.pause,
                stop: this.stop,
                isStarted: this.isStarted,
                isPaused: this.isPaused,
                isStopped: this.isStopped,
                isCompleted: this.isCompleted
            }
        }
    }, {
        key: "getRenderProps",
        value: function() {
            var nt = this.props
              , it = nt.daysInHours
              , st = nt.zeroPadTime
              , at = nt.zeroPadDays
              , ot = this.state.timeDelta;
            return Object.assign(Object.assign({}, ot), {
                api: this.getApi(),
                props: this.props,
                formatted: formatTimeDelta(ot, {
                    daysInHours: it,
                    zeroPadTime: st,
                    zeroPadDays: at
                })
            })
        }
    }, {
        key: "render",
        value: function() {
            if (this.legacyMode) {
                var nt = this.props
                  , it = nt.count
                  , st = nt.children
                  , at = nt.onComplete;
                return reactExports.createElement(Countdown, {
                    ref: this.legacyCountdownRef,
                    count: it,
                    onComplete: at
                }, st)
            }
            var ot = this.props
              , lt = ot.className
              , dt = ot.overtime
              , ct = ot.children
              , ut = ot.renderer
              , ft = this.getRenderProps();
            if (ut)
                return ut(ft);
            if (ct && this.state.timeDelta.completed && !dt)
                return reactExports.cloneElement(ct, {
                    countdown: ft
                });
            var ht = ft.formatted
              , gt = ht.days
              , bt = ht.hours
              , pt = ht.minutes
              , mt = ht.seconds;
            return reactExports.createElement("span", {
                className: lt
            }, ft.total < 0 ? "-" : "", gt, gt ? ":" : "", bt, ":", pt, ":", mt)
        }
    }]),
    tt
}(reactExports.Component);
Countdown$1.defaultProps = Object.assign(Object.assign({}, timeDeltaFormatOptionsDefaults), {
    controlled: !1,
    intervalDelay: 1e3,
    precision: 0,
    autoStart: !0
});
Countdown$1.propTypes = {
    date: propTypesExports.oneOfType([propTypesExports.instanceOf(Date), propTypesExports.string, propTypesExports.number]),
    daysInHours: propTypesExports.bool,
    zeroPadTime: propTypesExports.number,
    zeroPadDays: propTypesExports.number,
    controlled: propTypesExports.bool,
    intervalDelay: propTypesExports.number,
    precision: propTypesExports.number,
    autoStart: propTypesExports.bool,
    overtime: propTypesExports.bool,
    className: propTypesExports.string,
    children: propTypesExports.element,
    renderer: propTypesExports.func,
    now: propTypesExports.func,
    onMount: propTypesExports.func,
    onStart: propTypesExports.func,
    onPause: propTypesExports.func,
    onStop: propTypesExports.func,
    onTick: propTypesExports.func,
    onComplete: propTypesExports.func
};
const homeApiSlice = apiSlice.injectEndpoints({
    endpoints: _e=>({
        createAddress: _e.mutation({
            query: et=>({
                url: "/address/create",
                method: "POST",
                body: et
            })
        }),
        readAddress: _e.query({
            query: et=>({
                url: `/address/read/${et}`,
                method: "GET"
            })
        }),
        createNewAddress: _e.mutation({
            query: et=>({
                url: "/address/create-newaddress",
                method: "POST",
                body: et
            })
        }),
        readNewAddress: _e.query({
            query: et=>({
                url: `/address/read-newaddress/${et}`,
                method: "GET"
            })
        }),
        updateAddress: _e.mutation({
            query: et=>({
                url: "/address/update",
                method: "PATCH",
                body: et
            })
        }),
        getReferral: _e.query({
            query: et=>({
                url: `/address/referral/${et}`,
                method: "GET"
            })
        }),
        currencyConversion: _e.query({
            query: et=>({
                url: `/address/convert?currency=${et}`,
                method: "GET"
            })
        }),
        getPercentage: _e.query({
            query: ()=>({
                url: "/address/percentage",
                method: "GET"
            })
        }),
        createTransaction: _e.mutation({
            query: et=>({
                url: "/transaction/create",
                method: "POST",
                body: et
            })
        })
    })
})
  , {useCreateAddressMutation, useReadAddressQuery, useUpdateAddressMutation, useGetReferralQuery, useCurrencyConversionQuery, useGetPercentageQuery, useReadNewAddressQuery, useCreateNewAddressMutation, useCreateTransactionMutation} = homeApiSlice;
var Component = {}
  , toggleSelection = function() {
    var _e = document.getSelection();
    if (!_e.rangeCount)
        return function() {}
        ;
    for (var et = document.activeElement, tt = [], rt = 0; rt < _e.rangeCount; rt++)
        tt.push(_e.getRangeAt(rt));
    switch (et.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
        et.blur();
        break;
    default:
        et = null;
        break
    }
    return _e.removeAllRanges(),
    function() {
        _e.type === "Caret" && _e.removeAllRanges(),
        _e.rangeCount || tt.forEach(function(nt) {
            _e.addRange(nt)
        }),
        et && et.focus()
    }
}
  , deselectCurrent = toggleSelection
  , clipboardToIE11Formatting = {
    "text/plain": "Text",
    "text/html": "Url",
    default: "Text"
}
  , defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$2(_e) {
    var et = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
    return _e.replace(/#{\s*key\s*}/g, et)
}
function copy(_e, et) {
    var tt, rt, nt, it, st, at, ot = !1;
    et || (et = {}),
    tt = et.debug || !1;
    try {
        nt = deselectCurrent(),
        it = document.createRange(),
        st = document.getSelection(),
        at = document.createElement("span"),
        at.textContent = _e,
        at.ariaHidden = "true",
        at.style.all = "unset",
        at.style.position = "fixed",
        at.style.top = 0,
        at.style.clip = "rect(0, 0, 0, 0)",
        at.style.whiteSpace = "pre",
        at.style.webkitUserSelect = "text",
        at.style.MozUserSelect = "text",
        at.style.msUserSelect = "text",
        at.style.userSelect = "text",
        at.addEventListener("copy", function(dt) {
            if (dt.stopPropagation(),
            et.format)
                if (dt.preventDefault(),
                typeof dt.clipboardData > "u") {
                    tt && console.warn("unable to use e.clipboardData"),
                    tt && console.warn("trying IE specific stuff"),
                    window.clipboardData.clearData();
                    var ct = clipboardToIE11Formatting[et.format] || clipboardToIE11Formatting.default;
                    window.clipboardData.setData(ct, _e)
                } else
                    dt.clipboardData.clearData(),
                    dt.clipboardData.setData(et.format, _e);
            et.onCopy && (dt.preventDefault(),
            et.onCopy(dt.clipboardData))
        }),
        document.body.appendChild(at),
        it.selectNodeContents(at),
        st.addRange(it);
        var lt = document.execCommand("copy");
        if (!lt)
            throw new Error("copy command was unsuccessful");
        ot = !0
    } catch (dt) {
        tt && console.error("unable to copy using execCommand: ", dt),
        tt && console.warn("trying IE specific stuff");
        try {
            window.clipboardData.setData(et.format || "text", _e),
            et.onCopy && et.onCopy(window.clipboardData),
            ot = !0
        } catch (ct) {
            tt && console.error("unable to copy using clipboardData: ", ct),
            tt && console.error("falling back to prompt"),
            rt = format$2("message"in et ? et.message : defaultMessage),
            window.prompt(rt, _e)
        }
    } finally {
        st && (typeof st.removeRange == "function" ? st.removeRange(it) : st.removeAllRanges()),
        at && document.body.removeChild(at),
        nt()
    }
    return ot
}
var copyToClipboard = copy;
function _typeof(_e) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(et) {
        return typeof et
    }
    : function(et) {
        return et && typeof Symbol == "function" && et.constructor === Symbol && et !== Symbol.prototype ? "symbol" : typeof et
    }
    ,
    _typeof(_e)
}
Object.defineProperty(Component, "__esModule", {
    value: !0
});
Component.CopyToClipboard = void 0;
var _react = _interopRequireDefault(reactExports)
  , _copyToClipboard = _interopRequireDefault(copyToClipboard)
  , _excluded = ["text", "onCopy", "options", "children"];
function _interopRequireDefault(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
function ownKeys(_e, et) {
    var tt = Object.keys(_e);
    if (Object.getOwnPropertySymbols) {
        var rt = Object.getOwnPropertySymbols(_e);
        et && (rt = rt.filter(function(nt) {
            return Object.getOwnPropertyDescriptor(_e, nt).enumerable
        })),
        tt.push.apply(tt, rt)
    }
    return tt
}
function _objectSpread(_e) {
    for (var et = 1; et < arguments.length; et++) {
        var tt = arguments[et] != null ? arguments[et] : {};
        et % 2 ? ownKeys(Object(tt), !0).forEach(function(rt) {
            _defineProperty(_e, rt, tt[rt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_e, Object.getOwnPropertyDescriptors(tt)) : ownKeys(Object(tt)).forEach(function(rt) {
            Object.defineProperty(_e, rt, Object.getOwnPropertyDescriptor(tt, rt))
        })
    }
    return _e
}
function _objectWithoutProperties(_e, et) {
    if (_e == null)
        return {};
    var tt = _objectWithoutPropertiesLoose(_e, et), rt, nt;
    if (Object.getOwnPropertySymbols) {
        var it = Object.getOwnPropertySymbols(_e);
        for (nt = 0; nt < it.length; nt++)
            rt = it[nt],
            !(et.indexOf(rt) >= 0) && Object.prototype.propertyIsEnumerable.call(_e, rt) && (tt[rt] = _e[rt])
    }
    return tt
}
function _objectWithoutPropertiesLoose(_e, et) {
    if (_e == null)
        return {};
    var tt = {}, rt = Object.keys(_e), nt, it;
    for (it = 0; it < rt.length; it++)
        nt = rt[it],
        !(et.indexOf(nt) >= 0) && (tt[nt] = _e[nt]);
    return tt
}
function _classCallCheck(_e, et) {
    if (!(_e instanceof et))
        throw new TypeError("Cannot call a class as a function")
}
function _defineProperties(_e, et) {
    for (var tt = 0; tt < et.length; tt++) {
        var rt = et[tt];
        rt.enumerable = rt.enumerable || !1,
        rt.configurable = !0,
        "value"in rt && (rt.writable = !0),
        Object.defineProperty(_e, rt.key, rt)
    }
}
function _createClass(_e, et, tt) {
    return et && _defineProperties(_e.prototype, et),
    tt && _defineProperties(_e, tt),
    Object.defineProperty(_e, "prototype", {
        writable: !1
    }),
    _e
}
function _inherits(_e, et) {
    if (typeof et != "function" && et !== null)
        throw new TypeError("Super expression must either be null or a function");
    _e.prototype = Object.create(et && et.prototype, {
        constructor: {
            value: _e,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(_e, "prototype", {
        writable: !1
    }),
    et && _setPrototypeOf(_e, et)
}
function _setPrototypeOf(_e, et) {
    return _setPrototypeOf = Object.setPrototypeOf || function(rt, nt) {
        return rt.__proto__ = nt,
        rt
    }
    ,
    _setPrototypeOf(_e, et)
}
function _createSuper(_e) {
    var et = _isNativeReflectConstruct();
    return function() {
        var rt = _getPrototypeOf(_e), nt;
        if (et) {
            var it = _getPrototypeOf(this).constructor;
            nt = Reflect.construct(rt, arguments, it)
        } else
            nt = rt.apply(this, arguments);
        return _possibleConstructorReturn(this, nt)
    }
}
function _possibleConstructorReturn(_e, et) {
    if (et && (_typeof(et) === "object" || typeof et == "function"))
        return et;
    if (et !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(_e)
}
function _assertThisInitialized(_e) {
    if (_e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return _e
}
function _isNativeReflectConstruct() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function _getPrototypeOf(_e) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(tt) {
        return tt.__proto__ || Object.getPrototypeOf(tt)
    }
    ,
    _getPrototypeOf(_e)
}
function _defineProperty(_e, et, tt) {
    return et in _e ? Object.defineProperty(_e, et, {
        value: tt,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : _e[et] = tt,
    _e
}
var CopyToClipboard$2 = function(_e) {
    _inherits(tt, _e);
    var et = _createSuper(tt);
    function tt() {
        var rt;
        _classCallCheck(this, tt);
        for (var nt = arguments.length, it = new Array(nt), st = 0; st < nt; st++)
            it[st] = arguments[st];
        return rt = et.call.apply(et, [this].concat(it)),
        _defineProperty(_assertThisInitialized(rt), "onClick", function(at) {
            var ot = rt.props
              , lt = ot.text
              , dt = ot.onCopy
              , ct = ot.children
              , ut = ot.options
              , ft = _react.default.Children.only(ct)
              , ht = (0,
            _copyToClipboard.default)(lt, ut);
            dt && dt(lt, ht),
            ft && ft.props && typeof ft.props.onClick == "function" && ft.props.onClick(at)
        }),
        rt
    }
    return _createClass(tt, [{
        key: "render",
        value: function() {
            var nt = this.props;
            nt.text,
            nt.onCopy,
            nt.options;
            var it = nt.children
              , st = _objectWithoutProperties(nt, _excluded)
              , at = _react.default.Children.only(it);
            return _react.default.cloneElement(at, _objectSpread(_objectSpread({}, st), {}, {
                onClick: this.onClick
            }))
        }
    }]),
    tt
}(_react.default.PureComponent);
Component.CopyToClipboard = CopyToClipboard$2;
_defineProperty(CopyToClipboard$2, "defaultProps", {
    onCopy: void 0,
    options: void 0
});
var _require = Component
  , CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib = CopyToClipboard;
const CopyToClipboard$1 = getDefaultExportFromCjs(lib);
function LuClipboardCopy(_e) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "rect",
            attr: {
                width: "8",
                height: "4",
                x: "8",
                y: "2",
                rx: "1",
                ry: "1"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M16 4h2a2 2 0 0 1 2 2v4"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M21 14H11"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "m15 10-4 4 4 4"
            },
            child: []
        }]
    })(_e)
}
const ETH = "data:image/svg+xml,%3csvg%20width='50'%20height='50'%20viewBox='0%200%2050%2050'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M25.1435%2049.5432C38.7831%2049.5432%2049.8401%2038.4529%2049.8401%2024.7716C49.8401%2011.0902%2038.7831%200%2025.1435%200C11.5039%200%200.446777%2011.0902%200.446777%2024.7716C0.446777%2038.4529%2011.5039%2049.5432%2025.1435%2049.5432Z'%20fill='%234793FF'/%3e%3cpath%20d='M25.1436%200C38.7613%200%2049.8402%2011.1125%2049.8402%2024.7716C49.8402%2038.4306%2038.7613%2049.5432%2025.1436%2049.5432V0Z'%20fill='%235E69E2'/%3e%3cpath%20d='M25.1432%2043.3244C35.3586%2043.3244%2043.6399%2035.0184%2043.6399%2024.7717C43.6399%2014.5249%2035.3586%206.21899%2025.1432%206.21899C14.9277%206.21899%206.64648%2014.5249%206.64648%2024.7717C6.64648%2035.0184%2014.9277%2043.3244%2025.1432%2043.3244Z'%20fill='%232EBEEF'/%3e%3cpath%20d='M25.1436%206.21899C35.3427%206.21899%2043.6403%2014.541%2043.6403%2024.7717C43.6403%2035.0023%2035.3427%2043.3244%2025.1436%2043.3244V6.21899Z'%20fill='%234793FF'/%3e%3cpath%20d='M23.9395%2012.3066L16.1896%2023.9666C15.8655%2024.4533%2015.8655%2025.0887%2016.1896%2025.5767L23.9395%2037.2367C24.5122%2038.0987%2025.7747%2038.0987%2026.3475%2037.2367L34.0973%2025.5767C34.4215%2025.0887%2034.4215%2024.4533%2034.0973%2023.9666L26.3475%2012.3066C25.7747%2011.4445%2024.5123%2011.4445%2023.9395%2012.3066Z'%20fill='%2376E5F6'/%3e%3cpath%20d='M25.1436%2026.6468V37.8832C25.6024%2037.8832%2026.0612%2037.6677%2026.3476%2037.2367L34.0975%2025.5767C34.2481%2025.35%2034.3279%2025.0912%2034.3384%2024.8311L25.4273%2026.6183C25.3337%2026.6369%2025.2386%2026.6468%2025.1436%2026.6468Z'%20fill='%232EBEEF'/%3e%3cpath%20d='M25.143%2011.66C24.6842%2011.66%2024.2254%2011.8756%2023.939%2012.3066L16.1891%2023.9666C16.0158%2024.2279%2015.9361%2024.5301%2015.9482%2024.8311L24.8592%2026.6183C24.9529%2026.6369%2025.048%2026.6468%2025.143%2026.6468V11.66Z'%20fill='%23C2F4FB'/%3e%3c/svg%3e"
  , usdt = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Group'%3e%3cpath%20id='Vector'%20d='M12%2024C18.6274%2024%2024%2018.6274%2024%2012C24%205.37258%2018.6274%200%2012%200C5.37258%200%200%205.37258%200%2012C0%2018.6274%205.37258%2024%2012%2024Z'%20fill='%2315B785'/%3e%3cpath%20id='Vector_2'%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M13.4415%2013.0375V13.036C13.359%2013.042%2012.9338%2013.0675%2011.985%2013.0675C11.2275%2013.0675%2010.6943%2013.045%2010.5068%2013.036V13.0383C7.59079%2012.91%205.41429%2012.4023%205.41429%2011.7948C5.41429%2011.188%207.59079%2010.6803%2010.5068%2010.5498V12.5328C10.6973%2012.5463%2011.2433%2012.5785%2011.9978%2012.5785C12.903%2012.5785%2013.3568%2012.541%2013.4415%2012.5335V10.5513C16.3515%2010.681%2018.5228%2011.1888%2018.5228%2011.7948C18.5228%2012.4023%2016.3515%2012.9085%2013.4415%2013.0375V13.0375ZM13.4415%2010.345V8.5705H17.502V5.8645H6.44629V8.5705H10.5068V10.3443C7.20679%2010.4958%204.72504%2011.1498%204.72504%2011.9328C4.72504%2012.7158%207.20679%2013.369%2010.5068%2013.5213V19.2078H13.4415V13.5198C16.7363%2013.3683%2019.212%2012.715%2019.212%2011.9328C19.212%2011.1505%2016.7363%2010.4973%2013.4415%2010.345'%20fill='white'/%3e%3c/g%3e%3c/svg%3e"
  , card = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M2.97656%208.50496H22.9766'%20stroke='%23ffffff'%20stroke-width='1.5'%20stroke-miterlimit='10'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M6.97656%2016.505H8.97656'%20stroke='%23ffffff'%20stroke-width='1.5'%20stroke-miterlimit='10'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M11.4766%2016.505H15.4766'%20stroke='%23ffffff'%20stroke-width='1.5'%20stroke-miterlimit='10'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M7.41656%203.50496H18.5266C22.0866%203.50496%2022.9766%204.38496%2022.9766%207.89496V16.105C22.9766%2019.615%2022.0866%2020.495%2018.5366%2020.495H7.41656C3.86656%2020.505%202.97656%2019.625%202.97656%2016.115V7.89496C2.97656%204.38496%203.86656%203.50496%207.41656%203.50496Z'%20stroke='%23ffffff'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , BNB = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_4240_60908)'%3e%3cpath%20d='M16%2032C24.8366%2032%2032%2024.8366%2032%2016C32%207.16344%2024.8366%200%2016%200C7.16344%200%200%207.16344%200%2016C0%2024.8366%207.16344%2032%2016%2032Z'%20fill='%23F3BA2F'/%3e%3cpath%20d='M12.116%2014.404L16%2010.52L19.886%2014.406L22.146%2012.146L16%206L9.856%2012.144L12.116%2014.404ZM6%2016L8.26%2013.74L10.52%2016L8.26%2018.26L6%2016ZM12.116%2017.596L16%2021.48L19.886%2017.594L22.146%2019.853L16%2026L9.856%2019.856L9.853%2019.853L12.116%2017.596ZM21.48%2016L23.74%2013.74L26%2016L23.74%2018.26L21.48%2016ZM18.292%2015.998H18.294V16L16%2018.294L13.709%2016.004L13.705%2016L13.709%2015.997L14.11%2015.595L14.305%2015.4L16%2013.706L18.293%2015.999L18.292%2015.998Z'%20fill='white'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_4240_60908'%3e%3crect%20width='32'%20height='32'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e"
  , favicon = "/assets/favicon-3tSd1HKr.webp";
var cssUnit = {
    cm: !0,
    mm: !0,
    in: !0,
    px: !0,
    pt: !0,
    pc: !0,
    em: !0,
    ex: !0,
    ch: !0,
    rem: !0,
    vw: !0,
    vh: !0,
    vmin: !0,
    vmax: !0,
    "%": !0
};
function parseLengthAndUnit(_e) {
    if (typeof _e == "number")
        return {
            value: _e,
            unit: "px"
        };
    var et, tt = (_e.match(/^[0-9.]*/) || "").toString();
    tt.includes(".") ? et = parseFloat(tt) : et = parseInt(tt, 10);
    var rt = (_e.match(/[^0-9]*$/) || "").toString();
    return cssUnit[rt] ? {
        value: et,
        unit: rt
    } : (console.warn("React Spinners: ".concat(_e, " is not a valid css value. Defaulting to ").concat(et, "px.")),
    {
        value: et,
        unit: "px"
    })
}
function cssValue(_e) {
    var et = parseLengthAndUnit(_e);
    return "".concat(et.value).concat(et.unit)
}
var createAnimation = function(_e, et, tt) {
    var rt = "react-spinners-".concat(_e, "-").concat(tt);
    if (typeof window > "u" || !window.document)
        return rt;
    var nt = document.createElement("style");
    document.head.appendChild(nt);
    var it = nt.sheet
      , st = `
    @keyframes `.concat(rt, ` {
      `).concat(et, `
    }
  `);
    return it && it.insertRule(st, 0),
    rt
}
  , __assign$1 = function() {
    return __assign$1 = Object.assign || function(_e) {
        for (var et, tt = 1, rt = arguments.length; tt < rt; tt++) {
            et = arguments[tt];
            for (var nt in et)
                Object.prototype.hasOwnProperty.call(et, nt) && (_e[nt] = et[nt])
        }
        return _e
    }
    ,
    __assign$1.apply(this, arguments)
}
  , __rest$1 = function(_e, et) {
    var tt = {};
    for (var rt in _e)
        Object.prototype.hasOwnProperty.call(_e, rt) && et.indexOf(rt) < 0 && (tt[rt] = _e[rt]);
    if (_e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var nt = 0, rt = Object.getOwnPropertySymbols(_e); nt < rt.length; nt++)
            et.indexOf(rt[nt]) < 0 && Object.prototype.propertyIsEnumerable.call(_e, rt[nt]) && (tt[rt[nt]] = _e[rt[nt]]);
    return tt
}
  , bounce = createAnimation("BounceLoader", "0% {transform: scale(0)} 50% {transform: scale(1.0)} 100% {transform: scale(0)}", "bounce");
function BounceLoader(_e) {
    var et = _e.loading
      , tt = et === void 0 ? !0 : et
      , rt = _e.color
      , nt = rt === void 0 ? "#000000" : rt
      , it = _e.speedMultiplier
      , st = it === void 0 ? 1 : it
      , at = _e.cssOverride
      , ot = at === void 0 ? {} : at
      , lt = _e.size
      , dt = lt === void 0 ? 60 : lt
      , ct = __rest$1(_e, ["loading", "color", "speedMultiplier", "cssOverride", "size"])
      , ut = function(ht) {
        var gt = ht === 1 ? "".concat(1 / st, "s") : "0s";
        return {
            position: "absolute",
            height: cssValue(dt),
            width: cssValue(dt),
            backgroundColor: nt,
            borderRadius: "100%",
            opacity: .6,
            top: 0,
            left: 0,
            animationFillMode: "both",
            animation: "".concat(bounce, " ").concat(2.1 / st, "s ").concat(gt, " infinite ease-in-out")
        }
    }
      , ft = __assign$1({
        display: "inherit",
        position: "relative",
        width: cssValue(dt),
        height: cssValue(dt)
    }, ot);
    return tt ? reactExports.createElement("span", __assign$1({
        style: ft
    }, ct), reactExports.createElement("span", {
        style: ut(1)
    }), reactExports.createElement("span", {
        style: ut(2)
    })) : null
}
var __assign = function() {
    return __assign = Object.assign || function(_e) {
        for (var et, tt = 1, rt = arguments.length; tt < rt; tt++) {
            et = arguments[tt];
            for (var nt in et)
                Object.prototype.hasOwnProperty.call(et, nt) && (_e[nt] = et[nt])
        }
        return _e
    }
    ,
    __assign.apply(this, arguments)
}
  , __rest = function(_e, et) {
    var tt = {};
    for (var rt in _e)
        Object.prototype.hasOwnProperty.call(_e, rt) && et.indexOf(rt) < 0 && (tt[rt] = _e[rt]);
    if (_e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var nt = 0, rt = Object.getOwnPropertySymbols(_e); nt < rt.length; nt++)
            et.indexOf(rt[nt]) < 0 && Object.prototype.propertyIsEnumerable.call(_e, rt[nt]) && (tt[rt[nt]] = _e[rt[nt]]);
    return tt
}
  , moon = createAnimation("MoonLoader", "100% {transform: rotate(360deg)}", "moon");
function MoonLoader(_e) {
    var et = _e.loading
      , tt = et === void 0 ? !0 : et
      , rt = _e.color
      , nt = rt === void 0 ? "#000000" : rt
      , it = _e.speedMultiplier
      , st = it === void 0 ? 1 : it
      , at = _e.cssOverride
      , ot = at === void 0 ? {} : at
      , lt = _e.size
      , dt = lt === void 0 ? 60 : lt
      , ct = __rest(_e, ["loading", "color", "speedMultiplier", "cssOverride", "size"])
      , ut = parseLengthAndUnit(dt)
      , ft = ut.value
      , ht = ut.unit
      , gt = ft / 7
      , bt = __assign({
        display: "inherit",
        position: "relative",
        width: "".concat("".concat(ft + gt * 2).concat(ht)),
        height: "".concat("".concat(ft + gt * 2).concat(ht)),
        animation: "".concat(moon, " ").concat(.6 / st, "s 0s infinite linear"),
        animationFillMode: "forwards"
    }, ot)
      , pt = function(vt) {
        return {
            width: cssValue(vt),
            height: cssValue(vt),
            borderRadius: "100%"
        }
    }
      , mt = __assign(__assign({}, pt(gt)), {
        backgroundColor: "".concat(nt),
        opacity: "0.8",
        position: "absolute",
        top: "".concat("".concat(ft / 2 - gt / 2).concat(ht)),
        animation: "".concat(moon, " ").concat(.6 / st, "s 0s infinite linear"),
        animationFillMode: "forwards"
    })
      , yt = __assign(__assign({}, pt(ft)), {
        border: "".concat(gt, "px solid ").concat(nt),
        opacity: "0.1",
        boxSizing: "content-box",
        position: "absolute"
    });
    return tt ? reactExports.createElement("span", __assign({
        style: bt
    }, ct), reactExports.createElement("span", {
        style: mt
    }), reactExports.createElement("span", {
        style: yt
    })) : null
}
var reactUseanimations = {}
  , lottie = {
    exports: {}
};
(function(module, exports) {
    typeof navigator < "u" && function(_e, et) {
        module.exports = et()
    }(commonjsGlobal, function() {
        var svgNS = "http://www.w3.org/2000/svg"
          , locationHref = ""
          , _useWebWorker = !1
          , initialDefaultFrame = -999999
          , setWebWorker = function(et) {
            _useWebWorker = !!et
        }
          , getWebWorker = function() {
            return _useWebWorker
        }
          , setLocationHref = function(et) {
            locationHref = et
        }
          , getLocationHref = function() {
            return locationHref
        };
        function createTag(_e) {
            return document.createElement(_e)
        }
        function extendPrototype(_e, et) {
            var tt, rt = _e.length, nt;
            for (tt = 0; tt < rt; tt += 1) {
                nt = _e[tt].prototype;
                for (var it in nt)
                    Object.prototype.hasOwnProperty.call(nt, it) && (et.prototype[it] = nt[it])
            }
        }
        function getDescriptor(_e, et) {
            return Object.getOwnPropertyDescriptor(_e, et)
        }
        function createProxyFunction(_e) {
            function et() {}
            return et.prototype = _e,
            et
        }
        var audioControllerFactory = function() {
            function _e(et) {
                this.audios = [],
                this.audioFactory = et,
                this._volume = 1,
                this._isMuted = !1
            }
            return _e.prototype = {
                addAudio: function(tt) {
                    this.audios.push(tt)
                },
                pause: function() {
                    var tt, rt = this.audios.length;
                    for (tt = 0; tt < rt; tt += 1)
                        this.audios[tt].pause()
                },
                resume: function() {
                    var tt, rt = this.audios.length;
                    for (tt = 0; tt < rt; tt += 1)
                        this.audios[tt].resume()
                },
                setRate: function(tt) {
                    var rt, nt = this.audios.length;
                    for (rt = 0; rt < nt; rt += 1)
                        this.audios[rt].setRate(tt)
                },
                createAudio: function(tt) {
                    return this.audioFactory ? this.audioFactory(tt) : window.Howl ? new window.Howl({
                        src: [tt]
                    }) : {
                        isPlaying: !1,
                        play: function() {
                            this.isPlaying = !0
                        },
                        seek: function() {
                            this.isPlaying = !1
                        },
                        playing: function() {},
                        rate: function() {},
                        setVolume: function() {}
                    }
                },
                setAudioFactory: function(tt) {
                    this.audioFactory = tt
                },
                setVolume: function(tt) {
                    this._volume = tt,
                    this._updateVolume()
                },
                mute: function() {
                    this._isMuted = !0,
                    this._updateVolume()
                },
                unmute: function() {
                    this._isMuted = !1,
                    this._updateVolume()
                },
                getVolume: function() {
                    return this._volume
                },
                _updateVolume: function() {
                    var tt, rt = this.audios.length;
                    for (tt = 0; tt < rt; tt += 1)
                        this.audios[tt].volume(this._volume * (this._isMuted ? 0 : 1))
                }
            },
            function() {
                return new _e
            }
        }()
          , createTypedArray = function() {
            function _e(tt, rt) {
                var nt = 0, it = [], st;
                switch (tt) {
                case "int16":
                case "uint8c":
                    st = 1;
                    break;
                default:
                    st = 1.1;
                    break
                }
                for (nt = 0; nt < rt; nt += 1)
                    it.push(st);
                return it
            }
            function et(tt, rt) {
                return tt === "float32" ? new Float32Array(rt) : tt === "int16" ? new Int16Array(rt) : tt === "uint8c" ? new Uint8ClampedArray(rt) : _e(tt, rt)
            }
            return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? et : _e
        }();
        function createSizedArray(_e) {
            return Array.apply(null, {
                length: _e
            })
        }
        function _typeof$6(_e) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function(tt) {
                return typeof tt
            }
            : _typeof$6 = function(tt) {
                return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
            }
            ,
            _typeof$6(_e)
        }
        var subframeEnabled = !0
          , expressionsPlugin = null
          , expressionsInterfaces = null
          , idPrefix$1 = ""
          , isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          , bmPow = Math.pow
          , bmSqrt = Math.sqrt
          , bmFloor = Math.floor
          , bmMax = Math.max
          , bmMin = Math.min
          , BMMath = {};
        (function() {
            var _e = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], et, tt = _e.length;
            for (et = 0; et < tt; et += 1)
                BMMath[_e[et]] = Math[_e[et]]
        }
        )(),
        BMMath.random = Math.random,
        BMMath.abs = function(_e) {
            var et = _typeof$6(_e);
            if (et === "object" && _e.length) {
                var tt = createSizedArray(_e.length), rt, nt = _e.length;
                for (rt = 0; rt < nt; rt += 1)
                    tt[rt] = Math.abs(_e[rt]);
                return tt
            }
            return Math.abs(_e)
        }
        ;
        var defaultCurveSegments = 150
          , degToRads = Math.PI / 180
          , roundCorner = .5519;
        function styleDiv(_e) {
            _e.style.position = "absolute",
            _e.style.top = 0,
            _e.style.left = 0,
            _e.style.display = "block",
            _e.style.transformOrigin = "0 0",
            _e.style.webkitTransformOrigin = "0 0",
            _e.style.backfaceVisibility = "visible",
            _e.style.webkitBackfaceVisibility = "visible",
            _e.style.transformStyle = "preserve-3d",
            _e.style.webkitTransformStyle = "preserve-3d",
            _e.style.mozTransformStyle = "preserve-3d"
        }
        function BMEnterFrameEvent(_e, et, tt, rt) {
            this.type = _e,
            this.currentTime = et,
            this.totalTime = tt,
            this.direction = rt < 0 ? -1 : 1
        }
        function BMCompleteEvent(_e, et) {
            this.type = _e,
            this.direction = et < 0 ? -1 : 1
        }
        function BMCompleteLoopEvent(_e, et, tt, rt) {
            this.type = _e,
            this.currentLoop = tt,
            this.totalLoops = et,
            this.direction = rt < 0 ? -1 : 1
        }
        function BMSegmentStartEvent(_e, et, tt) {
            this.type = _e,
            this.firstFrame = et,
            this.totalFrames = tt
        }
        function BMDestroyEvent(_e, et) {
            this.type = _e,
            this.target = et
        }
        function BMRenderFrameErrorEvent(_e, et) {
            this.type = "renderFrameError",
            this.nativeError = _e,
            this.currentTime = et
        }
        function BMConfigErrorEvent(_e) {
            this.type = "configError",
            this.nativeError = _e
        }
        var createElementID = function() {
            var _e = 0;
            return function() {
                return _e += 1,
                idPrefix$1 + "__lottie_element_" + _e
            }
        }();
        function HSVtoRGB(_e, et, tt) {
            var rt, nt, it, st, at, ot, lt, dt;
            switch (st = Math.floor(_e * 6),
            at = _e * 6 - st,
            ot = tt * (1 - et),
            lt = tt * (1 - at * et),
            dt = tt * (1 - (1 - at) * et),
            st % 6) {
            case 0:
                rt = tt,
                nt = dt,
                it = ot;
                break;
            case 1:
                rt = lt,
                nt = tt,
                it = ot;
                break;
            case 2:
                rt = ot,
                nt = tt,
                it = dt;
                break;
            case 3:
                rt = ot,
                nt = lt,
                it = tt;
                break;
            case 4:
                rt = dt,
                nt = ot,
                it = tt;
                break;
            case 5:
                rt = tt,
                nt = ot,
                it = lt;
                break
            }
            return [rt, nt, it]
        }
        function RGBtoHSV(_e, et, tt) {
            var rt = Math.max(_e, et, tt), nt = Math.min(_e, et, tt), it = rt - nt, st, at = rt === 0 ? 0 : it / rt, ot = rt / 255;
            switch (rt) {
            case nt:
                st = 0;
                break;
            case _e:
                st = et - tt + it * (et < tt ? 6 : 0),
                st /= 6 * it;
                break;
            case et:
                st = tt - _e + it * 2,
                st /= 6 * it;
                break;
            case tt:
                st = _e - et + it * 4,
                st /= 6 * it;
                break
            }
            return [st, at, ot]
        }
        function addSaturationToRGB(_e, et) {
            var tt = RGBtoHSV(_e[0] * 255, _e[1] * 255, _e[2] * 255);
            return tt[1] += et,
            tt[1] > 1 ? tt[1] = 1 : tt[1] <= 0 && (tt[1] = 0),
            HSVtoRGB(tt[0], tt[1], tt[2])
        }
        function addBrightnessToRGB(_e, et) {
            var tt = RGBtoHSV(_e[0] * 255, _e[1] * 255, _e[2] * 255);
            return tt[2] += et,
            tt[2] > 1 ? tt[2] = 1 : tt[2] < 0 && (tt[2] = 0),
            HSVtoRGB(tt[0], tt[1], tt[2])
        }
        function addHueToRGB(_e, et) {
            var tt = RGBtoHSV(_e[0] * 255, _e[1] * 255, _e[2] * 255);
            return tt[0] += et / 360,
            tt[0] > 1 ? tt[0] -= 1 : tt[0] < 0 && (tt[0] += 1),
            HSVtoRGB(tt[0], tt[1], tt[2])
        }
        var rgbToHex = function() {
            var _e = [], et, tt;
            for (et = 0; et < 256; et += 1)
                tt = et.toString(16),
                _e[et] = tt.length === 1 ? "0" + tt : tt;
            return function(rt, nt, it) {
                return rt < 0 && (rt = 0),
                nt < 0 && (nt = 0),
                it < 0 && (it = 0),
                "#" + _e[rt] + _e[nt] + _e[it]
            }
        }()
          , setSubframeEnabled = function(et) {
            subframeEnabled = !!et
        }
          , getSubframeEnabled = function() {
            return subframeEnabled
        }
          , setExpressionsPlugin = function(et) {
            expressionsPlugin = et
        }
          , getExpressionsPlugin = function() {
            return expressionsPlugin
        }
          , setExpressionInterfaces = function(et) {
            expressionsInterfaces = et
        }
          , getExpressionInterfaces = function() {
            return expressionsInterfaces
        }
          , setDefaultCurveSegments = function(et) {
            defaultCurveSegments = et
        }
          , getDefaultCurveSegments = function() {
            return defaultCurveSegments
        }
          , setIdPrefix = function(et) {
            idPrefix$1 = et
        };
        function createNS(_e) {
            return document.createElementNS(svgNS, _e)
        }
        function _typeof$5(_e) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function(tt) {
                return typeof tt
            }
            : _typeof$5 = function(tt) {
                return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
            }
            ,
            _typeof$5(_e)
        }
        var dataManager = function() {
            var _e = 1, et = [], tt, rt, nt = {
                onmessage: function() {},
                postMessage: function(ft) {
                    tt({
                        data: ft
                    })
                }
            }, it = {
                postMessage: function(ft) {
                    nt.onmessage({
                        data: ft
                    })
                }
            };
            function st(ut) {
                if (window.Worker && window.Blob && getWebWorker()) {
                    var ft = new Blob(["var _workerSelf = self; self.onmessage = ", ut.toString()],{
                        type: "text/javascript"
                    })
                      , ht = URL.createObjectURL(ft);
                    return new Worker(ht)
                }
                return tt = ut,
                nt
            }
            function at() {
                rt || (rt = st(function(ft) {
                    function ht() {
                        function bt(Mt, $t) {
                            var kt, At, Pt = Mt.length, Dt, Bt, zt, Yt;
                            for (At = 0; At < Pt; At += 1)
                                if (kt = Mt[At],
                                "ks"in kt && !kt.completed) {
                                    if (kt.completed = !0,
                                    kt.hasMask) {
                                        var rr = kt.masksProperties;
                                        for (Bt = rr.length,
                                        Dt = 0; Dt < Bt; Dt += 1)
                                            if (rr[Dt].pt.k.i)
                                                wt(rr[Dt].pt.k);
                                            else
                                                for (Yt = rr[Dt].pt.k.length,
                                                zt = 0; zt < Yt; zt += 1)
                                                    rr[Dt].pt.k[zt].s && wt(rr[Dt].pt.k[zt].s[0]),
                                                    rr[Dt].pt.k[zt].e && wt(rr[Dt].pt.k[zt].e[0])
                                    }
                                    kt.ty === 0 ? (kt.layers = yt(kt.refId, $t),
                                    bt(kt.layers, $t)) : kt.ty === 4 ? vt(kt.shapes) : kt.ty === 5 && Ft(kt)
                                }
                        }
                        function pt(Mt, $t) {
                            if (Mt) {
                                var kt = 0
                                  , At = Mt.length;
                                for (kt = 0; kt < At; kt += 1)
                                    Mt[kt].t === 1 && (Mt[kt].data.layers = yt(Mt[kt].data.refId, $t),
                                    bt(Mt[kt].data.layers, $t))
                            }
                        }
                        function mt(Mt, $t) {
                            for (var kt = 0, At = $t.length; kt < At; ) {
                                if ($t[kt].id === Mt)
                                    return $t[kt];
                                kt += 1
                            }
                            return null
                        }
                        function yt(Mt, $t) {
                            var kt = mt(Mt, $t);
                            return kt ? kt.layers.__used ? JSON.parse(JSON.stringify(kt.layers)) : (kt.layers.__used = !0,
                            kt.layers) : null
                        }
                        function vt(Mt) {
                            var $t, kt = Mt.length, At, Pt;
                            for ($t = kt - 1; $t >= 0; $t -= 1)
                                if (Mt[$t].ty === "sh")
                                    if (Mt[$t].ks.k.i)
                                        wt(Mt[$t].ks.k);
                                    else
                                        for (Pt = Mt[$t].ks.k.length,
                                        At = 0; At < Pt; At += 1)
                                            Mt[$t].ks.k[At].s && wt(Mt[$t].ks.k[At].s[0]),
                                            Mt[$t].ks.k[At].e && wt(Mt[$t].ks.k[At].e[0]);
                                else
                                    Mt[$t].ty === "gr" && vt(Mt[$t].it)
                        }
                        function wt(Mt) {
                            var $t, kt = Mt.i.length;
                            for ($t = 0; $t < kt; $t += 1)
                                Mt.i[$t][0] += Mt.v[$t][0],
                                Mt.i[$t][1] += Mt.v[$t][1],
                                Mt.o[$t][0] += Mt.v[$t][0],
                                Mt.o[$t][1] += Mt.v[$t][1]
                        }
                        function _t(Mt, $t) {
                            var kt = $t ? $t.split(".") : [100, 100, 100];
                            return Mt[0] > kt[0] ? !0 : kt[0] > Mt[0] ? !1 : Mt[1] > kt[1] ? !0 : kt[1] > Mt[1] ? !1 : Mt[2] > kt[2] ? !0 : kt[2] > Mt[2] ? !1 : null
                        }
                        var Et = function() {
                            var Mt = [4, 4, 14];
                            function $t(At) {
                                var Pt = At.t.d;
                                At.t.d = {
                                    k: [{
                                        s: Pt,
                                        t: 0
                                    }]
                                }
                            }
                            function kt(At) {
                                var Pt, Dt = At.length;
                                for (Pt = 0; Pt < Dt; Pt += 1)
                                    At[Pt].ty === 5 && $t(At[Pt])
                            }
                            return function(At) {
                                if (_t(Mt, At.v) && (kt(At.layers),
                                At.assets)) {
                                    var Pt, Dt = At.assets.length;
                                    for (Pt = 0; Pt < Dt; Pt += 1)
                                        At.assets[Pt].layers && kt(At.assets[Pt].layers)
                                }
                            }
                        }()
                          , xt = function() {
                            var Mt = [4, 7, 99];
                            return function($t) {
                                if ($t.chars && !_t(Mt, $t.v)) {
                                    var kt, At = $t.chars.length;
                                    for (kt = 0; kt < At; kt += 1) {
                                        var Pt = $t.chars[kt];
                                        Pt.data && Pt.data.shapes && (vt(Pt.data.shapes),
                                        Pt.data.ip = 0,
                                        Pt.data.op = 99999,
                                        Pt.data.st = 0,
                                        Pt.data.sr = 1,
                                        Pt.data.ks = {
                                            p: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            s: {
                                                k: [100, 100],
                                                a: 0
                                            },
                                            a: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            r: {
                                                k: 0,
                                                a: 0
                                            },
                                            o: {
                                                k: 100,
                                                a: 0
                                            }
                                        },
                                        $t.chars[kt].t || (Pt.data.shapes.push({
                                            ty: "no"
                                        }),
                                        Pt.data.shapes[0].it.push({
                                            p: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            s: {
                                                k: [100, 100],
                                                a: 0
                                            },
                                            a: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            r: {
                                                k: 0,
                                                a: 0
                                            },
                                            o: {
                                                k: 100,
                                                a: 0
                                            },
                                            sk: {
                                                k: 0,
                                                a: 0
                                            },
                                            sa: {
                                                k: 0,
                                                a: 0
                                            },
                                            ty: "tr"
                                        })))
                                    }
                                }
                            }
                        }()
                          , Ct = function() {
                            var Mt = [5, 7, 15];
                            function $t(At) {
                                var Pt = At.t.p;
                                typeof Pt.a == "number" && (Pt.a = {
                                    a: 0,
                                    k: Pt.a
                                }),
                                typeof Pt.p == "number" && (Pt.p = {
                                    a: 0,
                                    k: Pt.p
                                }),
                                typeof Pt.r == "number" && (Pt.r = {
                                    a: 0,
                                    k: Pt.r
                                })
                            }
                            function kt(At) {
                                var Pt, Dt = At.length;
                                for (Pt = 0; Pt < Dt; Pt += 1)
                                    At[Pt].ty === 5 && $t(At[Pt])
                            }
                            return function(At) {
                                if (_t(Mt, At.v) && (kt(At.layers),
                                At.assets)) {
                                    var Pt, Dt = At.assets.length;
                                    for (Pt = 0; Pt < Dt; Pt += 1)
                                        At.assets[Pt].layers && kt(At.assets[Pt].layers)
                                }
                            }
                        }()
                          , Tt = function() {
                            var Mt = [4, 1, 9];
                            function $t(At) {
                                var Pt, Dt = At.length, Bt, zt;
                                for (Pt = 0; Pt < Dt; Pt += 1)
                                    if (At[Pt].ty === "gr")
                                        $t(At[Pt].it);
                                    else if (At[Pt].ty === "fl" || At[Pt].ty === "st")
                                        if (At[Pt].c.k && At[Pt].c.k[0].i)
                                            for (zt = At[Pt].c.k.length,
                                            Bt = 0; Bt < zt; Bt += 1)
                                                At[Pt].c.k[Bt].s && (At[Pt].c.k[Bt].s[0] /= 255,
                                                At[Pt].c.k[Bt].s[1] /= 255,
                                                At[Pt].c.k[Bt].s[2] /= 255,
                                                At[Pt].c.k[Bt].s[3] /= 255),
                                                At[Pt].c.k[Bt].e && (At[Pt].c.k[Bt].e[0] /= 255,
                                                At[Pt].c.k[Bt].e[1] /= 255,
                                                At[Pt].c.k[Bt].e[2] /= 255,
                                                At[Pt].c.k[Bt].e[3] /= 255);
                                        else
                                            At[Pt].c.k[0] /= 255,
                                            At[Pt].c.k[1] /= 255,
                                            At[Pt].c.k[2] /= 255,
                                            At[Pt].c.k[3] /= 255
                            }
                            function kt(At) {
                                var Pt, Dt = At.length;
                                for (Pt = 0; Pt < Dt; Pt += 1)
                                    At[Pt].ty === 4 && $t(At[Pt].shapes)
                            }
                            return function(At) {
                                if (_t(Mt, At.v) && (kt(At.layers),
                                At.assets)) {
                                    var Pt, Dt = At.assets.length;
                                    for (Pt = 0; Pt < Dt; Pt += 1)
                                        At.assets[Pt].layers && kt(At.assets[Pt].layers)
                                }
                            }
                        }()
                          , It = function() {
                            var Mt = [4, 4, 18];
                            function $t(At) {
                                var Pt, Dt = At.length, Bt, zt;
                                for (Pt = Dt - 1; Pt >= 0; Pt -= 1)
                                    if (At[Pt].ty === "sh")
                                        if (At[Pt].ks.k.i)
                                            At[Pt].ks.k.c = At[Pt].closed;
                                        else
                                            for (zt = At[Pt].ks.k.length,
                                            Bt = 0; Bt < zt; Bt += 1)
                                                At[Pt].ks.k[Bt].s && (At[Pt].ks.k[Bt].s[0].c = At[Pt].closed),
                                                At[Pt].ks.k[Bt].e && (At[Pt].ks.k[Bt].e[0].c = At[Pt].closed);
                                    else
                                        At[Pt].ty === "gr" && $t(At[Pt].it)
                            }
                            function kt(At) {
                                var Pt, Dt, Bt = At.length, zt, Yt, rr, ar;
                                for (Dt = 0; Dt < Bt; Dt += 1) {
                                    if (Pt = At[Dt],
                                    Pt.hasMask) {
                                        var or = Pt.masksProperties;
                                        for (Yt = or.length,
                                        zt = 0; zt < Yt; zt += 1)
                                            if (or[zt].pt.k.i)
                                                or[zt].pt.k.c = or[zt].cl;
                                            else
                                                for (ar = or[zt].pt.k.length,
                                                rr = 0; rr < ar; rr += 1)
                                                    or[zt].pt.k[rr].s && (or[zt].pt.k[rr].s[0].c = or[zt].cl),
                                                    or[zt].pt.k[rr].e && (or[zt].pt.k[rr].e[0].c = or[zt].cl)
                                    }
                                    Pt.ty === 4 && $t(Pt.shapes)
                                }
                            }
                            return function(At) {
                                if (_t(Mt, At.v) && (kt(At.layers),
                                At.assets)) {
                                    var Pt, Dt = At.assets.length;
                                    for (Pt = 0; Pt < Dt; Pt += 1)
                                        At.assets[Pt].layers && kt(At.assets[Pt].layers)
                                }
                            }
                        }();
                        function Nt(Mt) {
                            Mt.__complete || (Tt(Mt),
                            Et(Mt),
                            xt(Mt),
                            Ct(Mt),
                            It(Mt),
                            bt(Mt.layers, Mt.assets),
                            pt(Mt.chars, Mt.assets),
                            Mt.__complete = !0)
                        }
                        function Ft(Mt) {
                            Mt.t.a.length === 0 && "m"in Mt.t.p
                        }
                        var Lt = {};
                        return Lt.completeData = Nt,
                        Lt.checkColors = Tt,
                        Lt.checkChars = xt,
                        Lt.checkPathProperties = Ct,
                        Lt.checkShapes = It,
                        Lt.completeLayers = bt,
                        Lt
                    }
                    if (it.dataManager || (it.dataManager = ht()),
                    it.assetLoader || (it.assetLoader = function() {
                        function bt(mt) {
                            var yt = mt.getResponseHeader("content-type");
                            return yt && mt.responseType === "json" && yt.indexOf("json") !== -1 || mt.response && _typeof$5(mt.response) === "object" ? mt.response : mt.response && typeof mt.response == "string" ? JSON.parse(mt.response) : mt.responseText ? JSON.parse(mt.responseText) : null
                        }
                        function pt(mt, yt, vt, wt) {
                            var _t, Et = new XMLHttpRequest;
                            try {
                                Et.responseType = "json"
                            } catch {}
                            Et.onreadystatechange = function() {
                                if (Et.readyState === 4)
                                    if (Et.status === 200)
                                        _t = bt(Et),
                                        vt(_t);
                                    else
                                        try {
                                            _t = bt(Et),
                                            vt(_t)
                                        } catch (xt) {
                                            wt && wt(xt)
                                        }
                            }
                            ;
                            try {
                                Et.open(["G", "E", "T"].join(""), mt, !0)
                            } catch {
                                Et.open(["G", "E", "T"].join(""), yt + "/" + mt, !0)
                            }
                            Et.send()
                        }
                        return {
                            load: pt
                        }
                    }()),
                    ft.data.type === "loadAnimation")
                        it.assetLoader.load(ft.data.path, ft.data.fullPath, function(bt) {
                            it.dataManager.completeData(bt),
                            it.postMessage({
                                id: ft.data.id,
                                payload: bt,
                                status: "success"
                            })
                        }, function() {
                            it.postMessage({
                                id: ft.data.id,
                                status: "error"
                            })
                        });
                    else if (ft.data.type === "complete") {
                        var gt = ft.data.animation;
                        it.dataManager.completeData(gt),
                        it.postMessage({
                            id: ft.data.id,
                            payload: gt,
                            status: "success"
                        })
                    } else
                        ft.data.type === "loadData" && it.assetLoader.load(ft.data.path, ft.data.fullPath, function(bt) {
                            it.postMessage({
                                id: ft.data.id,
                                payload: bt,
                                status: "success"
                            })
                        }, function() {
                            it.postMessage({
                                id: ft.data.id,
                                status: "error"
                            })
                        })
                }),
                rt.onmessage = function(ut) {
                    var ft = ut.data
                      , ht = ft.id
                      , gt = et[ht];
                    et[ht] = null,
                    ft.status === "success" ? gt.onComplete(ft.payload) : gt.onError && gt.onError()
                }
                )
            }
            function ot(ut, ft) {
                _e += 1;
                var ht = "processId_" + _e;
                return et[ht] = {
                    onComplete: ut,
                    onError: ft
                },
                ht
            }
            function lt(ut, ft, ht) {
                at();
                var gt = ot(ft, ht);
                rt.postMessage({
                    type: "loadAnimation",
                    path: ut,
                    fullPath: window.location.origin + window.location.pathname,
                    id: gt
                })
            }
            function dt(ut, ft, ht) {
                at();
                var gt = ot(ft, ht);
                rt.postMessage({
                    type: "loadData",
                    path: ut,
                    fullPath: window.location.origin + window.location.pathname,
                    id: gt
                })
            }
            function ct(ut, ft, ht) {
                at();
                var gt = ot(ft, ht);
                rt.postMessage({
                    type: "complete",
                    animation: ut,
                    id: gt
                })
            }
            return {
                loadAnimation: lt,
                loadData: dt,
                completeAnimation: ct
            }
        }()
          , ImagePreloader = function() {
            var _e = function() {
                var pt = createTag("canvas");
                pt.width = 1,
                pt.height = 1;
                var mt = pt.getContext("2d");
                return mt.fillStyle = "rgba(0,0,0,0)",
                mt.fillRect(0, 0, 1, 1),
                pt
            }();
            function et() {
                this.loadedAssets += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function tt() {
                this.loadedFootagesCount += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function rt(pt, mt, yt) {
                var vt = "";
                if (pt.e)
                    vt = pt.p;
                else if (mt) {
                    var wt = pt.p;
                    wt.indexOf("images/") !== -1 && (wt = wt.split("/")[1]),
                    vt = mt + wt
                } else
                    vt = yt,
                    vt += pt.u ? pt.u : "",
                    vt += pt.p;
                return vt
            }
            function nt(pt) {
                var mt = 0
                  , yt = setInterval((function() {
                    var vt = pt.getBBox();
                    (vt.width || mt > 500) && (this._imageLoaded(),
                    clearInterval(yt)),
                    mt += 1
                }
                ).bind(this), 50)
            }
            function it(pt) {
                var mt = rt(pt, this.assetsPath, this.path)
                  , yt = createNS("image");
                isSafari ? this.testImageLoaded(yt) : yt.addEventListener("load", this._imageLoaded, !1),
                yt.addEventListener("error", (function() {
                    vt.img = _e,
                    this._imageLoaded()
                }
                ).bind(this), !1),
                yt.setAttributeNS("http://www.w3.org/1999/xlink", "href", mt),
                this._elementHelper.append ? this._elementHelper.append(yt) : this._elementHelper.appendChild(yt);
                var vt = {
                    img: yt,
                    assetData: pt
                };
                return vt
            }
            function st(pt) {
                var mt = rt(pt, this.assetsPath, this.path)
                  , yt = createTag("img");
                yt.crossOrigin = "anonymous",
                yt.addEventListener("load", this._imageLoaded, !1),
                yt.addEventListener("error", (function() {
                    vt.img = _e,
                    this._imageLoaded()
                }
                ).bind(this), !1),
                yt.src = mt;
                var vt = {
                    img: yt,
                    assetData: pt
                };
                return vt
            }
            function at(pt) {
                var mt = {
                    assetData: pt
                }
                  , yt = rt(pt, this.assetsPath, this.path);
                return dataManager.loadData(yt, (function(vt) {
                    mt.img = vt,
                    this._footageLoaded()
                }
                ).bind(this), (function() {
                    mt.img = {},
                    this._footageLoaded()
                }
                ).bind(this)),
                mt
            }
            function ot(pt, mt) {
                this.imagesLoadedCb = mt;
                var yt, vt = pt.length;
                for (yt = 0; yt < vt; yt += 1)
                    pt[yt].layers || (!pt[yt].t || pt[yt].t === "seq" ? (this.totalImages += 1,
                    this.images.push(this._createImageData(pt[yt]))) : pt[yt].t === 3 && (this.totalFootages += 1,
                    this.images.push(this.createFootageData(pt[yt]))))
            }
            function lt(pt) {
                this.path = pt || ""
            }
            function dt(pt) {
                this.assetsPath = pt || ""
            }
            function ct(pt) {
                for (var mt = 0, yt = this.images.length; mt < yt; ) {
                    if (this.images[mt].assetData === pt)
                        return this.images[mt].img;
                    mt += 1
                }
                return null
            }
            function ut() {
                this.imagesLoadedCb = null,
                this.images.length = 0
            }
            function ft() {
                return this.totalImages === this.loadedAssets
            }
            function ht() {
                return this.totalFootages === this.loadedFootagesCount
            }
            function gt(pt, mt) {
                pt === "svg" ? (this._elementHelper = mt,
                this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
            }
            function bt() {
                this._imageLoaded = et.bind(this),
                this._footageLoaded = tt.bind(this),
                this.testImageLoaded = nt.bind(this),
                this.createFootageData = at.bind(this),
                this.assetsPath = "",
                this.path = "",
                this.totalImages = 0,
                this.totalFootages = 0,
                this.loadedAssets = 0,
                this.loadedFootagesCount = 0,
                this.imagesLoadedCb = null,
                this.images = []
            }
            return bt.prototype = {
                loadAssets: ot,
                setAssetsPath: dt,
                setPath: lt,
                loadedImages: ft,
                loadedFootages: ht,
                destroy: ut,
                getAsset: ct,
                createImgData: st,
                createImageData: it,
                imageLoaded: et,
                footageLoaded: tt,
                setCacheType: gt
            },
            bt
        }();
        function BaseEvent() {}
        BaseEvent.prototype = {
            triggerEvent: function(et, tt) {
                if (this._cbs[et])
                    for (var rt = this._cbs[et], nt = 0; nt < rt.length; nt += 1)
                        rt[nt](tt)
            },
            addEventListener: function(et, tt) {
                return this._cbs[et] || (this._cbs[et] = []),
                this._cbs[et].push(tt),
                (function() {
                    this.removeEventListener(et, tt)
                }
                ).bind(this)
            },
            removeEventListener: function(et, tt) {
                if (!tt)
                    this._cbs[et] = null;
                else if (this._cbs[et]) {
                    for (var rt = 0, nt = this._cbs[et].length; rt < nt; )
                        this._cbs[et][rt] === tt && (this._cbs[et].splice(rt, 1),
                        rt -= 1,
                        nt -= 1),
                        rt += 1;
                    this._cbs[et].length || (this._cbs[et] = null)
                }
            }
        };
        var markerParser = function() {
            function _e(et) {
                for (var tt = et.split(`\r
`), rt = {}, nt, it = 0, st = 0; st < tt.length; st += 1)
                    nt = tt[st].split(":"),
                    nt.length === 2 && (rt[nt[0]] = nt[1].trim(),
                    it += 1);
                if (it === 0)
                    throw new Error;
                return rt
            }
            return function(et) {
                for (var tt = [], rt = 0; rt < et.length; rt += 1) {
                    var nt = et[rt]
                      , it = {
                        time: nt.tm,
                        duration: nt.dr
                    };
                    try {
                        it.payload = JSON.parse(et[rt].cm)
                    } catch {
                        try {
                            it.payload = _e(et[rt].cm)
                        } catch {
                            it.payload = {
                                name: et[rt].cm
                            }
                        }
                    }
                    tt.push(it)
                }
                return tt
            }
        }()
          , ProjectInterface = function() {
            function _e(et) {
                this.compositions.push(et)
            }
            return function() {
                function et(tt) {
                    for (var rt = 0, nt = this.compositions.length; rt < nt; ) {
                        if (this.compositions[rt].data && this.compositions[rt].data.nm === tt)
                            return this.compositions[rt].prepareFrame && this.compositions[rt].data.xt && this.compositions[rt].prepareFrame(this.currentFrame),
                            this.compositions[rt].compInterface;
                        rt += 1
                    }
                    return null
                }
                return et.compositions = [],
                et.currentFrame = 0,
                et.registerComposition = _e,
                et
            }
        }()
          , renderers = {}
          , registerRenderer = function(et, tt) {
            renderers[et] = tt
        };
        function getRenderer(_e) {
            return renderers[_e]
        }
        function getRegisteredRenderer() {
            if (renderers.canvas)
                return "canvas";
            for (var _e in renderers)
                if (renderers[_e])
                    return _e;
            return ""
        }
        function _typeof$4(_e) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function(tt) {
                return typeof tt
            }
            : _typeof$4 = function(tt) {
                return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
            }
            ,
            _typeof$4(_e)
        }
        var AnimationItem = function() {
            this._cbs = [],
            this.name = "",
            this.path = "",
            this.isLoaded = !1,
            this.currentFrame = 0,
            this.currentRawFrame = 0,
            this.firstFrame = 0,
            this.totalFrames = 0,
            this.frameRate = 0,
            this.frameMult = 0,
            this.playSpeed = 1,
            this.playDirection = 1,
            this.playCount = 0,
            this.animationData = {},
            this.assets = [],
            this.isPaused = !0,
            this.autoplay = !1,
            this.loop = !0,
            this.renderer = null,
            this.animationID = createElementID(),
            this.assetsPath = "",
            this.timeCompleted = 0,
            this.segmentPos = 0,
            this.isSubframeEnabled = getSubframeEnabled(),
            this.segments = [],
            this._idle = !0,
            this._completedLoop = !1,
            this.projectInterface = ProjectInterface(),
            this.imagePreloader = new ImagePreloader,
            this.audioController = audioControllerFactory(),
            this.markers = [],
            this.configAnimation = this.configAnimation.bind(this),
            this.onSetupError = this.onSetupError.bind(this),
            this.onSegmentComplete = this.onSegmentComplete.bind(this),
            this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame",0,0,0),
            this.expressionsPlugin = getExpressionsPlugin()
        };
        extendPrototype([BaseEvent], AnimationItem),
        AnimationItem.prototype.setParams = function(_e) {
            (_e.wrapper || _e.container) && (this.wrapper = _e.wrapper || _e.container);
            var et = "svg";
            _e.animType ? et = _e.animType : _e.renderer && (et = _e.renderer);
            var tt = getRenderer(et);
            this.renderer = new tt(this,_e.rendererSettings),
            this.imagePreloader.setCacheType(et, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            this.animType = et,
            _e.loop === "" || _e.loop === null || _e.loop === void 0 || _e.loop === !0 ? this.loop = !0 : _e.loop === !1 ? this.loop = !1 : this.loop = parseInt(_e.loop, 10),
            this.autoplay = "autoplay"in _e ? _e.autoplay : !0,
            this.name = _e.name ? _e.name : "",
            this.autoloadSegments = Object.prototype.hasOwnProperty.call(_e, "autoloadSegments") ? _e.autoloadSegments : !0,
            this.assetsPath = _e.assetsPath,
            this.initialSegment = _e.initialSegment,
            _e.audioFactory && this.audioController.setAudioFactory(_e.audioFactory),
            _e.animationData ? this.setupAnimation(_e.animationData) : _e.path && (_e.path.lastIndexOf("\\") !== -1 ? this.path = _e.path.substr(0, _e.path.lastIndexOf("\\") + 1) : this.path = _e.path.substr(0, _e.path.lastIndexOf("/") + 1),
            this.fileName = _e.path.substr(_e.path.lastIndexOf("/") + 1),
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")),
            dataManager.loadAnimation(_e.path, this.configAnimation, this.onSetupError))
        }
        ,
        AnimationItem.prototype.onSetupError = function() {
            this.trigger("data_failed")
        }
        ,
        AnimationItem.prototype.setupAnimation = function(_e) {
            dataManager.completeAnimation(_e, this.configAnimation)
        }
        ,
        AnimationItem.prototype.setData = function(_e, et) {
            et && _typeof$4(et) !== "object" && (et = JSON.parse(et));
            var tt = {
                wrapper: _e,
                animationData: et
            }
              , rt = _e.attributes;
            tt.path = rt.getNamedItem("data-animation-path") ? rt.getNamedItem("data-animation-path").value : rt.getNamedItem("data-bm-path") ? rt.getNamedItem("data-bm-path").value : rt.getNamedItem("bm-path") ? rt.getNamedItem("bm-path").value : "",
            tt.animType = rt.getNamedItem("data-anim-type") ? rt.getNamedItem("data-anim-type").value : rt.getNamedItem("data-bm-type") ? rt.getNamedItem("data-bm-type").value : rt.getNamedItem("bm-type") ? rt.getNamedItem("bm-type").value : rt.getNamedItem("data-bm-renderer") ? rt.getNamedItem("data-bm-renderer").value : rt.getNamedItem("bm-renderer") ? rt.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
            var nt = rt.getNamedItem("data-anim-loop") ? rt.getNamedItem("data-anim-loop").value : rt.getNamedItem("data-bm-loop") ? rt.getNamedItem("data-bm-loop").value : rt.getNamedItem("bm-loop") ? rt.getNamedItem("bm-loop").value : "";
            nt === "false" ? tt.loop = !1 : nt === "true" ? tt.loop = !0 : nt !== "" && (tt.loop = parseInt(nt, 10));
            var it = rt.getNamedItem("data-anim-autoplay") ? rt.getNamedItem("data-anim-autoplay").value : rt.getNamedItem("data-bm-autoplay") ? rt.getNamedItem("data-bm-autoplay").value : rt.getNamedItem("bm-autoplay") ? rt.getNamedItem("bm-autoplay").value : !0;
            tt.autoplay = it !== "false",
            tt.name = rt.getNamedItem("data-name") ? rt.getNamedItem("data-name").value : rt.getNamedItem("data-bm-name") ? rt.getNamedItem("data-bm-name").value : rt.getNamedItem("bm-name") ? rt.getNamedItem("bm-name").value : "";
            var st = rt.getNamedItem("data-anim-prerender") ? rt.getNamedItem("data-anim-prerender").value : rt.getNamedItem("data-bm-prerender") ? rt.getNamedItem("data-bm-prerender").value : rt.getNamedItem("bm-prerender") ? rt.getNamedItem("bm-prerender").value : "";
            st === "false" && (tt.prerender = !1),
            tt.path ? this.setParams(tt) : this.trigger("destroy")
        }
        ,
        AnimationItem.prototype.includeLayers = function(_e) {
            _e.op > this.animationData.op && (this.animationData.op = _e.op,
            this.totalFrames = Math.floor(_e.op - this.animationData.ip));
            var et = this.animationData.layers, tt, rt = et.length, nt = _e.layers, it, st = nt.length;
            for (it = 0; it < st; it += 1)
                for (tt = 0; tt < rt; ) {
                    if (et[tt].id === nt[it].id) {
                        et[tt] = nt[it];
                        break
                    }
                    tt += 1
                }
            if ((_e.chars || _e.fonts) && (this.renderer.globalData.fontManager.addChars(_e.chars),
            this.renderer.globalData.fontManager.addFonts(_e.fonts, this.renderer.globalData.defs)),
            _e.assets)
                for (rt = _e.assets.length,
                tt = 0; tt < rt; tt += 1)
                    this.animationData.assets.push(_e.assets[tt]);
            this.animationData.__complete = !1,
            dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
        }
        ,
        AnimationItem.prototype.onSegmentComplete = function(_e) {
            this.animationData = _e;
            var et = getExpressionsPlugin();
            et && et.initExpressions(this),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.loadNextSegment = function() {
            var _e = this.animationData.segments;
            if (!_e || _e.length === 0 || !this.autoloadSegments) {
                this.trigger("data_ready"),
                this.timeCompleted = this.totalFrames;
                return
            }
            var et = _e.shift();
            this.timeCompleted = et.time * this.frameRate;
            var tt = this.path + this.fileName + "_" + this.segmentPos + ".json";
            this.segmentPos += 1,
            dataManager.loadData(tt, this.includeLayers.bind(this), (function() {
                this.trigger("data_failed")
            }
            ).bind(this))
        }
        ,
        AnimationItem.prototype.loadSegments = function() {
            var _e = this.animationData.segments;
            _e || (this.timeCompleted = this.totalFrames),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.imagesLoaded = function() {
            this.trigger("loaded_images"),
            this.checkLoaded()
        }
        ,
        AnimationItem.prototype.preloadImages = function() {
            this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
        }
        ,
        AnimationItem.prototype.configAnimation = function(_e) {
            if (this.renderer)
                try {
                    this.animationData = _e,
                    this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]),
                    this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip),
                    this.firstFrame = Math.round(this.animationData.ip)),
                    this.renderer.configAnimation(_e),
                    _e.assets || (_e.assets = []),
                    this.assets = this.animationData.assets,
                    this.frameRate = this.animationData.fr,
                    this.frameMult = this.animationData.fr / 1e3,
                    this.renderer.searchExtraCompositions(_e.assets),
                    this.markers = markerParser(_e.markers || []),
                    this.trigger("config_ready"),
                    this.preloadImages(),
                    this.loadSegments(),
                    this.updaFrameModifier(),
                    this.waitForFontsLoaded(),
                    this.isPaused && this.audioController.pause()
                } catch (et) {
                    this.triggerConfigError(et)
                }
        }
        ,
        AnimationItem.prototype.waitForFontsLoaded = function() {
            this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
        }
        ,
        AnimationItem.prototype.checkLoaded = function() {
            if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
                this.isLoaded = !0;
                var _e = getExpressionsPlugin();
                _e && _e.initExpressions(this),
                this.renderer.initItems(),
                setTimeout((function() {
                    this.trigger("DOMLoaded")
                }
                ).bind(this), 0),
                this.gotoFrame(),
                this.autoplay && this.play()
            }
        }
        ,
        AnimationItem.prototype.resize = function(_e, et) {
            var tt = typeof _e == "number" ? _e : void 0
              , rt = typeof et == "number" ? et : void 0;
            this.renderer.updateContainerSize(tt, rt)
        }
        ,
        AnimationItem.prototype.setSubframe = function(_e) {
            this.isSubframeEnabled = !!_e
        }
        ,
        AnimationItem.prototype.gotoFrame = function() {
            this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame,
            this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame")
        }
        ,
        AnimationItem.prototype.renderFrame = function() {
            if (!(this.isLoaded === !1 || !this.renderer))
                try {
                    this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                    this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                } catch (_e) {
                    this.triggerRenderFrameError(_e)
                }
        }
        ,
        AnimationItem.prototype.play = function(_e) {
            _e && this.name !== _e || this.isPaused === !0 && (this.isPaused = !1,
            this.trigger("_play"),
            this.audioController.resume(),
            this._idle && (this._idle = !1,
            this.trigger("_active")))
        }
        ,
        AnimationItem.prototype.pause = function(_e) {
            _e && this.name !== _e || this.isPaused === !1 && (this.isPaused = !0,
            this.trigger("_pause"),
            this._idle = !0,
            this.trigger("_idle"),
            this.audioController.pause())
        }
        ,
        AnimationItem.prototype.togglePause = function(_e) {
            _e && this.name !== _e || (this.isPaused === !0 ? this.play() : this.pause())
        }
        ,
        AnimationItem.prototype.stop = function(_e) {
            _e && this.name !== _e || (this.pause(),
            this.playCount = 0,
            this._completedLoop = !1,
            this.setCurrentRawFrameValue(0))
        }
        ,
        AnimationItem.prototype.getMarkerData = function(_e) {
            for (var et, tt = 0; tt < this.markers.length; tt += 1)
                if (et = this.markers[tt],
                et.payload && et.payload.name === _e)
                    return et;
            return null
        }
        ,
        AnimationItem.prototype.goToAndStop = function(_e, et, tt) {
            if (!(tt && this.name !== tt)) {
                var rt = Number(_e);
                if (isNaN(rt)) {
                    var nt = this.getMarkerData(_e);
                    nt && this.goToAndStop(nt.time, !0)
                } else
                    et ? this.setCurrentRawFrameValue(_e) : this.setCurrentRawFrameValue(_e * this.frameModifier);
                this.pause()
            }
        }
        ,
        AnimationItem.prototype.goToAndPlay = function(_e, et, tt) {
            if (!(tt && this.name !== tt)) {
                var rt = Number(_e);
                if (isNaN(rt)) {
                    var nt = this.getMarkerData(_e);
                    nt && (nt.duration ? this.playSegments([nt.time, nt.time + nt.duration], !0) : this.goToAndStop(nt.time, !0))
                } else
                    this.goToAndStop(rt, et, tt);
                this.play()
            }
        }
        ,
        AnimationItem.prototype.advanceTime = function(_e) {
            if (!(this.isPaused === !0 || this.isLoaded === !1)) {
                var et = this.currentRawFrame + _e * this.frameModifier
                  , tt = !1;
                et >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(et > this.totalFrames ? et % this.totalFrames : 0) || (tt = !0,
                et = this.totalFrames - 1) : et >= this.totalFrames ? (this.playCount += 1,
                this.checkSegments(et % this.totalFrames) || (this.setCurrentRawFrameValue(et % this.totalFrames),
                this._completedLoop = !0,
                this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(et) : et < 0 ? this.checkSegments(et % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + et % this.totalFrames),
                this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (tt = !0,
                et = 0)) : this.setCurrentRawFrameValue(et),
                tt && (this.setCurrentRawFrameValue(et),
                this.pause(),
                this.trigger("complete"))
            }
        }
        ,
        AnimationItem.prototype.adjustSegment = function(_e, et) {
            this.playCount = 0,
            _e[1] < _e[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)),
            this.totalFrames = _e[0] - _e[1],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = _e[1],
            this.setCurrentRawFrameValue(this.totalFrames - .001 - et)) : _e[1] > _e[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)),
            this.totalFrames = _e[1] - _e[0],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = _e[0],
            this.setCurrentRawFrameValue(.001 + et)),
            this.trigger("segmentStart")
        }
        ,
        AnimationItem.prototype.setSegment = function(_e, et) {
            var tt = -1;
            this.isPaused && (this.currentRawFrame + this.firstFrame < _e ? tt = _e : this.currentRawFrame + this.firstFrame > et && (tt = et - _e)),
            this.firstFrame = _e,
            this.totalFrames = et - _e,
            this.timeCompleted = this.totalFrames,
            tt !== -1 && this.goToAndStop(tt, !0)
        }
        ,
        AnimationItem.prototype.playSegments = function(_e, et) {
            if (et && (this.segments.length = 0),
            _typeof$4(_e[0]) === "object") {
                var tt, rt = _e.length;
                for (tt = 0; tt < rt; tt += 1)
                    this.segments.push(_e[tt])
            } else
                this.segments.push(_e);
            this.segments.length && et && this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play()
        }
        ,
        AnimationItem.prototype.resetSegments = function(_e) {
            this.segments.length = 0,
            this.segments.push([this.animationData.ip, this.animationData.op]),
            _e && this.checkSegments(0)
        }
        ,
        AnimationItem.prototype.checkSegments = function(_e) {
            return this.segments.length ? (this.adjustSegment(this.segments.shift(), _e),
            !0) : !1
        }
        ,
        AnimationItem.prototype.destroy = function(_e) {
            _e && this.name !== _e || !this.renderer || (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            this._cbs = null,
            this.onEnterFrame = null,
            this.onLoopComplete = null,
            this.onComplete = null,
            this.onSegmentStart = null,
            this.onDestroy = null,
            this.renderer = null,
            this.expressionsPlugin = null,
            this.imagePreloader = null,
            this.projectInterface = null)
        }
        ,
        AnimationItem.prototype.setCurrentRawFrameValue = function(_e) {
            this.currentRawFrame = _e,
            this.gotoFrame()
        }
        ,
        AnimationItem.prototype.setSpeed = function(_e) {
            this.playSpeed = _e,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setDirection = function(_e) {
            this.playDirection = _e < 0 ? -1 : 1,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setLoop = function(_e) {
            this.loop = _e
        }
        ,
        AnimationItem.prototype.setVolume = function(_e, et) {
            et && this.name !== et || this.audioController.setVolume(_e)
        }
        ,
        AnimationItem.prototype.getVolume = function() {
            return this.audioController.getVolume()
        }
        ,
        AnimationItem.prototype.mute = function(_e) {
            _e && this.name !== _e || this.audioController.mute()
        }
        ,
        AnimationItem.prototype.unmute = function(_e) {
            _e && this.name !== _e || this.audioController.unmute()
        }
        ,
        AnimationItem.prototype.updaFrameModifier = function() {
            this.frameModifier = this.frameMult * this.playSpeed * this.playDirection,
            this.audioController.setRate(this.playSpeed * this.playDirection)
        }
        ,
        AnimationItem.prototype.getPath = function() {
            return this.path
        }
        ,
        AnimationItem.prototype.getAssetsPath = function(_e) {
            var et = "";
            if (_e.e)
                et = _e.p;
            else if (this.assetsPath) {
                var tt = _e.p;
                tt.indexOf("images/") !== -1 && (tt = tt.split("/")[1]),
                et = this.assetsPath + tt
            } else
                et = this.path,
                et += _e.u ? _e.u : "",
                et += _e.p;
            return et
        }
        ,
        AnimationItem.prototype.getAssetData = function(_e) {
            for (var et = 0, tt = this.assets.length; et < tt; ) {
                if (_e === this.assets[et].id)
                    return this.assets[et];
                et += 1
            }
            return null
        }
        ,
        AnimationItem.prototype.hide = function() {
            this.renderer.hide()
        }
        ,
        AnimationItem.prototype.show = function() {
            this.renderer.show()
        }
        ,
        AnimationItem.prototype.getDuration = function(_e) {
            return _e ? this.totalFrames : this.totalFrames / this.frameRate
        }
        ,
        AnimationItem.prototype.updateDocumentData = function(_e, et, tt) {
            try {
                var rt = this.renderer.getElementByPath(_e);
                rt.updateDocumentData(et, tt)
            } catch {}
        }
        ,
        AnimationItem.prototype.trigger = function(_e) {
            if (this._cbs && this._cbs[_e])
                switch (_e) {
                case "enterFrame":
                    this.triggerEvent(_e, new BMEnterFrameEvent(_e,this.currentFrame,this.totalFrames,this.frameModifier));
                    break;
                case "drawnFrame":
                    this.drawnFrameEvent.currentTime = this.currentFrame,
                    this.drawnFrameEvent.totalTime = this.totalFrames,
                    this.drawnFrameEvent.direction = this.frameModifier,
                    this.triggerEvent(_e, this.drawnFrameEvent);
                    break;
                case "loopComplete":
                    this.triggerEvent(_e, new BMCompleteLoopEvent(_e,this.loop,this.playCount,this.frameMult));
                    break;
                case "complete":
                    this.triggerEvent(_e, new BMCompleteEvent(_e,this.frameMult));
                    break;
                case "segmentStart":
                    this.triggerEvent(_e, new BMSegmentStartEvent(_e,this.firstFrame,this.totalFrames));
                    break;
                case "destroy":
                    this.triggerEvent(_e, new BMDestroyEvent(_e,this));
                    break;
                default:
                    this.triggerEvent(_e)
                }
            _e === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(_e,this.currentFrame,this.totalFrames,this.frameMult)),
            _e === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(_e,this.loop,this.playCount,this.frameMult)),
            _e === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(_e,this.frameMult)),
            _e === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(_e,this.firstFrame,this.totalFrames)),
            _e === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(_e,this))
        }
        ,
        AnimationItem.prototype.triggerRenderFrameError = function(_e) {
            var et = new BMRenderFrameErrorEvent(_e,this.currentFrame);
            this.triggerEvent("error", et),
            this.onError && this.onError.call(this, et)
        }
        ,
        AnimationItem.prototype.triggerConfigError = function(_e) {
            var et = new BMConfigErrorEvent(_e,this.currentFrame);
            this.triggerEvent("error", et),
            this.onError && this.onError.call(this, et)
        }
        ;
        var animationManager = function() {
            var _e = {}
              , et = []
              , tt = 0
              , rt = 0
              , nt = 0
              , it = !0
              , st = !1;
            function at($t) {
                for (var kt = 0, At = $t.target; kt < rt; )
                    et[kt].animation === At && (et.splice(kt, 1),
                    kt -= 1,
                    rt -= 1,
                    At.isPaused || ct()),
                    kt += 1
            }
            function ot($t, kt) {
                if (!$t)
                    return null;
                for (var At = 0; At < rt; ) {
                    if (et[At].elem === $t && et[At].elem !== null)
                        return et[At].animation;
                    At += 1
                }
                var Pt = new AnimationItem;
                return ut(Pt, $t),
                Pt.setData($t, kt),
                Pt
            }
            function lt() {
                var $t, kt = et.length, At = [];
                for ($t = 0; $t < kt; $t += 1)
                    At.push(et[$t].animation);
                return At
            }
            function dt() {
                nt += 1,
                Tt()
            }
            function ct() {
                nt -= 1
            }
            function ut($t, kt) {
                $t.addEventListener("destroy", at),
                $t.addEventListener("_active", dt),
                $t.addEventListener("_idle", ct),
                et.push({
                    elem: kt,
                    animation: $t
                }),
                rt += 1
            }
            function ft($t) {
                var kt = new AnimationItem;
                return ut(kt, null),
                kt.setParams($t),
                kt
            }
            function ht($t, kt) {
                var At;
                for (At = 0; At < rt; At += 1)
                    et[At].animation.setSpeed($t, kt)
            }
            function gt($t, kt) {
                var At;
                for (At = 0; At < rt; At += 1)
                    et[At].animation.setDirection($t, kt)
            }
            function bt($t) {
                var kt;
                for (kt = 0; kt < rt; kt += 1)
                    et[kt].animation.play($t)
            }
            function pt($t) {
                var kt = $t - tt, At;
                for (At = 0; At < rt; At += 1)
                    et[At].animation.advanceTime(kt);
                tt = $t,
                nt && !st ? window.requestAnimationFrame(pt) : it = !0
            }
            function mt($t) {
                tt = $t,
                window.requestAnimationFrame(pt)
            }
            function yt($t) {
                var kt;
                for (kt = 0; kt < rt; kt += 1)
                    et[kt].animation.pause($t)
            }
            function vt($t, kt, At) {
                var Pt;
                for (Pt = 0; Pt < rt; Pt += 1)
                    et[Pt].animation.goToAndStop($t, kt, At)
            }
            function wt($t) {
                var kt;
                for (kt = 0; kt < rt; kt += 1)
                    et[kt].animation.stop($t)
            }
            function _t($t) {
                var kt;
                for (kt = 0; kt < rt; kt += 1)
                    et[kt].animation.togglePause($t)
            }
            function Et($t) {
                var kt;
                for (kt = rt - 1; kt >= 0; kt -= 1)
                    et[kt].animation.destroy($t)
            }
            function xt($t, kt, At) {
                var Pt = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), Dt, Bt = Pt.length;
                for (Dt = 0; Dt < Bt; Dt += 1)
                    At && Pt[Dt].setAttribute("data-bm-type", At),
                    ot(Pt[Dt], $t);
                if (kt && Bt === 0) {
                    At || (At = "svg");
                    var zt = document.getElementsByTagName("body")[0];
                    zt.innerText = "";
                    var Yt = createTag("div");
                    Yt.style.width = "100%",
                    Yt.style.height = "100%",
                    Yt.setAttribute("data-bm-type", At),
                    zt.appendChild(Yt),
                    ot(Yt, $t)
                }
            }
            function Ct() {
                var $t;
                for ($t = 0; $t < rt; $t += 1)
                    et[$t].animation.resize()
            }
            function Tt() {
                !st && nt && it && (window.requestAnimationFrame(mt),
                it = !1)
            }
            function It() {
                st = !0
            }
            function Nt() {
                st = !1,
                Tt()
            }
            function Ft($t, kt) {
                var At;
                for (At = 0; At < rt; At += 1)
                    et[At].animation.setVolume($t, kt)
            }
            function Lt($t) {
                var kt;
                for (kt = 0; kt < rt; kt += 1)
                    et[kt].animation.mute($t)
            }
            function Mt($t) {
                var kt;
                for (kt = 0; kt < rt; kt += 1)
                    et[kt].animation.unmute($t)
            }
            return _e.registerAnimation = ot,
            _e.loadAnimation = ft,
            _e.setSpeed = ht,
            _e.setDirection = gt,
            _e.play = bt,
            _e.pause = yt,
            _e.stop = wt,
            _e.togglePause = _t,
            _e.searchAnimations = xt,
            _e.resize = Ct,
            _e.goToAndStop = vt,
            _e.destroy = Et,
            _e.freeze = It,
            _e.unfreeze = Nt,
            _e.setVolume = Ft,
            _e.mute = Lt,
            _e.unmute = Mt,
            _e.getRegisteredAnimations = lt,
            _e
        }()
          , BezierFactory = function() {
            var _e = {};
            _e.getBezierEasing = tt;
            var et = {};
            function tt(mt, yt, vt, wt, _t) {
                var Et = _t || ("bez_" + mt + "_" + yt + "_" + vt + "_" + wt).replace(/\./g, "p");
                if (et[Et])
                    return et[Et];
                var xt = new pt([mt, yt, vt, wt]);
                return et[Et] = xt,
                xt
            }
            var rt = 4
              , nt = .001
              , it = 1e-7
              , st = 10
              , at = 11
              , ot = 1 / (at - 1)
              , lt = typeof Float32Array == "function";
            function dt(mt, yt) {
                return 1 - 3 * yt + 3 * mt
            }
            function ct(mt, yt) {
                return 3 * yt - 6 * mt
            }
            function ut(mt) {
                return 3 * mt
            }
            function ft(mt, yt, vt) {
                return ((dt(yt, vt) * mt + ct(yt, vt)) * mt + ut(yt)) * mt
            }
            function ht(mt, yt, vt) {
                return 3 * dt(yt, vt) * mt * mt + 2 * ct(yt, vt) * mt + ut(yt)
            }
            function gt(mt, yt, vt, wt, _t) {
                var Et, xt, Ct = 0;
                do
                    xt = yt + (vt - yt) / 2,
                    Et = ft(xt, wt, _t) - mt,
                    Et > 0 ? vt = xt : yt = xt;
                while (Math.abs(Et) > it && ++Ct < st);
                return xt
            }
            function bt(mt, yt, vt, wt) {
                for (var _t = 0; _t < rt; ++_t) {
                    var Et = ht(yt, vt, wt);
                    if (Et === 0)
                        return yt;
                    var xt = ft(yt, vt, wt) - mt;
                    yt -= xt / Et
                }
                return yt
            }
            function pt(mt) {
                this._p = mt,
                this._mSampleValues = lt ? new Float32Array(at) : new Array(at),
                this._precomputed = !1,
                this.get = this.get.bind(this)
            }
            return pt.prototype = {
                get: function(yt) {
                    var vt = this._p[0]
                      , wt = this._p[1]
                      , _t = this._p[2]
                      , Et = this._p[3];
                    return this._precomputed || this._precompute(),
                    vt === wt && _t === Et ? yt : yt === 0 ? 0 : yt === 1 ? 1 : ft(this._getTForX(yt), wt, Et)
                },
                _precompute: function() {
                    var yt = this._p[0]
                      , vt = this._p[1]
                      , wt = this._p[2]
                      , _t = this._p[3];
                    this._precomputed = !0,
                    (yt !== vt || wt !== _t) && this._calcSampleValues()
                },
                _calcSampleValues: function() {
                    for (var yt = this._p[0], vt = this._p[2], wt = 0; wt < at; ++wt)
                        this._mSampleValues[wt] = ft(wt * ot, yt, vt)
                },
                _getTForX: function(yt) {
                    for (var vt = this._p[0], wt = this._p[2], _t = this._mSampleValues, Et = 0, xt = 1, Ct = at - 1; xt !== Ct && _t[xt] <= yt; ++xt)
                        Et += ot;
                    --xt;
                    var Tt = (yt - _t[xt]) / (_t[xt + 1] - _t[xt])
                      , It = Et + Tt * ot
                      , Nt = ht(It, vt, wt);
                    return Nt >= nt ? bt(yt, It, vt, wt) : Nt === 0 ? It : gt(yt, Et, Et + ot, vt, wt)
                }
            },
            _e
        }()
          , pooling = function() {
            function _e(et) {
                return et.concat(createSizedArray(et.length))
            }
            return {
                double: _e
            }
        }()
          , poolFactory = function() {
            return function(_e, et, tt) {
                var rt = 0
                  , nt = _e
                  , it = createSizedArray(nt)
                  , st = {
                    newElement: at,
                    release: ot
                };
                function at() {
                    var lt;
                    return rt ? (rt -= 1,
                    lt = it[rt]) : lt = et(),
                    lt
                }
                function ot(lt) {
                    rt === nt && (it = pooling.double(it),
                    nt *= 2),
                    tt && tt(lt),
                    it[rt] = lt,
                    rt += 1
                }
                return st
            }
        }()
          , bezierLengthPool = function() {
            function _e() {
                return {
                    addedLength: 0,
                    percents: createTypedArray("float32", getDefaultCurveSegments()),
                    lengths: createTypedArray("float32", getDefaultCurveSegments())
                }
            }
            return poolFactory(8, _e)
        }()
          , segmentsLengthPool = function() {
            function _e() {
                return {
                    lengths: [],
                    totalLength: 0
                }
            }
            function et(tt) {
                var rt, nt = tt.lengths.length;
                for (rt = 0; rt < nt; rt += 1)
                    bezierLengthPool.release(tt.lengths[rt]);
                tt.lengths.length = 0
            }
            return poolFactory(8, _e, et)
        }();
        function bezFunction() {
            var _e = Math;
            function et(ut, ft, ht, gt, bt, pt) {
                var mt = ut * gt + ft * bt + ht * pt - bt * gt - pt * ut - ht * ft;
                return mt > -.001 && mt < .001
            }
            function tt(ut, ft, ht, gt, bt, pt, mt, yt, vt) {
                if (ht === 0 && pt === 0 && vt === 0)
                    return et(ut, ft, gt, bt, mt, yt);
                var wt = _e.sqrt(_e.pow(gt - ut, 2) + _e.pow(bt - ft, 2) + _e.pow(pt - ht, 2)), _t = _e.sqrt(_e.pow(mt - ut, 2) + _e.pow(yt - ft, 2) + _e.pow(vt - ht, 2)), Et = _e.sqrt(_e.pow(mt - gt, 2) + _e.pow(yt - bt, 2) + _e.pow(vt - pt, 2)), xt;
                return wt > _t ? wt > Et ? xt = wt - _t - Et : xt = Et - _t - wt : Et > _t ? xt = Et - _t - wt : xt = _t - wt - Et,
                xt > -1e-4 && xt < 1e-4
            }
            var rt = function() {
                return function(ut, ft, ht, gt) {
                    var bt = getDefaultCurveSegments(), pt, mt, yt, vt, wt, _t = 0, Et, xt = [], Ct = [], Tt = bezierLengthPool.newElement();
                    for (yt = ht.length,
                    pt = 0; pt < bt; pt += 1) {
                        for (wt = pt / (bt - 1),
                        Et = 0,
                        mt = 0; mt < yt; mt += 1)
                            vt = bmPow(1 - wt, 3) * ut[mt] + 3 * bmPow(1 - wt, 2) * wt * ht[mt] + 3 * (1 - wt) * bmPow(wt, 2) * gt[mt] + bmPow(wt, 3) * ft[mt],
                            xt[mt] = vt,
                            Ct[mt] !== null && (Et += bmPow(xt[mt] - Ct[mt], 2)),
                            Ct[mt] = xt[mt];
                        Et && (Et = bmSqrt(Et),
                        _t += Et),
                        Tt.percents[pt] = wt,
                        Tt.lengths[pt] = _t
                    }
                    return Tt.addedLength = _t,
                    Tt
                }
            }();
            function nt(ut) {
                var ft = segmentsLengthPool.newElement(), ht = ut.c, gt = ut.v, bt = ut.o, pt = ut.i, mt, yt = ut._length, vt = ft.lengths, wt = 0;
                for (mt = 0; mt < yt - 1; mt += 1)
                    vt[mt] = rt(gt[mt], gt[mt + 1], bt[mt], pt[mt + 1]),
                    wt += vt[mt].addedLength;
                return ht && yt && (vt[mt] = rt(gt[mt], gt[0], bt[mt], pt[0]),
                wt += vt[mt].addedLength),
                ft.totalLength = wt,
                ft
            }
            function it(ut) {
                this.segmentLength = 0,
                this.points = new Array(ut)
            }
            function st(ut, ft) {
                this.partialLength = ut,
                this.point = ft
            }
            var at = function() {
                var ut = {};
                return function(ft, ht, gt, bt) {
                    var pt = (ft[0] + "_" + ft[1] + "_" + ht[0] + "_" + ht[1] + "_" + gt[0] + "_" + gt[1] + "_" + bt[0] + "_" + bt[1]).replace(/\./g, "p");
                    if (!ut[pt]) {
                        var mt = getDefaultCurveSegments(), yt, vt, wt, _t, Et, xt = 0, Ct, Tt, It = null;
                        ft.length === 2 && (ft[0] !== ht[0] || ft[1] !== ht[1]) && et(ft[0], ft[1], ht[0], ht[1], ft[0] + gt[0], ft[1] + gt[1]) && et(ft[0], ft[1], ht[0], ht[1], ht[0] + bt[0], ht[1] + bt[1]) && (mt = 2);
                        var Nt = new it(mt);
                        for (wt = gt.length,
                        yt = 0; yt < mt; yt += 1) {
                            for (Tt = createSizedArray(wt),
                            Et = yt / (mt - 1),
                            Ct = 0,
                            vt = 0; vt < wt; vt += 1)
                                _t = bmPow(1 - Et, 3) * ft[vt] + 3 * bmPow(1 - Et, 2) * Et * (ft[vt] + gt[vt]) + 3 * (1 - Et) * bmPow(Et, 2) * (ht[vt] + bt[vt]) + bmPow(Et, 3) * ht[vt],
                                Tt[vt] = _t,
                                It !== null && (Ct += bmPow(Tt[vt] - It[vt], 2));
                            Ct = bmSqrt(Ct),
                            xt += Ct,
                            Nt.points[yt] = new st(Ct,Tt),
                            It = Tt
                        }
                        Nt.segmentLength = xt,
                        ut[pt] = Nt
                    }
                    return ut[pt]
                }
            }();
            function ot(ut, ft) {
                var ht = ft.percents
                  , gt = ft.lengths
                  , bt = ht.length
                  , pt = bmFloor((bt - 1) * ut)
                  , mt = ut * ft.addedLength
                  , yt = 0;
                if (pt === bt - 1 || pt === 0 || mt === gt[pt])
                    return ht[pt];
                for (var vt = gt[pt] > mt ? -1 : 1, wt = !0; wt; )
                    if (gt[pt] <= mt && gt[pt + 1] > mt ? (yt = (mt - gt[pt]) / (gt[pt + 1] - gt[pt]),
                    wt = !1) : pt += vt,
                    pt < 0 || pt >= bt - 1) {
                        if (pt === bt - 1)
                            return ht[pt];
                        wt = !1
                    }
                return ht[pt] + (ht[pt + 1] - ht[pt]) * yt
            }
            function lt(ut, ft, ht, gt, bt, pt) {
                var mt = ot(bt, pt)
                  , yt = 1 - mt
                  , vt = _e.round((yt * yt * yt * ut[0] + (mt * yt * yt + yt * mt * yt + yt * yt * mt) * ht[0] + (mt * mt * yt + yt * mt * mt + mt * yt * mt) * gt[0] + mt * mt * mt * ft[0]) * 1e3) / 1e3
                  , wt = _e.round((yt * yt * yt * ut[1] + (mt * yt * yt + yt * mt * yt + yt * yt * mt) * ht[1] + (mt * mt * yt + yt * mt * mt + mt * yt * mt) * gt[1] + mt * mt * mt * ft[1]) * 1e3) / 1e3;
                return [vt, wt]
            }
            var dt = createTypedArray("float32", 8);
            function ct(ut, ft, ht, gt, bt, pt, mt) {
                bt < 0 ? bt = 0 : bt > 1 && (bt = 1);
                var yt = ot(bt, mt);
                pt = pt > 1 ? 1 : pt;
                var vt = ot(pt, mt), wt, _t = ut.length, Et = 1 - yt, xt = 1 - vt, Ct = Et * Et * Et, Tt = yt * Et * Et * 3, It = yt * yt * Et * 3, Nt = yt * yt * yt, Ft = Et * Et * xt, Lt = yt * Et * xt + Et * yt * xt + Et * Et * vt, Mt = yt * yt * xt + Et * yt * vt + yt * Et * vt, $t = yt * yt * vt, kt = Et * xt * xt, At = yt * xt * xt + Et * vt * xt + Et * xt * vt, Pt = yt * vt * xt + Et * vt * vt + yt * xt * vt, Dt = yt * vt * vt, Bt = xt * xt * xt, zt = vt * xt * xt + xt * vt * xt + xt * xt * vt, Yt = vt * vt * xt + xt * vt * vt + vt * xt * vt, rr = vt * vt * vt;
                for (wt = 0; wt < _t; wt += 1)
                    dt[wt * 4] = _e.round((Ct * ut[wt] + Tt * ht[wt] + It * gt[wt] + Nt * ft[wt]) * 1e3) / 1e3,
                    dt[wt * 4 + 1] = _e.round((Ft * ut[wt] + Lt * ht[wt] + Mt * gt[wt] + $t * ft[wt]) * 1e3) / 1e3,
                    dt[wt * 4 + 2] = _e.round((kt * ut[wt] + At * ht[wt] + Pt * gt[wt] + Dt * ft[wt]) * 1e3) / 1e3,
                    dt[wt * 4 + 3] = _e.round((Bt * ut[wt] + zt * ht[wt] + Yt * gt[wt] + rr * ft[wt]) * 1e3) / 1e3;
                return dt
            }
            return {
                getSegmentsLength: nt,
                getNewSegment: ct,
                getPointInSegment: lt,
                buildBezierData: at,
                pointOnLine2D: et,
                pointOnLine3D: tt
            }
        }
        var bez = bezFunction()
          , initFrame = initialDefaultFrame
          , mathAbs = Math.abs;
        function interpolateValue(_e, et) {
            var tt = this.offsetTime, rt;
            this.propType === "multidimensional" && (rt = createTypedArray("float32", this.pv.length));
            for (var nt = et.lastIndex, it = nt, st = this.keyframes.length - 1, at = !0, ot, lt, dt; at; ) {
                if (ot = this.keyframes[it],
                lt = this.keyframes[it + 1],
                it === st - 1 && _e >= lt.t - tt) {
                    ot.h && (ot = lt),
                    nt = 0;
                    break
                }
                if (lt.t - tt > _e) {
                    nt = it;
                    break
                }
                it < st - 1 ? it += 1 : (nt = 0,
                at = !1)
            }
            dt = this.keyframesMetadata[it] || {};
            var ct, ut, ft, ht, gt, bt, pt = lt.t - tt, mt = ot.t - tt, yt;
            if (ot.to) {
                dt.bezierData || (dt.bezierData = bez.buildBezierData(ot.s, lt.s || ot.e, ot.to, ot.ti));
                var vt = dt.bezierData;
                if (_e >= pt || _e < mt) {
                    var wt = _e >= pt ? vt.points.length - 1 : 0;
                    for (ut = vt.points[wt].point.length,
                    ct = 0; ct < ut; ct += 1)
                        rt[ct] = vt.points[wt].point[ct]
                } else {
                    dt.__fnct ? bt = dt.__fnct : (bt = BezierFactory.getBezierEasing(ot.o.x, ot.o.y, ot.i.x, ot.i.y, ot.n).get,
                    dt.__fnct = bt),
                    ft = bt((_e - mt) / (pt - mt));
                    var _t = vt.segmentLength * ft, Et, xt = et.lastFrame < _e && et._lastKeyframeIndex === it ? et._lastAddedLength : 0;
                    for (gt = et.lastFrame < _e && et._lastKeyframeIndex === it ? et._lastPoint : 0,
                    at = !0,
                    ht = vt.points.length; at; ) {
                        if (xt += vt.points[gt].partialLength,
                        _t === 0 || ft === 0 || gt === vt.points.length - 1) {
                            for (ut = vt.points[gt].point.length,
                            ct = 0; ct < ut; ct += 1)
                                rt[ct] = vt.points[gt].point[ct];
                            break
                        } else if (_t >= xt && _t < xt + vt.points[gt + 1].partialLength) {
                            for (Et = (_t - xt) / vt.points[gt + 1].partialLength,
                            ut = vt.points[gt].point.length,
                            ct = 0; ct < ut; ct += 1)
                                rt[ct] = vt.points[gt].point[ct] + (vt.points[gt + 1].point[ct] - vt.points[gt].point[ct]) * Et;
                            break
                        }
                        gt < ht - 1 ? gt += 1 : at = !1
                    }
                    et._lastPoint = gt,
                    et._lastAddedLength = xt - vt.points[gt].partialLength,
                    et._lastKeyframeIndex = it
                }
            } else {
                var Ct, Tt, It, Nt, Ft;
                if (st = ot.s.length,
                yt = lt.s || ot.e,
                this.sh && ot.h !== 1)
                    if (_e >= pt)
                        rt[0] = yt[0],
                        rt[1] = yt[1],
                        rt[2] = yt[2];
                    else if (_e <= mt)
                        rt[0] = ot.s[0],
                        rt[1] = ot.s[1],
                        rt[2] = ot.s[2];
                    else {
                        var Lt = createQuaternion(ot.s)
                          , Mt = createQuaternion(yt)
                          , $t = (_e - mt) / (pt - mt);
                        quaternionToEuler(rt, slerp(Lt, Mt, $t))
                    }
                else
                    for (it = 0; it < st; it += 1)
                        ot.h !== 1 && (_e >= pt ? ft = 1 : _e < mt ? ft = 0 : (ot.o.x.constructor === Array ? (dt.__fnct || (dt.__fnct = []),
                        dt.__fnct[it] ? bt = dt.__fnct[it] : (Ct = ot.o.x[it] === void 0 ? ot.o.x[0] : ot.o.x[it],
                        Tt = ot.o.y[it] === void 0 ? ot.o.y[0] : ot.o.y[it],
                        It = ot.i.x[it] === void 0 ? ot.i.x[0] : ot.i.x[it],
                        Nt = ot.i.y[it] === void 0 ? ot.i.y[0] : ot.i.y[it],
                        bt = BezierFactory.getBezierEasing(Ct, Tt, It, Nt).get,
                        dt.__fnct[it] = bt)) : dt.__fnct ? bt = dt.__fnct : (Ct = ot.o.x,
                        Tt = ot.o.y,
                        It = ot.i.x,
                        Nt = ot.i.y,
                        bt = BezierFactory.getBezierEasing(Ct, Tt, It, Nt).get,
                        ot.keyframeMetadata = bt),
                        ft = bt((_e - mt) / (pt - mt)))),
                        yt = lt.s || ot.e,
                        Ft = ot.h === 1 ? ot.s[it] : ot.s[it] + (yt[it] - ot.s[it]) * ft,
                        this.propType === "multidimensional" ? rt[it] = Ft : rt = Ft
            }
            return et.lastIndex = nt,
            rt
        }
        function slerp(_e, et, tt) {
            var rt = [], nt = _e[0], it = _e[1], st = _e[2], at = _e[3], ot = et[0], lt = et[1], dt = et[2], ct = et[3], ut, ft, ht, gt, bt;
            return ft = nt * ot + it * lt + st * dt + at * ct,
            ft < 0 && (ft = -ft,
            ot = -ot,
            lt = -lt,
            dt = -dt,
            ct = -ct),
            1 - ft > 1e-6 ? (ut = Math.acos(ft),
            ht = Math.sin(ut),
            gt = Math.sin((1 - tt) * ut) / ht,
            bt = Math.sin(tt * ut) / ht) : (gt = 1 - tt,
            bt = tt),
            rt[0] = gt * nt + bt * ot,
            rt[1] = gt * it + bt * lt,
            rt[2] = gt * st + bt * dt,
            rt[3] = gt * at + bt * ct,
            rt
        }
        function quaternionToEuler(_e, et) {
            var tt = et[0]
              , rt = et[1]
              , nt = et[2]
              , it = et[3]
              , st = Math.atan2(2 * rt * it - 2 * tt * nt, 1 - 2 * rt * rt - 2 * nt * nt)
              , at = Math.asin(2 * tt * rt + 2 * nt * it)
              , ot = Math.atan2(2 * tt * it - 2 * rt * nt, 1 - 2 * tt * tt - 2 * nt * nt);
            _e[0] = st / degToRads,
            _e[1] = at / degToRads,
            _e[2] = ot / degToRads
        }
        function createQuaternion(_e) {
            var et = _e[0] * degToRads
              , tt = _e[1] * degToRads
              , rt = _e[2] * degToRads
              , nt = Math.cos(et / 2)
              , it = Math.cos(tt / 2)
              , st = Math.cos(rt / 2)
              , at = Math.sin(et / 2)
              , ot = Math.sin(tt / 2)
              , lt = Math.sin(rt / 2)
              , dt = nt * it * st - at * ot * lt
              , ct = at * ot * st + nt * it * lt
              , ut = at * it * st + nt * ot * lt
              , ft = nt * ot * st - at * it * lt;
            return [ct, ut, ft, dt]
        }
        function getValueAtCurrentTime() {
            var _e = this.comp.renderedFrame - this.offsetTime
              , et = this.keyframes[0].t - this.offsetTime
              , tt = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            if (!(_e === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= tt && _e >= tt || this._caching.lastFrame < et && _e < et))) {
                this._caching.lastFrame >= _e && (this._caching._lastKeyframeIndex = -1,
                this._caching.lastIndex = 0);
                var rt = this.interpolateValue(_e, this._caching);
                this.pv = rt
            }
            return this._caching.lastFrame = _e,
            this.pv
        }
        function setVValue(_e) {
            var et;
            if (this.propType === "unidimensional")
                et = _e * this.mult,
                mathAbs(this.v - et) > 1e-5 && (this.v = et,
                this._mdf = !0);
            else
                for (var tt = 0, rt = this.v.length; tt < rt; )
                    et = _e[tt] * this.mult,
                    mathAbs(this.v[tt] - et) > 1e-5 && (this.v[tt] = et,
                    this._mdf = !0),
                    tt += 1
        }
        function processEffectsSequence() {
            if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
                if (this.lock) {
                    this.setVValue(this.pv);
                    return
                }
                this.lock = !0,
                this._mdf = this._isFirstFrame;
                var _e, et = this.effectsSequence.length, tt = this.kf ? this.pv : this.data.k;
                for (_e = 0; _e < et; _e += 1)
                    tt = this.effectsSequence[_e](tt);
                this.setVValue(tt),
                this._isFirstFrame = !1,
                this.lock = !1,
                this.frameId = this.elem.globalData.frameId
            }
        }
        function addEffect(_e) {
            this.effectsSequence.push(_e),
            this.container.addDynamicProperty(this)
        }
        function ValueProperty(_e, et, tt, rt) {
            this.propType = "unidimensional",
            this.mult = tt || 1,
            this.data = et,
            this.v = tt ? et.k * tt : et.k,
            this.pv = et.k,
            this._mdf = !1,
            this.elem = _e,
            this.container = rt,
            this.comp = _e.comp,
            this.k = !1,
            this.kf = !1,
            this.vel = 0,
            this.effectsSequence = [],
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function MultiDimensionalProperty(_e, et, tt, rt) {
            this.propType = "multidimensional",
            this.mult = tt || 1,
            this.data = et,
            this._mdf = !1,
            this.elem = _e,
            this.container = rt,
            this.comp = _e.comp,
            this.k = !1,
            this.kf = !1,
            this.frameId = -1;
            var nt, it = et.k.length;
            for (this.v = createTypedArray("float32", it),
            this.pv = createTypedArray("float32", it),
            this.vel = createTypedArray("float32", it),
            nt = 0; nt < it; nt += 1)
                this.v[nt] = et.k[nt] * this.mult,
                this.pv[nt] = et.k[nt];
            this._isFirstFrame = !0,
            this.effectsSequence = [],
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function KeyframedValueProperty(_e, et, tt, rt) {
            this.propType = "unidimensional",
            this.keyframes = et.k,
            this.keyframesMetadata = [],
            this.offsetTime = _e.data.st,
            this.frameId = -1,
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1
            },
            this.k = !0,
            this.kf = !0,
            this.data = et,
            this.mult = tt || 1,
            this.elem = _e,
            this.container = rt,
            this.comp = _e.comp,
            this.v = initFrame,
            this.pv = initFrame,
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.addEffect = addEffect
        }
        function KeyframedMultidimensionalProperty(_e, et, tt, rt) {
            this.propType = "multidimensional";
            var nt, it = et.k.length, st, at, ot, lt;
            for (nt = 0; nt < it - 1; nt += 1)
                et.k[nt].to && et.k[nt].s && et.k[nt + 1] && et.k[nt + 1].s && (st = et.k[nt].s,
                at = et.k[nt + 1].s,
                ot = et.k[nt].to,
                lt = et.k[nt].ti,
                (st.length === 2 && !(st[0] === at[0] && st[1] === at[1]) && bez.pointOnLine2D(st[0], st[1], at[0], at[1], st[0] + ot[0], st[1] + ot[1]) && bez.pointOnLine2D(st[0], st[1], at[0], at[1], at[0] + lt[0], at[1] + lt[1]) || st.length === 3 && !(st[0] === at[0] && st[1] === at[1] && st[2] === at[2]) && bez.pointOnLine3D(st[0], st[1], st[2], at[0], at[1], at[2], st[0] + ot[0], st[1] + ot[1], st[2] + ot[2]) && bez.pointOnLine3D(st[0], st[1], st[2], at[0], at[1], at[2], at[0] + lt[0], at[1] + lt[1], at[2] + lt[2])) && (et.k[nt].to = null,
                et.k[nt].ti = null),
                st[0] === at[0] && st[1] === at[1] && ot[0] === 0 && ot[1] === 0 && lt[0] === 0 && lt[1] === 0 && (st.length === 2 || st[2] === at[2] && ot[2] === 0 && lt[2] === 0) && (et.k[nt].to = null,
                et.k[nt].ti = null));
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.data = et,
            this.keyframes = et.k,
            this.keyframesMetadata = [],
            this.offsetTime = _e.data.st,
            this.k = !0,
            this.kf = !0,
            this._isFirstFrame = !0,
            this.mult = tt || 1,
            this.elem = _e,
            this.container = rt,
            this.comp = _e.comp,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.frameId = -1;
            var dt = et.k[0].s.length;
            for (this.v = createTypedArray("float32", dt),
            this.pv = createTypedArray("float32", dt),
            nt = 0; nt < dt; nt += 1)
                this.v[nt] = initFrame,
                this.pv[nt] = initFrame;
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray("float32", dt)
            },
            this.addEffect = addEffect
        }
        var PropertyFactory = function() {
            function _e(tt, rt, nt, it, st) {
                rt.sid && (rt = tt.globalData.slotManager.getProp(rt));
                var at;
                if (!rt.k.length)
                    at = new ValueProperty(tt,rt,it,st);
                else if (typeof rt.k[0] == "number")
                    at = new MultiDimensionalProperty(tt,rt,it,st);
                else
                    switch (nt) {
                    case 0:
                        at = new KeyframedValueProperty(tt,rt,it,st);
                        break;
                    case 1:
                        at = new KeyframedMultidimensionalProperty(tt,rt,it,st);
                        break
                    }
                return at.effectsSequence.length && st.addDynamicProperty(at),
                at
            }
            var et = {
                getProp: _e
            };
            return et
        }();
        function DynamicPropertyContainer() {}
        DynamicPropertyContainer.prototype = {
            addDynamicProperty: function(et) {
                this.dynamicProperties.indexOf(et) === -1 && (this.dynamicProperties.push(et),
                this.container.addDynamicProperty(this),
                this._isAnimated = !0)
            },
            iterateDynamicProperties: function() {
                this._mdf = !1;
                var et, tt = this.dynamicProperties.length;
                for (et = 0; et < tt; et += 1)
                    this.dynamicProperties[et].getValue(),
                    this.dynamicProperties[et]._mdf && (this._mdf = !0)
            },
            initDynamicPropertyContainer: function(et) {
                this.container = et,
                this.dynamicProperties = [],
                this._mdf = !1,
                this._isAnimated = !1
            }
        };
        var pointPool = function() {
            function _e() {
                return createTypedArray("float32", 2)
            }
            return poolFactory(8, _e)
        }();
        function ShapePath() {
            this.c = !1,
            this._length = 0,
            this._maxLength = 8,
            this.v = createSizedArray(this._maxLength),
            this.o = createSizedArray(this._maxLength),
            this.i = createSizedArray(this._maxLength)
        }
        ShapePath.prototype.setPathData = function(_e, et) {
            this.c = _e,
            this.setLength(et);
            for (var tt = 0; tt < et; )
                this.v[tt] = pointPool.newElement(),
                this.o[tt] = pointPool.newElement(),
                this.i[tt] = pointPool.newElement(),
                tt += 1
        }
        ,
        ShapePath.prototype.setLength = function(_e) {
            for (; this._maxLength < _e; )
                this.doubleArrayLength();
            this._length = _e
        }
        ,
        ShapePath.prototype.doubleArrayLength = function() {
            this.v = this.v.concat(createSizedArray(this._maxLength)),
            this.i = this.i.concat(createSizedArray(this._maxLength)),
            this.o = this.o.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2
        }
        ,
        ShapePath.prototype.setXYAt = function(_e, et, tt, rt, nt) {
            var it;
            switch (this._length = Math.max(this._length, rt + 1),
            this._length >= this._maxLength && this.doubleArrayLength(),
            tt) {
            case "v":
                it = this.v;
                break;
            case "i":
                it = this.i;
                break;
            case "o":
                it = this.o;
                break;
            default:
                it = [];
                break
            }
            (!it[rt] || it[rt] && !nt) && (it[rt] = pointPool.newElement()),
            it[rt][0] = _e,
            it[rt][1] = et
        }
        ,
        ShapePath.prototype.setTripleAt = function(_e, et, tt, rt, nt, it, st, at) {
            this.setXYAt(_e, et, "v", st, at),
            this.setXYAt(tt, rt, "o", st, at),
            this.setXYAt(nt, it, "i", st, at)
        }
        ,
        ShapePath.prototype.reverse = function() {
            var _e = new ShapePath;
            _e.setPathData(this.c, this._length);
            var et = this.v
              , tt = this.o
              , rt = this.i
              , nt = 0;
            this.c && (_e.setTripleAt(et[0][0], et[0][1], rt[0][0], rt[0][1], tt[0][0], tt[0][1], 0, !1),
            nt = 1);
            var it = this._length - 1, st = this._length, at;
            for (at = nt; at < st; at += 1)
                _e.setTripleAt(et[it][0], et[it][1], rt[it][0], rt[it][1], tt[it][0], tt[it][1], at, !1),
                it -= 1;
            return _e
        }
        ,
        ShapePath.prototype.length = function() {
            return this._length
        }
        ;
        var shapePool = function() {
            function _e() {
                return new ShapePath
            }
            function et(nt) {
                var it = nt._length, st;
                for (st = 0; st < it; st += 1)
                    pointPool.release(nt.v[st]),
                    pointPool.release(nt.i[st]),
                    pointPool.release(nt.o[st]),
                    nt.v[st] = null,
                    nt.i[st] = null,
                    nt.o[st] = null;
                nt._length = 0,
                nt.c = !1
            }
            function tt(nt) {
                var it = rt.newElement(), st, at = nt._length === void 0 ? nt.v.length : nt._length;
                for (it.setLength(at),
                it.c = nt.c,
                st = 0; st < at; st += 1)
                    it.setTripleAt(nt.v[st][0], nt.v[st][1], nt.o[st][0], nt.o[st][1], nt.i[st][0], nt.i[st][1], st);
                return it
            }
            var rt = poolFactory(4, _e, et);
            return rt.clone = tt,
            rt
        }();
        function ShapeCollection() {
            this._length = 0,
            this._maxLength = 4,
            this.shapes = createSizedArray(this._maxLength)
        }
        ShapeCollection.prototype.addShape = function(_e) {
            this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2),
            this.shapes[this._length] = _e,
            this._length += 1
        }
        ,
        ShapeCollection.prototype.releaseShapes = function() {
            var _e;
            for (_e = 0; _e < this._length; _e += 1)
                shapePool.release(this.shapes[_e]);
            this._length = 0
        }
        ;
        var shapeCollectionPool = function() {
            var _e = {
                newShapeCollection: nt,
                release: it
            }
              , et = 0
              , tt = 4
              , rt = createSizedArray(tt);
            function nt() {
                var st;
                return et ? (et -= 1,
                st = rt[et]) : st = new ShapeCollection,
                st
            }
            function it(st) {
                var at, ot = st._length;
                for (at = 0; at < ot; at += 1)
                    shapePool.release(st.shapes[at]);
                st._length = 0,
                et === tt && (rt = pooling.double(rt),
                tt *= 2),
                rt[et] = st,
                et += 1
            }
            return _e
        }()
          , ShapePropertyFactory = function() {
            var _e = -999999;
            function et(pt, mt, yt) {
                var vt = yt.lastIndex, wt, _t, Et, xt, Ct, Tt, It, Nt, Ft, Lt = this.keyframes;
                if (pt < Lt[0].t - this.offsetTime)
                    wt = Lt[0].s[0],
                    Et = !0,
                    vt = 0;
                else if (pt >= Lt[Lt.length - 1].t - this.offsetTime)
                    wt = Lt[Lt.length - 1].s ? Lt[Lt.length - 1].s[0] : Lt[Lt.length - 2].e[0],
                    Et = !0;
                else {
                    for (var Mt = vt, $t = Lt.length - 1, kt = !0, At, Pt, Dt; kt && (At = Lt[Mt],
                    Pt = Lt[Mt + 1],
                    !(Pt.t - this.offsetTime > pt)); )
                        Mt < $t - 1 ? Mt += 1 : kt = !1;
                    if (Dt = this.keyframesMetadata[Mt] || {},
                    Et = At.h === 1,
                    vt = Mt,
                    !Et) {
                        if (pt >= Pt.t - this.offsetTime)
                            Nt = 1;
                        else if (pt < At.t - this.offsetTime)
                            Nt = 0;
                        else {
                            var Bt;
                            Dt.__fnct ? Bt = Dt.__fnct : (Bt = BezierFactory.getBezierEasing(At.o.x, At.o.y, At.i.x, At.i.y).get,
                            Dt.__fnct = Bt),
                            Nt = Bt((pt - (At.t - this.offsetTime)) / (Pt.t - this.offsetTime - (At.t - this.offsetTime)))
                        }
                        _t = Pt.s ? Pt.s[0] : At.e[0]
                    }
                    wt = At.s[0]
                }
                for (Tt = mt._length,
                It = wt.i[0].length,
                yt.lastIndex = vt,
                xt = 0; xt < Tt; xt += 1)
                    for (Ct = 0; Ct < It; Ct += 1)
                        Ft = Et ? wt.i[xt][Ct] : wt.i[xt][Ct] + (_t.i[xt][Ct] - wt.i[xt][Ct]) * Nt,
                        mt.i[xt][Ct] = Ft,
                        Ft = Et ? wt.o[xt][Ct] : wt.o[xt][Ct] + (_t.o[xt][Ct] - wt.o[xt][Ct]) * Nt,
                        mt.o[xt][Ct] = Ft,
                        Ft = Et ? wt.v[xt][Ct] : wt.v[xt][Ct] + (_t.v[xt][Ct] - wt.v[xt][Ct]) * Nt,
                        mt.v[xt][Ct] = Ft
            }
            function tt() {
                var pt = this.comp.renderedFrame - this.offsetTime
                  , mt = this.keyframes[0].t - this.offsetTime
                  , yt = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
                  , vt = this._caching.lastFrame;
                return vt !== _e && (vt < mt && pt < mt || vt > yt && pt > yt) || (this._caching.lastIndex = vt < pt ? this._caching.lastIndex : 0,
                this.interpolateShape(pt, this.pv, this._caching)),
                this._caching.lastFrame = pt,
                this.pv
            }
            function rt() {
                this.paths = this.localShapeCollection
            }
            function nt(pt, mt) {
                if (pt._length !== mt._length || pt.c !== mt.c)
                    return !1;
                var yt, vt = pt._length;
                for (yt = 0; yt < vt; yt += 1)
                    if (pt.v[yt][0] !== mt.v[yt][0] || pt.v[yt][1] !== mt.v[yt][1] || pt.o[yt][0] !== mt.o[yt][0] || pt.o[yt][1] !== mt.o[yt][1] || pt.i[yt][0] !== mt.i[yt][0] || pt.i[yt][1] !== mt.i[yt][1])
                        return !1;
                return !0
            }
            function it(pt) {
                nt(this.v, pt) || (this.v = shapePool.clone(pt),
                this.localShapeCollection.releaseShapes(),
                this.localShapeCollection.addShape(this.v),
                this._mdf = !0,
                this.paths = this.localShapeCollection)
            }
            function st() {
                if (this.elem.globalData.frameId !== this.frameId) {
                    if (!this.effectsSequence.length) {
                        this._mdf = !1;
                        return
                    }
                    if (this.lock) {
                        this.setVValue(this.pv);
                        return
                    }
                    this.lock = !0,
                    this._mdf = !1;
                    var pt;
                    this.kf ? pt = this.pv : this.data.ks ? pt = this.data.ks.k : pt = this.data.pt.k;
                    var mt, yt = this.effectsSequence.length;
                    for (mt = 0; mt < yt; mt += 1)
                        pt = this.effectsSequence[mt](pt);
                    this.setVValue(pt),
                    this.lock = !1,
                    this.frameId = this.elem.globalData.frameId
                }
            }
            function at(pt, mt, yt) {
                this.propType = "shape",
                this.comp = pt.comp,
                this.container = pt,
                this.elem = pt,
                this.data = mt,
                this.k = !1,
                this.kf = !1,
                this._mdf = !1;
                var vt = yt === 3 ? mt.pt.k : mt.ks.k;
                this.v = shapePool.clone(vt),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.reset = rt,
                this.effectsSequence = []
            }
            function ot(pt) {
                this.effectsSequence.push(pt),
                this.container.addDynamicProperty(this)
            }
            at.prototype.interpolateShape = et,
            at.prototype.getValue = st,
            at.prototype.setVValue = it,
            at.prototype.addEffect = ot;
            function lt(pt, mt, yt) {
                this.propType = "shape",
                this.comp = pt.comp,
                this.elem = pt,
                this.container = pt,
                this.offsetTime = pt.data.st,
                this.keyframes = yt === 3 ? mt.pt.k : mt.ks.k,
                this.keyframesMetadata = [],
                this.k = !0,
                this.kf = !0;
                var vt = this.keyframes[0].s[0].i.length;
                this.v = shapePool.newElement(),
                this.v.setPathData(this.keyframes[0].s[0].c, vt),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.lastFrame = _e,
                this.reset = rt,
                this._caching = {
                    lastFrame: _e,
                    lastIndex: 0
                },
                this.effectsSequence = [tt.bind(this)]
            }
            lt.prototype.getValue = st,
            lt.prototype.interpolateShape = et,
            lt.prototype.setVValue = it,
            lt.prototype.addEffect = ot;
            var dt = function() {
                var pt = roundCorner;
                function mt(yt, vt) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 4),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.paths = this.localShapeCollection,
                    this.localShapeCollection.addShape(this.v),
                    this.d = vt.d,
                    this.elem = yt,
                    this.comp = yt.comp,
                    this.frameId = -1,
                    this.initDynamicPropertyContainer(yt),
                    this.p = PropertyFactory.getProp(yt, vt.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(yt, vt.s, 1, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertEllToPath())
                }
                return mt.prototype = {
                    reset: rt,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertEllToPath())
                    },
                    convertEllToPath: function() {
                        var vt = this.p.v[0]
                          , wt = this.p.v[1]
                          , _t = this.s.v[0] / 2
                          , Et = this.s.v[1] / 2
                          , xt = this.d !== 3
                          , Ct = this.v;
                        Ct.v[0][0] = vt,
                        Ct.v[0][1] = wt - Et,
                        Ct.v[1][0] = xt ? vt + _t : vt - _t,
                        Ct.v[1][1] = wt,
                        Ct.v[2][0] = vt,
                        Ct.v[2][1] = wt + Et,
                        Ct.v[3][0] = xt ? vt - _t : vt + _t,
                        Ct.v[3][1] = wt,
                        Ct.i[0][0] = xt ? vt - _t * pt : vt + _t * pt,
                        Ct.i[0][1] = wt - Et,
                        Ct.i[1][0] = xt ? vt + _t : vt - _t,
                        Ct.i[1][1] = wt - Et * pt,
                        Ct.i[2][0] = xt ? vt + _t * pt : vt - _t * pt,
                        Ct.i[2][1] = wt + Et,
                        Ct.i[3][0] = xt ? vt - _t : vt + _t,
                        Ct.i[3][1] = wt + Et * pt,
                        Ct.o[0][0] = xt ? vt + _t * pt : vt - _t * pt,
                        Ct.o[0][1] = wt - Et,
                        Ct.o[1][0] = xt ? vt + _t : vt - _t,
                        Ct.o[1][1] = wt + Et * pt,
                        Ct.o[2][0] = xt ? vt - _t * pt : vt + _t * pt,
                        Ct.o[2][1] = wt + Et,
                        Ct.o[3][0] = xt ? vt - _t : vt + _t,
                        Ct.o[3][1] = wt - Et * pt
                    }
                },
                extendPrototype([DynamicPropertyContainer], mt),
                mt
            }()
              , ct = function() {
                function pt(mt, yt) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 0),
                    this.elem = mt,
                    this.comp = mt.comp,
                    this.data = yt,
                    this.frameId = -1,
                    this.d = yt.d,
                    this.initDynamicPropertyContainer(mt),
                    yt.sy === 1 ? (this.ir = PropertyFactory.getProp(mt, yt.ir, 0, 0, this),
                    this.is = PropertyFactory.getProp(mt, yt.is, 0, .01, this),
                    this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath,
                    this.pt = PropertyFactory.getProp(mt, yt.pt, 0, 0, this),
                    this.p = PropertyFactory.getProp(mt, yt.p, 1, 0, this),
                    this.r = PropertyFactory.getProp(mt, yt.r, 0, degToRads, this),
                    this.or = PropertyFactory.getProp(mt, yt.or, 0, 0, this),
                    this.os = PropertyFactory.getProp(mt, yt.os, 0, .01, this),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertToPath())
                }
                return pt.prototype = {
                    reset: rt,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertToPath())
                    },
                    convertStarToPath: function() {
                        var yt = Math.floor(this.pt.v) * 2, vt = Math.PI * 2 / yt, wt = !0, _t = this.or.v, Et = this.ir.v, xt = this.os.v, Ct = this.is.v, Tt = 2 * Math.PI * _t / (yt * 2), It = 2 * Math.PI * Et / (yt * 2), Nt, Ft, Lt, Mt, $t = -Math.PI / 2;
                        $t += this.r.v;
                        var kt = this.data.d === 3 ? -1 : 1;
                        for (this.v._length = 0,
                        Nt = 0; Nt < yt; Nt += 1) {
                            Ft = wt ? _t : Et,
                            Lt = wt ? xt : Ct,
                            Mt = wt ? Tt : It;
                            var At = Ft * Math.cos($t)
                              , Pt = Ft * Math.sin($t)
                              , Dt = At === 0 && Pt === 0 ? 0 : Pt / Math.sqrt(At * At + Pt * Pt)
                              , Bt = At === 0 && Pt === 0 ? 0 : -At / Math.sqrt(At * At + Pt * Pt);
                            At += +this.p.v[0],
                            Pt += +this.p.v[1],
                            this.v.setTripleAt(At, Pt, At - Dt * Mt * Lt * kt, Pt - Bt * Mt * Lt * kt, At + Dt * Mt * Lt * kt, Pt + Bt * Mt * Lt * kt, Nt, !0),
                            wt = !wt,
                            $t += vt * kt
                        }
                    },
                    convertPolygonToPath: function() {
                        var yt = Math.floor(this.pt.v), vt = Math.PI * 2 / yt, wt = this.or.v, _t = this.os.v, Et = 2 * Math.PI * wt / (yt * 4), xt, Ct = -Math.PI * .5, Tt = this.data.d === 3 ? -1 : 1;
                        for (Ct += this.r.v,
                        this.v._length = 0,
                        xt = 0; xt < yt; xt += 1) {
                            var It = wt * Math.cos(Ct)
                              , Nt = wt * Math.sin(Ct)
                              , Ft = It === 0 && Nt === 0 ? 0 : Nt / Math.sqrt(It * It + Nt * Nt)
                              , Lt = It === 0 && Nt === 0 ? 0 : -It / Math.sqrt(It * It + Nt * Nt);
                            It += +this.p.v[0],
                            Nt += +this.p.v[1],
                            this.v.setTripleAt(It, Nt, It - Ft * Et * _t * Tt, Nt - Lt * Et * _t * Tt, It + Ft * Et * _t * Tt, Nt + Lt * Et * _t * Tt, xt, !0),
                            Ct += vt * Tt
                        }
                        this.paths.length = 0,
                        this.paths[0] = this.v
                    }
                },
                extendPrototype([DynamicPropertyContainer], pt),
                pt
            }()
              , ut = function() {
                function pt(mt, yt) {
                    this.v = shapePool.newElement(),
                    this.v.c = !0,
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.elem = mt,
                    this.comp = mt.comp,
                    this.frameId = -1,
                    this.d = yt.d,
                    this.initDynamicPropertyContainer(mt),
                    this.p = PropertyFactory.getProp(mt, yt.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(mt, yt.s, 1, 0, this),
                    this.r = PropertyFactory.getProp(mt, yt.r, 0, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertRectToPath())
                }
                return pt.prototype = {
                    convertRectToPath: function() {
                        var yt = this.p.v[0]
                          , vt = this.p.v[1]
                          , wt = this.s.v[0] / 2
                          , _t = this.s.v[1] / 2
                          , Et = bmMin(wt, _t, this.r.v)
                          , xt = Et * (1 - roundCorner);
                        this.v._length = 0,
                        this.d === 2 || this.d === 1 ? (this.v.setTripleAt(yt + wt, vt - _t + Et, yt + wt, vt - _t + Et, yt + wt, vt - _t + xt, 0, !0),
                        this.v.setTripleAt(yt + wt, vt + _t - Et, yt + wt, vt + _t - xt, yt + wt, vt + _t - Et, 1, !0),
                        Et !== 0 ? (this.v.setTripleAt(yt + wt - Et, vt + _t, yt + wt - Et, vt + _t, yt + wt - xt, vt + _t, 2, !0),
                        this.v.setTripleAt(yt - wt + Et, vt + _t, yt - wt + xt, vt + _t, yt - wt + Et, vt + _t, 3, !0),
                        this.v.setTripleAt(yt - wt, vt + _t - Et, yt - wt, vt + _t - Et, yt - wt, vt + _t - xt, 4, !0),
                        this.v.setTripleAt(yt - wt, vt - _t + Et, yt - wt, vt - _t + xt, yt - wt, vt - _t + Et, 5, !0),
                        this.v.setTripleAt(yt - wt + Et, vt - _t, yt - wt + Et, vt - _t, yt - wt + xt, vt - _t, 6, !0),
                        this.v.setTripleAt(yt + wt - Et, vt - _t, yt + wt - xt, vt - _t, yt + wt - Et, vt - _t, 7, !0)) : (this.v.setTripleAt(yt - wt, vt + _t, yt - wt + xt, vt + _t, yt - wt, vt + _t, 2),
                        this.v.setTripleAt(yt - wt, vt - _t, yt - wt, vt - _t + xt, yt - wt, vt - _t, 3))) : (this.v.setTripleAt(yt + wt, vt - _t + Et, yt + wt, vt - _t + xt, yt + wt, vt - _t + Et, 0, !0),
                        Et !== 0 ? (this.v.setTripleAt(yt + wt - Et, vt - _t, yt + wt - Et, vt - _t, yt + wt - xt, vt - _t, 1, !0),
                        this.v.setTripleAt(yt - wt + Et, vt - _t, yt - wt + xt, vt - _t, yt - wt + Et, vt - _t, 2, !0),
                        this.v.setTripleAt(yt - wt, vt - _t + Et, yt - wt, vt - _t + Et, yt - wt, vt - _t + xt, 3, !0),
                        this.v.setTripleAt(yt - wt, vt + _t - Et, yt - wt, vt + _t - xt, yt - wt, vt + _t - Et, 4, !0),
                        this.v.setTripleAt(yt - wt + Et, vt + _t, yt - wt + Et, vt + _t, yt - wt + xt, vt + _t, 5, !0),
                        this.v.setTripleAt(yt + wt - Et, vt + _t, yt + wt - xt, vt + _t, yt + wt - Et, vt + _t, 6, !0),
                        this.v.setTripleAt(yt + wt, vt + _t - Et, yt + wt, vt + _t - Et, yt + wt, vt + _t - xt, 7, !0)) : (this.v.setTripleAt(yt - wt, vt - _t, yt - wt + xt, vt - _t, yt - wt, vt - _t, 1, !0),
                        this.v.setTripleAt(yt - wt, vt + _t, yt - wt, vt + _t - xt, yt - wt, vt + _t, 2, !0),
                        this.v.setTripleAt(yt + wt, vt + _t, yt + wt - xt, vt + _t, yt + wt, vt + _t, 3, !0)))
                    },
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertRectToPath())
                    },
                    reset: rt
                },
                extendPrototype([DynamicPropertyContainer], pt),
                pt
            }();
            function ft(pt, mt, yt) {
                var vt;
                if (yt === 3 || yt === 4) {
                    var wt = yt === 3 ? mt.pt : mt.ks
                      , _t = wt.k;
                    _t.length ? vt = new lt(pt,mt,yt) : vt = new at(pt,mt,yt)
                } else
                    yt === 5 ? vt = new ut(pt,mt) : yt === 6 ? vt = new dt(pt,mt) : yt === 7 && (vt = new ct(pt,mt));
                return vt.k && pt.addDynamicProperty(vt),
                vt
            }
            function ht() {
                return at
            }
            function gt() {
                return lt
            }
            var bt = {};
            return bt.getShapeProp = ft,
            bt.getConstructorFunction = ht,
            bt.getKeyframedConstructorFunction = gt,
            bt
        }();
        /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */
        var Matrix = function() {
            var _e = Math.cos
              , et = Math.sin
              , tt = Math.tan
              , rt = Math.round;
            function nt() {
                return this.props[0] = 1,
                this.props[1] = 0,
                this.props[2] = 0,
                this.props[3] = 0,
                this.props[4] = 0,
                this.props[5] = 1,
                this.props[6] = 0,
                this.props[7] = 0,
                this.props[8] = 0,
                this.props[9] = 0,
                this.props[10] = 1,
                this.props[11] = 0,
                this.props[12] = 0,
                this.props[13] = 0,
                this.props[14] = 0,
                this.props[15] = 1,
                this
            }
            function it(At) {
                if (At === 0)
                    return this;
                var Pt = _e(At)
                  , Dt = et(At);
                return this._t(Pt, -Dt, 0, 0, Dt, Pt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function st(At) {
                if (At === 0)
                    return this;
                var Pt = _e(At)
                  , Dt = et(At);
                return this._t(1, 0, 0, 0, 0, Pt, -Dt, 0, 0, Dt, Pt, 0, 0, 0, 0, 1)
            }
            function at(At) {
                if (At === 0)
                    return this;
                var Pt = _e(At)
                  , Dt = et(At);
                return this._t(Pt, 0, Dt, 0, 0, 1, 0, 0, -Dt, 0, Pt, 0, 0, 0, 0, 1)
            }
            function ot(At) {
                if (At === 0)
                    return this;
                var Pt = _e(At)
                  , Dt = et(At);
                return this._t(Pt, -Dt, 0, 0, Dt, Pt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function lt(At, Pt) {
                return this._t(1, Pt, At, 1, 0, 0)
            }
            function dt(At, Pt) {
                return this.shear(tt(At), tt(Pt))
            }
            function ct(At, Pt) {
                var Dt = _e(Pt)
                  , Bt = et(Pt);
                return this._t(Dt, Bt, 0, 0, -Bt, Dt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, tt(At), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(Dt, -Bt, 0, 0, Bt, Dt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function ut(At, Pt, Dt) {
                return !Dt && Dt !== 0 && (Dt = 1),
                At === 1 && Pt === 1 && Dt === 1 ? this : this._t(At, 0, 0, 0, 0, Pt, 0, 0, 0, 0, Dt, 0, 0, 0, 0, 1)
            }
            function ft(At, Pt, Dt, Bt, zt, Yt, rr, ar, or, pr, gr, Sr, br, Pr, Wr, _r) {
                return this.props[0] = At,
                this.props[1] = Pt,
                this.props[2] = Dt,
                this.props[3] = Bt,
                this.props[4] = zt,
                this.props[5] = Yt,
                this.props[6] = rr,
                this.props[7] = ar,
                this.props[8] = or,
                this.props[9] = pr,
                this.props[10] = gr,
                this.props[11] = Sr,
                this.props[12] = br,
                this.props[13] = Pr,
                this.props[14] = Wr,
                this.props[15] = _r,
                this
            }
            function ht(At, Pt, Dt) {
                return Dt = Dt || 0,
                At !== 0 || Pt !== 0 || Dt !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, At, Pt, Dt, 1) : this
            }
            function gt(At, Pt, Dt, Bt, zt, Yt, rr, ar, or, pr, gr, Sr, br, Pr, Wr, _r) {
                var hr = this.props;
                if (At === 1 && Pt === 0 && Dt === 0 && Bt === 0 && zt === 0 && Yt === 1 && rr === 0 && ar === 0 && or === 0 && pr === 0 && gr === 1 && Sr === 0)
                    return hr[12] = hr[12] * At + hr[15] * br,
                    hr[13] = hr[13] * Yt + hr[15] * Pr,
                    hr[14] = hr[14] * gr + hr[15] * Wr,
                    hr[15] *= _r,
                    this._identityCalculated = !1,
                    this;
                var Vr = hr[0]
                  , Xr = hr[1]
                  , Yr = hr[2]
                  , Hr = hr[3]
                  , Gt = hr[4]
                  , Jt = hr[5]
                  , tr = hr[6]
                  , lr = hr[7]
                  , sr = hr[8]
                  , ir = hr[9]
                  , ur = hr[10]
                  , Cr = hr[11]
                  , Wt = hr[12]
                  , Rt = hr[13]
                  , jt = hr[14]
                  , Ht = hr[15];
                return hr[0] = Vr * At + Xr * zt + Yr * or + Hr * br,
                hr[1] = Vr * Pt + Xr * Yt + Yr * pr + Hr * Pr,
                hr[2] = Vr * Dt + Xr * rr + Yr * gr + Hr * Wr,
                hr[3] = Vr * Bt + Xr * ar + Yr * Sr + Hr * _r,
                hr[4] = Gt * At + Jt * zt + tr * or + lr * br,
                hr[5] = Gt * Pt + Jt * Yt + tr * pr + lr * Pr,
                hr[6] = Gt * Dt + Jt * rr + tr * gr + lr * Wr,
                hr[7] = Gt * Bt + Jt * ar + tr * Sr + lr * _r,
                hr[8] = sr * At + ir * zt + ur * or + Cr * br,
                hr[9] = sr * Pt + ir * Yt + ur * pr + Cr * Pr,
                hr[10] = sr * Dt + ir * rr + ur * gr + Cr * Wr,
                hr[11] = sr * Bt + ir * ar + ur * Sr + Cr * _r,
                hr[12] = Wt * At + Rt * zt + jt * or + Ht * br,
                hr[13] = Wt * Pt + Rt * Yt + jt * pr + Ht * Pr,
                hr[14] = Wt * Dt + Rt * rr + jt * gr + Ht * Wr,
                hr[15] = Wt * Bt + Rt * ar + jt * Sr + Ht * _r,
                this._identityCalculated = !1,
                this
            }
            function bt(At) {
                var Pt = At.props;
                return this.transform(Pt[0], Pt[1], Pt[2], Pt[3], Pt[4], Pt[5], Pt[6], Pt[7], Pt[8], Pt[9], Pt[10], Pt[11], Pt[12], Pt[13], Pt[14], Pt[15])
            }
            function pt() {
                return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1),
                this._identityCalculated = !0),
                this._identity
            }
            function mt(At) {
                for (var Pt = 0; Pt < 16; ) {
                    if (At.props[Pt] !== this.props[Pt])
                        return !1;
                    Pt += 1
                }
                return !0
            }
            function yt(At) {
                var Pt;
                for (Pt = 0; Pt < 16; Pt += 1)
                    At.props[Pt] = this.props[Pt];
                return At
            }
            function vt(At) {
                var Pt;
                for (Pt = 0; Pt < 16; Pt += 1)
                    this.props[Pt] = At[Pt]
            }
            function wt(At, Pt, Dt) {
                return {
                    x: At * this.props[0] + Pt * this.props[4] + Dt * this.props[8] + this.props[12],
                    y: At * this.props[1] + Pt * this.props[5] + Dt * this.props[9] + this.props[13],
                    z: At * this.props[2] + Pt * this.props[6] + Dt * this.props[10] + this.props[14]
                }
            }
            function _t(At, Pt, Dt) {
                return At * this.props[0] + Pt * this.props[4] + Dt * this.props[8] + this.props[12]
            }
            function Et(At, Pt, Dt) {
                return At * this.props[1] + Pt * this.props[5] + Dt * this.props[9] + this.props[13]
            }
            function xt(At, Pt, Dt) {
                return At * this.props[2] + Pt * this.props[6] + Dt * this.props[10] + this.props[14]
            }
            function Ct() {
                var At = this.props[0] * this.props[5] - this.props[1] * this.props[4]
                  , Pt = this.props[5] / At
                  , Dt = -this.props[1] / At
                  , Bt = -this.props[4] / At
                  , zt = this.props[0] / At
                  , Yt = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / At
                  , rr = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / At
                  , ar = new Matrix;
                return ar.props[0] = Pt,
                ar.props[1] = Dt,
                ar.props[4] = Bt,
                ar.props[5] = zt,
                ar.props[12] = Yt,
                ar.props[13] = rr,
                ar
            }
            function Tt(At) {
                var Pt = this.getInverseMatrix();
                return Pt.applyToPointArray(At[0], At[1], At[2] || 0)
            }
            function It(At) {
                var Pt, Dt = At.length, Bt = [];
                for (Pt = 0; Pt < Dt; Pt += 1)
                    Bt[Pt] = Tt(At[Pt]);
                return Bt
            }
            function Nt(At, Pt, Dt) {
                var Bt = createTypedArray("float32", 6);
                if (this.isIdentity())
                    Bt[0] = At[0],
                    Bt[1] = At[1],
                    Bt[2] = Pt[0],
                    Bt[3] = Pt[1],
                    Bt[4] = Dt[0],
                    Bt[5] = Dt[1];
                else {
                    var zt = this.props[0]
                      , Yt = this.props[1]
                      , rr = this.props[4]
                      , ar = this.props[5]
                      , or = this.props[12]
                      , pr = this.props[13];
                    Bt[0] = At[0] * zt + At[1] * rr + or,
                    Bt[1] = At[0] * Yt + At[1] * ar + pr,
                    Bt[2] = Pt[0] * zt + Pt[1] * rr + or,
                    Bt[3] = Pt[0] * Yt + Pt[1] * ar + pr,
                    Bt[4] = Dt[0] * zt + Dt[1] * rr + or,
                    Bt[5] = Dt[0] * Yt + Dt[1] * ar + pr
                }
                return Bt
            }
            function Ft(At, Pt, Dt) {
                var Bt;
                return this.isIdentity() ? Bt = [At, Pt, Dt] : Bt = [At * this.props[0] + Pt * this.props[4] + Dt * this.props[8] + this.props[12], At * this.props[1] + Pt * this.props[5] + Dt * this.props[9] + this.props[13], At * this.props[2] + Pt * this.props[6] + Dt * this.props[10] + this.props[14]],
                Bt
            }
            function Lt(At, Pt) {
                if (this.isIdentity())
                    return At + "," + Pt;
                var Dt = this.props;
                return Math.round((At * Dt[0] + Pt * Dt[4] + Dt[12]) * 100) / 100 + "," + Math.round((At * Dt[1] + Pt * Dt[5] + Dt[13]) * 100) / 100
            }
            function Mt() {
                for (var At = 0, Pt = this.props, Dt = "matrix3d(", Bt = 1e4; At < 16; )
                    Dt += rt(Pt[At] * Bt) / Bt,
                    Dt += At === 15 ? ")" : ",",
                    At += 1;
                return Dt
            }
            function $t(At) {
                var Pt = 1e4;
                return At < 1e-6 && At > 0 || At > -1e-6 && At < 0 ? rt(At * Pt) / Pt : At
            }
            function kt() {
                var At = this.props
                  , Pt = $t(At[0])
                  , Dt = $t(At[1])
                  , Bt = $t(At[4])
                  , zt = $t(At[5])
                  , Yt = $t(At[12])
                  , rr = $t(At[13]);
                return "matrix(" + Pt + "," + Dt + "," + Bt + "," + zt + "," + Yt + "," + rr + ")"
            }
            return function() {
                this.reset = nt,
                this.rotate = it,
                this.rotateX = st,
                this.rotateY = at,
                this.rotateZ = ot,
                this.skew = dt,
                this.skewFromAxis = ct,
                this.shear = lt,
                this.scale = ut,
                this.setTransform = ft,
                this.translate = ht,
                this.transform = gt,
                this.multiply = bt,
                this.applyToPoint = wt,
                this.applyToX = _t,
                this.applyToY = Et,
                this.applyToZ = xt,
                this.applyToPointArray = Ft,
                this.applyToTriplePoints = Nt,
                this.applyToPointStringified = Lt,
                this.toCSS = Mt,
                this.to2dCSS = kt,
                this.clone = yt,
                this.cloneFromProps = vt,
                this.equals = mt,
                this.inversePoints = It,
                this.inversePoint = Tt,
                this.getInverseMatrix = Ct,
                this._t = this.transform,
                this.isIdentity = pt,
                this._identity = !0,
                this._identityCalculated = !1,
                this.props = createTypedArray("float32", 16),
                this.reset()
            }
        }();
        function _typeof$3(_e) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function(tt) {
                return typeof tt
            }
            : _typeof$3 = function(tt) {
                return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
            }
            ,
            _typeof$3(_e)
        }
        var lottie = {};
        function setLocation(_e) {
            setLocationHref(_e)
        }
        function searchAnimations() {
            animationManager.searchAnimations()
        }
        function setSubframeRendering(_e) {
            setSubframeEnabled(_e)
        }
        function setPrefix(_e) {
            setIdPrefix(_e)
        }
        function loadAnimation(_e) {
            return animationManager.loadAnimation(_e)
        }
        function setQuality(_e) {
            if (typeof _e == "string")
                switch (_e) {
                case "high":
                    setDefaultCurveSegments(200);
                    break;
                default:
                case "medium":
                    setDefaultCurveSegments(50);
                    break;
                case "low":
                    setDefaultCurveSegments(10);
                    break
                }
            else
                !isNaN(_e) && _e > 1 && setDefaultCurveSegments(_e)
        }
        function inBrowser() {
            return typeof navigator < "u"
        }
        function installPlugin(_e, et) {
            _e === "expressions" && setExpressionsPlugin(et)
        }
        function getFactory(_e) {
            switch (_e) {
            case "propertyFactory":
                return PropertyFactory;
            case "shapePropertyFactory":
                return ShapePropertyFactory;
            case "matrix":
                return Matrix;
            default:
                return null
            }
        }
        lottie.play = animationManager.play,
        lottie.pause = animationManager.pause,
        lottie.setLocationHref = setLocation,
        lottie.togglePause = animationManager.togglePause,
        lottie.setSpeed = animationManager.setSpeed,
        lottie.setDirection = animationManager.setDirection,
        lottie.stop = animationManager.stop,
        lottie.searchAnimations = searchAnimations,
        lottie.registerAnimation = animationManager.registerAnimation,
        lottie.loadAnimation = loadAnimation,
        lottie.setSubframeRendering = setSubframeRendering,
        lottie.resize = animationManager.resize,
        lottie.goToAndStop = animationManager.goToAndStop,
        lottie.destroy = animationManager.destroy,
        lottie.setQuality = setQuality,
        lottie.inBrowser = inBrowser,
        lottie.installPlugin = installPlugin,
        lottie.freeze = animationManager.freeze,
        lottie.unfreeze = animationManager.unfreeze,
        lottie.setVolume = animationManager.setVolume,
        lottie.mute = animationManager.mute,
        lottie.unmute = animationManager.unmute,
        lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations,
        lottie.useWebWorker = setWebWorker,
        lottie.setIDPrefix = setPrefix,
        lottie.__getFactory = getFactory,
        lottie.version = "5.12.2";
        function checkReady() {
            document.readyState === "complete" && (clearInterval(readyStateCheckInterval),
            searchAnimations())
        }
        function getQueryVariable(_e) {
            for (var et = queryString.split("&"), tt = 0; tt < et.length; tt += 1) {
                var rt = et[tt].split("=");
                if (decodeURIComponent(rt[0]) == _e)
                    return decodeURIComponent(rt[1])
            }
            return null
        }
        var queryString = "";
        {
            var scripts = document.getElementsByTagName("script")
              , index = scripts.length - 1
              , myScript = scripts[index] || {
                src: ""
            };
            queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "",
            getQueryVariable("renderer")
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        try {
            _typeof$3(exports) !== "object" && (window.bodymovin = lottie)
        } catch (_e) {}
        var ShapeModifiers = function() {
            var _e = {}
              , et = {};
            _e.registerModifier = tt,
            _e.getModifier = rt;
            function tt(nt, it) {
                et[nt] || (et[nt] = it)
            }
            function rt(nt, it, st) {
                return new et[nt](it,st)
            }
            return _e
        }();
        function ShapeModifier() {}
        ShapeModifier.prototype.initModifierProperties = function() {}
        ,
        ShapeModifier.prototype.addShapeToModifier = function() {}
        ,
        ShapeModifier.prototype.addShape = function(_e) {
            if (!this.closed) {
                _e.sh.container.addDynamicProperty(_e.sh);
                var et = {
                    shape: _e.sh,
                    data: _e,
                    localShapeCollection: shapeCollectionPool.newShapeCollection()
                };
                this.shapes.push(et),
                this.addShapeToModifier(et),
                this._isAnimated && _e.setAsAnimated()
            }
        }
        ,
        ShapeModifier.prototype.init = function(_e, et) {
            this.shapes = [],
            this.elem = _e,
            this.initDynamicPropertyContainer(_e),
            this.initModifierProperties(_e, et),
            this.frameId = initialDefaultFrame,
            this.closed = !1,
            this.k = !1,
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        ShapeModifier.prototype.processKeys = function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
        function TrimModifier() {}
        extendPrototype([ShapeModifier], TrimModifier),
        TrimModifier.prototype.initModifierProperties = function(_e, et) {
            this.s = PropertyFactory.getProp(_e, et.s, 0, .01, this),
            this.e = PropertyFactory.getProp(_e, et.e, 0, .01, this),
            this.o = PropertyFactory.getProp(_e, et.o, 0, 0, this),
            this.sValue = 0,
            this.eValue = 0,
            this.getValue = this.processKeys,
            this.m = et.m,
            this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
        }
        ,
        TrimModifier.prototype.addShapeToModifier = function(_e) {
            _e.pathsData = []
        }
        ,
        TrimModifier.prototype.calculateShapeEdges = function(_e, et, tt, rt, nt) {
            var it = [];
            et <= 1 ? it.push({
                s: _e,
                e: et
            }) : _e >= 1 ? it.push({
                s: _e - 1,
                e: et - 1
            }) : (it.push({
                s: _e,
                e: 1
            }),
            it.push({
                s: 0,
                e: et - 1
            }));
            var st = [], at, ot = it.length, lt;
            for (at = 0; at < ot; at += 1)
                if (lt = it[at],
                !(lt.e * nt < rt || lt.s * nt > rt + tt)) {
                    var dt, ct;
                    lt.s * nt <= rt ? dt = 0 : dt = (lt.s * nt - rt) / tt,
                    lt.e * nt >= rt + tt ? ct = 1 : ct = (lt.e * nt - rt) / tt,
                    st.push([dt, ct])
                }
            return st.length || st.push([0, 0]),
            st
        }
        ,
        TrimModifier.prototype.releasePathsData = function(_e) {
            var et, tt = _e.length;
            for (et = 0; et < tt; et += 1)
                segmentsLengthPool.release(_e[et]);
            return _e.length = 0,
            _e
        }
        ,
        TrimModifier.prototype.processShapes = function(_e) {
            var et, tt;
            if (this._mdf || _e) {
                var rt = this.o.v % 360 / 360;
                if (rt < 0 && (rt += 1),
                this.s.v > 1 ? et = 1 + rt : this.s.v < 0 ? et = 0 + rt : et = this.s.v + rt,
                this.e.v > 1 ? tt = 1 + rt : this.e.v < 0 ? tt = 0 + rt : tt = this.e.v + rt,
                et > tt) {
                    var nt = et;
                    et = tt,
                    tt = nt
                }
                et = Math.round(et * 1e4) * 1e-4,
                tt = Math.round(tt * 1e4) * 1e-4,
                this.sValue = et,
                this.eValue = tt
            } else
                et = this.sValue,
                tt = this.eValue;
            var it, st, at = this.shapes.length, ot, lt, dt, ct, ut, ft = 0;
            if (tt === et)
                for (st = 0; st < at; st += 1)
                    this.shapes[st].localShapeCollection.releaseShapes(),
                    this.shapes[st].shape._mdf = !0,
                    this.shapes[st].shape.paths = this.shapes[st].localShapeCollection,
                    this._mdf && (this.shapes[st].pathsData.length = 0);
            else if (tt === 1 && et === 0 || tt === 0 && et === 1) {
                if (this._mdf)
                    for (st = 0; st < at; st += 1)
                        this.shapes[st].pathsData.length = 0,
                        this.shapes[st].shape._mdf = !0
            } else {
                var ht = [], gt, bt;
                for (st = 0; st < at; st += 1)
                    if (gt = this.shapes[st],
                    !gt.shape._mdf && !this._mdf && !_e && this.m !== 2)
                        gt.shape.paths = gt.localShapeCollection;
                    else {
                        if (it = gt.shape.paths,
                        lt = it._length,
                        ut = 0,
                        !gt.shape._mdf && gt.pathsData.length)
                            ut = gt.totalShapeLength;
                        else {
                            for (dt = this.releasePathsData(gt.pathsData),
                            ot = 0; ot < lt; ot += 1)
                                ct = bez.getSegmentsLength(it.shapes[ot]),
                                dt.push(ct),
                                ut += ct.totalLength;
                            gt.totalShapeLength = ut,
                            gt.pathsData = dt
                        }
                        ft += ut,
                        gt.shape._mdf = !0
                    }
                var pt = et, mt = tt, yt = 0, vt;
                for (st = at - 1; st >= 0; st -= 1)
                    if (gt = this.shapes[st],
                    gt.shape._mdf) {
                        for (bt = gt.localShapeCollection,
                        bt.releaseShapes(),
                        this.m === 2 && at > 1 ? (vt = this.calculateShapeEdges(et, tt, gt.totalShapeLength, yt, ft),
                        yt += gt.totalShapeLength) : vt = [[pt, mt]],
                        lt = vt.length,
                        ot = 0; ot < lt; ot += 1) {
                            pt = vt[ot][0],
                            mt = vt[ot][1],
                            ht.length = 0,
                            mt <= 1 ? ht.push({
                                s: gt.totalShapeLength * pt,
                                e: gt.totalShapeLength * mt
                            }) : pt >= 1 ? ht.push({
                                s: gt.totalShapeLength * (pt - 1),
                                e: gt.totalShapeLength * (mt - 1)
                            }) : (ht.push({
                                s: gt.totalShapeLength * pt,
                                e: gt.totalShapeLength
                            }),
                            ht.push({
                                s: 0,
                                e: gt.totalShapeLength * (mt - 1)
                            }));
                            var wt = this.addShapes(gt, ht[0]);
                            if (ht[0].s !== ht[0].e) {
                                if (ht.length > 1) {
                                    var _t = gt.shape.paths.shapes[gt.shape.paths._length - 1];
                                    if (_t.c) {
                                        var Et = wt.pop();
                                        this.addPaths(wt, bt),
                                        wt = this.addShapes(gt, ht[1], Et)
                                    } else
                                        this.addPaths(wt, bt),
                                        wt = this.addShapes(gt, ht[1])
                                }
                                this.addPaths(wt, bt)
                            }
                        }
                        gt.shape.paths = bt
                    }
            }
        }
        ,
        TrimModifier.prototype.addPaths = function(_e, et) {
            var tt, rt = _e.length;
            for (tt = 0; tt < rt; tt += 1)
                et.addShape(_e[tt])
        }
        ,
        TrimModifier.prototype.addSegment = function(_e, et, tt, rt, nt, it, st) {
            nt.setXYAt(et[0], et[1], "o", it),
            nt.setXYAt(tt[0], tt[1], "i", it + 1),
            st && nt.setXYAt(_e[0], _e[1], "v", it),
            nt.setXYAt(rt[0], rt[1], "v", it + 1)
        }
        ,
        TrimModifier.prototype.addSegmentFromArray = function(_e, et, tt, rt) {
            et.setXYAt(_e[1], _e[5], "o", tt),
            et.setXYAt(_e[2], _e[6], "i", tt + 1),
            rt && et.setXYAt(_e[0], _e[4], "v", tt),
            et.setXYAt(_e[3], _e[7], "v", tt + 1)
        }
        ,
        TrimModifier.prototype.addShapes = function(_e, et, tt) {
            var rt = _e.pathsData, nt = _e.shape.paths.shapes, it, st = _e.shape.paths._length, at, ot, lt = 0, dt, ct, ut, ft, ht = [], gt, bt = !0;
            for (tt ? (ct = tt._length,
            gt = tt._length) : (tt = shapePool.newElement(),
            ct = 0,
            gt = 0),
            ht.push(tt),
            it = 0; it < st; it += 1) {
                for (ut = rt[it].lengths,
                tt.c = nt[it].c,
                ot = nt[it].c ? ut.length : ut.length + 1,
                at = 1; at < ot; at += 1)
                    if (dt = ut[at - 1],
                    lt + dt.addedLength < et.s)
                        lt += dt.addedLength,
                        tt.c = !1;
                    else if (lt > et.e) {
                        tt.c = !1;
                        break
                    } else
                        et.s <= lt && et.e >= lt + dt.addedLength ? (this.addSegment(nt[it].v[at - 1], nt[it].o[at - 1], nt[it].i[at], nt[it].v[at], tt, ct, bt),
                        bt = !1) : (ft = bez.getNewSegment(nt[it].v[at - 1], nt[it].v[at], nt[it].o[at - 1], nt[it].i[at], (et.s - lt) / dt.addedLength, (et.e - lt) / dt.addedLength, ut[at - 1]),
                        this.addSegmentFromArray(ft, tt, ct, bt),
                        bt = !1,
                        tt.c = !1),
                        lt += dt.addedLength,
                        ct += 1;
                if (nt[it].c && ut.length) {
                    if (dt = ut[at - 1],
                    lt <= et.e) {
                        var pt = ut[at - 1].addedLength;
                        et.s <= lt && et.e >= lt + pt ? (this.addSegment(nt[it].v[at - 1], nt[it].o[at - 1], nt[it].i[0], nt[it].v[0], tt, ct, bt),
                        bt = !1) : (ft = bez.getNewSegment(nt[it].v[at - 1], nt[it].v[0], nt[it].o[at - 1], nt[it].i[0], (et.s - lt) / pt, (et.e - lt) / pt, ut[at - 1]),
                        this.addSegmentFromArray(ft, tt, ct, bt),
                        bt = !1,
                        tt.c = !1)
                    } else
                        tt.c = !1;
                    lt += dt.addedLength,
                    ct += 1
                }
                if (tt._length && (tt.setXYAt(tt.v[gt][0], tt.v[gt][1], "i", gt),
                tt.setXYAt(tt.v[tt._length - 1][0], tt.v[tt._length - 1][1], "o", tt._length - 1)),
                lt > et.e)
                    break;
                it < st - 1 && (tt = shapePool.newElement(),
                bt = !0,
                ht.push(tt),
                ct = 0)
            }
            return ht
        }
        ;
        function PuckerAndBloatModifier() {}
        extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        PuckerAndBloatModifier.prototype.initModifierProperties = function(_e, et) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(_e, et.a, 0, null, this),
            this._isAnimated = !!this.amount.effectsSequence.length
        }
        ,
        PuckerAndBloatModifier.prototype.processPath = function(_e, et) {
            var tt = et / 100
              , rt = [0, 0]
              , nt = _e._length
              , it = 0;
            for (it = 0; it < nt; it += 1)
                rt[0] += _e.v[it][0],
                rt[1] += _e.v[it][1];
            rt[0] /= nt,
            rt[1] /= nt;
            var st = shapePool.newElement();
            st.c = _e.c;
            var at, ot, lt, dt, ct, ut;
            for (it = 0; it < nt; it += 1)
                at = _e.v[it][0] + (rt[0] - _e.v[it][0]) * tt,
                ot = _e.v[it][1] + (rt[1] - _e.v[it][1]) * tt,
                lt = _e.o[it][0] + (rt[0] - _e.o[it][0]) * -tt,
                dt = _e.o[it][1] + (rt[1] - _e.o[it][1]) * -tt,
                ct = _e.i[it][0] + (rt[0] - _e.i[it][0]) * -tt,
                ut = _e.i[it][1] + (rt[1] - _e.i[it][1]) * -tt,
                st.setTripleAt(at, ot, lt, dt, ct, ut, it);
            return st
        }
        ,
        PuckerAndBloatModifier.prototype.processShapes = function(_e) {
            var et, tt, rt = this.shapes.length, nt, it, st = this.amount.v;
            if (st !== 0) {
                var at, ot;
                for (tt = 0; tt < rt; tt += 1) {
                    if (at = this.shapes[tt],
                    ot = at.localShapeCollection,
                    !(!at.shape._mdf && !this._mdf && !_e))
                        for (ot.releaseShapes(),
                        at.shape._mdf = !0,
                        et = at.shape.paths.shapes,
                        it = at.shape.paths._length,
                        nt = 0; nt < it; nt += 1)
                            ot.addShape(this.processPath(et[nt], st));
                    at.shape.paths = at.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        var TransformPropertyFactory = function() {
            var _e = [0, 0];
            function et(ot) {
                var lt = this._mdf;
                this.iterateDynamicProperties(),
                this._mdf = this._mdf || lt,
                this.a && ot.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.s && ot.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk && ot.skewFromAxis(-this.sk.v, this.sa.v),
                this.r ? ot.rotate(-this.r.v) : ot.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                this.data.p.s ? this.data.p.z ? ot.translate(this.px.v, this.py.v, -this.pz.v) : ot.translate(this.px.v, this.py.v, 0) : ot.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
            }
            function tt(ot) {
                if (this.elem.globalData.frameId !== this.frameId) {
                    if (this._isDirty && (this.precalculateMatrix(),
                    this._isDirty = !1),
                    this.iterateDynamicProperties(),
                    this._mdf || ot) {
                        var lt;
                        if (this.v.cloneFromProps(this.pre.props),
                        this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                        this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                        this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v),
                        this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                        this.autoOriented) {
                            var dt, ct;
                            if (lt = this.elem.globalData.frameRate,
                            this.p && this.p.keyframes && this.p.getValueAtTime)
                                this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (dt = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / lt, 0),
                                ct = this.p.getValueAtTime(this.p.keyframes[0].t / lt, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (dt = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / lt, 0),
                                ct = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / lt, 0)) : (dt = this.p.pv,
                                ct = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / lt, this.p.offsetTime));
                            else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                dt = [],
                                ct = [];
                                var ut = this.px
                                  , ft = this.py;
                                ut._caching.lastFrame + ut.offsetTime <= ut.keyframes[0].t ? (dt[0] = ut.getValueAtTime((ut.keyframes[0].t + .01) / lt, 0),
                                dt[1] = ft.getValueAtTime((ft.keyframes[0].t + .01) / lt, 0),
                                ct[0] = ut.getValueAtTime(ut.keyframes[0].t / lt, 0),
                                ct[1] = ft.getValueAtTime(ft.keyframes[0].t / lt, 0)) : ut._caching.lastFrame + ut.offsetTime >= ut.keyframes[ut.keyframes.length - 1].t ? (dt[0] = ut.getValueAtTime(ut.keyframes[ut.keyframes.length - 1].t / lt, 0),
                                dt[1] = ft.getValueAtTime(ft.keyframes[ft.keyframes.length - 1].t / lt, 0),
                                ct[0] = ut.getValueAtTime((ut.keyframes[ut.keyframes.length - 1].t - .01) / lt, 0),
                                ct[1] = ft.getValueAtTime((ft.keyframes[ft.keyframes.length - 1].t - .01) / lt, 0)) : (dt = [ut.pv, ft.pv],
                                ct[0] = ut.getValueAtTime((ut._caching.lastFrame + ut.offsetTime - .01) / lt, ut.offsetTime),
                                ct[1] = ft.getValueAtTime((ft._caching.lastFrame + ft.offsetTime - .01) / lt, ft.offsetTime))
                            } else
                                ct = _e,
                                dt = ct;
                            this.v.rotate(-Math.atan2(dt[1] - ct[1], dt[0] - ct[0]))
                        }
                        this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                    }
                    this.frameId = this.elem.globalData.frameId
                }
            }
            function rt() {
                if (this.appliedTransformations = 0,
                this.pre.reset(),
                !this.a.effectsSequence.length)
                    this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    this.appliedTransformations = 1;
                else
                    return;
                if (!this.s.effectsSequence.length)
                    this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    this.appliedTransformations = 2;
                else
                    return;
                if (this.sk)
                    if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length)
                        this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                        this.appliedTransformations = 3;
                    else
                        return;
                this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v),
                this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                this.appliedTransformations = 4)
            }
            function nt() {}
            function it(ot) {
                this._addDynamicProperty(ot),
                this.elem.addDynamicProperty(ot),
                this._isDirty = !0
            }
            function st(ot, lt, dt) {
                if (this.elem = ot,
                this.frameId = -1,
                this.propType = "transform",
                this.data = lt,
                this.v = new Matrix,
                this.pre = new Matrix,
                this.appliedTransformations = 0,
                this.initDynamicPropertyContainer(dt || ot),
                lt.p && lt.p.s ? (this.px = PropertyFactory.getProp(ot, lt.p.x, 0, 0, this),
                this.py = PropertyFactory.getProp(ot, lt.p.y, 0, 0, this),
                lt.p.z && (this.pz = PropertyFactory.getProp(ot, lt.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(ot, lt.p || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                lt.rx) {
                    if (this.rx = PropertyFactory.getProp(ot, lt.rx, 0, degToRads, this),
                    this.ry = PropertyFactory.getProp(ot, lt.ry, 0, degToRads, this),
                    this.rz = PropertyFactory.getProp(ot, lt.rz, 0, degToRads, this),
                    lt.or.k[0].ti) {
                        var ct, ut = lt.or.k.length;
                        for (ct = 0; ct < ut; ct += 1)
                            lt.or.k[ct].to = null,
                            lt.or.k[ct].ti = null
                    }
                    this.or = PropertyFactory.getProp(ot, lt.or, 1, degToRads, this),
                    this.or.sh = !0
                } else
                    this.r = PropertyFactory.getProp(ot, lt.r || {
                        k: 0
                    }, 0, degToRads, this);
                lt.sk && (this.sk = PropertyFactory.getProp(ot, lt.sk, 0, degToRads, this),
                this.sa = PropertyFactory.getProp(ot, lt.sa, 0, degToRads, this)),
                this.a = PropertyFactory.getProp(ot, lt.a || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                this.s = PropertyFactory.getProp(ot, lt.s || {
                    k: [100, 100, 100]
                }, 1, .01, this),
                lt.o ? this.o = PropertyFactory.getProp(ot, lt.o, 0, .01, ot) : this.o = {
                    _mdf: !1,
                    v: 1
                },
                this._isDirty = !0,
                this.dynamicProperties.length || this.getValue(!0)
            }
            st.prototype = {
                applyToMatrix: et,
                getValue: tt,
                precalculateMatrix: rt,
                autoOrient: nt
            },
            extendPrototype([DynamicPropertyContainer], st),
            st.prototype.addDynamicProperty = it,
            st.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
            function at(ot, lt, dt) {
                return new st(ot,lt,dt)
            }
            return {
                getTransformProperty: at
            }
        }();
        function RepeaterModifier() {}
        extendPrototype([ShapeModifier], RepeaterModifier),
        RepeaterModifier.prototype.initModifierProperties = function(_e, et) {
            this.getValue = this.processKeys,
            this.c = PropertyFactory.getProp(_e, et.c, 0, null, this),
            this.o = PropertyFactory.getProp(_e, et.o, 0, null, this),
            this.tr = TransformPropertyFactory.getTransformProperty(_e, et.tr, this),
            this.so = PropertyFactory.getProp(_e, et.tr.so, 0, .01, this),
            this.eo = PropertyFactory.getProp(_e, et.tr.eo, 0, .01, this),
            this.data = et,
            this.dynamicProperties.length || this.getValue(!0),
            this._isAnimated = !!this.dynamicProperties.length,
            this.pMatrix = new Matrix,
            this.rMatrix = new Matrix,
            this.sMatrix = new Matrix,
            this.tMatrix = new Matrix,
            this.matrix = new Matrix
        }
        ,
        RepeaterModifier.prototype.applyTransforms = function(_e, et, tt, rt, nt, it) {
            var st = it ? -1 : 1
              , at = rt.s.v[0] + (1 - rt.s.v[0]) * (1 - nt)
              , ot = rt.s.v[1] + (1 - rt.s.v[1]) * (1 - nt);
            _e.translate(rt.p.v[0] * st * nt, rt.p.v[1] * st * nt, rt.p.v[2]),
            et.translate(-rt.a.v[0], -rt.a.v[1], rt.a.v[2]),
            et.rotate(-rt.r.v * st * nt),
            et.translate(rt.a.v[0], rt.a.v[1], rt.a.v[2]),
            tt.translate(-rt.a.v[0], -rt.a.v[1], rt.a.v[2]),
            tt.scale(it ? 1 / at : at, it ? 1 / ot : ot),
            tt.translate(rt.a.v[0], rt.a.v[1], rt.a.v[2])
        }
        ,
        RepeaterModifier.prototype.init = function(_e, et, tt, rt) {
            for (this.elem = _e,
            this.arr = et,
            this.pos = tt,
            this.elemsData = rt,
            this._currentCopies = 0,
            this._elements = [],
            this._groups = [],
            this.frameId = -1,
            this.initDynamicPropertyContainer(_e),
            this.initModifierProperties(_e, et[tt]); tt > 0; )
                tt -= 1,
                this._elements.unshift(et[tt]);
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        RepeaterModifier.prototype.resetElements = function(_e) {
            var et, tt = _e.length;
            for (et = 0; et < tt; et += 1)
                _e[et]._processed = !1,
                _e[et].ty === "gr" && this.resetElements(_e[et].it)
        }
        ,
        RepeaterModifier.prototype.cloneElements = function(_e) {
            var et = JSON.parse(JSON.stringify(_e));
            return this.resetElements(et),
            et
        }
        ,
        RepeaterModifier.prototype.changeGroupRender = function(_e, et) {
            var tt, rt = _e.length;
            for (tt = 0; tt < rt; tt += 1)
                _e[tt]._render = et,
                _e[tt].ty === "gr" && this.changeGroupRender(_e[tt].it, et)
        }
        ,
        RepeaterModifier.prototype.processShapes = function(_e) {
            var et, tt, rt, nt, it, st = !1;
            if (this._mdf || _e) {
                var at = Math.ceil(this.c.v);
                if (this._groups.length < at) {
                    for (; this._groups.length < at; ) {
                        var ot = {
                            it: this.cloneElements(this._elements),
                            ty: "gr"
                        };
                        ot.it.push({
                            a: {
                                a: 0,
                                ix: 1,
                                k: [0, 0]
                            },
                            nm: "Transform",
                            o: {
                                a: 0,
                                ix: 7,
                                k: 100
                            },
                            p: {
                                a: 0,
                                ix: 2,
                                k: [0, 0]
                            },
                            r: {
                                a: 1,
                                ix: 6,
                                k: [{
                                    s: 0,
                                    e: 0,
                                    t: 0
                                }, {
                                    s: 0,
                                    e: 0,
                                    t: 1
                                }]
                            },
                            s: {
                                a: 0,
                                ix: 3,
                                k: [100, 100]
                            },
                            sa: {
                                a: 0,
                                ix: 5,
                                k: 0
                            },
                            sk: {
                                a: 0,
                                ix: 4,
                                k: 0
                            },
                            ty: "tr"
                        }),
                        this.arr.splice(0, 0, ot),
                        this._groups.splice(0, 0, ot),
                        this._currentCopies += 1
                    }
                    this.elem.reloadShapes(),
                    st = !0
                }
                it = 0;
                var lt;
                for (rt = 0; rt <= this._groups.length - 1; rt += 1) {
                    if (lt = it < at,
                    this._groups[rt]._render = lt,
                    this.changeGroupRender(this._groups[rt].it, lt),
                    !lt) {
                        var dt = this.elemsData[rt].it
                          , ct = dt[dt.length - 1];
                        ct.transform.op.v !== 0 ? (ct.transform.op._mdf = !0,
                        ct.transform.op.v = 0) : ct.transform.op._mdf = !1
                    }
                    it += 1
                }
                this._currentCopies = at;
                var ut = this.o.v
                  , ft = ut % 1
                  , ht = ut > 0 ? Math.floor(ut) : Math.ceil(ut)
                  , gt = this.pMatrix.props
                  , bt = this.rMatrix.props
                  , pt = this.sMatrix.props;
                this.pMatrix.reset(),
                this.rMatrix.reset(),
                this.sMatrix.reset(),
                this.tMatrix.reset(),
                this.matrix.reset();
                var mt = 0;
                if (ut > 0) {
                    for (; mt < ht; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        mt += 1;
                    ft && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, ft, !1),
                    mt += ft)
                } else if (ut < 0) {
                    for (; mt > ht; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0),
                        mt -= 1;
                    ft && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -ft, !0),
                    mt -= ft)
                }
                rt = this.data.m === 1 ? 0 : this._currentCopies - 1,
                nt = this.data.m === 1 ? 1 : -1,
                it = this._currentCopies;
                for (var yt, vt; it; ) {
                    if (et = this.elemsData[rt].it,
                    tt = et[et.length - 1].transform.mProps.v.props,
                    vt = tt.length,
                    et[et.length - 1].transform.mProps._mdf = !0,
                    et[et.length - 1].transform.op._mdf = !0,
                    et[et.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (rt / (this._currentCopies - 1)),
                    mt !== 0) {
                        for ((rt !== 0 && nt === 1 || rt !== this._currentCopies - 1 && nt === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        this.matrix.transform(bt[0], bt[1], bt[2], bt[3], bt[4], bt[5], bt[6], bt[7], bt[8], bt[9], bt[10], bt[11], bt[12], bt[13], bt[14], bt[15]),
                        this.matrix.transform(pt[0], pt[1], pt[2], pt[3], pt[4], pt[5], pt[6], pt[7], pt[8], pt[9], pt[10], pt[11], pt[12], pt[13], pt[14], pt[15]),
                        this.matrix.transform(gt[0], gt[1], gt[2], gt[3], gt[4], gt[5], gt[6], gt[7], gt[8], gt[9], gt[10], gt[11], gt[12], gt[13], gt[14], gt[15]),
                        yt = 0; yt < vt; yt += 1)
                            tt[yt] = this.matrix.props[yt];
                        this.matrix.reset()
                    } else
                        for (this.matrix.reset(),
                        yt = 0; yt < vt; yt += 1)
                            tt[yt] = this.matrix.props[yt];
                    mt += 1,
                    it -= 1,
                    rt += nt
                }
            } else
                for (it = this._currentCopies,
                rt = 0,
                nt = 1; it; )
                    et = this.elemsData[rt].it,
                    tt = et[et.length - 1].transform.mProps.v.props,
                    et[et.length - 1].transform.mProps._mdf = !1,
                    et[et.length - 1].transform.op._mdf = !1,
                    it -= 1,
                    rt += nt;
            return st
        }
        ,
        RepeaterModifier.prototype.addShape = function() {}
        ;
        function RoundCornersModifier() {}
        extendPrototype([ShapeModifier], RoundCornersModifier),
        RoundCornersModifier.prototype.initModifierProperties = function(_e, et) {
            this.getValue = this.processKeys,
            this.rd = PropertyFactory.getProp(_e, et.r, 0, null, this),
            this._isAnimated = !!this.rd.effectsSequence.length
        }
        ,
        RoundCornersModifier.prototype.processPath = function(_e, et) {
            var tt = shapePool.newElement();
            tt.c = _e.c;
            var rt, nt = _e._length, it, st, at, ot, lt, dt, ct = 0, ut, ft, ht, gt, bt, pt;
            for (rt = 0; rt < nt; rt += 1)
                it = _e.v[rt],
                at = _e.o[rt],
                st = _e.i[rt],
                it[0] === at[0] && it[1] === at[1] && it[0] === st[0] && it[1] === st[1] ? (rt === 0 || rt === nt - 1) && !_e.c ? (tt.setTripleAt(it[0], it[1], at[0], at[1], st[0], st[1], ct),
                ct += 1) : (rt === 0 ? ot = _e.v[nt - 1] : ot = _e.v[rt - 1],
                lt = Math.sqrt(Math.pow(it[0] - ot[0], 2) + Math.pow(it[1] - ot[1], 2)),
                dt = lt ? Math.min(lt / 2, et) / lt : 0,
                bt = it[0] + (ot[0] - it[0]) * dt,
                ut = bt,
                pt = it[1] - (it[1] - ot[1]) * dt,
                ft = pt,
                ht = ut - (ut - it[0]) * roundCorner,
                gt = ft - (ft - it[1]) * roundCorner,
                tt.setTripleAt(ut, ft, ht, gt, bt, pt, ct),
                ct += 1,
                rt === nt - 1 ? ot = _e.v[0] : ot = _e.v[rt + 1],
                lt = Math.sqrt(Math.pow(it[0] - ot[0], 2) + Math.pow(it[1] - ot[1], 2)),
                dt = lt ? Math.min(lt / 2, et) / lt : 0,
                ht = it[0] + (ot[0] - it[0]) * dt,
                ut = ht,
                gt = it[1] + (ot[1] - it[1]) * dt,
                ft = gt,
                bt = ut - (ut - it[0]) * roundCorner,
                pt = ft - (ft - it[1]) * roundCorner,
                tt.setTripleAt(ut, ft, ht, gt, bt, pt, ct),
                ct += 1) : (tt.setTripleAt(_e.v[rt][0], _e.v[rt][1], _e.o[rt][0], _e.o[rt][1], _e.i[rt][0], _e.i[rt][1], ct),
                ct += 1);
            return tt
        }
        ,
        RoundCornersModifier.prototype.processShapes = function(_e) {
            var et, tt, rt = this.shapes.length, nt, it, st = this.rd.v;
            if (st !== 0) {
                var at, ot;
                for (tt = 0; tt < rt; tt += 1) {
                    if (at = this.shapes[tt],
                    ot = at.localShapeCollection,
                    !(!at.shape._mdf && !this._mdf && !_e))
                        for (ot.releaseShapes(),
                        at.shape._mdf = !0,
                        et = at.shape.paths.shapes,
                        it = at.shape.paths._length,
                        nt = 0; nt < it; nt += 1)
                            ot.addShape(this.processPath(et[nt], st));
                    at.shape.paths = at.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function floatEqual(_e, et) {
            return Math.abs(_e - et) * 1e5 <= Math.min(Math.abs(_e), Math.abs(et))
        }
        function floatZero(_e) {
            return Math.abs(_e) <= 1e-5
        }
        function lerp(_e, et, tt) {
            return _e * (1 - tt) + et * tt
        }
        function lerpPoint(_e, et, tt) {
            return [lerp(_e[0], et[0], tt), lerp(_e[1], et[1], tt)]
        }
        function quadRoots(_e, et, tt) {
            if (_e === 0)
                return [];
            var rt = et * et - 4 * _e * tt;
            if (rt < 0)
                return [];
            var nt = -et / (2 * _e);
            if (rt === 0)
                return [nt];
            var it = Math.sqrt(rt) / (2 * _e);
            return [nt - it, nt + it]
        }
        function polynomialCoefficients(_e, et, tt, rt) {
            return [-_e + 3 * et - 3 * tt + rt, 3 * _e - 6 * et + 3 * tt, -3 * _e + 3 * et, _e]
        }
        function singlePoint(_e) {
            return new PolynomialBezier(_e,_e,_e,_e,!1)
        }
        function PolynomialBezier(_e, et, tt, rt, nt) {
            nt && pointEqual(_e, et) && (et = lerpPoint(_e, rt, 1 / 3)),
            nt && pointEqual(tt, rt) && (tt = lerpPoint(_e, rt, 2 / 3));
            var it = polynomialCoefficients(_e[0], et[0], tt[0], rt[0])
              , st = polynomialCoefficients(_e[1], et[1], tt[1], rt[1]);
            this.a = [it[0], st[0]],
            this.b = [it[1], st[1]],
            this.c = [it[2], st[2]],
            this.d = [it[3], st[3]],
            this.points = [_e, et, tt, rt]
        }
        PolynomialBezier.prototype.point = function(_e) {
            return [((this.a[0] * _e + this.b[0]) * _e + this.c[0]) * _e + this.d[0], ((this.a[1] * _e + this.b[1]) * _e + this.c[1]) * _e + this.d[1]]
        }
        ,
        PolynomialBezier.prototype.derivative = function(_e) {
            return [(3 * _e * this.a[0] + 2 * this.b[0]) * _e + this.c[0], (3 * _e * this.a[1] + 2 * this.b[1]) * _e + this.c[1]]
        }
        ,
        PolynomialBezier.prototype.tangentAngle = function(_e) {
            var et = this.derivative(_e);
            return Math.atan2(et[1], et[0])
        }
        ,
        PolynomialBezier.prototype.normalAngle = function(_e) {
            var et = this.derivative(_e);
            return Math.atan2(et[0], et[1])
        }
        ,
        PolynomialBezier.prototype.inflectionPoints = function() {
            var _e = this.a[1] * this.b[0] - this.a[0] * this.b[1];
            if (floatZero(_e))
                return [];
            var et = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / _e
              , tt = et * et - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / _e;
            if (tt < 0)
                return [];
            var rt = Math.sqrt(tt);
            return floatZero(rt) ? rt > 0 && rt < 1 ? [et] : [] : [et - rt, et + rt].filter(function(nt) {
                return nt > 0 && nt < 1
            })
        }
        ,
        PolynomialBezier.prototype.split = function(_e) {
            if (_e <= 0)
                return [singlePoint(this.points[0]), this];
            if (_e >= 1)
                return [this, singlePoint(this.points[this.points.length - 1])];
            var et = lerpPoint(this.points[0], this.points[1], _e)
              , tt = lerpPoint(this.points[1], this.points[2], _e)
              , rt = lerpPoint(this.points[2], this.points[3], _e)
              , nt = lerpPoint(et, tt, _e)
              , it = lerpPoint(tt, rt, _e)
              , st = lerpPoint(nt, it, _e);
            return [new PolynomialBezier(this.points[0],et,nt,st,!0), new PolynomialBezier(st,it,rt,this.points[3],!0)]
        }
        ;
        function extrema(_e, et) {
            var tt = _e.points[0][et]
              , rt = _e.points[_e.points.length - 1][et];
            if (tt > rt) {
                var nt = rt;
                rt = tt,
                tt = nt
            }
            for (var it = quadRoots(3 * _e.a[et], 2 * _e.b[et], _e.c[et]), st = 0; st < it.length; st += 1)
                if (it[st] > 0 && it[st] < 1) {
                    var at = _e.point(it[st])[et];
                    at < tt ? tt = at : at > rt && (rt = at)
                }
            return {
                min: tt,
                max: rt
            }
        }
        PolynomialBezier.prototype.bounds = function() {
            return {
                x: extrema(this, 0),
                y: extrema(this, 1)
            }
        }
        ,
        PolynomialBezier.prototype.boundingBox = function() {
            var _e = this.bounds();
            return {
                left: _e.x.min,
                right: _e.x.max,
                top: _e.y.min,
                bottom: _e.y.max,
                width: _e.x.max - _e.x.min,
                height: _e.y.max - _e.y.min,
                cx: (_e.x.max + _e.x.min) / 2,
                cy: (_e.y.max + _e.y.min) / 2
            }
        }
        ;
        function intersectData(_e, et, tt) {
            var rt = _e.boundingBox();
            return {
                cx: rt.cx,
                cy: rt.cy,
                width: rt.width,
                height: rt.height,
                bez: _e,
                t: (et + tt) / 2,
                t1: et,
                t2: tt
            }
        }
        function splitData(_e) {
            var et = _e.bez.split(.5);
            return [intersectData(et[0], _e.t1, _e.t), intersectData(et[1], _e.t, _e.t2)]
        }
        function boxIntersect(_e, et) {
            return Math.abs(_e.cx - et.cx) * 2 < _e.width + et.width && Math.abs(_e.cy - et.cy) * 2 < _e.height + et.height
        }
        function intersectsImpl(_e, et, tt, rt, nt, it) {
            if (boxIntersect(_e, et)) {
                if (tt >= it || _e.width <= rt && _e.height <= rt && et.width <= rt && et.height <= rt) {
                    nt.push([_e.t, et.t]);
                    return
                }
                var st = splitData(_e)
                  , at = splitData(et);
                intersectsImpl(st[0], at[0], tt + 1, rt, nt, it),
                intersectsImpl(st[0], at[1], tt + 1, rt, nt, it),
                intersectsImpl(st[1], at[0], tt + 1, rt, nt, it),
                intersectsImpl(st[1], at[1], tt + 1, rt, nt, it)
            }
        }
        PolynomialBezier.prototype.intersections = function(_e, et, tt) {
            et === void 0 && (et = 2),
            tt === void 0 && (tt = 7);
            var rt = [];
            return intersectsImpl(intersectData(this, 0, 1), intersectData(_e, 0, 1), 0, et, rt, tt),
            rt
        }
        ,
        PolynomialBezier.shapeSegment = function(_e, et) {
            var tt = (et + 1) % _e.length();
            return new PolynomialBezier(_e.v[et],_e.o[et],_e.i[tt],_e.v[tt],!0)
        }
        ,
        PolynomialBezier.shapeSegmentInverted = function(_e, et) {
            var tt = (et + 1) % _e.length();
            return new PolynomialBezier(_e.v[tt],_e.i[tt],_e.o[et],_e.v[et],!0)
        }
        ;
        function crossProduct(_e, et) {
            return [_e[1] * et[2] - _e[2] * et[1], _e[2] * et[0] - _e[0] * et[2], _e[0] * et[1] - _e[1] * et[0]]
        }
        function lineIntersection(_e, et, tt, rt) {
            var nt = [_e[0], _e[1], 1]
              , it = [et[0], et[1], 1]
              , st = [tt[0], tt[1], 1]
              , at = [rt[0], rt[1], 1]
              , ot = crossProduct(crossProduct(nt, it), crossProduct(st, at));
            return floatZero(ot[2]) ? null : [ot[0] / ot[2], ot[1] / ot[2]]
        }
        function polarOffset(_e, et, tt) {
            return [_e[0] + Math.cos(et) * tt, _e[1] - Math.sin(et) * tt]
        }
        function pointDistance(_e, et) {
            return Math.hypot(_e[0] - et[0], _e[1] - et[1])
        }
        function pointEqual(_e, et) {
            return floatEqual(_e[0], et[0]) && floatEqual(_e[1], et[1])
        }
        function ZigZagModifier() {}
        extendPrototype([ShapeModifier], ZigZagModifier),
        ZigZagModifier.prototype.initModifierProperties = function(_e, et) {
            this.getValue = this.processKeys,
            this.amplitude = PropertyFactory.getProp(_e, et.s, 0, null, this),
            this.frequency = PropertyFactory.getProp(_e, et.r, 0, null, this),
            this.pointsType = PropertyFactory.getProp(_e, et.pt, 0, null, this),
            this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0
        }
        ;
        function setPoint(_e, et, tt, rt, nt, it, st) {
            var at = tt - Math.PI / 2
              , ot = tt + Math.PI / 2
              , lt = et[0] + Math.cos(tt) * rt * nt
              , dt = et[1] - Math.sin(tt) * rt * nt;
            _e.setTripleAt(lt, dt, lt + Math.cos(at) * it, dt - Math.sin(at) * it, lt + Math.cos(ot) * st, dt - Math.sin(ot) * st, _e.length())
        }
        function getPerpendicularVector(_e, et) {
            var tt = [et[0] - _e[0], et[1] - _e[1]]
              , rt = -Math.PI * .5
              , nt = [Math.cos(rt) * tt[0] - Math.sin(rt) * tt[1], Math.sin(rt) * tt[0] + Math.cos(rt) * tt[1]];
            return nt
        }
        function getProjectingAngle(_e, et) {
            var tt = et === 0 ? _e.length() - 1 : et - 1
              , rt = (et + 1) % _e.length()
              , nt = _e.v[tt]
              , it = _e.v[rt]
              , st = getPerpendicularVector(nt, it);
            return Math.atan2(0, 1) - Math.atan2(st[1], st[0])
        }
        function zigZagCorner(_e, et, tt, rt, nt, it, st) {
            var at = getProjectingAngle(et, tt)
              , ot = et.v[tt % et._length]
              , lt = et.v[tt === 0 ? et._length - 1 : tt - 1]
              , dt = et.v[(tt + 1) % et._length]
              , ct = it === 2 ? Math.sqrt(Math.pow(ot[0] - lt[0], 2) + Math.pow(ot[1] - lt[1], 2)) : 0
              , ut = it === 2 ? Math.sqrt(Math.pow(ot[0] - dt[0], 2) + Math.pow(ot[1] - dt[1], 2)) : 0;
            setPoint(_e, et.v[tt % et._length], at, st, rt, ut / ((nt + 1) * 2), ct / ((nt + 1) * 2))
        }
        function zigZagSegment(_e, et, tt, rt, nt, it) {
            for (var st = 0; st < rt; st += 1) {
                var at = (st + 1) / (rt + 1)
                  , ot = nt === 2 ? Math.sqrt(Math.pow(et.points[3][0] - et.points[0][0], 2) + Math.pow(et.points[3][1] - et.points[0][1], 2)) : 0
                  , lt = et.normalAngle(at)
                  , dt = et.point(at);
                setPoint(_e, dt, lt, it, tt, ot / ((rt + 1) * 2), ot / ((rt + 1) * 2)),
                it = -it
            }
            return it
        }
        ZigZagModifier.prototype.processPath = function(_e, et, tt, rt) {
            var nt = _e._length
              , it = shapePool.newElement();
            if (it.c = _e.c,
            _e.c || (nt -= 1),
            nt === 0)
                return it;
            var st = -1
              , at = PolynomialBezier.shapeSegment(_e, 0);
            zigZagCorner(it, _e, 0, et, tt, rt, st);
            for (var ot = 0; ot < nt; ot += 1)
                st = zigZagSegment(it, at, et, tt, rt, -st),
                ot === nt - 1 && !_e.c ? at = null : at = PolynomialBezier.shapeSegment(_e, (ot + 1) % nt),
                zigZagCorner(it, _e, ot + 1, et, tt, rt, st);
            return it
        }
        ,
        ZigZagModifier.prototype.processShapes = function(_e) {
            var et, tt, rt = this.shapes.length, nt, it, st = this.amplitude.v, at = Math.max(0, Math.round(this.frequency.v)), ot = this.pointsType.v;
            if (st !== 0) {
                var lt, dt;
                for (tt = 0; tt < rt; tt += 1) {
                    if (lt = this.shapes[tt],
                    dt = lt.localShapeCollection,
                    !(!lt.shape._mdf && !this._mdf && !_e))
                        for (dt.releaseShapes(),
                        lt.shape._mdf = !0,
                        et = lt.shape.paths.shapes,
                        it = lt.shape.paths._length,
                        nt = 0; nt < it; nt += 1)
                            dt.addShape(this.processPath(et[nt], st, at, ot));
                    lt.shape.paths = lt.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function linearOffset(_e, et, tt) {
            var rt = Math.atan2(et[0] - _e[0], et[1] - _e[1]);
            return [polarOffset(_e, rt, tt), polarOffset(et, rt, tt)]
        }
        function offsetSegment(_e, et) {
            var tt, rt, nt, it, st, at, ot;
            ot = linearOffset(_e.points[0], _e.points[1], et),
            tt = ot[0],
            rt = ot[1],
            ot = linearOffset(_e.points[1], _e.points[2], et),
            nt = ot[0],
            it = ot[1],
            ot = linearOffset(_e.points[2], _e.points[3], et),
            st = ot[0],
            at = ot[1];
            var lt = lineIntersection(tt, rt, nt, it);
            lt === null && (lt = rt);
            var dt = lineIntersection(st, at, nt, it);
            return dt === null && (dt = st),
            new PolynomialBezier(tt,lt,dt,at)
        }
        function joinLines(_e, et, tt, rt, nt) {
            var it = et.points[3]
              , st = tt.points[0];
            if (rt === 3 || pointEqual(it, st))
                return it;
            if (rt === 2) {
                var at = -et.tangentAngle(1)
                  , ot = -tt.tangentAngle(0) + Math.PI
                  , lt = lineIntersection(it, polarOffset(it, at + Math.PI / 2, 100), st, polarOffset(st, at + Math.PI / 2, 100))
                  , dt = lt ? pointDistance(lt, it) : pointDistance(it, st) / 2
                  , ct = polarOffset(it, at, 2 * dt * roundCorner);
                return _e.setXYAt(ct[0], ct[1], "o", _e.length() - 1),
                ct = polarOffset(st, ot, 2 * dt * roundCorner),
                _e.setTripleAt(st[0], st[1], st[0], st[1], ct[0], ct[1], _e.length()),
                st
            }
            var ut = pointEqual(it, et.points[2]) ? et.points[0] : et.points[2]
              , ft = pointEqual(st, tt.points[1]) ? tt.points[3] : tt.points[1]
              , ht = lineIntersection(ut, it, st, ft);
            return ht && pointDistance(ht, it) < nt ? (_e.setTripleAt(ht[0], ht[1], ht[0], ht[1], ht[0], ht[1], _e.length()),
            ht) : it
        }
        function getIntersection(_e, et) {
            var tt = _e.intersections(et);
            return tt.length && floatEqual(tt[0][0], 1) && tt.shift(),
            tt.length ? tt[0] : null
        }
        function pruneSegmentIntersection(_e, et) {
            var tt = _e.slice()
              , rt = et.slice()
              , nt = getIntersection(_e[_e.length - 1], et[0]);
            return nt && (tt[_e.length - 1] = _e[_e.length - 1].split(nt[0])[0],
            rt[0] = et[0].split(nt[1])[1]),
            _e.length > 1 && et.length > 1 && (nt = getIntersection(_e[0], et[et.length - 1]),
            nt) ? [[_e[0].split(nt[0])[0]], [et[et.length - 1].split(nt[1])[1]]] : [tt, rt]
        }
        function pruneIntersections(_e) {
            for (var et, tt = 1; tt < _e.length; tt += 1)
                et = pruneSegmentIntersection(_e[tt - 1], _e[tt]),
                _e[tt - 1] = et[0],
                _e[tt] = et[1];
            return _e.length > 1 && (et = pruneSegmentIntersection(_e[_e.length - 1], _e[0]),
            _e[_e.length - 1] = et[0],
            _e[0] = et[1]),
            _e
        }
        function offsetSegmentSplit(_e, et) {
            var tt = _e.inflectionPoints(), rt, nt, it, st;
            if (tt.length === 0)
                return [offsetSegment(_e, et)];
            if (tt.length === 1 || floatEqual(tt[1], 1))
                return it = _e.split(tt[0]),
                rt = it[0],
                nt = it[1],
                [offsetSegment(rt, et), offsetSegment(nt, et)];
            it = _e.split(tt[0]),
            rt = it[0];
            var at = (tt[1] - tt[0]) / (1 - tt[0]);
            return it = it[1].split(at),
            st = it[0],
            nt = it[1],
            [offsetSegment(rt, et), offsetSegment(st, et), offsetSegment(nt, et)]
        }
        function OffsetPathModifier() {}
        extendPrototype([ShapeModifier], OffsetPathModifier),
        OffsetPathModifier.prototype.initModifierProperties = function(_e, et) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(_e, et.a, 0, null, this),
            this.miterLimit = PropertyFactory.getProp(_e, et.ml, 0, null, this),
            this.lineJoin = et.lj,
            this._isAnimated = this.amount.effectsSequence.length !== 0
        }
        ,
        OffsetPathModifier.prototype.processPath = function(_e, et, tt, rt) {
            var nt = shapePool.newElement();
            nt.c = _e.c;
            var it = _e.length();
            _e.c || (it -= 1);
            var st, at, ot, lt = [];
            for (st = 0; st < it; st += 1)
                ot = PolynomialBezier.shapeSegment(_e, st),
                lt.push(offsetSegmentSplit(ot, et));
            if (!_e.c)
                for (st = it - 1; st >= 0; st -= 1)
                    ot = PolynomialBezier.shapeSegmentInverted(_e, st),
                    lt.push(offsetSegmentSplit(ot, et));
            lt = pruneIntersections(lt);
            var dt = null
              , ct = null;
            for (st = 0; st < lt.length; st += 1) {
                var ut = lt[st];
                for (ct && (dt = joinLines(nt, ct, ut[0], tt, rt)),
                ct = ut[ut.length - 1],
                at = 0; at < ut.length; at += 1)
                    ot = ut[at],
                    dt && pointEqual(ot.points[0], dt) ? nt.setXYAt(ot.points[1][0], ot.points[1][1], "o", nt.length() - 1) : nt.setTripleAt(ot.points[0][0], ot.points[0][1], ot.points[1][0], ot.points[1][1], ot.points[0][0], ot.points[0][1], nt.length()),
                    nt.setTripleAt(ot.points[3][0], ot.points[3][1], ot.points[3][0], ot.points[3][1], ot.points[2][0], ot.points[2][1], nt.length()),
                    dt = ot.points[3]
            }
            return lt.length && joinLines(nt, ct, lt[0][0], tt, rt),
            nt
        }
        ,
        OffsetPathModifier.prototype.processShapes = function(_e) {
            var et, tt, rt = this.shapes.length, nt, it, st = this.amount.v, at = this.miterLimit.v, ot = this.lineJoin;
            if (st !== 0) {
                var lt, dt;
                for (tt = 0; tt < rt; tt += 1) {
                    if (lt = this.shapes[tt],
                    dt = lt.localShapeCollection,
                    !(!lt.shape._mdf && !this._mdf && !_e))
                        for (dt.releaseShapes(),
                        lt.shape._mdf = !0,
                        et = lt.shape.paths.shapes,
                        it = lt.shape.paths._length,
                        nt = 0; nt < it; nt += 1)
                            dt.addShape(this.processPath(et[nt], st, ot, at));
                    lt.shape.paths = lt.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function getFontProperties(_e) {
            for (var et = _e.fStyle ? _e.fStyle.split(" ") : [], tt = "normal", rt = "normal", nt = et.length, it, st = 0; st < nt; st += 1)
                switch (it = et[st].toLowerCase(),
                it) {
                case "italic":
                    rt = "italic";
                    break;
                case "bold":
                    tt = "700";
                    break;
                case "black":
                    tt = "900";
                    break;
                case "medium":
                    tt = "500";
                    break;
                case "regular":
                case "normal":
                    tt = "400";
                    break;
                case "light":
                case "thin":
                    tt = "200";
                    break
                }
            return {
                style: rt,
                weight: _e.fWeight || tt
            }
        }
        var FontManager = function() {
            var _e = 5e3
              , et = {
                w: 0,
                size: 0,
                shapes: [],
                data: {
                    shapes: []
                }
            }
              , tt = [];
            tt = tt.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
            var rt = 127988
              , nt = 917631
              , it = 917601
              , st = 917626
              , at = 65039
              , ot = 8205
              , lt = 127462
              , dt = 127487
              , ct = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
            function ut($t) {
                var kt = $t.split(","), At, Pt = kt.length, Dt = [];
                for (At = 0; At < Pt; At += 1)
                    kt[At] !== "sans-serif" && kt[At] !== "monospace" && Dt.push(kt[At]);
                return Dt.join(",")
            }
            function ft($t, kt) {
                var At = createTag("span");
                At.setAttribute("aria-hidden", !0),
                At.style.fontFamily = kt;
                var Pt = createTag("span");
                Pt.innerText = "giItT1WQy@!-/#",
                At.style.position = "absolute",
                At.style.left = "-10000px",
                At.style.top = "-10000px",
                At.style.fontSize = "300px",
                At.style.fontVariant = "normal",
                At.style.fontStyle = "normal",
                At.style.fontWeight = "normal",
                At.style.letterSpacing = "0",
                At.appendChild(Pt),
                document.body.appendChild(At);
                var Dt = Pt.offsetWidth;
                return Pt.style.fontFamily = ut($t) + ", " + kt,
                {
                    node: Pt,
                    w: Dt,
                    parent: At
                }
            }
            function ht() {
                var $t, kt = this.fonts.length, At, Pt, Dt = kt;
                for ($t = 0; $t < kt; $t += 1)
                    this.fonts[$t].loaded ? Dt -= 1 : this.fonts[$t].fOrigin === "n" || this.fonts[$t].origin === 0 ? this.fonts[$t].loaded = !0 : (At = this.fonts[$t].monoCase.node,
                    Pt = this.fonts[$t].monoCase.w,
                    At.offsetWidth !== Pt ? (Dt -= 1,
                    this.fonts[$t].loaded = !0) : (At = this.fonts[$t].sansCase.node,
                    Pt = this.fonts[$t].sansCase.w,
                    At.offsetWidth !== Pt && (Dt -= 1,
                    this.fonts[$t].loaded = !0)),
                    this.fonts[$t].loaded && (this.fonts[$t].sansCase.parent.parentNode.removeChild(this.fonts[$t].sansCase.parent),
                    this.fonts[$t].monoCase.parent.parentNode.removeChild(this.fonts[$t].monoCase.parent)));
                Dt !== 0 && Date.now() - this.initTime < _e ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
            }
            function gt($t, kt) {
                var At = document.body && kt ? "svg" : "canvas", Pt, Dt = getFontProperties($t);
                if (At === "svg") {
                    var Bt = createNS("text");
                    Bt.style.fontSize = "100px",
                    Bt.setAttribute("font-family", $t.fFamily),
                    Bt.setAttribute("font-style", Dt.style),
                    Bt.setAttribute("font-weight", Dt.weight),
                    Bt.textContent = "1",
                    $t.fClass ? (Bt.style.fontFamily = "inherit",
                    Bt.setAttribute("class", $t.fClass)) : Bt.style.fontFamily = $t.fFamily,
                    kt.appendChild(Bt),
                    Pt = Bt
                } else {
                    var zt = new OffscreenCanvas(500,500).getContext("2d");
                    zt.font = Dt.style + " " + Dt.weight + " 100px " + $t.fFamily,
                    Pt = zt
                }
                function Yt(rr) {
                    return At === "svg" ? (Pt.textContent = rr,
                    Pt.getComputedTextLength()) : Pt.measureText(rr).width
                }
                return {
                    measureText: Yt
                }
            }
            function bt($t, kt) {
                if (!$t) {
                    this.isLoaded = !0;
                    return
                }
                if (this.chars) {
                    this.isLoaded = !0,
                    this.fonts = $t.list;
                    return
                }
                if (!document.body) {
                    this.isLoaded = !0,
                    $t.list.forEach(function(gr) {
                        gr.helper = gt(gr),
                        gr.cache = {}
                    }),
                    this.fonts = $t.list;
                    return
                }
                var At = $t.list, Pt, Dt = At.length, Bt = Dt;
                for (Pt = 0; Pt < Dt; Pt += 1) {
                    var zt = !0, Yt, rr;
                    if (At[Pt].loaded = !1,
                    At[Pt].monoCase = ft(At[Pt].fFamily, "monospace"),
                    At[Pt].sansCase = ft(At[Pt].fFamily, "sans-serif"),
                    !At[Pt].fPath)
                        At[Pt].loaded = !0,
                        Bt -= 1;
                    else if (At[Pt].fOrigin === "p" || At[Pt].origin === 3) {
                        if (Yt = document.querySelectorAll('style[f-forigin="p"][f-family="' + At[Pt].fFamily + '"], style[f-origin="3"][f-family="' + At[Pt].fFamily + '"]'),
                        Yt.length > 0 && (zt = !1),
                        zt) {
                            var ar = createTag("style");
                            ar.setAttribute("f-forigin", At[Pt].fOrigin),
                            ar.setAttribute("f-origin", At[Pt].origin),
                            ar.setAttribute("f-family", At[Pt].fFamily),
                            ar.type = "text/css",
                            ar.innerText = "@font-face {font-family: " + At[Pt].fFamily + "; font-style: normal; src: url('" + At[Pt].fPath + "');}",
                            kt.appendChild(ar)
                        }
                    } else if (At[Pt].fOrigin === "g" || At[Pt].origin === 1) {
                        for (Yt = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'),
                        rr = 0; rr < Yt.length; rr += 1)
                            Yt[rr].href.indexOf(At[Pt].fPath) !== -1 && (zt = !1);
                        if (zt) {
                            var or = createTag("link");
                            or.setAttribute("f-forigin", At[Pt].fOrigin),
                            or.setAttribute("f-origin", At[Pt].origin),
                            or.type = "text/css",
                            or.rel = "stylesheet",
                            or.href = At[Pt].fPath,
                            document.body.appendChild(or)
                        }
                    } else if (At[Pt].fOrigin === "t" || At[Pt].origin === 2) {
                        for (Yt = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'),
                        rr = 0; rr < Yt.length; rr += 1)
                            At[Pt].fPath === Yt[rr].src && (zt = !1);
                        if (zt) {
                            var pr = createTag("link");
                            pr.setAttribute("f-forigin", At[Pt].fOrigin),
                            pr.setAttribute("f-origin", At[Pt].origin),
                            pr.setAttribute("rel", "stylesheet"),
                            pr.setAttribute("href", At[Pt].fPath),
                            kt.appendChild(pr)
                        }
                    }
                    At[Pt].helper = gt(At[Pt], kt),
                    At[Pt].cache = {},
                    this.fonts.push(At[Pt])
                }
                Bt === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
            }
            function pt($t) {
                if ($t) {
                    this.chars || (this.chars = []);
                    var kt, At = $t.length, Pt, Dt = this.chars.length, Bt;
                    for (kt = 0; kt < At; kt += 1) {
                        for (Pt = 0,
                        Bt = !1; Pt < Dt; )
                            this.chars[Pt].style === $t[kt].style && this.chars[Pt].fFamily === $t[kt].fFamily && this.chars[Pt].ch === $t[kt].ch && (Bt = !0),
                            Pt += 1;
                        Bt || (this.chars.push($t[kt]),
                        Dt += 1)
                    }
                }
            }
            function mt($t, kt, At) {
                for (var Pt = 0, Dt = this.chars.length; Pt < Dt; ) {
                    if (this.chars[Pt].ch === $t && this.chars[Pt].style === kt && this.chars[Pt].fFamily === At)
                        return this.chars[Pt];
                    Pt += 1
                }
                return (typeof $t == "string" && $t.charCodeAt(0) !== 13 || !$t) && console && console.warn && !this._warned && (this._warned = !0,
                console.warn("Missing character from exported characters list: ", $t, kt, At)),
                et
            }
            function yt($t, kt, At) {
                var Pt = this.getFontByName(kt)
                  , Dt = $t;
                if (!Pt.cache[Dt]) {
                    var Bt = Pt.helper;
                    if ($t === " ") {
                        var zt = Bt.measureText("|" + $t + "|")
                          , Yt = Bt.measureText("||");
                        Pt.cache[Dt] = (zt - Yt) / 100
                    } else
                        Pt.cache[Dt] = Bt.measureText($t) / 100
                }
                return Pt.cache[Dt] * At
            }
            function vt($t) {
                for (var kt = 0, At = this.fonts.length; kt < At; ) {
                    if (this.fonts[kt].fName === $t)
                        return this.fonts[kt];
                    kt += 1
                }
                return this.fonts[0]
            }
            function wt($t) {
                var kt = 0
                  , At = $t.charCodeAt(0);
                if (At >= 55296 && At <= 56319) {
                    var Pt = $t.charCodeAt(1);
                    Pt >= 56320 && Pt <= 57343 && (kt = (At - 55296) * 1024 + Pt - 56320 + 65536)
                }
                return kt
            }
            function _t($t, kt) {
                var At = $t.toString(16) + kt.toString(16);
                return ct.indexOf(At) !== -1
            }
            function Et($t) {
                return $t === ot
            }
            function xt($t) {
                return $t === at
            }
            function Ct($t) {
                var kt = wt($t);
                return kt >= lt && kt <= dt
            }
            function Tt($t) {
                return Ct($t.substr(0, 2)) && Ct($t.substr(2, 2))
            }
            function It($t) {
                return tt.indexOf($t) !== -1
            }
            function Nt($t, kt) {
                var At = wt($t.substr(kt, 2));
                if (At !== rt)
                    return !1;
                var Pt = 0;
                for (kt += 2; Pt < 5; ) {
                    if (At = wt($t.substr(kt, 2)),
                    At < it || At > st)
                        return !1;
                    Pt += 1,
                    kt += 2
                }
                return wt($t.substr(kt, 2)) === nt
            }
            function Ft() {
                this.isLoaded = !0
            }
            var Lt = function() {
                this.fonts = [],
                this.chars = null,
                this.typekitLoaded = 0,
                this.isLoaded = !1,
                this._warned = !1,
                this.initTime = Date.now(),
                this.setIsLoadedBinded = this.setIsLoaded.bind(this),
                this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
            };
            Lt.isModifier = _t,
            Lt.isZeroWidthJoiner = Et,
            Lt.isFlagEmoji = Tt,
            Lt.isRegionalCode = Ct,
            Lt.isCombinedCharacter = It,
            Lt.isRegionalFlag = Nt,
            Lt.isVariationSelector = xt,
            Lt.BLACK_FLAG_CODE_POINT = rt;
            var Mt = {
                addChars: pt,
                addFonts: bt,
                getCharData: mt,
                getFontByName: vt,
                measureText: yt,
                checkLoadedFonts: ht,
                setIsLoaded: Ft
            };
            return Lt.prototype = Mt,
            Lt
        }();
        function SlotManager(_e) {
            this.animationData = _e
        }
        SlotManager.prototype.getProp = function(_e) {
            return this.animationData.slots && this.animationData.slots[_e.sid] ? Object.assign(_e, this.animationData.slots[_e.sid].p) : _e
        }
        ;
        function slotFactory(_e) {
            return new SlotManager(_e)
        }
        function RenderableElement() {}
        RenderableElement.prototype = {
            initRenderable: function() {
                this.isInRange = !1,
                this.hidden = !1,
                this.isTransparent = !1,
                this.renderableComponents = []
            },
            addRenderableComponent: function(et) {
                this.renderableComponents.indexOf(et) === -1 && this.renderableComponents.push(et)
            },
            removeRenderableComponent: function(et) {
                this.renderableComponents.indexOf(et) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(et), 1)
            },
            prepareRenderableFrame: function(et) {
                this.checkLayerLimits(et)
            },
            checkTransparency: function() {
                this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0,
                this.hide()) : this.isTransparent && (this.isTransparent = !1,
                this.show())
            },
            checkLayerLimits: function(et) {
                this.data.ip - this.data.st <= et && this.data.op - this.data.st > et ? this.isInRange !== !0 && (this.globalData._mdf = !0,
                this._mdf = !0,
                this.isInRange = !0,
                this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0,
                this.isInRange = !1,
                this.hide())
            },
            renderRenderable: function() {
                var et, tt = this.renderableComponents.length;
                for (et = 0; et < tt; et += 1)
                    this.renderableComponents[et].renderFrame(this._isFirstFrame)
            },
            sourceRectAtTime: function() {
                return {
                    top: 0,
                    left: 0,
                    width: 100,
                    height: 100
                }
            },
            getLayerSize: function() {
                return this.data.ty === 5 ? {
                    w: this.data.textData.width,
                    h: this.data.textData.height
                } : {
                    w: this.data.width,
                    h: this.data.height
                }
            }
        };
        var getBlendMode = function() {
            var _e = {
                0: "source-over",
                1: "multiply",
                2: "screen",
                3: "overlay",
                4: "darken",
                5: "lighten",
                6: "color-dodge",
                7: "color-burn",
                8: "hard-light",
                9: "soft-light",
                10: "difference",
                11: "exclusion",
                12: "hue",
                13: "saturation",
                14: "color",
                15: "luminosity"
            };
            return function(et) {
                return _e[et] || ""
            }
        }();
        function SliderEffect(_e, et, tt) {
            this.p = PropertyFactory.getProp(et, _e.v, 0, 0, tt)
        }
        function AngleEffect(_e, et, tt) {
            this.p = PropertyFactory.getProp(et, _e.v, 0, 0, tt)
        }
        function ColorEffect(_e, et, tt) {
            this.p = PropertyFactory.getProp(et, _e.v, 1, 0, tt)
        }
        function PointEffect(_e, et, tt) {
            this.p = PropertyFactory.getProp(et, _e.v, 1, 0, tt)
        }
        function LayerIndexEffect(_e, et, tt) {
            this.p = PropertyFactory.getProp(et, _e.v, 0, 0, tt)
        }
        function MaskIndexEffect(_e, et, tt) {
            this.p = PropertyFactory.getProp(et, _e.v, 0, 0, tt)
        }
        function CheckboxEffect(_e, et, tt) {
            this.p = PropertyFactory.getProp(et, _e.v, 0, 0, tt)
        }
        function NoValueEffect() {
            this.p = {}
        }
        function EffectsManager(_e, et) {
            var tt = _e.ef || [];
            this.effectElements = [];
            var rt, nt = tt.length, it;
            for (rt = 0; rt < nt; rt += 1)
                it = new GroupEffect(tt[rt],et),
                this.effectElements.push(it)
        }
        function GroupEffect(_e, et) {
            this.init(_e, et)
        }
        extendPrototype([DynamicPropertyContainer], GroupEffect),
        GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties,
        GroupEffect.prototype.init = function(_e, et) {
            this.data = _e,
            this.effectElements = [],
            this.initDynamicPropertyContainer(et);
            var tt, rt = this.data.ef.length, nt, it = this.data.ef;
            for (tt = 0; tt < rt; tt += 1) {
                switch (nt = null,
                it[tt].ty) {
                case 0:
                    nt = new SliderEffect(it[tt],et,this);
                    break;
                case 1:
                    nt = new AngleEffect(it[tt],et,this);
                    break;
                case 2:
                    nt = new ColorEffect(it[tt],et,this);
                    break;
                case 3:
                    nt = new PointEffect(it[tt],et,this);
                    break;
                case 4:
                case 7:
                    nt = new CheckboxEffect(it[tt],et,this);
                    break;
                case 10:
                    nt = new LayerIndexEffect(it[tt],et,this);
                    break;
                case 11:
                    nt = new MaskIndexEffect(it[tt],et,this);
                    break;
                case 5:
                    nt = new EffectsManager(it[tt],et);
                    break;
                default:
                    nt = new NoValueEffect(it[tt]);
                    break
                }
                nt && this.effectElements.push(nt)
            }
        }
        ;
        function BaseElement() {}
        BaseElement.prototype = {
            checkMasks: function() {
                if (!this.data.hasMask)
                    return !1;
                for (var et = 0, tt = this.data.masksProperties.length; et < tt; ) {
                    if (this.data.masksProperties[et].mode !== "n" && this.data.masksProperties[et].cl !== !1)
                        return !0;
                    et += 1
                }
                return !1
            },
            initExpressions: function() {
                var et = getExpressionInterfaces();
                if (et) {
                    var tt = et("layer")
                      , rt = et("effects")
                      , nt = et("shape")
                      , it = et("text")
                      , st = et("comp");
                    this.layerInterface = tt(this),
                    this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                    var at = rt.createEffectsInterface(this, this.layerInterface);
                    this.layerInterface.registerEffectsInterface(at),
                    this.data.ty === 0 || this.data.xt ? this.compInterface = st(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = nt(this.shapesData, this.itemsData, this.layerInterface),
                    this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = it(this),
                    this.layerInterface.text = this.layerInterface.textInterface)
                }
            },
            setBlendMode: function() {
                var et = getBlendMode(this.data.bm)
                  , tt = this.baseElement || this.layerElement;
                tt.style["mix-blend-mode"] = et
            },
            initBaseData: function(et, tt, rt) {
                this.globalData = tt,
                this.comp = rt,
                this.data = et,
                this.layerId = createElementID(),
                this.data.sr || (this.data.sr = 1),
                this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties)
            },
            getType: function() {
                return this.type
            },
            sourceRectAtTime: function() {}
        };
        function FrameElement() {}
        FrameElement.prototype = {
            initFrame: function() {
                this._isFirstFrame = !1,
                this.dynamicProperties = [],
                this._mdf = !1
            },
            prepareProperties: function(et, tt) {
                var rt, nt = this.dynamicProperties.length;
                for (rt = 0; rt < nt; rt += 1)
                    (tt || this._isParent && this.dynamicProperties[rt].propType === "transform") && (this.dynamicProperties[rt].getValue(),
                    this.dynamicProperties[rt]._mdf && (this.globalData._mdf = !0,
                    this._mdf = !0))
            },
            addDynamicProperty: function(et) {
                this.dynamicProperties.indexOf(et) === -1 && this.dynamicProperties.push(et)
            }
        };
        function FootageElement(_e, et, tt) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = et.getAssetData(_e.refId),
            this.footageData = et.imageLoader.getAsset(this.assetData),
            this.initBaseData(_e, et, tt)
        }
        FootageElement.prototype.prepareFrame = function() {}
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement),
        FootageElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        FootageElement.prototype.renderFrame = function() {}
        ,
        FootageElement.prototype.destroy = function() {}
        ,
        FootageElement.prototype.initExpressions = function() {
            var _e = getExpressionInterfaces();
            if (_e) {
                var et = _e("footage");
                this.layerInterface = et(this)
            }
        }
        ,
        FootageElement.prototype.getFootageData = function() {
            return this.footageData
        }
        ;
        function AudioElement(_e, et, tt) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = et.getAssetData(_e.refId),
            this.initBaseData(_e, et, tt),
            this._isPlaying = !1,
            this._canPlay = !1;
            var rt = this.globalData.getAssetsPath(this.assetData);
            this.audio = this.globalData.audioController.createAudio(rt),
            this._currentTime = 0,
            this.globalData.audioController.addAudio(this),
            this._volumeMultiplier = 1,
            this._volume = 1,
            this._previousVolume = null,
            this.tm = _e.tm ? PropertyFactory.getProp(this, _e.tm, 0, et.frameRate, this) : {
                _placeholder: !0
            },
            this.lv = PropertyFactory.getProp(this, _e.au && _e.au.lv ? _e.au.lv : {
                k: [100]
            }, 1, .01, this)
        }
        AudioElement.prototype.prepareFrame = function(_e) {
            if (this.prepareRenderableFrame(_e, !0),
            this.prepareProperties(_e, !0),
            this.tm._placeholder)
                this._currentTime = _e / this.data.sr;
            else {
                var et = this.tm.v;
                this._currentTime = et
            }
            this._volume = this.lv.v[0];
            var tt = this._volume * this._volumeMultiplier;
            this._previousVolume !== tt && (this._previousVolume = tt,
            this.audio.volume(tt))
        }
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement),
        AudioElement.prototype.renderFrame = function() {
            this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(),
            this.audio.seek(this._currentTime / this.globalData.frameRate),
            this._isPlaying = !0))
        }
        ,
        AudioElement.prototype.show = function() {}
        ,
        AudioElement.prototype.hide = function() {
            this.audio.pause(),
            this._isPlaying = !1
        }
        ,
        AudioElement.prototype.pause = function() {
            this.audio.pause(),
            this._isPlaying = !1,
            this._canPlay = !1
        }
        ,
        AudioElement.prototype.resume = function() {
            this._canPlay = !0
        }
        ,
        AudioElement.prototype.setRate = function(_e) {
            this.audio.rate(_e)
        }
        ,
        AudioElement.prototype.volume = function(_e) {
            this._volumeMultiplier = _e,
            this._previousVolume = _e * this._volume,
            this.audio.volume(this._previousVolume)
        }
        ,
        AudioElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        AudioElement.prototype.destroy = function() {}
        ,
        AudioElement.prototype.sourceRectAtTime = function() {}
        ,
        AudioElement.prototype.initExpressions = function() {}
        ;
        function BaseRenderer() {}
        BaseRenderer.prototype.checkLayers = function(_e) {
            var et, tt = this.layers.length, rt;
            for (this.completeLayers = !0,
            et = tt - 1; et >= 0; et -= 1)
                this.elements[et] || (rt = this.layers[et],
                rt.ip - rt.st <= _e - this.layers[et].st && rt.op - rt.st > _e - this.layers[et].st && this.buildItem(et)),
                this.completeLayers = this.elements[et] ? this.completeLayers : !1;
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.createItem = function(_e) {
            switch (_e.ty) {
            case 2:
                return this.createImage(_e);
            case 0:
                return this.createComp(_e);
            case 1:
                return this.createSolid(_e);
            case 3:
                return this.createNull(_e);
            case 4:
                return this.createShape(_e);
            case 5:
                return this.createText(_e);
            case 6:
                return this.createAudio(_e);
            case 13:
                return this.createCamera(_e);
            case 15:
                return this.createFootage(_e);
            default:
                return this.createNull(_e)
            }
        }
        ,
        BaseRenderer.prototype.createCamera = function() {
            throw new Error("You're using a 3d camera. Try the html renderer.")
        }
        ,
        BaseRenderer.prototype.createAudio = function(_e) {
            return new AudioElement(_e,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.createFootage = function(_e) {
            return new FootageElement(_e,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.buildAllItems = function() {
            var _e, et = this.layers.length;
            for (_e = 0; _e < et; _e += 1)
                this.buildItem(_e);
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.includeLayers = function(_e) {
            this.completeLayers = !1;
            var et, tt = _e.length, rt, nt = this.layers.length;
            for (et = 0; et < tt; et += 1)
                for (rt = 0; rt < nt; ) {
                    if (this.layers[rt].id === _e[et].id) {
                        this.layers[rt] = _e[et];
                        break
                    }
                    rt += 1
                }
        }
        ,
        BaseRenderer.prototype.setProjectInterface = function(_e) {
            this.globalData.projectInterface = _e
        }
        ,
        BaseRenderer.prototype.initItems = function() {
            this.globalData.progressiveLoad || this.buildAllItems()
        }
        ,
        BaseRenderer.prototype.buildElementParenting = function(_e, et, tt) {
            for (var rt = this.elements, nt = this.layers, it = 0, st = nt.length; it < st; )
                nt[it].ind == et && (!rt[it] || rt[it] === !0 ? (this.buildItem(it),
                this.addPendingElement(_e)) : (tt.push(rt[it]),
                rt[it].setAsParent(),
                nt[it].parent !== void 0 ? this.buildElementParenting(_e, nt[it].parent, tt) : _e.setHierarchy(tt))),
                it += 1
        }
        ,
        BaseRenderer.prototype.addPendingElement = function(_e) {
            this.pendingElements.push(_e)
        }
        ,
        BaseRenderer.prototype.searchExtraCompositions = function(_e) {
            var et, tt = _e.length;
            for (et = 0; et < tt; et += 1)
                if (_e[et].xt) {
                    var rt = this.createComp(_e[et]);
                    rt.initExpressions(),
                    this.globalData.projectInterface.registerComposition(rt)
                }
        }
        ,
        BaseRenderer.prototype.getElementById = function(_e) {
            var et, tt = this.elements.length;
            for (et = 0; et < tt; et += 1)
                if (this.elements[et].data.ind === _e)
                    return this.elements[et];
            return null
        }
        ,
        BaseRenderer.prototype.getElementByPath = function(_e) {
            var et = _e.shift(), tt;
            if (typeof et == "number")
                tt = this.elements[et];
            else {
                var rt, nt = this.elements.length;
                for (rt = 0; rt < nt; rt += 1)
                    if (this.elements[rt].data.nm === et) {
                        tt = this.elements[rt];
                        break
                    }
            }
            return _e.length === 0 ? tt : tt.getElementByPath(_e)
        }
        ,
        BaseRenderer.prototype.setupGlobalData = function(_e, et) {
            this.globalData.fontManager = new FontManager,
            this.globalData.slotManager = slotFactory(_e),
            this.globalData.fontManager.addChars(_e.chars),
            this.globalData.fontManager.addFonts(_e.fonts, et),
            this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem),
            this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem),
            this.globalData.imageLoader = this.animationItem.imagePreloader,
            this.globalData.audioController = this.animationItem.audioController,
            this.globalData.frameId = 0,
            this.globalData.frameRate = _e.fr,
            this.globalData.nm = _e.nm,
            this.globalData.compSize = {
                w: _e.w,
                h: _e.h
            }
        }
        ;
        var effectTypes = {
            TRANSFORM_EFFECT: "transformEFfect"
        };
        function TransformElement() {}
        TransformElement.prototype = {
            initTransform: function() {
                var et = new Matrix;
                this.finalTransform = {
                    mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                        o: 0
                    },
                    _matMdf: !1,
                    _localMatMdf: !1,
                    _opMdf: !1,
                    mat: et,
                    localMat: et,
                    localOpacity: 1
                },
                this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
                this.data.ty
            },
            renderTransform: function() {
                if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame,
                this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame,
                this.hierarchy) {
                    var et, tt = this.finalTransform.mat, rt = 0, nt = this.hierarchy.length;
                    if (!this.finalTransform._matMdf)
                        for (; rt < nt; ) {
                            if (this.hierarchy[rt].finalTransform.mProp._mdf) {
                                this.finalTransform._matMdf = !0;
                                break
                            }
                            rt += 1
                        }
                    if (this.finalTransform._matMdf)
                        for (et = this.finalTransform.mProp.v.props,
                        tt.cloneFromProps(et),
                        rt = 0; rt < nt; rt += 1)
                            tt.multiply(this.hierarchy[rt].finalTransform.mProp.v)
                }
                this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
                this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
            },
            renderLocalTransform: function() {
                if (this.localTransforms) {
                    var et = 0
                      , tt = this.localTransforms.length;
                    if (this.finalTransform._localMatMdf = this.finalTransform._matMdf,
                    !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
                        for (; et < tt; )
                            this.localTransforms[et]._mdf && (this.finalTransform._localMatMdf = !0),
                            this.localTransforms[et]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v,
                            this.finalTransform._opMdf = !0),
                            et += 1;
                    if (this.finalTransform._localMatMdf) {
                        var rt = this.finalTransform.localMat;
                        for (this.localTransforms[0].matrix.clone(rt),
                        et = 1; et < tt; et += 1) {
                            var nt = this.localTransforms[et].matrix;
                            rt.multiply(nt)
                        }
                        rt.multiply(this.finalTransform.mat)
                    }
                    if (this.finalTransform._opMdf) {
                        var it = this.finalTransform.localOpacity;
                        for (et = 0; et < tt; et += 1)
                            it *= this.localTransforms[et].opacity * .01;
                        this.finalTransform.localOpacity = it
                    }
                }
            },
            searchEffectTransforms: function() {
                if (this.renderableEffectsManager) {
                    var et = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                    if (et.length) {
                        this.localTransforms = [],
                        this.finalTransform.localMat = new Matrix;
                        var tt = 0
                          , rt = et.length;
                        for (tt = 0; tt < rt; tt += 1)
                            this.localTransforms.push(et[tt])
                    }
                }
            },
            globalToLocal: function(et) {
                var tt = [];
                tt.push(this.finalTransform);
                for (var rt = !0, nt = this.comp; rt; )
                    nt.finalTransform ? (nt.data.hasMask && tt.splice(0, 0, nt.finalTransform),
                    nt = nt.comp) : rt = !1;
                var it, st = tt.length, at;
                for (it = 0; it < st; it += 1)
                    at = tt[it].mat.applyToPointArray(0, 0, 0),
                    et = [et[0] - at[0], et[1] - at[1], 0];
                return et
            },
            mHelper: new Matrix
        };
        function MaskElement(_e, et, tt) {
            this.data = _e,
            this.element = et,
            this.globalData = tt,
            this.storedData = [],
            this.masksProperties = this.data.masksProperties || [],
            this.maskElement = null;
            var rt = this.globalData.defs, nt, it = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(it),
            this.solidPath = "";
            var st, at = this.masksProperties, ot = 0, lt = [], dt, ct, ut = createElementID(), ft, ht, gt, bt, pt = "clipPath", mt = "clip-path";
            for (nt = 0; nt < it; nt += 1)
                if ((at[nt].mode !== "a" && at[nt].mode !== "n" || at[nt].inv || at[nt].o.k !== 100 || at[nt].o.x) && (pt = "mask",
                mt = "mask"),
                (at[nt].mode === "s" || at[nt].mode === "i") && ot === 0 ? (ft = createNS("rect"),
                ft.setAttribute("fill", "#ffffff"),
                ft.setAttribute("width", this.element.comp.data.w || 0),
                ft.setAttribute("height", this.element.comp.data.h || 0),
                lt.push(ft)) : ft = null,
                st = createNS("path"),
                at[nt].mode === "n")
                    this.viewData[nt] = {
                        op: PropertyFactory.getProp(this.element, at[nt].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, at[nt], 3),
                        elem: st,
                        lastPath: ""
                    },
                    rt.appendChild(st);
                else {
                    ot += 1,
                    st.setAttribute("fill", at[nt].mode === "s" ? "#000000" : "#ffffff"),
                    st.setAttribute("clip-rule", "nonzero");
                    var yt;
                    if (at[nt].x.k !== 0 ? (pt = "mask",
                    mt = "mask",
                    bt = PropertyFactory.getProp(this.element, at[nt].x, 0, null, this.element),
                    yt = createElementID(),
                    ht = createNS("filter"),
                    ht.setAttribute("id", yt),
                    gt = createNS("feMorphology"),
                    gt.setAttribute("operator", "erode"),
                    gt.setAttribute("in", "SourceGraphic"),
                    gt.setAttribute("radius", "0"),
                    ht.appendChild(gt),
                    rt.appendChild(ht),
                    st.setAttribute("stroke", at[nt].mode === "s" ? "#000000" : "#ffffff")) : (gt = null,
                    bt = null),
                    this.storedData[nt] = {
                        elem: st,
                        x: bt,
                        expan: gt,
                        lastPath: "",
                        lastOperator: "",
                        filterId: yt,
                        lastRadius: 0
                    },
                    at[nt].mode === "i") {
                        ct = lt.length;
                        var vt = createNS("g");
                        for (dt = 0; dt < ct; dt += 1)
                            vt.appendChild(lt[dt]);
                        var wt = createNS("mask");
                        wt.setAttribute("mask-type", "alpha"),
                        wt.setAttribute("id", ut + "_" + ot),
                        wt.appendChild(st),
                        rt.appendChild(wt),
                        vt.setAttribute("mask", "url(" + getLocationHref() + "#" + ut + "_" + ot + ")"),
                        lt.length = 0,
                        lt.push(vt)
                    } else
                        lt.push(st);
                    at[nt].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()),
                    this.viewData[nt] = {
                        elem: st,
                        lastPath: "",
                        op: PropertyFactory.getProp(this.element, at[nt].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, at[nt], 3),
                        invRect: ft
                    },
                    this.viewData[nt].prop.k || this.drawPath(at[nt], this.viewData[nt].prop.v, this.viewData[nt])
                }
            for (this.maskElement = createNS(pt),
            it = lt.length,
            nt = 0; nt < it; nt += 1)
                this.maskElement.appendChild(lt[nt]);
            ot > 0 && (this.maskElement.setAttribute("id", ut),
            this.element.maskedElement.setAttribute(mt, "url(" + getLocationHref() + "#" + ut + ")"),
            rt.appendChild(this.maskElement)),
            this.viewData.length && this.element.addRenderableComponent(this)
        }
        MaskElement.prototype.getMaskProperty = function(_e) {
            return this.viewData[_e].prop
        }
        ,
        MaskElement.prototype.renderFrame = function(_e) {
            var et = this.element.finalTransform.mat, tt, rt = this.masksProperties.length;
            for (tt = 0; tt < rt; tt += 1)
                if ((this.viewData[tt].prop._mdf || _e) && this.drawPath(this.masksProperties[tt], this.viewData[tt].prop.v, this.viewData[tt]),
                (this.viewData[tt].op._mdf || _e) && this.viewData[tt].elem.setAttribute("fill-opacity", this.viewData[tt].op.v),
                this.masksProperties[tt].mode !== "n" && (this.viewData[tt].invRect && (this.element.finalTransform.mProp._mdf || _e) && this.viewData[tt].invRect.setAttribute("transform", et.getInverseMatrix().to2dCSS()),
                this.storedData[tt].x && (this.storedData[tt].x._mdf || _e))) {
                    var nt = this.storedData[tt].expan;
                    this.storedData[tt].x.v < 0 ? (this.storedData[tt].lastOperator !== "erode" && (this.storedData[tt].lastOperator = "erode",
                    this.storedData[tt].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[tt].filterId + ")")),
                    nt.setAttribute("radius", -this.storedData[tt].x.v)) : (this.storedData[tt].lastOperator !== "dilate" && (this.storedData[tt].lastOperator = "dilate",
                    this.storedData[tt].elem.setAttribute("filter", null)),
                    this.storedData[tt].elem.setAttribute("stroke-width", this.storedData[tt].x.v * 2))
                }
        }
        ,
        MaskElement.prototype.getMaskelement = function() {
            return this.maskElement
        }
        ,
        MaskElement.prototype.createLayerSolidPath = function() {
            var _e = "M0,0 ";
            return _e += " h" + this.globalData.compSize.w,
            _e += " v" + this.globalData.compSize.h,
            _e += " h-" + this.globalData.compSize.w,
            _e += " v-" + this.globalData.compSize.h + " ",
            _e
        }
        ,
        MaskElement.prototype.drawPath = function(_e, et, tt) {
            var rt = " M" + et.v[0][0] + "," + et.v[0][1], nt, it;
            for (it = et._length,
            nt = 1; nt < it; nt += 1)
                rt += " C" + et.o[nt - 1][0] + "," + et.o[nt - 1][1] + " " + et.i[nt][0] + "," + et.i[nt][1] + " " + et.v[nt][0] + "," + et.v[nt][1];
            if (et.c && it > 1 && (rt += " C" + et.o[nt - 1][0] + "," + et.o[nt - 1][1] + " " + et.i[0][0] + "," + et.i[0][1] + " " + et.v[0][0] + "," + et.v[0][1]),
            tt.lastPath !== rt) {
                var st = "";
                tt.elem && (et.c && (st = _e.inv ? this.solidPath + rt : rt),
                tt.elem.setAttribute("d", st)),
                tt.lastPath = rt
            }
        }
        ,
        MaskElement.prototype.destroy = function() {
            this.element = null,
            this.globalData = null,
            this.maskElement = null,
            this.data = null,
            this.masksProperties = null
        }
        ;
        var filtersFactory = function() {
            var _e = {};
            _e.createFilter = et,
            _e.createAlphaToLuminanceFilter = tt;
            function et(rt, nt) {
                var it = createNS("filter");
                return it.setAttribute("id", rt),
                nt !== !0 && (it.setAttribute("filterUnits", "objectBoundingBox"),
                it.setAttribute("x", "0%"),
                it.setAttribute("y", "0%"),
                it.setAttribute("width", "100%"),
                it.setAttribute("height", "100%")),
                it
            }
            function tt() {
                var rt = createNS("feColorMatrix");
                return rt.setAttribute("type", "matrix"),
                rt.setAttribute("color-interpolation-filters", "sRGB"),
                rt.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"),
                rt
            }
            return _e
        }()
          , featureSupport = function() {
            var _e = {
                maskType: !0,
                svgLumaHidden: !0,
                offscreenCanvas: typeof OffscreenCanvas < "u"
            };
            return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (_e.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (_e.svgLumaHidden = !1),
            _e
        }()
          , registeredEffects$1 = {}
          , idPrefix = "filter_result_";
        function SVGEffects(_e) {
            var et, tt = "SourceGraphic", rt = _e.data.ef ? _e.data.ef.length : 0, nt = createElementID(), it = filtersFactory.createFilter(nt, !0), st = 0;
            this.filters = [];
            var at;
            for (et = 0; et < rt; et += 1) {
                at = null;
                var ot = _e.data.ef[et].ty;
                if (registeredEffects$1[ot]) {
                    var lt = registeredEffects$1[ot].effect;
                    at = new lt(it,_e.effectsManager.effectElements[et],_e,idPrefix + st,tt),
                    tt = idPrefix + st,
                    registeredEffects$1[ot].countsAsEffect && (st += 1)
                }
                at && this.filters.push(at)
            }
            st && (_e.globalData.defs.appendChild(it),
            _e.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + nt + ")")),
            this.filters.length && _e.addRenderableComponent(this)
        }
        SVGEffects.prototype.renderFrame = function(_e) {
            var et, tt = this.filters.length;
            for (et = 0; et < tt; et += 1)
                this.filters[et].renderFrame(_e)
        }
        ,
        SVGEffects.prototype.getEffects = function(_e) {
            var et, tt = this.filters.length, rt = [];
            for (et = 0; et < tt; et += 1)
                this.filters[et].type === _e && rt.push(this.filters[et]);
            return rt
        }
        ;
        function registerEffect$1(_e, et, tt) {
            registeredEffects$1[_e] = {
                effect: et,
                countsAsEffect: tt
            }
        }
        function SVGBaseElement() {}
        SVGBaseElement.prototype = {
            initRendererElement: function() {
                this.layerElement = createNS("g")
            },
            createContainerElements: function() {
                this.matteElement = createNS("g"),
                this.transformedElement = this.layerElement,
                this.maskedElement = this.layerElement,
                this._sizeChanged = !1;
                var et = null;
                if (this.data.td) {
                    this.matteMasks = {};
                    var tt = createNS("g");
                    tt.setAttribute("id", this.layerId),
                    tt.appendChild(this.layerElement),
                    et = tt,
                    this.globalData.defs.appendChild(tt)
                } else
                    this.data.tt ? (this.matteElement.appendChild(this.layerElement),
                    et = this.matteElement,
                    this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.ty === 0 && !this.data.hd) {
                    var rt = createNS("clipPath")
                      , nt = createNS("path");
                    nt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                    var it = createElementID();
                    if (rt.setAttribute("id", it),
                    rt.appendChild(nt),
                    this.globalData.defs.appendChild(rt),
                    this.checkMasks()) {
                        var st = createNS("g");
                        st.setAttribute("clip-path", "url(" + getLocationHref() + "#" + it + ")"),
                        st.appendChild(this.layerElement),
                        this.transformedElement = st,
                        et ? et.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                    } else
                        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + it + ")")
                }
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()),
                this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
            },
            destroyBaseElement: function() {
                this.layerElement = null,
                this.matteElement = null,
                this.maskManager.destroy()
            },
            getBaseElement: function() {
                return this.data.hd ? null : this.baseElement
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData),
                this.renderableEffectsManager = new SVGEffects(this),
                this.searchEffectTransforms()
            },
            getMatte: function(et) {
                if (this.matteMasks || (this.matteMasks = {}),
                !this.matteMasks[et]) {
                    var tt = this.layerId + "_" + et, rt, nt, it, st;
                    if (et === 1 || et === 3) {
                        var at = createNS("mask");
                        at.setAttribute("id", tt),
                        at.setAttribute("mask-type", et === 3 ? "luminance" : "alpha"),
                        it = createNS("use"),
                        it.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        at.appendChild(it),
                        this.globalData.defs.appendChild(at),
                        !featureSupport.maskType && et === 1 && (at.setAttribute("mask-type", "luminance"),
                        rt = createElementID(),
                        nt = filtersFactory.createFilter(rt),
                        this.globalData.defs.appendChild(nt),
                        nt.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        st = createNS("g"),
                        st.appendChild(it),
                        at.appendChild(st),
                        st.setAttribute("filter", "url(" + getLocationHref() + "#" + rt + ")"))
                    } else if (et === 2) {
                        var ot = createNS("mask");
                        ot.setAttribute("id", tt),
                        ot.setAttribute("mask-type", "alpha");
                        var lt = createNS("g");
                        ot.appendChild(lt),
                        rt = createElementID(),
                        nt = filtersFactory.createFilter(rt);
                        var dt = createNS("feComponentTransfer");
                        dt.setAttribute("in", "SourceGraphic"),
                        nt.appendChild(dt);
                        var ct = createNS("feFuncA");
                        ct.setAttribute("type", "table"),
                        ct.setAttribute("tableValues", "1.0 0.0"),
                        dt.appendChild(ct),
                        this.globalData.defs.appendChild(nt);
                        var ut = createNS("rect");
                        ut.setAttribute("width", this.comp.data.w),
                        ut.setAttribute("height", this.comp.data.h),
                        ut.setAttribute("x", "0"),
                        ut.setAttribute("y", "0"),
                        ut.setAttribute("fill", "#ffffff"),
                        ut.setAttribute("opacity", "0"),
                        lt.setAttribute("filter", "url(" + getLocationHref() + "#" + rt + ")"),
                        lt.appendChild(ut),
                        it = createNS("use"),
                        it.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        lt.appendChild(it),
                        featureSupport.maskType || (ot.setAttribute("mask-type", "luminance"),
                        nt.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        st = createNS("g"),
                        lt.appendChild(ut),
                        st.appendChild(this.layerElement),
                        lt.appendChild(st)),
                        this.globalData.defs.appendChild(ot)
                    }
                    this.matteMasks[et] = tt
                }
                return this.matteMasks[et]
            },
            setMatte: function(et) {
                this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + et + ")")
            }
        };
        function HierarchyElement() {}
        HierarchyElement.prototype = {
            initHierarchy: function() {
                this.hierarchy = [],
                this._isParent = !1,
                this.checkParenting()
            },
            setHierarchy: function(et) {
                this.hierarchy = et
            },
            setAsParent: function() {
                this._isParent = !0
            },
            checkParenting: function() {
                this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, [])
            }
        };
        function RenderableDOMElement() {}
        (function() {
            var _e = {
                initElement: function(tt, rt, nt) {
                    this.initFrame(),
                    this.initBaseData(tt, rt, nt),
                    this.initTransform(tt, rt, nt),
                    this.initHierarchy(),
                    this.initRenderable(),
                    this.initRendererElement(),
                    this.createContainerElements(),
                    this.createRenderableComponents(),
                    this.createContent(),
                    this.hide()
                },
                hide: function() {
                    if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                        var tt = this.baseElement || this.layerElement;
                        tt.style.display = "none",
                        this.hidden = !0
                    }
                },
                show: function() {
                    if (this.isInRange && !this.isTransparent) {
                        if (!this.data.hd) {
                            var tt = this.baseElement || this.layerElement;
                            tt.style.display = "block"
                        }
                        this.hidden = !1,
                        this._isFirstFrame = !0
                    }
                },
                renderFrame: function() {
                    this.data.hd || this.hidden || (this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.renderElement(),
                    this.renderInnerContent(),
                    this._isFirstFrame && (this._isFirstFrame = !1))
                },
                renderInnerContent: function() {},
                prepareFrame: function(tt) {
                    this._mdf = !1,
                    this.prepareRenderableFrame(tt),
                    this.prepareProperties(tt, this.isInRange),
                    this.checkTransparency()
                },
                destroy: function() {
                    this.innerElem = null,
                    this.destroyBaseElement()
                }
            };
            extendPrototype([RenderableElement, createProxyFunction(_e)], RenderableDOMElement)
        }
        )();
        function IImageElement(_e, et, tt) {
            this.assetData = et.getAssetData(_e.refId),
            this.assetData && this.assetData.sid && (this.assetData = et.slotManager.getProp(this.assetData)),
            this.initElement(_e, et, tt),
            this.sourceRect = {
                top: 0,
                left: 0,
                width: this.assetData.w,
                height: this.assetData.h
            }
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement),
        IImageElement.prototype.createContent = function() {
            var _e = this.globalData.getAssetsPath(this.assetData);
            this.innerElem = createNS("image"),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio),
            this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", _e),
            this.layerElement.appendChild(this.innerElem)
        }
        ,
        IImageElement.prototype.sourceRectAtTime = function() {
            return this.sourceRect
        }
        ;
        function ProcessedElement(_e, et) {
            this.elem = _e,
            this.pos = et
        }
        function IShapeElement() {}
        IShapeElement.prototype = {
            addShapeToModifiers: function(et) {
                var tt, rt = this.shapeModifiers.length;
                for (tt = 0; tt < rt; tt += 1)
                    this.shapeModifiers[tt].addShape(et)
            },
            isShapeInAnimatedModifiers: function(et) {
                for (var tt = 0, rt = this.shapeModifiers.length; tt < rt; )
                    if (this.shapeModifiers[tt].isAnimatedWithShape(et))
                        return !0;
                return !1
            },
            renderModifiers: function() {
                if (this.shapeModifiers.length) {
                    var et, tt = this.shapes.length;
                    for (et = 0; et < tt; et += 1)
                        this.shapes[et].sh.reset();
                    tt = this.shapeModifiers.length;
                    var rt;
                    for (et = tt - 1; et >= 0 && (rt = this.shapeModifiers[et].processShapes(this._isFirstFrame),
                    !rt); et -= 1)
                        ;
                }
            },
            searchProcessedElement: function(et) {
                for (var tt = this.processedElements, rt = 0, nt = tt.length; rt < nt; ) {
                    if (tt[rt].elem === et)
                        return tt[rt].pos;
                    rt += 1
                }
                return 0
            },
            addProcessedElement: function(et, tt) {
                for (var rt = this.processedElements, nt = rt.length; nt; )
                    if (nt -= 1,
                    rt[nt].elem === et) {
                        rt[nt].pos = tt;
                        return
                    }
                rt.push(new ProcessedElement(et,tt))
            },
            prepareFrame: function(et) {
                this.prepareRenderableFrame(et),
                this.prepareProperties(et, this.isInRange)
            }
        };
        var lineCapEnum = {
            1: "butt",
            2: "round",
            3: "square"
        }
          , lineJoinEnum = {
            1: "miter",
            2: "round",
            3: "bevel"
        };
        function SVGShapeData(_e, et, tt) {
            this.caches = [],
            this.styles = [],
            this.transformers = _e,
            this.lStr = "",
            this.sh = tt,
            this.lvl = et,
            this._isAnimated = !!tt.k;
            for (var rt = 0, nt = _e.length; rt < nt; ) {
                if (_e[rt].mProps.dynamicProperties.length) {
                    this._isAnimated = !0;
                    break
                }
                rt += 1
            }
        }
        SVGShapeData.prototype.setAsAnimated = function() {
            this._isAnimated = !0
        }
        ;
        function SVGStyleData(_e, et) {
            this.data = _e,
            this.type = _e.ty,
            this.d = "",
            this.lvl = et,
            this._mdf = !1,
            this.closed = _e.hd === !0,
            this.pElem = createNS("path"),
            this.msElem = null
        }
        SVGStyleData.prototype.reset = function() {
            this.d = "",
            this._mdf = !1
        }
        ;
        function DashProperty(_e, et, tt, rt) {
            this.elem = _e,
            this.frameId = -1,
            this.dataProps = createSizedArray(et.length),
            this.renderer = tt,
            this.k = !1,
            this.dashStr = "",
            this.dashArray = createTypedArray("float32", et.length ? et.length - 1 : 0),
            this.dashoffset = createTypedArray("float32", 1),
            this.initDynamicPropertyContainer(rt);
            var nt, it = et.length || 0, st;
            for (nt = 0; nt < it; nt += 1)
                st = PropertyFactory.getProp(_e, et[nt].v, 0, 0, this),
                this.k = st.k || this.k,
                this.dataProps[nt] = {
                    n: et[nt].n,
                    p: st
                };
            this.k || this.getValue(!0),
            this._isAnimated = this.k
        }
        DashProperty.prototype.getValue = function(_e) {
            if (!(this.elem.globalData.frameId === this.frameId && !_e) && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties(),
            this._mdf = this._mdf || _e,
            this._mdf)) {
                var et = 0
                  , tt = this.dataProps.length;
                for (this.renderer === "svg" && (this.dashStr = ""),
                et = 0; et < tt; et += 1)
                    this.dataProps[et].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[et].p.v : this.dashArray[et] = this.dataProps[et].p.v : this.dashoffset[0] = this.dataProps[et].p.v
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], DashProperty);
        function SVGStrokeStyleData(_e, et, tt) {
            this.initDynamicPropertyContainer(_e),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(_e, et.o, 0, .01, this),
            this.w = PropertyFactory.getProp(_e, et.w, 0, null, this),
            this.d = new DashProperty(_e,et.d || {},"svg",this),
            this.c = PropertyFactory.getProp(_e, et.c, 1, 255, this),
            this.style = tt,
            this._isAnimated = !!this._isAnimated
        }
        extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
        function SVGFillStyleData(_e, et, tt) {
            this.initDynamicPropertyContainer(_e),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(_e, et.o, 0, .01, this),
            this.c = PropertyFactory.getProp(_e, et.c, 1, 255, this),
            this.style = tt
        }
        extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
        function SVGNoStyleData(_e, et, tt) {
            this.initDynamicPropertyContainer(_e),
            this.getValue = this.iterateDynamicProperties,
            this.style = tt
        }
        extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
        function GradientProperty(_e, et, tt) {
            this.data = et,
            this.c = createTypedArray("uint8c", et.p * 4);
            var rt = et.k.k[0].s ? et.k.k[0].s.length - et.p * 4 : et.k.k.length - et.p * 4;
            this.o = createTypedArray("float32", rt),
            this._cmdf = !1,
            this._omdf = !1,
            this._collapsable = this.checkCollapsable(),
            this._hasOpacity = rt,
            this.initDynamicPropertyContainer(tt),
            this.prop = PropertyFactory.getProp(_e, et.k, 1, null, this),
            this.k = this.prop.k,
            this.getValue(!0)
        }
        GradientProperty.prototype.comparePoints = function(_e, et) {
            for (var tt = 0, rt = this.o.length / 2, nt; tt < rt; ) {
                if (nt = Math.abs(_e[tt * 4] - _e[et * 4 + tt * 2]),
                nt > .01)
                    return !1;
                tt += 1
            }
            return !0
        }
        ,
        GradientProperty.prototype.checkCollapsable = function() {
            if (this.o.length / 2 !== this.c.length / 4)
                return !1;
            if (this.data.k.k[0].s)
                for (var _e = 0, et = this.data.k.k.length; _e < et; ) {
                    if (!this.comparePoints(this.data.k.k[_e].s, this.data.p))
                        return !1;
                    _e += 1
                }
            else if (!this.comparePoints(this.data.k.k, this.data.p))
                return !1;
            return !0
        }
        ,
        GradientProperty.prototype.getValue = function(_e) {
            if (this.prop.getValue(),
            this._mdf = !1,
            this._cmdf = !1,
            this._omdf = !1,
            this.prop._mdf || _e) {
                var et, tt = this.data.p * 4, rt, nt;
                for (et = 0; et < tt; et += 1)
                    rt = et % 4 === 0 ? 100 : 255,
                    nt = Math.round(this.prop.v[et] * rt),
                    this.c[et] !== nt && (this.c[et] = nt,
                    this._cmdf = !_e);
                if (this.o.length)
                    for (tt = this.prop.v.length,
                    et = this.data.p * 4; et < tt; et += 1)
                        rt = et % 2 === 0 ? 100 : 1,
                        nt = et % 2 === 0 ? Math.round(this.prop.v[et] * 100) : this.prop.v[et],
                        this.o[et - this.data.p * 4] !== nt && (this.o[et - this.data.p * 4] = nt,
                        this._omdf = !_e);
                this._mdf = !_e
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], GradientProperty);
        function SVGGradientFillStyleData(_e, et, tt) {
            this.initDynamicPropertyContainer(_e),
            this.getValue = this.iterateDynamicProperties,
            this.initGradientData(_e, et, tt)
        }
        SVGGradientFillStyleData.prototype.initGradientData = function(_e, et, tt) {
            this.o = PropertyFactory.getProp(_e, et.o, 0, .01, this),
            this.s = PropertyFactory.getProp(_e, et.s, 1, null, this),
            this.e = PropertyFactory.getProp(_e, et.e, 1, null, this),
            this.h = PropertyFactory.getProp(_e, et.h || {
                k: 0
            }, 0, .01, this),
            this.a = PropertyFactory.getProp(_e, et.a || {
                k: 0
            }, 0, degToRads, this),
            this.g = new GradientProperty(_e,et.g,this),
            this.style = tt,
            this.stops = [],
            this.setGradientData(tt.pElem, et),
            this.setGradientOpacity(et, tt),
            this._isAnimated = !!this._isAnimated
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientData = function(_e, et) {
            var tt = createElementID()
              , rt = createNS(et.t === 1 ? "linearGradient" : "radialGradient");
            rt.setAttribute("id", tt),
            rt.setAttribute("spreadMethod", "pad"),
            rt.setAttribute("gradientUnits", "userSpaceOnUse");
            var nt = [], it, st, at;
            for (at = et.g.p * 4,
            st = 0; st < at; st += 4)
                it = createNS("stop"),
                rt.appendChild(it),
                nt.push(it);
            _e.setAttribute(et.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + tt + ")"),
            this.gf = rt,
            this.cst = nt
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientOpacity = function(_e, et) {
            if (this.g._hasOpacity && !this.g._collapsable) {
                var tt, rt, nt, it = createNS("mask"), st = createNS("path");
                it.appendChild(st);
                var at = createElementID()
                  , ot = createElementID();
                it.setAttribute("id", ot);
                var lt = createNS(_e.t === 1 ? "linearGradient" : "radialGradient");
                lt.setAttribute("id", at),
                lt.setAttribute("spreadMethod", "pad"),
                lt.setAttribute("gradientUnits", "userSpaceOnUse"),
                nt = _e.g.k.k[0].s ? _e.g.k.k[0].s.length : _e.g.k.k.length;
                var dt = this.stops;
                for (rt = _e.g.p * 4; rt < nt; rt += 2)
                    tt = createNS("stop"),
                    tt.setAttribute("stop-color", "rgb(255,255,255)"),
                    lt.appendChild(tt),
                    dt.push(tt);
                st.setAttribute(_e.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + at + ")"),
                _e.ty === "gs" && (st.setAttribute("stroke-linecap", lineCapEnum[_e.lc || 2]),
                st.setAttribute("stroke-linejoin", lineJoinEnum[_e.lj || 2]),
                _e.lj === 1 && st.setAttribute("stroke-miterlimit", _e.ml)),
                this.of = lt,
                this.ms = it,
                this.ost = dt,
                this.maskId = ot,
                et.msElem = st
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
        function SVGGradientStrokeStyleData(_e, et, tt) {
            this.initDynamicPropertyContainer(_e),
            this.getValue = this.iterateDynamicProperties,
            this.w = PropertyFactory.getProp(_e, et.w, 0, null, this),
            this.d = new DashProperty(_e,et.d || {},"svg",this),
            this.initGradientData(_e, et, tt),
            this._isAnimated = !!this._isAnimated
        }
        extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        function ShapeGroupData() {
            this.it = [],
            this.prevViewData = [],
            this.gr = createNS("g")
        }
        function SVGTransformData(_e, et, tt) {
            this.transform = {
                mProps: _e,
                op: et,
                container: tt
            },
            this.elements = [],
            this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
        }
        var buildShapeString = function(et, tt, rt, nt) {
            if (tt === 0)
                return "";
            var it = et.o, st = et.i, at = et.v, ot, lt = " M" + nt.applyToPointStringified(at[0][0], at[0][1]);
            for (ot = 1; ot < tt; ot += 1)
                lt += " C" + nt.applyToPointStringified(it[ot - 1][0], it[ot - 1][1]) + " " + nt.applyToPointStringified(st[ot][0], st[ot][1]) + " " + nt.applyToPointStringified(at[ot][0], at[ot][1]);
            return rt && tt && (lt += " C" + nt.applyToPointStringified(it[ot - 1][0], it[ot - 1][1]) + " " + nt.applyToPointStringified(st[0][0], st[0][1]) + " " + nt.applyToPointStringified(at[0][0], at[0][1]),
            lt += "z"),
            lt
        }
          , SVGElementsRenderer = function() {
            var _e = new Matrix
              , et = new Matrix
              , tt = {
                createRenderFunction: rt
            };
            function rt(ct) {
                switch (ct.ty) {
                case "fl":
                    return at;
                case "gf":
                    return lt;
                case "gs":
                    return ot;
                case "st":
                    return dt;
                case "sh":
                case "el":
                case "rc":
                case "sr":
                    return st;
                case "tr":
                    return nt;
                case "no":
                    return it;
                default:
                    return null
                }
            }
            function nt(ct, ut, ft) {
                (ft || ut.transform.op._mdf) && ut.transform.container.setAttribute("opacity", ut.transform.op.v),
                (ft || ut.transform.mProps._mdf) && ut.transform.container.setAttribute("transform", ut.transform.mProps.v.to2dCSS())
            }
            function it() {}
            function st(ct, ut, ft) {
                var ht, gt, bt, pt, mt, yt, vt = ut.styles.length, wt = ut.lvl, _t, Et, xt, Ct;
                for (yt = 0; yt < vt; yt += 1) {
                    if (pt = ut.sh._mdf || ft,
                    ut.styles[yt].lvl < wt) {
                        for (Et = et.reset(),
                        xt = wt - ut.styles[yt].lvl,
                        Ct = ut.transformers.length - 1; !pt && xt > 0; )
                            pt = ut.transformers[Ct].mProps._mdf || pt,
                            xt -= 1,
                            Ct -= 1;
                        if (pt)
                            for (xt = wt - ut.styles[yt].lvl,
                            Ct = ut.transformers.length - 1; xt > 0; )
                                Et.multiply(ut.transformers[Ct].mProps.v),
                                xt -= 1,
                                Ct -= 1
                    } else
                        Et = _e;
                    if (_t = ut.sh.paths,
                    gt = _t._length,
                    pt) {
                        for (bt = "",
                        ht = 0; ht < gt; ht += 1)
                            mt = _t.shapes[ht],
                            mt && mt._length && (bt += buildShapeString(mt, mt._length, mt.c, Et));
                        ut.caches[yt] = bt
                    } else
                        bt = ut.caches[yt];
                    ut.styles[yt].d += ct.hd === !0 ? "" : bt,
                    ut.styles[yt]._mdf = pt || ut.styles[yt]._mdf
                }
            }
            function at(ct, ut, ft) {
                var ht = ut.style;
                (ut.c._mdf || ft) && ht.pElem.setAttribute("fill", "rgb(" + bmFloor(ut.c.v[0]) + "," + bmFloor(ut.c.v[1]) + "," + bmFloor(ut.c.v[2]) + ")"),
                (ut.o._mdf || ft) && ht.pElem.setAttribute("fill-opacity", ut.o.v)
            }
            function ot(ct, ut, ft) {
                lt(ct, ut, ft),
                dt(ct, ut, ft)
            }
            function lt(ct, ut, ft) {
                var ht = ut.gf
                  , gt = ut.g._hasOpacity
                  , bt = ut.s.v
                  , pt = ut.e.v;
                if (ut.o._mdf || ft) {
                    var mt = ct.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                    ut.style.pElem.setAttribute(mt, ut.o.v)
                }
                if (ut.s._mdf || ft) {
                    var yt = ct.t === 1 ? "x1" : "cx"
                      , vt = yt === "x1" ? "y1" : "cy";
                    ht.setAttribute(yt, bt[0]),
                    ht.setAttribute(vt, bt[1]),
                    gt && !ut.g._collapsable && (ut.of.setAttribute(yt, bt[0]),
                    ut.of.setAttribute(vt, bt[1]))
                }
                var wt, _t, Et, xt;
                if (ut.g._cmdf || ft) {
                    wt = ut.cst;
                    var Ct = ut.g.c;
                    for (Et = wt.length,
                    _t = 0; _t < Et; _t += 1)
                        xt = wt[_t],
                        xt.setAttribute("offset", Ct[_t * 4] + "%"),
                        xt.setAttribute("stop-color", "rgb(" + Ct[_t * 4 + 1] + "," + Ct[_t * 4 + 2] + "," + Ct[_t * 4 + 3] + ")")
                }
                if (gt && (ut.g._omdf || ft)) {
                    var Tt = ut.g.o;
                    for (ut.g._collapsable ? wt = ut.cst : wt = ut.ost,
                    Et = wt.length,
                    _t = 0; _t < Et; _t += 1)
                        xt = wt[_t],
                        ut.g._collapsable || xt.setAttribute("offset", Tt[_t * 2] + "%"),
                        xt.setAttribute("stop-opacity", Tt[_t * 2 + 1])
                }
                if (ct.t === 1)
                    (ut.e._mdf || ft) && (ht.setAttribute("x2", pt[0]),
                    ht.setAttribute("y2", pt[1]),
                    gt && !ut.g._collapsable && (ut.of.setAttribute("x2", pt[0]),
                    ut.of.setAttribute("y2", pt[1])));
                else {
                    var It;
                    if ((ut.s._mdf || ut.e._mdf || ft) && (It = Math.sqrt(Math.pow(bt[0] - pt[0], 2) + Math.pow(bt[1] - pt[1], 2)),
                    ht.setAttribute("r", It),
                    gt && !ut.g._collapsable && ut.of.setAttribute("r", It)),
                    ut.e._mdf || ut.h._mdf || ut.a._mdf || ft) {
                        It || (It = Math.sqrt(Math.pow(bt[0] - pt[0], 2) + Math.pow(bt[1] - pt[1], 2)));
                        var Nt = Math.atan2(pt[1] - bt[1], pt[0] - bt[0])
                          , Ft = ut.h.v;
                        Ft >= 1 ? Ft = .99 : Ft <= -1 && (Ft = -.99);
                        var Lt = It * Ft
                          , Mt = Math.cos(Nt + ut.a.v) * Lt + bt[0]
                          , $t = Math.sin(Nt + ut.a.v) * Lt + bt[1];
                        ht.setAttribute("fx", Mt),
                        ht.setAttribute("fy", $t),
                        gt && !ut.g._collapsable && (ut.of.setAttribute("fx", Mt),
                        ut.of.setAttribute("fy", $t))
                    }
                }
            }
            function dt(ct, ut, ft) {
                var ht = ut.style
                  , gt = ut.d;
                gt && (gt._mdf || ft) && gt.dashStr && (ht.pElem.setAttribute("stroke-dasharray", gt.dashStr),
                ht.pElem.setAttribute("stroke-dashoffset", gt.dashoffset[0])),
                ut.c && (ut.c._mdf || ft) && ht.pElem.setAttribute("stroke", "rgb(" + bmFloor(ut.c.v[0]) + "," + bmFloor(ut.c.v[1]) + "," + bmFloor(ut.c.v[2]) + ")"),
                (ut.o._mdf || ft) && ht.pElem.setAttribute("stroke-opacity", ut.o.v),
                (ut.w._mdf || ft) && (ht.pElem.setAttribute("stroke-width", ut.w.v),
                ht.msElem && ht.msElem.setAttribute("stroke-width", ut.w.v))
            }
            return tt
        }();
        function SVGShapeElement(_e, et, tt) {
            this.shapes = [],
            this.shapesData = _e.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.initElement(_e, et, tt),
            this.prevViewData = []
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement),
        SVGShapeElement.prototype.initSecondaryElement = function() {}
        ,
        SVGShapeElement.prototype.identityMatrix = new Matrix,
        SVGShapeElement.prototype.buildExpressionInterface = function() {}
        ,
        SVGShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes()
        }
        ,
        SVGShapeElement.prototype.filterUniqueShapes = function() {
            var _e, et = this.shapes.length, tt, rt, nt = this.stylesList.length, it, st = [], at = !1;
            for (rt = 0; rt < nt; rt += 1) {
                for (it = this.stylesList[rt],
                at = !1,
                st.length = 0,
                _e = 0; _e < et; _e += 1)
                    tt = this.shapes[_e],
                    tt.styles.indexOf(it) !== -1 && (st.push(tt),
                    at = tt._isAnimated || at);
                st.length > 1 && at && this.setShapesAsAnimated(st)
            }
        }
        ,
        SVGShapeElement.prototype.setShapesAsAnimated = function(_e) {
            var et, tt = _e.length;
            for (et = 0; et < tt; et += 1)
                _e[et].setAsAnimated()
        }
        ,
        SVGShapeElement.prototype.createStyleElement = function(_e, et) {
            var tt, rt = new SVGStyleData(_e,et), nt = rt.pElem;
            if (_e.ty === "st")
                tt = new SVGStrokeStyleData(this,_e,rt);
            else if (_e.ty === "fl")
                tt = new SVGFillStyleData(this,_e,rt);
            else if (_e.ty === "gf" || _e.ty === "gs") {
                var it = _e.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
                tt = new it(this,_e,rt),
                this.globalData.defs.appendChild(tt.gf),
                tt.maskId && (this.globalData.defs.appendChild(tt.ms),
                this.globalData.defs.appendChild(tt.of),
                nt.setAttribute("mask", "url(" + getLocationHref() + "#" + tt.maskId + ")"))
            } else
                _e.ty === "no" && (tt = new SVGNoStyleData(this,_e,rt));
            return (_e.ty === "st" || _e.ty === "gs") && (nt.setAttribute("stroke-linecap", lineCapEnum[_e.lc || 2]),
            nt.setAttribute("stroke-linejoin", lineJoinEnum[_e.lj || 2]),
            nt.setAttribute("fill-opacity", "0"),
            _e.lj === 1 && nt.setAttribute("stroke-miterlimit", _e.ml)),
            _e.r === 2 && nt.setAttribute("fill-rule", "evenodd"),
            _e.ln && nt.setAttribute("id", _e.ln),
            _e.cl && nt.setAttribute("class", _e.cl),
            _e.bm && (nt.style["mix-blend-mode"] = getBlendMode(_e.bm)),
            this.stylesList.push(rt),
            this.addToAnimatedContents(_e, tt),
            tt
        }
        ,
        SVGShapeElement.prototype.createGroupElement = function(_e) {
            var et = new ShapeGroupData;
            return _e.ln && et.gr.setAttribute("id", _e.ln),
            _e.cl && et.gr.setAttribute("class", _e.cl),
            _e.bm && (et.gr.style["mix-blend-mode"] = getBlendMode(_e.bm)),
            et
        }
        ,
        SVGShapeElement.prototype.createTransformElement = function(_e, et) {
            var tt = TransformPropertyFactory.getTransformProperty(this, _e, this)
              , rt = new SVGTransformData(tt,tt.o,et);
            return this.addToAnimatedContents(_e, rt),
            rt
        }
        ,
        SVGShapeElement.prototype.createShapeElement = function(_e, et, tt) {
            var rt = 4;
            _e.ty === "rc" ? rt = 5 : _e.ty === "el" ? rt = 6 : _e.ty === "sr" && (rt = 7);
            var nt = ShapePropertyFactory.getShapeProp(this, _e, rt, this)
              , it = new SVGShapeData(et,tt,nt);
            return this.shapes.push(it),
            this.addShapeToModifiers(it),
            this.addToAnimatedContents(_e, it),
            it
        }
        ,
        SVGShapeElement.prototype.addToAnimatedContents = function(_e, et) {
            for (var tt = 0, rt = this.animatedContents.length; tt < rt; ) {
                if (this.animatedContents[tt].element === et)
                    return;
                tt += 1
            }
            this.animatedContents.push({
                fn: SVGElementsRenderer.createRenderFunction(_e),
                element: et,
                data: _e
            })
        }
        ,
        SVGShapeElement.prototype.setElementStyles = function(_e) {
            var et = _e.styles, tt, rt = this.stylesList.length;
            for (tt = 0; tt < rt; tt += 1)
                this.stylesList[tt].closed || et.push(this.stylesList[tt])
        }
        ,
        SVGShapeElement.prototype.reloadShapes = function() {
            this._isFirstFrame = !0;
            var _e, et = this.itemsData.length;
            for (_e = 0; _e < et; _e += 1)
                this.prevViewData[_e] = this.itemsData[_e];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes(),
            et = this.dynamicProperties.length,
            _e = 0; _e < et; _e += 1)
                this.dynamicProperties[_e].getValue();
            this.renderModifiers()
        }
        ,
        SVGShapeElement.prototype.searchShapes = function(_e, et, tt, rt, nt, it, st) {
            var at = [].concat(it), ot, lt = _e.length - 1, dt, ct, ut = [], ft = [], ht, gt, bt;
            for (ot = lt; ot >= 0; ot -= 1) {
                if (bt = this.searchProcessedElement(_e[ot]),
                bt ? et[ot] = tt[bt - 1] : _e[ot]._render = st,
                _e[ot].ty === "fl" || _e[ot].ty === "st" || _e[ot].ty === "gf" || _e[ot].ty === "gs" || _e[ot].ty === "no")
                    bt ? et[ot].style.closed = !1 : et[ot] = this.createStyleElement(_e[ot], nt),
                    _e[ot]._render && et[ot].style.pElem.parentNode !== rt && rt.appendChild(et[ot].style.pElem),
                    ut.push(et[ot].style);
                else if (_e[ot].ty === "gr") {
                    if (!bt)
                        et[ot] = this.createGroupElement(_e[ot]);
                    else
                        for (ct = et[ot].it.length,
                        dt = 0; dt < ct; dt += 1)
                            et[ot].prevViewData[dt] = et[ot].it[dt];
                    this.searchShapes(_e[ot].it, et[ot].it, et[ot].prevViewData, et[ot].gr, nt + 1, at, st),
                    _e[ot]._render && et[ot].gr.parentNode !== rt && rt.appendChild(et[ot].gr)
                } else
                    _e[ot].ty === "tr" ? (bt || (et[ot] = this.createTransformElement(_e[ot], rt)),
                    ht = et[ot].transform,
                    at.push(ht)) : _e[ot].ty === "sh" || _e[ot].ty === "rc" || _e[ot].ty === "el" || _e[ot].ty === "sr" ? (bt || (et[ot] = this.createShapeElement(_e[ot], at, nt)),
                    this.setElementStyles(et[ot])) : _e[ot].ty === "tm" || _e[ot].ty === "rd" || _e[ot].ty === "ms" || _e[ot].ty === "pb" || _e[ot].ty === "zz" || _e[ot].ty === "op" ? (bt ? (gt = et[ot],
                    gt.closed = !1) : (gt = ShapeModifiers.getModifier(_e[ot].ty),
                    gt.init(this, _e[ot]),
                    et[ot] = gt,
                    this.shapeModifiers.push(gt)),
                    ft.push(gt)) : _e[ot].ty === "rp" && (bt ? (gt = et[ot],
                    gt.closed = !0) : (gt = ShapeModifiers.getModifier(_e[ot].ty),
                    et[ot] = gt,
                    gt.init(this, _e, ot, et),
                    this.shapeModifiers.push(gt),
                    st = !1),
                    ft.push(gt));
                this.addProcessedElement(_e[ot], ot + 1)
            }
            for (lt = ut.length,
            ot = 0; ot < lt; ot += 1)
                ut[ot].closed = !0;
            for (lt = ft.length,
            ot = 0; ot < lt; ot += 1)
                ft[ot].closed = !0
        }
        ,
        SVGShapeElement.prototype.renderInnerContent = function() {
            this.renderModifiers();
            var _e, et = this.stylesList.length;
            for (_e = 0; _e < et; _e += 1)
                this.stylesList[_e].reset();
            for (this.renderShape(),
            _e = 0; _e < et; _e += 1)
                (this.stylesList[_e]._mdf || this._isFirstFrame) && (this.stylesList[_e].msElem && (this.stylesList[_e].msElem.setAttribute("d", this.stylesList[_e].d),
                this.stylesList[_e].d = "M0 0" + this.stylesList[_e].d),
                this.stylesList[_e].pElem.setAttribute("d", this.stylesList[_e].d || "M0 0"))
        }
        ,
        SVGShapeElement.prototype.renderShape = function() {
            var _e, et = this.animatedContents.length, tt;
            for (_e = 0; _e < et; _e += 1)
                tt = this.animatedContents[_e],
                (this._isFirstFrame || tt.element._isAnimated) && tt.data !== !0 && tt.fn(tt.data, tt.element, this._isFirstFrame)
        }
        ,
        SVGShapeElement.prototype.destroy = function() {
            this.destroyBaseElement(),
            this.shapesData = null,
            this.itemsData = null
        }
        ;
        function LetterProps(_e, et, tt, rt, nt, it) {
            this.o = _e,
            this.sw = et,
            this.sc = tt,
            this.fc = rt,
            this.m = nt,
            this.p = it,
            this._mdf = {
                o: !0,
                sw: !!et,
                sc: !!tt,
                fc: !!rt,
                m: !0,
                p: !0
            }
        }
        LetterProps.prototype.update = function(_e, et, tt, rt, nt, it) {
            this._mdf.o = !1,
            this._mdf.sw = !1,
            this._mdf.sc = !1,
            this._mdf.fc = !1,
            this._mdf.m = !1,
            this._mdf.p = !1;
            var st = !1;
            return this.o !== _e && (this.o = _e,
            this._mdf.o = !0,
            st = !0),
            this.sw !== et && (this.sw = et,
            this._mdf.sw = !0,
            st = !0),
            this.sc !== tt && (this.sc = tt,
            this._mdf.sc = !0,
            st = !0),
            this.fc !== rt && (this.fc = rt,
            this._mdf.fc = !0,
            st = !0),
            this.m !== nt && (this.m = nt,
            this._mdf.m = !0,
            st = !0),
            it.length && (this.p[0] !== it[0] || this.p[1] !== it[1] || this.p[4] !== it[4] || this.p[5] !== it[5] || this.p[12] !== it[12] || this.p[13] !== it[13]) && (this.p = it,
            this._mdf.p = !0,
            st = !0),
            st
        }
        ;
        function TextProperty(_e, et) {
            this._frameId = initialDefaultFrame,
            this.pv = "",
            this.v = "",
            this.kf = !1,
            this._isFirstFrame = !0,
            this._mdf = !1,
            et.d && et.d.sid && (et.d = _e.globalData.slotManager.getProp(et.d)),
            this.data = et,
            this.elem = _e,
            this.comp = this.elem.comp,
            this.keysIndex = 0,
            this.canResize = !1,
            this.minimumFontSize = 1,
            this.effectsSequence = [],
            this.currentData = {
                ascent: 0,
                boxWidth: this.defaultBoxWidth,
                f: "",
                fStyle: "",
                fWeight: "",
                fc: "",
                j: "",
                justifyOffset: "",
                l: [],
                lh: 0,
                lineWidths: [],
                ls: "",
                of: "",
                s: "",
                sc: "",
                sw: 0,
                t: 0,
                tr: 0,
                sz: 0,
                ps: null,
                fillColorAnim: !1,
                strokeColorAnim: !1,
                strokeWidthAnim: !1,
                yOffset: 0,
                finalSize: 0,
                finalText: [],
                finalLineHeight: 0,
                __complete: !1
            },
            this.copyData(this.currentData, this.data.d.k[0].s),
            this.searchProperty() || this.completeTextData(this.currentData)
        }
        TextProperty.prototype.defaultBoxWidth = [0, 0],
        TextProperty.prototype.copyData = function(_e, et) {
            for (var tt in et)
                Object.prototype.hasOwnProperty.call(et, tt) && (_e[tt] = et[tt]);
            return _e
        }
        ,
        TextProperty.prototype.setCurrentData = function(_e) {
            _e.__complete || this.completeTextData(_e),
            this.currentData = _e,
            this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth,
            this._mdf = !0
        }
        ,
        TextProperty.prototype.searchProperty = function() {
            return this.searchKeyframes()
        }
        ,
        TextProperty.prototype.searchKeyframes = function() {
            return this.kf = this.data.d.k.length > 1,
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
        }
        ,
        TextProperty.prototype.addEffect = function(_e) {
            this.effectsSequence.push(_e),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.getValue = function(_e) {
            if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_e)) {
                this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                var et = this.currentData
                  , tt = this.keysIndex;
                if (this.lock) {
                    this.setCurrentData(this.currentData);
                    return
                }
                this.lock = !0,
                this._mdf = !1;
                var rt, nt = this.effectsSequence.length, it = _e || this.data.d.k[this.keysIndex].s;
                for (rt = 0; rt < nt; rt += 1)
                    tt !== this.keysIndex ? it = this.effectsSequence[rt](it, it.t) : it = this.effectsSequence[rt](this.currentData, it.t);
                et !== it && this.setCurrentData(it),
                this.v = this.currentData,
                this.pv = this.v,
                this.lock = !1,
                this.frameId = this.elem.globalData.frameId
            }
        }
        ,
        TextProperty.prototype.getKeyframeValue = function() {
            for (var _e = this.data.d.k, et = this.elem.comp.renderedFrame, tt = 0, rt = _e.length; tt <= rt - 1 && !(tt === rt - 1 || _e[tt + 1].t > et); )
                tt += 1;
            return this.keysIndex !== tt && (this.keysIndex = tt),
            this.data.d.k[this.keysIndex].s
        }
        ,
        TextProperty.prototype.buildFinalText = function(_e) {
            for (var et = [], tt = 0, rt = _e.length, nt, it, st = !1, at = !1, ot = ""; tt < rt; )
                st = at,
                at = !1,
                nt = _e.charCodeAt(tt),
                ot = _e.charAt(tt),
                FontManager.isCombinedCharacter(nt) ? st = !0 : nt >= 55296 && nt <= 56319 ? FontManager.isRegionalFlag(_e, tt) ? ot = _e.substr(tt, 14) : (it = _e.charCodeAt(tt + 1),
                it >= 56320 && it <= 57343 && (FontManager.isModifier(nt, it) ? (ot = _e.substr(tt, 2),
                st = !0) : FontManager.isFlagEmoji(_e.substr(tt, 4)) ? ot = _e.substr(tt, 4) : ot = _e.substr(tt, 2))) : nt > 56319 ? (it = _e.charCodeAt(tt + 1),
                FontManager.isVariationSelector(nt) && (st = !0)) : FontManager.isZeroWidthJoiner(nt) && (st = !0,
                at = !0),
                st ? (et[et.length - 1] += ot,
                st = !1) : et.push(ot),
                tt += ot.length;
            return et
        }
        ,
        TextProperty.prototype.completeTextData = function(_e) {
            _e.__complete = !0;
            var et = this.elem.globalData.fontManager, tt = this.data, rt = [], nt, it, st, at = 0, ot, lt = tt.m.g, dt = 0, ct = 0, ut = 0, ft = [], ht = 0, gt = 0, bt, pt, mt = et.getFontByName(_e.f), yt, vt = 0, wt = getFontProperties(mt);
            _e.fWeight = wt.weight,
            _e.fStyle = wt.style,
            _e.finalSize = _e.s,
            _e.finalText = this.buildFinalText(_e.t),
            it = _e.finalText.length,
            _e.finalLineHeight = _e.lh;
            var _t = _e.tr / 1e3 * _e.finalSize, Et;
            if (_e.sz)
                for (var xt = !0, Ct = _e.sz[0], Tt = _e.sz[1], It, Nt; xt; ) {
                    Nt = this.buildFinalText(_e.t),
                    It = 0,
                    ht = 0,
                    it = Nt.length,
                    _t = _e.tr / 1e3 * _e.finalSize;
                    var Ft = -1;
                    for (nt = 0; nt < it; nt += 1)
                        Et = Nt[nt].charCodeAt(0),
                        st = !1,
                        Nt[nt] === " " ? Ft = nt : (Et === 13 || Et === 3) && (ht = 0,
                        st = !0,
                        It += _e.finalLineHeight || _e.finalSize * 1.2),
                        et.chars ? (yt = et.getCharData(Nt[nt], mt.fStyle, mt.fFamily),
                        vt = st ? 0 : yt.w * _e.finalSize / 100) : vt = et.measureText(Nt[nt], _e.f, _e.finalSize),
                        ht + vt > Ct && Nt[nt] !== " " ? (Ft === -1 ? it += 1 : nt = Ft,
                        It += _e.finalLineHeight || _e.finalSize * 1.2,
                        Nt.splice(nt, Ft === nt ? 1 : 0, "\r"),
                        Ft = -1,
                        ht = 0) : (ht += vt,
                        ht += _t);
                    It += mt.ascent * _e.finalSize / 100,
                    this.canResize && _e.finalSize > this.minimumFontSize && Tt < It ? (_e.finalSize -= 1,
                    _e.finalLineHeight = _e.finalSize * _e.lh / _e.s) : (_e.finalText = Nt,
                    it = _e.finalText.length,
                    xt = !1)
                }
            ht = -_t,
            vt = 0;
            var Lt = 0, Mt;
            for (nt = 0; nt < it; nt += 1)
                if (st = !1,
                Mt = _e.finalText[nt],
                Et = Mt.charCodeAt(0),
                Et === 13 || Et === 3 ? (Lt = 0,
                ft.push(ht),
                gt = ht > gt ? ht : gt,
                ht = -2 * _t,
                ot = "",
                st = !0,
                ut += 1) : ot = Mt,
                et.chars ? (yt = et.getCharData(Mt, mt.fStyle, et.getFontByName(_e.f).fFamily),
                vt = st ? 0 : yt.w * _e.finalSize / 100) : vt = et.measureText(ot, _e.f, _e.finalSize),
                Mt === " " ? Lt += vt + _t : (ht += vt + _t + Lt,
                Lt = 0),
                rt.push({
                    l: vt,
                    an: vt,
                    add: dt,
                    n: st,
                    anIndexes: [],
                    val: ot,
                    line: ut,
                    animatorJustifyOffset: 0
                }),
                lt == 2) {
                    if (dt += vt,
                    ot === "" || ot === " " || nt === it - 1) {
                        for ((ot === "" || ot === " ") && (dt -= vt); ct <= nt; )
                            rt[ct].an = dt,
                            rt[ct].ind = at,
                            rt[ct].extra = vt,
                            ct += 1;
                        at += 1,
                        dt = 0
                    }
                } else if (lt == 3) {
                    if (dt += vt,
                    ot === "" || nt === it - 1) {
                        for (ot === "" && (dt -= vt); ct <= nt; )
                            rt[ct].an = dt,
                            rt[ct].ind = at,
                            rt[ct].extra = vt,
                            ct += 1;
                        dt = 0,
                        at += 1
                    }
                } else
                    rt[at].ind = at,
                    rt[at].extra = 0,
                    at += 1;
            if (_e.l = rt,
            gt = ht > gt ? ht : gt,
            ft.push(ht),
            _e.sz)
                _e.boxWidth = _e.sz[0],
                _e.justifyOffset = 0;
            else
                switch (_e.boxWidth = gt,
                _e.j) {
                case 1:
                    _e.justifyOffset = -_e.boxWidth;
                    break;
                case 2:
                    _e.justifyOffset = -_e.boxWidth / 2;
                    break;
                default:
                    _e.justifyOffset = 0
                }
            _e.lineWidths = ft;
            var $t = tt.a, kt, At;
            pt = $t.length;
            var Pt, Dt, Bt = [];
            for (bt = 0; bt < pt; bt += 1) {
                for (kt = $t[bt],
                kt.a.sc && (_e.strokeColorAnim = !0),
                kt.a.sw && (_e.strokeWidthAnim = !0),
                (kt.a.fc || kt.a.fh || kt.a.fs || kt.a.fb) && (_e.fillColorAnim = !0),
                Dt = 0,
                Pt = kt.s.b,
                nt = 0; nt < it; nt += 1)
                    At = rt[nt],
                    At.anIndexes[bt] = Dt,
                    (Pt == 1 && At.val !== "" || Pt == 2 && At.val !== "" && At.val !== " " || Pt == 3 && (At.n || At.val == " " || nt == it - 1) || Pt == 4 && (At.n || nt == it - 1)) && (kt.s.rn === 1 && Bt.push(Dt),
                    Dt += 1);
                tt.a[bt].s.totalChars = Dt;
                var zt = -1, Yt;
                if (kt.s.rn === 1)
                    for (nt = 0; nt < it; nt += 1)
                        At = rt[nt],
                        zt != At.anIndexes[bt] && (zt = At.anIndexes[bt],
                        Yt = Bt.splice(Math.floor(Math.random() * Bt.length), 1)[0]),
                        At.anIndexes[bt] = Yt
            }
            _e.yOffset = _e.finalLineHeight || _e.finalSize * 1.2,
            _e.ls = _e.ls || 0,
            _e.ascent = mt.ascent * _e.finalSize / 100
        }
        ,
        TextProperty.prototype.updateDocumentData = function(_e, et) {
            et = et === void 0 ? this.keysIndex : et;
            var tt = this.copyData({}, this.data.d.k[et].s);
            tt = this.copyData(tt, _e),
            this.data.d.k[et].s = tt,
            this.recalculate(et),
            this.setCurrentData(tt),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.recalculate = function(_e) {
            var et = this.data.d.k[_e].s;
            et.__complete = !1,
            this.keysIndex = 0,
            this._isFirstFrame = !0,
            this.getValue(et)
        }
        ,
        TextProperty.prototype.canResizeFont = function(_e) {
            this.canResize = _e,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.setMinimumFontSize = function(_e) {
            this.minimumFontSize = Math.floor(_e) || 1,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ;
        var TextSelectorProp = function() {
            var _e = Math.max
              , et = Math.min
              , tt = Math.floor;
            function rt(it, st) {
                this._currentTextLength = -1,
                this.k = !1,
                this.data = st,
                this.elem = it,
                this.comp = it.comp,
                this.finalS = 0,
                this.finalE = 0,
                this.initDynamicPropertyContainer(it),
                this.s = PropertyFactory.getProp(it, st.s || {
                    k: 0
                }, 0, 0, this),
                "e"in st ? this.e = PropertyFactory.getProp(it, st.e, 0, 0, this) : this.e = {
                    v: 100
                },
                this.o = PropertyFactory.getProp(it, st.o || {
                    k: 0
                }, 0, 0, this),
                this.xe = PropertyFactory.getProp(it, st.xe || {
                    k: 0
                }, 0, 0, this),
                this.ne = PropertyFactory.getProp(it, st.ne || {
                    k: 0
                }, 0, 0, this),
                this.sm = PropertyFactory.getProp(it, st.sm || {
                    k: 100
                }, 0, 0, this),
                this.a = PropertyFactory.getProp(it, st.a, 0, .01, this),
                this.dynamicProperties.length || this.getValue()
            }
            rt.prototype = {
                getMult: function(st) {
                    this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                    var at = 0
                      , ot = 0
                      , lt = 1
                      , dt = 1;
                    this.ne.v > 0 ? at = this.ne.v / 100 : ot = -this.ne.v / 100,
                    this.xe.v > 0 ? lt = 1 - this.xe.v / 100 : dt = 1 + this.xe.v / 100;
                    var ct = BezierFactory.getBezierEasing(at, ot, lt, dt).get
                      , ut = 0
                      , ft = this.finalS
                      , ht = this.finalE
                      , gt = this.data.sh;
                    if (gt === 2)
                        ht === ft ? ut = st >= ht ? 1 : 0 : ut = _e(0, et(.5 / (ht - ft) + (st - ft) / (ht - ft), 1)),
                        ut = ct(ut);
                    else if (gt === 3)
                        ht === ft ? ut = st >= ht ? 0 : 1 : ut = 1 - _e(0, et(.5 / (ht - ft) + (st - ft) / (ht - ft), 1)),
                        ut = ct(ut);
                    else if (gt === 4)
                        ht === ft ? ut = 0 : (ut = _e(0, et(.5 / (ht - ft) + (st - ft) / (ht - ft), 1)),
                        ut < .5 ? ut *= 2 : ut = 1 - 2 * (ut - .5)),
                        ut = ct(ut);
                    else if (gt === 5) {
                        if (ht === ft)
                            ut = 0;
                        else {
                            var bt = ht - ft;
                            st = et(_e(0, st + .5 - ft), ht - ft);
                            var pt = -bt / 2 + st
                              , mt = bt / 2;
                            ut = Math.sqrt(1 - pt * pt / (mt * mt))
                        }
                        ut = ct(ut)
                    } else
                        gt === 6 ? (ht === ft ? ut = 0 : (st = et(_e(0, st + .5 - ft), ht - ft),
                        ut = (1 + Math.cos(Math.PI + Math.PI * 2 * st / (ht - ft))) / 2),
                        ut = ct(ut)) : (st >= tt(ft) && (st - ft < 0 ? ut = _e(0, et(et(ht, 1) - (ft - st), 1)) : ut = _e(0, et(ht - st, 1))),
                        ut = ct(ut));
                    if (this.sm.v !== 100) {
                        var yt = this.sm.v * .01;
                        yt === 0 && (yt = 1e-8);
                        var vt = .5 - yt * .5;
                        ut < vt ? ut = 0 : (ut = (ut - vt) / yt,
                        ut > 1 && (ut = 1))
                    }
                    return ut * this.a.v
                },
                getValue: function(st) {
                    this.iterateDynamicProperties(),
                    this._mdf = st || this._mdf,
                    this._currentTextLength = this.elem.textProperty.currentData.l.length || 0,
                    st && this.data.r === 2 && (this.e.v = this._currentTextLength);
                    var at = this.data.r === 2 ? 1 : 100 / this.data.totalChars
                      , ot = this.o.v / at
                      , lt = this.s.v / at + ot
                      , dt = this.e.v / at + ot;
                    if (lt > dt) {
                        var ct = lt;
                        lt = dt,
                        dt = ct
                    }
                    this.finalS = lt,
                    this.finalE = dt
                }
            },
            extendPrototype([DynamicPropertyContainer], rt);
            function nt(it, st, at) {
                return new rt(it,st)
            }
            return {
                getTextSelectorProp: nt
            }
        }();
        function TextAnimatorDataProperty(_e, et, tt) {
            var rt = {
                propType: !1
            }
              , nt = PropertyFactory.getProp
              , it = et.a;
            this.a = {
                r: it.r ? nt(_e, it.r, 0, degToRads, tt) : rt,
                rx: it.rx ? nt(_e, it.rx, 0, degToRads, tt) : rt,
                ry: it.ry ? nt(_e, it.ry, 0, degToRads, tt) : rt,
                sk: it.sk ? nt(_e, it.sk, 0, degToRads, tt) : rt,
                sa: it.sa ? nt(_e, it.sa, 0, degToRads, tt) : rt,
                s: it.s ? nt(_e, it.s, 1, .01, tt) : rt,
                a: it.a ? nt(_e, it.a, 1, 0, tt) : rt,
                o: it.o ? nt(_e, it.o, 0, .01, tt) : rt,
                p: it.p ? nt(_e, it.p, 1, 0, tt) : rt,
                sw: it.sw ? nt(_e, it.sw, 0, 0, tt) : rt,
                sc: it.sc ? nt(_e, it.sc, 1, 0, tt) : rt,
                fc: it.fc ? nt(_e, it.fc, 1, 0, tt) : rt,
                fh: it.fh ? nt(_e, it.fh, 0, 0, tt) : rt,
                fs: it.fs ? nt(_e, it.fs, 0, .01, tt) : rt,
                fb: it.fb ? nt(_e, it.fb, 0, .01, tt) : rt,
                t: it.t ? nt(_e, it.t, 0, 0, tt) : rt
            },
            this.s = TextSelectorProp.getTextSelectorProp(_e, et.s, tt),
            this.s.t = et.s.t
        }
        function TextAnimatorProperty(_e, et, tt) {
            this._isFirstFrame = !0,
            this._hasMaskedPath = !1,
            this._frameId = -1,
            this._textData = _e,
            this._renderType = et,
            this._elem = tt,
            this._animatorsData = createSizedArray(this._textData.a.length),
            this._pathData = {},
            this._moreOptions = {
                alignment: {}
            },
            this.renderedLetters = [],
            this.lettersChangedFlag = !1,
            this.initDynamicPropertyContainer(tt)
        }
        TextAnimatorProperty.prototype.searchProperties = function() {
            var _e, et = this._textData.a.length, tt, rt = PropertyFactory.getProp;
            for (_e = 0; _e < et; _e += 1)
                tt = this._textData.a[_e],
                this._animatorsData[_e] = new TextAnimatorDataProperty(this._elem,tt,this);
            this._textData.p && "m"in this._textData.p ? (this._pathData = {
                a: rt(this._elem, this._textData.p.a, 0, 0, this),
                f: rt(this._elem, this._textData.p.f, 0, 0, this),
                l: rt(this._elem, this._textData.p.l, 0, 0, this),
                r: rt(this._elem, this._textData.p.r, 0, 0, this),
                p: rt(this._elem, this._textData.p.p, 0, 0, this),
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            },
            this._hasMaskedPath = !0) : this._hasMaskedPath = !1,
            this._moreOptions.alignment = rt(this._elem, this._textData.m.a, 1, 0, this)
        }
        ,
        TextAnimatorProperty.prototype.getMeasures = function(_e, et) {
            if (this.lettersChangedFlag = et,
            !(!this._mdf && !this._isFirstFrame && !et && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
                this._isFirstFrame = !1;
                var tt = this._moreOptions.alignment.v, rt = this._animatorsData, nt = this._textData, it = this.mHelper, st = this._renderType, at = this.renderedLetters.length, ot, lt, dt, ct, ut = _e.l, ft, ht, gt, bt, pt, mt, yt, vt, wt, _t, Et, xt, Ct, Tt, It;
                if (this._hasMaskedPath) {
                    if (It = this._pathData.m,
                    !this._pathData.n || this._pathData._mdf) {
                        var Nt = It.v;
                        this._pathData.r.v && (Nt = Nt.reverse()),
                        ft = {
                            tLength: 0,
                            segments: []
                        },
                        ct = Nt._length - 1;
                        var Ft;
                        for (xt = 0,
                        dt = 0; dt < ct; dt += 1)
                            Ft = bez.buildBezierData(Nt.v[dt], Nt.v[dt + 1], [Nt.o[dt][0] - Nt.v[dt][0], Nt.o[dt][1] - Nt.v[dt][1]], [Nt.i[dt + 1][0] - Nt.v[dt + 1][0], Nt.i[dt + 1][1] - Nt.v[dt + 1][1]]),
                            ft.tLength += Ft.segmentLength,
                            ft.segments.push(Ft),
                            xt += Ft.segmentLength;
                        dt = ct,
                        It.v.c && (Ft = bez.buildBezierData(Nt.v[dt], Nt.v[0], [Nt.o[dt][0] - Nt.v[dt][0], Nt.o[dt][1] - Nt.v[dt][1]], [Nt.i[0][0] - Nt.v[0][0], Nt.i[0][1] - Nt.v[0][1]]),
                        ft.tLength += Ft.segmentLength,
                        ft.segments.push(Ft),
                        xt += Ft.segmentLength),
                        this._pathData.pi = ft
                    }
                    if (ft = this._pathData.pi,
                    ht = this._pathData.f.v,
                    yt = 0,
                    mt = 1,
                    bt = 0,
                    pt = !0,
                    _t = ft.segments,
                    ht < 0 && It.v.c)
                        for (ft.tLength < Math.abs(ht) && (ht = -Math.abs(ht) % ft.tLength),
                        yt = _t.length - 1,
                        wt = _t[yt].points,
                        mt = wt.length - 1; ht < 0; )
                            ht += wt[mt].partialLength,
                            mt -= 1,
                            mt < 0 && (yt -= 1,
                            wt = _t[yt].points,
                            mt = wt.length - 1);
                    wt = _t[yt].points,
                    vt = wt[mt - 1],
                    gt = wt[mt],
                    Et = gt.partialLength
                }
                ct = ut.length,
                ot = 0,
                lt = 0;
                var Lt = _e.finalSize * 1.2 * .714, Mt = !0, $t, kt, At, Pt, Dt;
                Pt = rt.length;
                var Bt, zt = -1, Yt, rr, ar, or = ht, pr = yt, gr = mt, Sr = -1, br, Pr, Wr, _r, hr, Vr, Xr, Yr, Hr = "", Gt = this.defaultPropsArray, Jt;
                if (_e.j === 2 || _e.j === 1) {
                    var tr = 0
                      , lr = 0
                      , sr = _e.j === 2 ? -.5 : -1
                      , ir = 0
                      , ur = !0;
                    for (dt = 0; dt < ct; dt += 1)
                        if (ut[dt].n) {
                            for (tr && (tr += lr); ir < dt; )
                                ut[ir].animatorJustifyOffset = tr,
                                ir += 1;
                            tr = 0,
                            ur = !0
                        } else {
                            for (At = 0; At < Pt; At += 1)
                                $t = rt[At].a,
                                $t.t.propType && (ur && _e.j === 2 && (lr += $t.t.v * sr),
                                kt = rt[At].s,
                                Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                                Bt.length ? tr += $t.t.v * Bt[0] * sr : tr += $t.t.v * Bt * sr);
                            ur = !1
                        }
                    for (tr && (tr += lr); ir < dt; )
                        ut[ir].animatorJustifyOffset = tr,
                        ir += 1
                }
                for (dt = 0; dt < ct; dt += 1) {
                    if (it.reset(),
                    br = 1,
                    ut[dt].n)
                        ot = 0,
                        lt += _e.yOffset,
                        lt += Mt ? 1 : 0,
                        ht = or,
                        Mt = !1,
                        this._hasMaskedPath && (yt = pr,
                        mt = gr,
                        wt = _t[yt].points,
                        vt = wt[mt - 1],
                        gt = wt[mt],
                        Et = gt.partialLength,
                        bt = 0),
                        Hr = "",
                        Yr = "",
                        Vr = "",
                        Jt = "",
                        Gt = this.defaultPropsArray;
                    else {
                        if (this._hasMaskedPath) {
                            if (Sr !== ut[dt].line) {
                                switch (_e.j) {
                                case 1:
                                    ht += xt - _e.lineWidths[ut[dt].line];
                                    break;
                                case 2:
                                    ht += (xt - _e.lineWidths[ut[dt].line]) / 2;
                                    break
                                }
                                Sr = ut[dt].line
                            }
                            zt !== ut[dt].ind && (ut[zt] && (ht += ut[zt].extra),
                            ht += ut[dt].an / 2,
                            zt = ut[dt].ind),
                            ht += tt[0] * ut[dt].an * .005;
                            var Cr = 0;
                            for (At = 0; At < Pt; At += 1)
                                $t = rt[At].a,
                                $t.p.propType && (kt = rt[At].s,
                                Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                                Bt.length ? Cr += $t.p.v[0] * Bt[0] : Cr += $t.p.v[0] * Bt),
                                $t.a.propType && (kt = rt[At].s,
                                Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                                Bt.length ? Cr += $t.a.v[0] * Bt[0] : Cr += $t.a.v[0] * Bt);
                            for (pt = !0,
                            this._pathData.a.v && (ht = ut[0].an * .5 + (xt - this._pathData.f.v - ut[0].an * .5 - ut[ut.length - 1].an * .5) * zt / (ct - 1),
                            ht += this._pathData.f.v); pt; )
                                bt + Et >= ht + Cr || !wt ? (Ct = (ht + Cr - bt) / gt.partialLength,
                                rr = vt.point[0] + (gt.point[0] - vt.point[0]) * Ct,
                                ar = vt.point[1] + (gt.point[1] - vt.point[1]) * Ct,
                                it.translate(-tt[0] * ut[dt].an * .005, -(tt[1] * Lt) * .01),
                                pt = !1) : wt && (bt += gt.partialLength,
                                mt += 1,
                                mt >= wt.length && (mt = 0,
                                yt += 1,
                                _t[yt] ? wt = _t[yt].points : It.v.c ? (mt = 0,
                                yt = 0,
                                wt = _t[yt].points) : (bt -= gt.partialLength,
                                wt = null)),
                                wt && (vt = gt,
                                gt = wt[mt],
                                Et = gt.partialLength));
                            Yt = ut[dt].an / 2 - ut[dt].add,
                            it.translate(-Yt, 0, 0)
                        } else
                            Yt = ut[dt].an / 2 - ut[dt].add,
                            it.translate(-Yt, 0, 0),
                            it.translate(-tt[0] * ut[dt].an * .005, -tt[1] * Lt * .01, 0);
                        for (At = 0; At < Pt; At += 1)
                            $t = rt[At].a,
                            $t.t.propType && (kt = rt[At].s,
                            Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                            (ot !== 0 || _e.j !== 0) && (this._hasMaskedPath ? Bt.length ? ht += $t.t.v * Bt[0] : ht += $t.t.v * Bt : Bt.length ? ot += $t.t.v * Bt[0] : ot += $t.t.v * Bt));
                        for (_e.strokeWidthAnim && (Wr = _e.sw || 0),
                        _e.strokeColorAnim && (_e.sc ? Pr = [_e.sc[0], _e.sc[1], _e.sc[2]] : Pr = [0, 0, 0]),
                        _e.fillColorAnim && _e.fc && (_r = [_e.fc[0], _e.fc[1], _e.fc[2]]),
                        At = 0; At < Pt; At += 1)
                            $t = rt[At].a,
                            $t.a.propType && (kt = rt[At].s,
                            Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                            Bt.length ? it.translate(-$t.a.v[0] * Bt[0], -$t.a.v[1] * Bt[1], $t.a.v[2] * Bt[2]) : it.translate(-$t.a.v[0] * Bt, -$t.a.v[1] * Bt, $t.a.v[2] * Bt));
                        for (At = 0; At < Pt; At += 1)
                            $t = rt[At].a,
                            $t.s.propType && (kt = rt[At].s,
                            Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                            Bt.length ? it.scale(1 + ($t.s.v[0] - 1) * Bt[0], 1 + ($t.s.v[1] - 1) * Bt[1], 1) : it.scale(1 + ($t.s.v[0] - 1) * Bt, 1 + ($t.s.v[1] - 1) * Bt, 1));
                        for (At = 0; At < Pt; At += 1) {
                            if ($t = rt[At].a,
                            kt = rt[At].s,
                            Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                            $t.sk.propType && (Bt.length ? it.skewFromAxis(-$t.sk.v * Bt[0], $t.sa.v * Bt[1]) : it.skewFromAxis(-$t.sk.v * Bt, $t.sa.v * Bt)),
                            $t.r.propType && (Bt.length ? it.rotateZ(-$t.r.v * Bt[2]) : it.rotateZ(-$t.r.v * Bt)),
                            $t.ry.propType && (Bt.length ? it.rotateY($t.ry.v * Bt[1]) : it.rotateY($t.ry.v * Bt)),
                            $t.rx.propType && (Bt.length ? it.rotateX($t.rx.v * Bt[0]) : it.rotateX($t.rx.v * Bt)),
                            $t.o.propType && (Bt.length ? br += ($t.o.v * Bt[0] - br) * Bt[0] : br += ($t.o.v * Bt - br) * Bt),
                            _e.strokeWidthAnim && $t.sw.propType && (Bt.length ? Wr += $t.sw.v * Bt[0] : Wr += $t.sw.v * Bt),
                            _e.strokeColorAnim && $t.sc.propType)
                                for (hr = 0; hr < 3; hr += 1)
                                    Bt.length ? Pr[hr] += ($t.sc.v[hr] - Pr[hr]) * Bt[0] : Pr[hr] += ($t.sc.v[hr] - Pr[hr]) * Bt;
                            if (_e.fillColorAnim && _e.fc) {
                                if ($t.fc.propType)
                                    for (hr = 0; hr < 3; hr += 1)
                                        Bt.length ? _r[hr] += ($t.fc.v[hr] - _r[hr]) * Bt[0] : _r[hr] += ($t.fc.v[hr] - _r[hr]) * Bt;
                                $t.fh.propType && (Bt.length ? _r = addHueToRGB(_r, $t.fh.v * Bt[0]) : _r = addHueToRGB(_r, $t.fh.v * Bt)),
                                $t.fs.propType && (Bt.length ? _r = addSaturationToRGB(_r, $t.fs.v * Bt[0]) : _r = addSaturationToRGB(_r, $t.fs.v * Bt)),
                                $t.fb.propType && (Bt.length ? _r = addBrightnessToRGB(_r, $t.fb.v * Bt[0]) : _r = addBrightnessToRGB(_r, $t.fb.v * Bt))
                            }
                        }
                        for (At = 0; At < Pt; At += 1)
                            $t = rt[At].a,
                            $t.p.propType && (kt = rt[At].s,
                            Bt = kt.getMult(ut[dt].anIndexes[At], nt.a[At].s.totalChars),
                            this._hasMaskedPath ? Bt.length ? it.translate(0, $t.p.v[1] * Bt[0], -$t.p.v[2] * Bt[1]) : it.translate(0, $t.p.v[1] * Bt, -$t.p.v[2] * Bt) : Bt.length ? it.translate($t.p.v[0] * Bt[0], $t.p.v[1] * Bt[1], -$t.p.v[2] * Bt[2]) : it.translate($t.p.v[0] * Bt, $t.p.v[1] * Bt, -$t.p.v[2] * Bt));
                        if (_e.strokeWidthAnim && (Vr = Wr < 0 ? 0 : Wr),
                        _e.strokeColorAnim && (Xr = "rgb(" + Math.round(Pr[0] * 255) + "," + Math.round(Pr[1] * 255) + "," + Math.round(Pr[2] * 255) + ")"),
                        _e.fillColorAnim && _e.fc && (Yr = "rgb(" + Math.round(_r[0] * 255) + "," + Math.round(_r[1] * 255) + "," + Math.round(_r[2] * 255) + ")"),
                        this._hasMaskedPath) {
                            if (it.translate(0, -_e.ls),
                            it.translate(0, tt[1] * Lt * .01 + lt, 0),
                            this._pathData.p.v) {
                                Tt = (gt.point[1] - vt.point[1]) / (gt.point[0] - vt.point[0]);
                                var Wt = Math.atan(Tt) * 180 / Math.PI;
                                gt.point[0] < vt.point[0] && (Wt += 180),
                                it.rotate(-Wt * Math.PI / 180)
                            }
                            it.translate(rr, ar, 0),
                            ht -= tt[0] * ut[dt].an * .005,
                            ut[dt + 1] && zt !== ut[dt + 1].ind && (ht += ut[dt].an / 2,
                            ht += _e.tr * .001 * _e.finalSize)
                        } else {
                            switch (it.translate(ot, lt, 0),
                            _e.ps && it.translate(_e.ps[0], _e.ps[1] + _e.ascent, 0),
                            _e.j) {
                            case 1:
                                it.translate(ut[dt].animatorJustifyOffset + _e.justifyOffset + (_e.boxWidth - _e.lineWidths[ut[dt].line]), 0, 0);
                                break;
                            case 2:
                                it.translate(ut[dt].animatorJustifyOffset + _e.justifyOffset + (_e.boxWidth - _e.lineWidths[ut[dt].line]) / 2, 0, 0);
                                break
                            }
                            it.translate(0, -_e.ls),
                            it.translate(Yt, 0, 0),
                            it.translate(tt[0] * ut[dt].an * .005, tt[1] * Lt * .01, 0),
                            ot += ut[dt].l + _e.tr * .001 * _e.finalSize
                        }
                        st === "html" ? Hr = it.toCSS() : st === "svg" ? Hr = it.to2dCSS() : Gt = [it.props[0], it.props[1], it.props[2], it.props[3], it.props[4], it.props[5], it.props[6], it.props[7], it.props[8], it.props[9], it.props[10], it.props[11], it.props[12], it.props[13], it.props[14], it.props[15]],
                        Jt = br
                    }
                    at <= dt ? (Dt = new LetterProps(Jt,Vr,Xr,Yr,Hr,Gt),
                    this.renderedLetters.push(Dt),
                    at += 1,
                    this.lettersChangedFlag = !0) : (Dt = this.renderedLetters[dt],
                    this.lettersChangedFlag = Dt.update(Jt, Vr, Xr, Yr, Hr, Gt) || this.lettersChangedFlag)
                }
            }
        }
        ,
        TextAnimatorProperty.prototype.getValue = function() {
            this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        TextAnimatorProperty.prototype.mHelper = new Matrix,
        TextAnimatorProperty.prototype.defaultPropsArray = [],
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
        function ITextElement() {}
        ITextElement.prototype.initElement = function(_e, et, tt) {
            this.lettersChangedFlag = !0,
            this.initFrame(),
            this.initBaseData(_e, et, tt),
            this.textProperty = new TextProperty(this,_e.t,this.dynamicProperties),
            this.textAnimator = new TextAnimatorProperty(_e.t,this.renderType,this),
            this.initTransform(_e, et, tt),
            this.initHierarchy(),
            this.initRenderable(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            this.createContent(),
            this.hide(),
            this.textAnimator.searchProperties(this.dynamicProperties)
        }
        ,
        ITextElement.prototype.prepareFrame = function(_e) {
            this._mdf = !1,
            this.prepareRenderableFrame(_e),
            this.prepareProperties(_e, this.isInRange)
        }
        ,
        ITextElement.prototype.createPathShape = function(_e, et) {
            var tt, rt = et.length, nt, it = "";
            for (tt = 0; tt < rt; tt += 1)
                et[tt].ty === "sh" && (nt = et[tt].ks.k,
                it += buildShapeString(nt, nt.i.length, !0, _e));
            return it
        }
        ,
        ITextElement.prototype.updateDocumentData = function(_e, et) {
            this.textProperty.updateDocumentData(_e, et)
        }
        ,
        ITextElement.prototype.canResizeFont = function(_e) {
            this.textProperty.canResizeFont(_e)
        }
        ,
        ITextElement.prototype.setMinimumFontSize = function(_e) {
            this.textProperty.setMinimumFontSize(_e)
        }
        ,
        ITextElement.prototype.applyTextPropertiesToMatrix = function(_e, et, tt, rt, nt) {
            switch (_e.ps && et.translate(_e.ps[0], _e.ps[1] + _e.ascent, 0),
            et.translate(0, -_e.ls, 0),
            _e.j) {
            case 1:
                et.translate(_e.justifyOffset + (_e.boxWidth - _e.lineWidths[tt]), 0, 0);
                break;
            case 2:
                et.translate(_e.justifyOffset + (_e.boxWidth - _e.lineWidths[tt]) / 2, 0, 0);
                break
            }
            et.translate(rt, nt, 0)
        }
        ,
        ITextElement.prototype.buildColor = function(_e) {
            return "rgb(" + Math.round(_e[0] * 255) + "," + Math.round(_e[1] * 255) + "," + Math.round(_e[2] * 255) + ")"
        }
        ,
        ITextElement.prototype.emptyProp = new LetterProps,
        ITextElement.prototype.destroy = function() {}
        ,
        ITextElement.prototype.validateText = function() {
            (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(),
            this.textProperty._isFirstFrame = !1,
            this.textProperty._mdf = !1)
        }
        ;
        var emptyShapeData = {
            shapes: []
        };
        function SVGTextLottieElement(_e, et, tt) {
            this.textSpans = [],
            this.renderType = "svg",
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement),
        SVGTextLottieElement.prototype.createContent = function() {
            this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
        }
        ,
        SVGTextLottieElement.prototype.buildTextContents = function(_e) {
            for (var et = 0, tt = _e.length, rt = [], nt = ""; et < tt; )
                _e[et] === "\r" || _e[et] === "" ? (rt.push(nt),
                nt = "") : nt += _e[et],
                et += 1;
            return rt.push(nt),
            rt
        }
        ,
        SVGTextLottieElement.prototype.buildShapeData = function(_e, et) {
            if (_e.shapes && _e.shapes.length) {
                var tt = _e.shapes[0];
                if (tt.it) {
                    var rt = tt.it[tt.it.length - 1];
                    rt.s && (rt.s.k[0] = et,
                    rt.s.k[1] = et)
                }
            }
            return _e
        }
        ,
        SVGTextLottieElement.prototype.buildNewText = function() {
            this.addDynamicProperty(this);
            var _e, et, tt = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(tt ? tt.l.length : 0),
            tt.fc ? this.layerElement.setAttribute("fill", this.buildColor(tt.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            tt.sc && (this.layerElement.setAttribute("stroke", this.buildColor(tt.sc)),
            this.layerElement.setAttribute("stroke-width", tt.sw)),
            this.layerElement.setAttribute("font-size", tt.finalSize);
            var rt = this.globalData.fontManager.getFontByName(tt.f);
            if (rt.fClass)
                this.layerElement.setAttribute("class", rt.fClass);
            else {
                this.layerElement.setAttribute("font-family", rt.fFamily);
                var nt = tt.fWeight
                  , it = tt.fStyle;
                this.layerElement.setAttribute("font-style", it),
                this.layerElement.setAttribute("font-weight", nt)
            }
            this.layerElement.setAttribute("aria-label", tt.t);
            var st = tt.l || []
              , at = !!this.globalData.fontManager.chars;
            et = st.length;
            var ot, lt = this.mHelper, dt = "", ct = this.data.singleShape, ut = 0, ft = 0, ht = !0, gt = tt.tr * .001 * tt.finalSize;
            if (ct && !at && !tt.sz) {
                var bt = this.textContainer
                  , pt = "start";
                switch (tt.j) {
                case 1:
                    pt = "end";
                    break;
                case 2:
                    pt = "middle";
                    break;
                default:
                    pt = "start";
                    break
                }
                bt.setAttribute("text-anchor", pt),
                bt.setAttribute("letter-spacing", gt);
                var mt = this.buildTextContents(tt.finalText);
                for (et = mt.length,
                ft = tt.ps ? tt.ps[1] + tt.ascent : 0,
                _e = 0; _e < et; _e += 1)
                    ot = this.textSpans[_e].span || createNS("tspan"),
                    ot.textContent = mt[_e],
                    ot.setAttribute("x", 0),
                    ot.setAttribute("y", ft),
                    ot.style.display = "inherit",
                    bt.appendChild(ot),
                    this.textSpans[_e] || (this.textSpans[_e] = {
                        span: null,
                        glyph: null
                    }),
                    this.textSpans[_e].span = ot,
                    ft += tt.finalLineHeight;
                this.layerElement.appendChild(bt)
            } else {
                var yt = this.textSpans.length, vt;
                for (_e = 0; _e < et; _e += 1) {
                    if (this.textSpans[_e] || (this.textSpans[_e] = {
                        span: null,
                        childSpan: null,
                        glyph: null
                    }),
                    !at || !ct || _e === 0) {
                        if (ot = yt > _e ? this.textSpans[_e].span : createNS(at ? "g" : "text"),
                        yt <= _e) {
                            if (ot.setAttribute("stroke-linecap", "butt"),
                            ot.setAttribute("stroke-linejoin", "round"),
                            ot.setAttribute("stroke-miterlimit", "4"),
                            this.textSpans[_e].span = ot,
                            at) {
                                var wt = createNS("g");
                                ot.appendChild(wt),
                                this.textSpans[_e].childSpan = wt
                            }
                            this.textSpans[_e].span = ot,
                            this.layerElement.appendChild(ot)
                        }
                        ot.style.display = "inherit"
                    }
                    if (lt.reset(),
                    ct && (st[_e].n && (ut = -gt,
                    ft += tt.yOffset,
                    ft += ht ? 1 : 0,
                    ht = !1),
                    this.applyTextPropertiesToMatrix(tt, lt, st[_e].line, ut, ft),
                    ut += st[_e].l || 0,
                    ut += gt),
                    at) {
                        vt = this.globalData.fontManager.getCharData(tt.finalText[_e], rt.fStyle, this.globalData.fontManager.getFontByName(tt.f).fFamily);
                        var _t;
                        if (vt.t === 1)
                            _t = new SVGCompElement(vt.data,this.globalData,this);
                        else {
                            var Et = emptyShapeData;
                            vt.data && vt.data.shapes && (Et = this.buildShapeData(vt.data, tt.finalSize)),
                            _t = new SVGShapeElement(Et,this.globalData,this)
                        }
                        if (this.textSpans[_e].glyph) {
                            var xt = this.textSpans[_e].glyph;
                            this.textSpans[_e].childSpan.removeChild(xt.layerElement),
                            xt.destroy()
                        }
                        this.textSpans[_e].glyph = _t,
                        _t._debug = !0,
                        _t.prepareFrame(0),
                        _t.renderFrame(),
                        this.textSpans[_e].childSpan.appendChild(_t.layerElement),
                        vt.t === 1 && this.textSpans[_e].childSpan.setAttribute("transform", "scale(" + tt.finalSize / 100 + "," + tt.finalSize / 100 + ")")
                    } else
                        ct && ot.setAttribute("transform", "translate(" + lt.props[12] + "," + lt.props[13] + ")"),
                        ot.textContent = st[_e].val,
                        ot.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
                }
                ct && ot && ot.setAttribute("d", dt)
            }
            for (; _e < this.textSpans.length; )
                this.textSpans[_e].span.style.display = "none",
                _e += 1;
            this._sizeChanged = !0
        }
        ,
        SVGTextLottieElement.prototype.sourceRectAtTime = function() {
            if (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged) {
                this._sizeChanged = !1;
                var _e = this.layerElement.getBBox();
                this.bbox = {
                    top: _e.y,
                    left: _e.x,
                    width: _e.width,
                    height: _e.height
                }
            }
            return this.bbox
        }
        ,
        SVGTextLottieElement.prototype.getValue = function() {
            var _e, et = this.textSpans.length, tt;
            for (this.renderedFrame = this.comp.renderedFrame,
            _e = 0; _e < et; _e += 1)
                tt = this.textSpans[_e].glyph,
                tt && (tt.prepareFrame(this.comp.renderedFrame - this.data.st),
                tt._mdf && (this._mdf = !0))
        }
        ,
        SVGTextLottieElement.prototype.renderInnerContent = function() {
            if (this.validateText(),
            (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                this._sizeChanged = !0;
                var _e, et, tt = this.textAnimator.renderedLetters, rt = this.textProperty.currentData.l;
                et = rt.length;
                var nt, it, st;
                for (_e = 0; _e < et; _e += 1)
                    rt[_e].n || (nt = tt[_e],
                    it = this.textSpans[_e].span,
                    st = this.textSpans[_e].glyph,
                    st && st.renderFrame(),
                    nt._mdf.m && it.setAttribute("transform", nt.m),
                    nt._mdf.o && it.setAttribute("opacity", nt.o),
                    nt._mdf.sw && it.setAttribute("stroke-width", nt.sw),
                    nt._mdf.sc && it.setAttribute("stroke", nt.sc),
                    nt._mdf.fc && it.setAttribute("fill", nt.fc))
            }
        }
        ;
        function ISolidElement(_e, et, tt) {
            this.initElement(_e, et, tt)
        }
        extendPrototype([IImageElement], ISolidElement),
        ISolidElement.prototype.createContent = function() {
            var _e = createNS("rect");
            _e.setAttribute("width", this.data.sw),
            _e.setAttribute("height", this.data.sh),
            _e.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(_e)
        }
        ;
        function NullElement(_e, et, tt) {
            this.initFrame(),
            this.initBaseData(_e, et, tt),
            this.initFrame(),
            this.initTransform(_e, et, tt),
            this.initHierarchy()
        }
        NullElement.prototype.prepareFrame = function(_e) {
            this.prepareProperties(_e, !0)
        }
        ,
        NullElement.prototype.renderFrame = function() {}
        ,
        NullElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        NullElement.prototype.destroy = function() {}
        ,
        NullElement.prototype.sourceRectAtTime = function() {}
        ,
        NullElement.prototype.hide = function() {}
        ,
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
        function SVGRendererBase() {}
        extendPrototype([BaseRenderer], SVGRendererBase),
        SVGRendererBase.prototype.createNull = function(_e) {
            return new NullElement(_e,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createShape = function(_e) {
            return new SVGShapeElement(_e,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createText = function(_e) {
            return new SVGTextLottieElement(_e,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createImage = function(_e) {
            return new IImageElement(_e,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createSolid = function(_e) {
            return new ISolidElement(_e,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.configAnimation = function(_e) {
            this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"),
            this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + _e.w + " " + _e.h),
            this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", _e.w),
            this.svgElement.setAttribute("height", _e.h),
            this.svgElement.style.width = "100%",
            this.svgElement.style.height = "100%",
            this.svgElement.style.transform = "translate3d(0,0,0)",
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility),
            this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className),
            this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable),
            this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio),
            this.animationItem.wrapper.appendChild(this.svgElement);
            var et = this.globalData.defs;
            this.setupGlobalData(_e, et),
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.data = _e;
            var tt = createNS("clipPath")
              , rt = createNS("rect");
            rt.setAttribute("width", _e.w),
            rt.setAttribute("height", _e.h),
            rt.setAttribute("x", 0),
            rt.setAttribute("y", 0);
            var nt = createElementID();
            tt.setAttribute("id", nt),
            tt.appendChild(rt),
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + nt + ")"),
            et.appendChild(tt),
            this.layers = _e.layers,
            this.elements = createSizedArray(_e.layers.length)
        }
        ,
        SVGRendererBase.prototype.destroy = function() {
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.layerElement = null,
            this.globalData.defs = null;
            var _e, et = this.layers ? this.layers.length : 0;
            for (_e = 0; _e < et; _e += 1)
                this.elements[_e] && this.elements[_e].destroy && this.elements[_e].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        SVGRendererBase.prototype.updateContainerSize = function() {}
        ,
        SVGRendererBase.prototype.findIndexByInd = function(_e) {
            var et = 0
              , tt = this.layers.length;
            for (et = 0; et < tt; et += 1)
                if (this.layers[et].ind === _e)
                    return et;
            return -1
        }
        ,
        SVGRendererBase.prototype.buildItem = function(_e) {
            var et = this.elements;
            if (!(et[_e] || this.layers[_e].ty === 99)) {
                et[_e] = !0;
                var tt = this.createItem(this.layers[_e]);
                if (et[_e] = tt,
                getExpressionsPlugin() && (this.layers[_e].ty === 0 && this.globalData.projectInterface.registerComposition(tt),
                tt.initExpressions()),
                this.appendElementInPos(tt, _e),
                this.layers[_e].tt) {
                    var rt = "tp"in this.layers[_e] ? this.findIndexByInd(this.layers[_e].tp) : _e - 1;
                    if (rt === -1)
                        return;
                    if (!this.elements[rt] || this.elements[rt] === !0)
                        this.buildItem(rt),
                        this.addPendingElement(tt);
                    else {
                        var nt = et[rt]
                          , it = nt.getMatte(this.layers[_e].tt);
                        tt.setMatte(it)
                    }
                }
            }
        }
        ,
        SVGRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var _e = this.pendingElements.pop();
                if (_e.checkParenting(),
                _e.data.tt)
                    for (var et = 0, tt = this.elements.length; et < tt; ) {
                        if (this.elements[et] === _e) {
                            var rt = "tp"in _e.data ? this.findIndexByInd(_e.data.tp) : et - 1
                              , nt = this.elements[rt]
                              , it = nt.getMatte(this.layers[et].tt);
                            _e.setMatte(it);
                            break
                        }
                        et += 1
                    }
            }
        }
        ,
        SVGRendererBase.prototype.renderFrame = function(_e) {
            if (!(this.renderedFrame === _e || this.destroyed)) {
                _e === null ? _e = this.renderedFrame : this.renderedFrame = _e,
                this.globalData.frameNum = _e,
                this.globalData.frameId += 1,
                this.globalData.projectInterface.currentFrame = _e,
                this.globalData._mdf = !1;
                var et, tt = this.layers.length;
                for (this.completeLayers || this.checkLayers(_e),
                et = tt - 1; et >= 0; et -= 1)
                    (this.completeLayers || this.elements[et]) && this.elements[et].prepareFrame(_e - this.layers[et].st);
                if (this.globalData._mdf)
                    for (et = 0; et < tt; et += 1)
                        (this.completeLayers || this.elements[et]) && this.elements[et].renderFrame()
            }
        }
        ,
        SVGRendererBase.prototype.appendElementInPos = function(_e, et) {
            var tt = _e.getBaseElement();
            if (tt) {
                for (var rt = 0, nt; rt < et; )
                    this.elements[rt] && this.elements[rt] !== !0 && this.elements[rt].getBaseElement() && (nt = this.elements[rt].getBaseElement()),
                    rt += 1;
                nt ? this.layerElement.insertBefore(tt, nt) : this.layerElement.appendChild(tt)
            }
        }
        ,
        SVGRendererBase.prototype.hide = function() {
            this.layerElement.style.display = "none"
        }
        ,
        SVGRendererBase.prototype.show = function() {
            this.layerElement.style.display = "block"
        }
        ;
        function ICompElement() {}
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement),
        ICompElement.prototype.initElement = function(_e, et, tt) {
            this.initFrame(),
            this.initBaseData(_e, et, tt),
            this.initTransform(_e, et, tt),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            (this.data.xt || !et.progressiveLoad) && this.buildAllItems(),
            this.hide()
        }
        ,
        ICompElement.prototype.prepareFrame = function(_e) {
            if (this._mdf = !1,
            this.prepareRenderableFrame(_e),
            this.prepareProperties(_e, this.isInRange),
            !(!this.isInRange && !this.data.xt)) {
                if (this.tm._placeholder)
                    this.renderedFrame = _e / this.data.sr;
                else {
                    var et = this.tm.v;
                    et === this.data.op && (et = this.data.op - 1),
                    this.renderedFrame = et
                }
                var tt, rt = this.elements.length;
                for (this.completeLayers || this.checkLayers(this.renderedFrame),
                tt = rt - 1; tt >= 0; tt -= 1)
                    (this.completeLayers || this.elements[tt]) && (this.elements[tt].prepareFrame(this.renderedFrame - this.layers[tt].st),
                    this.elements[tt]._mdf && (this._mdf = !0))
            }
        }
        ,
        ICompElement.prototype.renderInnerContent = function() {
            var _e, et = this.layers.length;
            for (_e = 0; _e < et; _e += 1)
                (this.completeLayers || this.elements[_e]) && this.elements[_e].renderFrame()
        }
        ,
        ICompElement.prototype.setElements = function(_e) {
            this.elements = _e
        }
        ,
        ICompElement.prototype.getElements = function() {
            return this.elements
        }
        ,
        ICompElement.prototype.destroyElements = function() {
            var _e, et = this.layers.length;
            for (_e = 0; _e < et; _e += 1)
                this.elements[_e] && this.elements[_e].destroy()
        }
        ,
        ICompElement.prototype.destroy = function() {
            this.destroyElements(),
            this.destroyBaseElement()
        }
        ;
        function SVGCompElement(_e, et, tt) {
            this.layers = _e.layers,
            this.supports3d = !0,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(_e, et, tt),
            this.tm = _e.tm ? PropertyFactory.getProp(this, _e.tm, 0, et.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement),
        SVGCompElement.prototype.createComp = function(_e) {
            return new SVGCompElement(_e,this.globalData,this)
        }
        ;
        function SVGRenderer(_e, et) {
            this.animationItem = _e,
            this.layers = null,
            this.renderedFrame = -1,
            this.svgElement = createNS("svg");
            var tt = "";
            if (et && et.title) {
                var rt = createNS("title")
                  , nt = createElementID();
                rt.setAttribute("id", nt),
                rt.textContent = et.title,
                this.svgElement.appendChild(rt),
                tt += nt
            }
            if (et && et.description) {
                var it = createNS("desc")
                  , st = createElementID();
                it.setAttribute("id", st),
                it.textContent = et.description,
                this.svgElement.appendChild(it),
                tt += " " + st
            }
            tt && this.svgElement.setAttribute("aria-labelledby", tt);
            var at = createNS("defs");
            this.svgElement.appendChild(at);
            var ot = createNS("g");
            this.svgElement.appendChild(ot),
            this.layerElement = ot,
            this.renderConfig = {
                preserveAspectRatio: et && et.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: et && et.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: et && et.contentVisibility || "visible",
                progressiveLoad: et && et.progressiveLoad || !1,
                hideOnTransparent: !(et && et.hideOnTransparent === !1),
                viewBoxOnly: et && et.viewBoxOnly || !1,
                viewBoxSize: et && et.viewBoxSize || !1,
                className: et && et.className || "",
                id: et && et.id || "",
                focusable: et && et.focusable,
                filterSize: {
                    width: et && et.filterSize && et.filterSize.width || "100%",
                    height: et && et.filterSize && et.filterSize.height || "100%",
                    x: et && et.filterSize && et.filterSize.x || "0%",
                    y: et && et.filterSize && et.filterSize.y || "0%"
                },
                width: et && et.width,
                height: et && et.height,
                runExpressions: !et || et.runExpressions === void 0 || et.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                defs: at,
                renderConfig: this.renderConfig
            },
            this.elements = [],
            this.pendingElements = [],
            this.destroyed = !1,
            this.rendererType = "svg"
        }
        extendPrototype([SVGRendererBase], SVGRenderer),
        SVGRenderer.prototype.createComp = function(_e) {
            return new SVGCompElement(_e,this.globalData,this)
        }
        ;
        function ShapeTransformManager() {
            this.sequences = {},
            this.sequenceList = [],
            this.transform_key_count = 0
        }
        ShapeTransformManager.prototype = {
            addTransformSequence: function(et) {
                var tt, rt = et.length, nt = "_";
                for (tt = 0; tt < rt; tt += 1)
                    nt += et[tt].transform.key + "_";
                var it = this.sequences[nt];
                return it || (it = {
                    transforms: [].concat(et),
                    finalTransform: new Matrix,
                    _mdf: !1
                },
                this.sequences[nt] = it,
                this.sequenceList.push(it)),
                it
            },
            processSequence: function(et, tt) {
                for (var rt = 0, nt = et.transforms.length, it = tt; rt < nt && !tt; ) {
                    if (et.transforms[rt].transform.mProps._mdf) {
                        it = !0;
                        break
                    }
                    rt += 1
                }
                if (it)
                    for (et.finalTransform.reset(),
                    rt = nt - 1; rt >= 0; rt -= 1)
                        et.finalTransform.multiply(et.transforms[rt].transform.mProps.v);
                et._mdf = it
            },
            processSequences: function(et) {
                var tt, rt = this.sequenceList.length;
                for (tt = 0; tt < rt; tt += 1)
                    this.processSequence(this.sequenceList[tt], et)
            },
            getNewKey: function() {
                return this.transform_key_count += 1,
                "_" + this.transform_key_count
            }
        };
        var lumaLoader = function() {
            var et = "__lottie_element_luma_buffer"
              , tt = null
              , rt = null
              , nt = null;
            function it() {
                var ot = createNS("svg")
                  , lt = createNS("filter")
                  , dt = createNS("feColorMatrix");
                return lt.setAttribute("id", et),
                dt.setAttribute("type", "matrix"),
                dt.setAttribute("color-interpolation-filters", "sRGB"),
                dt.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"),
                lt.appendChild(dt),
                ot.appendChild(lt),
                ot.setAttribute("id", et + "_svg"),
                featureSupport.svgLumaHidden && (ot.style.display = "none"),
                ot
            }
            function st() {
                tt || (nt = it(),
                document.body.appendChild(nt),
                tt = createTag("canvas"),
                rt = tt.getContext("2d"),
                rt.filter = "url(#" + et + ")",
                rt.fillStyle = "rgba(0,0,0,0)",
                rt.fillRect(0, 0, 1, 1))
            }
            function at(ot) {
                return tt || st(),
                tt.width = ot.width,
                tt.height = ot.height,
                rt.filter = "url(#" + et + ")",
                tt
            }
            return {
                load: st,
                get: at
            }
        };
        function createCanvas(_e, et) {
            if (featureSupport.offscreenCanvas)
                return new OffscreenCanvas(_e,et);
            var tt = createTag("canvas");
            return tt.width = _e,
            tt.height = et,
            tt
        }
        var assetLoader = function() {
            return {
                loadLumaCanvas: lumaLoader.load,
                getLumaCanvas: lumaLoader.get,
                createCanvas
            }
        }()
          , registeredEffects = {};
        function CVEffects(_e) {
            var et, tt = _e.data.ef ? _e.data.ef.length : 0;
            this.filters = [];
            var rt;
            for (et = 0; et < tt; et += 1) {
                rt = null;
                var nt = _e.data.ef[et].ty;
                if (registeredEffects[nt]) {
                    var it = registeredEffects[nt].effect;
                    rt = new it(_e.effectsManager.effectElements[et],_e)
                }
                rt && this.filters.push(rt)
            }
            this.filters.length && _e.addRenderableComponent(this)
        }
        CVEffects.prototype.renderFrame = function(_e) {
            var et, tt = this.filters.length;
            for (et = 0; et < tt; et += 1)
                this.filters[et].renderFrame(_e)
        }
        ,
        CVEffects.prototype.getEffects = function(_e) {
            var et, tt = this.filters.length, rt = [];
            for (et = 0; et < tt; et += 1)
                this.filters[et].type === _e && rt.push(this.filters[et]);
            return rt
        }
        ;
        function registerEffect(_e, et) {
            registeredEffects[_e] = {
                effect: et
            }
        }
        function CVMaskElement(_e, et) {
            this.data = _e,
            this.element = et,
            this.masksProperties = this.data.masksProperties || [],
            this.viewData = createSizedArray(this.masksProperties.length);
            var tt, rt = this.masksProperties.length, nt = !1;
            for (tt = 0; tt < rt; tt += 1)
                this.masksProperties[tt].mode !== "n" && (nt = !0),
                this.viewData[tt] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[tt], 3);
            this.hasMasks = nt,
            nt && this.element.addRenderableComponent(this)
        }
        CVMaskElement.prototype.renderFrame = function() {
            if (this.hasMasks) {
                var _e = this.element.finalTransform.mat, et = this.element.canvasContext, tt, rt = this.masksProperties.length, nt, it, st;
                for (et.beginPath(),
                tt = 0; tt < rt; tt += 1)
                    if (this.masksProperties[tt].mode !== "n") {
                        this.masksProperties[tt].inv && (et.moveTo(0, 0),
                        et.lineTo(this.element.globalData.compSize.w, 0),
                        et.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h),
                        et.lineTo(0, this.element.globalData.compSize.h),
                        et.lineTo(0, 0)),
                        st = this.viewData[tt].v,
                        nt = _e.applyToPointArray(st.v[0][0], st.v[0][1], 0),
                        et.moveTo(nt[0], nt[1]);
                        var at, ot = st._length;
                        for (at = 1; at < ot; at += 1)
                            it = _e.applyToTriplePoints(st.o[at - 1], st.i[at], st.v[at]),
                            et.bezierCurveTo(it[0], it[1], it[2], it[3], it[4], it[5]);
                        it = _e.applyToTriplePoints(st.o[at - 1], st.i[0], st.v[0]),
                        et.bezierCurveTo(it[0], it[1], it[2], it[3], it[4], it[5])
                    }
                this.element.globalData.renderer.save(!0),
                et.clip()
            }
        }
        ,
        CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty,
        CVMaskElement.prototype.destroy = function() {
            this.element = null
        }
        ;
        function CVBaseElement() {}
        var operationsMap = {
            1: "source-in",
            2: "source-out",
            3: "source-in",
            4: "source-out"
        };
        CVBaseElement.prototype = {
            createElements: function() {},
            initRendererElement: function() {},
            createContainerElements: function() {
                if (this.data.tt >= 1) {
                    this.buffers = [];
                    var et = this.globalData.canvasContext
                      , tt = assetLoader.createCanvas(et.canvas.width, et.canvas.height);
                    this.buffers.push(tt);
                    var rt = assetLoader.createCanvas(et.canvas.width, et.canvas.height);
                    this.buffers.push(rt),
                    this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
                }
                this.canvasContext = this.globalData.canvasContext,
                this.transformCanvas = this.globalData.transformCanvas,
                this.renderableEffectsManager = new CVEffects(this),
                this.searchEffectTransforms()
            },
            createContent: function() {},
            setBlendMode: function() {
                var et = this.globalData;
                if (et.blendMode !== this.data.bm) {
                    et.blendMode = this.data.bm;
                    var tt = getBlendMode(this.data.bm);
                    et.canvasContext.globalCompositeOperation = tt
                }
            },
            createRenderableComponents: function() {
                this.maskManager = new CVMaskElement(this.data,this),
                this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
            },
            hideElement: function() {
                !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0)
            },
            showElement: function() {
                this.isInRange && !this.isTransparent && (this.hidden = !1,
                this._isFirstFrame = !0,
                this.maskManager._isFirstFrame = !0)
            },
            clearCanvas: function(et) {
                et.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
            },
            prepareLayer: function() {
                if (this.data.tt >= 1) {
                    var et = this.buffers[0]
                      , tt = et.getContext("2d");
                    this.clearCanvas(tt),
                    tt.drawImage(this.canvasContext.canvas, 0, 0),
                    this.currentTransform = this.canvasContext.getTransform(),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform)
                }
            },
            exitLayer: function() {
                if (this.data.tt >= 1) {
                    var et = this.buffers[1]
                      , tt = et.getContext("2d");
                    this.clearCanvas(tt),
                    tt.drawImage(this.canvasContext.canvas, 0, 0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform);
                    var rt = this.comp.getElementById("tp"in this.data ? this.data.tp : this.data.ind - 1);
                    if (rt.renderFrame(!0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.data.tt >= 3 && !document._isProxy) {
                        var nt = assetLoader.getLumaCanvas(this.canvasContext.canvas)
                          , it = nt.getContext("2d");
                        it.drawImage(this.canvasContext.canvas, 0, 0),
                        this.clearCanvas(this.canvasContext),
                        this.canvasContext.drawImage(nt, 0, 0)
                    }
                    this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt],
                    this.canvasContext.drawImage(et, 0, 0),
                    this.canvasContext.globalCompositeOperation = "destination-over",
                    this.canvasContext.drawImage(this.buffers[0], 0, 0),
                    this.canvasContext.setTransform(this.currentTransform),
                    this.canvasContext.globalCompositeOperation = "source-over"
                }
            },
            renderFrame: function(et) {
                if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !et)) {
                    this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.setBlendMode();
                    var tt = this.data.ty === 0;
                    this.prepareLayer(),
                    this.globalData.renderer.save(tt),
                    this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props),
                    this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity),
                    this.renderInnerContent(),
                    this.globalData.renderer.restore(tt),
                    this.exitLayer(),
                    this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
                    this._isFirstFrame && (this._isFirstFrame = !1)
                }
            },
            destroy: function() {
                this.canvasContext = null,
                this.data = null,
                this.globalData = null,
                this.maskManager.destroy()
            },
            mHelper: new Matrix
        },
        CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement,
        CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
        function CVShapeData(_e, et, tt, rt) {
            this.styledShapes = [],
            this.tr = [0, 0, 0, 0, 0, 0];
            var nt = 4;
            et.ty === "rc" ? nt = 5 : et.ty === "el" ? nt = 6 : et.ty === "sr" && (nt = 7),
            this.sh = ShapePropertyFactory.getShapeProp(_e, et, nt, _e);
            var it, st = tt.length, at;
            for (it = 0; it < st; it += 1)
                tt[it].closed || (at = {
                    transforms: rt.addTransformSequence(tt[it].transforms),
                    trNodes: []
                },
                this.styledShapes.push(at),
                tt[it].elements.push(at))
        }
        CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
        function CVShapeElement(_e, et, tt) {
            this.shapes = [],
            this.shapesData = _e.shapes,
            this.stylesList = [],
            this.itemsData = [],
            this.prevViewData = [],
            this.shapeModifiers = [],
            this.processedElements = [],
            this.transformsManager = new ShapeTransformManager,
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement),
        CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement,
        CVShapeElement.prototype.transformHelper = {
            opacity: 1,
            _opMdf: !1
        },
        CVShapeElement.prototype.dashResetter = [],
        CVShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
        }
        ,
        CVShapeElement.prototype.createStyleElement = function(_e, et) {
            var tt = {
                data: _e,
                type: _e.ty,
                preTransforms: this.transformsManager.addTransformSequence(et),
                transforms: [],
                elements: [],
                closed: _e.hd === !0
            }
              , rt = {};
            if (_e.ty === "fl" || _e.ty === "st" ? (rt.c = PropertyFactory.getProp(this, _e.c, 1, 255, this),
            rt.c.k || (tt.co = "rgb(" + bmFloor(rt.c.v[0]) + "," + bmFloor(rt.c.v[1]) + "," + bmFloor(rt.c.v[2]) + ")")) : (_e.ty === "gf" || _e.ty === "gs") && (rt.s = PropertyFactory.getProp(this, _e.s, 1, null, this),
            rt.e = PropertyFactory.getProp(this, _e.e, 1, null, this),
            rt.h = PropertyFactory.getProp(this, _e.h || {
                k: 0
            }, 0, .01, this),
            rt.a = PropertyFactory.getProp(this, _e.a || {
                k: 0
            }, 0, degToRads, this),
            rt.g = new GradientProperty(this,_e.g,this)),
            rt.o = PropertyFactory.getProp(this, _e.o, 0, .01, this),
            _e.ty === "st" || _e.ty === "gs") {
                if (tt.lc = lineCapEnum[_e.lc || 2],
                tt.lj = lineJoinEnum[_e.lj || 2],
                _e.lj == 1 && (tt.ml = _e.ml),
                rt.w = PropertyFactory.getProp(this, _e.w, 0, null, this),
                rt.w.k || (tt.wi = rt.w.v),
                _e.d) {
                    var nt = new DashProperty(this,_e.d,"canvas",this);
                    rt.d = nt,
                    rt.d.k || (tt.da = rt.d.dashArray,
                    tt.do = rt.d.dashoffset[0])
                }
            } else
                tt.r = _e.r === 2 ? "evenodd" : "nonzero";
            return this.stylesList.push(tt),
            rt.style = tt,
            rt
        }
        ,
        CVShapeElement.prototype.createGroupElement = function() {
            var _e = {
                it: [],
                prevViewData: []
            };
            return _e
        }
        ,
        CVShapeElement.prototype.createTransformElement = function(_e) {
            var et = {
                transform: {
                    opacity: 1,
                    _opMdf: !1,
                    key: this.transformsManager.getNewKey(),
                    op: PropertyFactory.getProp(this, _e.o, 0, .01, this),
                    mProps: TransformPropertyFactory.getTransformProperty(this, _e, this)
                }
            };
            return et
        }
        ,
        CVShapeElement.prototype.createShapeElement = function(_e) {
            var et = new CVShapeData(this,_e,this.stylesList,this.transformsManager);
            return this.shapes.push(et),
            this.addShapeToModifiers(et),
            et
        }
        ,
        CVShapeElement.prototype.reloadShapes = function() {
            this._isFirstFrame = !0;
            var _e, et = this.itemsData.length;
            for (_e = 0; _e < et; _e += 1)
                this.prevViewData[_e] = this.itemsData[_e];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []),
            et = this.dynamicProperties.length,
            _e = 0; _e < et; _e += 1)
                this.dynamicProperties[_e].getValue();
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame)
        }
        ,
        CVShapeElement.prototype.addTransformToStyleList = function(_e) {
            var et, tt = this.stylesList.length;
            for (et = 0; et < tt; et += 1)
                this.stylesList[et].closed || this.stylesList[et].transforms.push(_e)
        }
        ,
        CVShapeElement.prototype.removeTransformFromStyleList = function() {
            var _e, et = this.stylesList.length;
            for (_e = 0; _e < et; _e += 1)
                this.stylesList[_e].closed || this.stylesList[_e].transforms.pop()
        }
        ,
        CVShapeElement.prototype.closeStyles = function(_e) {
            var et, tt = _e.length;
            for (et = 0; et < tt; et += 1)
                _e[et].closed = !0
        }
        ,
        CVShapeElement.prototype.searchShapes = function(_e, et, tt, rt, nt) {
            var it, st = _e.length - 1, at, ot, lt = [], dt = [], ct, ut, ft, ht = [].concat(nt);
            for (it = st; it >= 0; it -= 1) {
                if (ct = this.searchProcessedElement(_e[it]),
                ct ? et[it] = tt[ct - 1] : _e[it]._shouldRender = rt,
                _e[it].ty === "fl" || _e[it].ty === "st" || _e[it].ty === "gf" || _e[it].ty === "gs")
                    ct ? et[it].style.closed = !1 : et[it] = this.createStyleElement(_e[it], ht),
                    lt.push(et[it].style);
                else if (_e[it].ty === "gr") {
                    if (!ct)
                        et[it] = this.createGroupElement(_e[it]);
                    else
                        for (ot = et[it].it.length,
                        at = 0; at < ot; at += 1)
                            et[it].prevViewData[at] = et[it].it[at];
                    this.searchShapes(_e[it].it, et[it].it, et[it].prevViewData, rt, ht)
                } else
                    _e[it].ty === "tr" ? (ct || (ft = this.createTransformElement(_e[it]),
                    et[it] = ft),
                    ht.push(et[it]),
                    this.addTransformToStyleList(et[it])) : _e[it].ty === "sh" || _e[it].ty === "rc" || _e[it].ty === "el" || _e[it].ty === "sr" ? ct || (et[it] = this.createShapeElement(_e[it])) : _e[it].ty === "tm" || _e[it].ty === "rd" || _e[it].ty === "pb" || _e[it].ty === "zz" || _e[it].ty === "op" ? (ct ? (ut = et[it],
                    ut.closed = !1) : (ut = ShapeModifiers.getModifier(_e[it].ty),
                    ut.init(this, _e[it]),
                    et[it] = ut,
                    this.shapeModifiers.push(ut)),
                    dt.push(ut)) : _e[it].ty === "rp" && (ct ? (ut = et[it],
                    ut.closed = !0) : (ut = ShapeModifiers.getModifier(_e[it].ty),
                    et[it] = ut,
                    ut.init(this, _e, it, et),
                    this.shapeModifiers.push(ut),
                    rt = !1),
                    dt.push(ut));
                this.addProcessedElement(_e[it], it + 1)
            }
            for (this.removeTransformFromStyleList(),
            this.closeStyles(lt),
            st = dt.length,
            it = 0; it < st; it += 1)
                dt[it].closed = !0
        }
        ,
        CVShapeElement.prototype.renderInnerContent = function() {
            this.transformHelper.opacity = 1,
            this.transformHelper._opMdf = !1,
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
        }
        ,
        CVShapeElement.prototype.renderShapeTransform = function(_e, et) {
            (_e._opMdf || et.op._mdf || this._isFirstFrame) && (et.opacity = _e.opacity,
            et.opacity *= et.op.v,
            et._opMdf = !0)
        }
        ,
        CVShapeElement.prototype.drawLayer = function() {
            var _e, et = this.stylesList.length, tt, rt, nt, it, st, at, ot = this.globalData.renderer, lt = this.globalData.canvasContext, dt, ct;
            for (_e = 0; _e < et; _e += 1)
                if (ct = this.stylesList[_e],
                dt = ct.type,
                !((dt === "st" || dt === "gs") && ct.wi === 0 || !ct.data._shouldRender || ct.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                    for (ot.save(),
                    st = ct.elements,
                    dt === "st" || dt === "gs" ? (ot.ctxStrokeStyle(dt === "st" ? ct.co : ct.grd),
                    ot.ctxLineWidth(ct.wi),
                    ot.ctxLineCap(ct.lc),
                    ot.ctxLineJoin(ct.lj),
                    ot.ctxMiterLimit(ct.ml || 0)) : ot.ctxFillStyle(dt === "fl" ? ct.co : ct.grd),
                    ot.ctxOpacity(ct.coOp),
                    dt !== "st" && dt !== "gs" && lt.beginPath(),
                    ot.ctxTransform(ct.preTransforms.finalTransform.props),
                    rt = st.length,
                    tt = 0; tt < rt; tt += 1) {
                        for ((dt === "st" || dt === "gs") && (lt.beginPath(),
                        ct.da && (lt.setLineDash(ct.da),
                        lt.lineDashOffset = ct.do)),
                        at = st[tt].trNodes,
                        it = at.length,
                        nt = 0; nt < it; nt += 1)
                            at[nt].t === "m" ? lt.moveTo(at[nt].p[0], at[nt].p[1]) : at[nt].t === "c" ? lt.bezierCurveTo(at[nt].pts[0], at[nt].pts[1], at[nt].pts[2], at[nt].pts[3], at[nt].pts[4], at[nt].pts[5]) : lt.closePath();
                        (dt === "st" || dt === "gs") && (ot.ctxStroke(),
                        ct.da && lt.setLineDash(this.dashResetter))
                    }
                    dt !== "st" && dt !== "gs" && this.globalData.renderer.ctxFill(ct.r),
                    ot.restore()
                }
        }
        ,
        CVShapeElement.prototype.renderShape = function(_e, et, tt, rt) {
            var nt, it = et.length - 1, st;
            for (st = _e,
            nt = it; nt >= 0; nt -= 1)
                et[nt].ty === "tr" ? (st = tt[nt].transform,
                this.renderShapeTransform(_e, st)) : et[nt].ty === "sh" || et[nt].ty === "el" || et[nt].ty === "rc" || et[nt].ty === "sr" ? this.renderPath(et[nt], tt[nt]) : et[nt].ty === "fl" ? this.renderFill(et[nt], tt[nt], st) : et[nt].ty === "st" ? this.renderStroke(et[nt], tt[nt], st) : et[nt].ty === "gf" || et[nt].ty === "gs" ? this.renderGradientFill(et[nt], tt[nt], st) : et[nt].ty === "gr" ? this.renderShape(st, et[nt].it, tt[nt].it) : et[nt].ty;
            rt && this.drawLayer()
        }
        ,
        CVShapeElement.prototype.renderStyledShape = function(_e, et) {
            if (this._isFirstFrame || et._mdf || _e.transforms._mdf) {
                var tt = _e.trNodes, rt = et.paths, nt, it, st, at = rt._length;
                tt.length = 0;
                var ot = _e.transforms.finalTransform;
                for (st = 0; st < at; st += 1) {
                    var lt = rt.shapes[st];
                    if (lt && lt.v) {
                        for (it = lt._length,
                        nt = 1; nt < it; nt += 1)
                            nt === 1 && tt.push({
                                t: "m",
                                p: ot.applyToPointArray(lt.v[0][0], lt.v[0][1], 0)
                            }),
                            tt.push({
                                t: "c",
                                pts: ot.applyToTriplePoints(lt.o[nt - 1], lt.i[nt], lt.v[nt])
                            });
                        it === 1 && tt.push({
                            t: "m",
                            p: ot.applyToPointArray(lt.v[0][0], lt.v[0][1], 0)
                        }),
                        lt.c && it && (tt.push({
                            t: "c",
                            pts: ot.applyToTriplePoints(lt.o[nt - 1], lt.i[0], lt.v[0])
                        }),
                        tt.push({
                            t: "z"
                        }))
                    }
                }
                _e.trNodes = tt
            }
        }
        ,
        CVShapeElement.prototype.renderPath = function(_e, et) {
            if (_e.hd !== !0 && _e._shouldRender) {
                var tt, rt = et.styledShapes.length;
                for (tt = 0; tt < rt; tt += 1)
                    this.renderStyledShape(et.styledShapes[tt], et.sh)
            }
        }
        ,
        CVShapeElement.prototype.renderFill = function(_e, et, tt) {
            var rt = et.style;
            (et.c._mdf || this._isFirstFrame) && (rt.co = "rgb(" + bmFloor(et.c.v[0]) + "," + bmFloor(et.c.v[1]) + "," + bmFloor(et.c.v[2]) + ")"),
            (et.o._mdf || tt._opMdf || this._isFirstFrame) && (rt.coOp = et.o.v * tt.opacity)
        }
        ,
        CVShapeElement.prototype.renderGradientFill = function(_e, et, tt) {
            var rt = et.style, nt;
            if (!rt.grd || et.g._mdf || et.s._mdf || et.e._mdf || _e.t !== 1 && (et.h._mdf || et.a._mdf)) {
                var it = this.globalData.canvasContext
                  , st = et.s.v
                  , at = et.e.v;
                if (_e.t === 1)
                    nt = it.createLinearGradient(st[0], st[1], at[0], at[1]);
                else {
                    var ot = Math.sqrt(Math.pow(st[0] - at[0], 2) + Math.pow(st[1] - at[1], 2))
                      , lt = Math.atan2(at[1] - st[1], at[0] - st[0])
                      , dt = et.h.v;
                    dt >= 1 ? dt = .99 : dt <= -1 && (dt = -.99);
                    var ct = ot * dt
                      , ut = Math.cos(lt + et.a.v) * ct + st[0]
                      , ft = Math.sin(lt + et.a.v) * ct + st[1];
                    nt = it.createRadialGradient(ut, ft, 0, st[0], st[1], ot)
                }
                var ht, gt = _e.g.p, bt = et.g.c, pt = 1;
                for (ht = 0; ht < gt; ht += 1)
                    et.g._hasOpacity && et.g._collapsable && (pt = et.g.o[ht * 2 + 1]),
                    nt.addColorStop(bt[ht * 4] / 100, "rgba(" + bt[ht * 4 + 1] + "," + bt[ht * 4 + 2] + "," + bt[ht * 4 + 3] + "," + pt + ")");
                rt.grd = nt
            }
            rt.coOp = et.o.v * tt.opacity
        }
        ,
        CVShapeElement.prototype.renderStroke = function(_e, et, tt) {
            var rt = et.style
              , nt = et.d;
            nt && (nt._mdf || this._isFirstFrame) && (rt.da = nt.dashArray,
            rt.do = nt.dashoffset[0]),
            (et.c._mdf || this._isFirstFrame) && (rt.co = "rgb(" + bmFloor(et.c.v[0]) + "," + bmFloor(et.c.v[1]) + "," + bmFloor(et.c.v[2]) + ")"),
            (et.o._mdf || tt._opMdf || this._isFirstFrame) && (rt.coOp = et.o.v * tt.opacity),
            (et.w._mdf || this._isFirstFrame) && (rt.wi = et.w.v)
        }
        ,
        CVShapeElement.prototype.destroy = function() {
            this.shapesData = null,
            this.globalData = null,
            this.canvasContext = null,
            this.stylesList.length = 0,
            this.itemsData.length = 0
        }
        ;
        function CVTextElement(_e, et, tt) {
            this.textSpans = [],
            this.yOffset = 0,
            this.fillColorAnim = !1,
            this.strokeColorAnim = !1,
            this.strokeWidthAnim = !1,
            this.stroke = !1,
            this.fill = !1,
            this.justifyOffset = 0,
            this.currentRender = null,
            this.renderType = "canvas",
            this.values = {
                fill: "rgba(0,0,0,0)",
                stroke: "rgba(0,0,0,0)",
                sWidth: 0,
                fValue: ""
            },
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement),
        CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"),
        CVTextElement.prototype.buildNewText = function() {
            var _e = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(_e.l ? _e.l.length : 0);
            var et = !1;
            _e.fc ? (et = !0,
            this.values.fill = this.buildColor(_e.fc)) : this.values.fill = "rgba(0,0,0,0)",
            this.fill = et;
            var tt = !1;
            _e.sc && (tt = !0,
            this.values.stroke = this.buildColor(_e.sc),
            this.values.sWidth = _e.sw);
            var rt = this.globalData.fontManager.getFontByName(_e.f), nt, it, st = _e.l, at = this.mHelper;
            this.stroke = tt,
            this.values.fValue = _e.finalSize + "px " + this.globalData.fontManager.getFontByName(_e.f).fFamily,
            it = _e.finalText.length;
            var ot, lt, dt, ct, ut, ft, ht, gt, bt, pt, mt = this.data.singleShape, yt = _e.tr * .001 * _e.finalSize, vt = 0, wt = 0, _t = !0, Et = 0;
            for (nt = 0; nt < it; nt += 1) {
                ot = this.globalData.fontManager.getCharData(_e.finalText[nt], rt.fStyle, this.globalData.fontManager.getFontByName(_e.f).fFamily),
                lt = ot && ot.data || {},
                at.reset(),
                mt && st[nt].n && (vt = -yt,
                wt += _e.yOffset,
                wt += _t ? 1 : 0,
                _t = !1),
                ut = lt.shapes ? lt.shapes[0].it : [],
                ht = ut.length,
                at.scale(_e.finalSize / 100, _e.finalSize / 100),
                mt && this.applyTextPropertiesToMatrix(_e, at, st[nt].line, vt, wt),
                bt = createSizedArray(ht - 1);
                var xt = 0;
                for (ft = 0; ft < ht; ft += 1)
                    if (ut[ft].ty === "sh") {
                        for (ct = ut[ft].ks.k.i.length,
                        gt = ut[ft].ks.k,
                        pt = [],
                        dt = 1; dt < ct; dt += 1)
                            dt === 1 && pt.push(at.applyToX(gt.v[0][0], gt.v[0][1], 0), at.applyToY(gt.v[0][0], gt.v[0][1], 0)),
                            pt.push(at.applyToX(gt.o[dt - 1][0], gt.o[dt - 1][1], 0), at.applyToY(gt.o[dt - 1][0], gt.o[dt - 1][1], 0), at.applyToX(gt.i[dt][0], gt.i[dt][1], 0), at.applyToY(gt.i[dt][0], gt.i[dt][1], 0), at.applyToX(gt.v[dt][0], gt.v[dt][1], 0), at.applyToY(gt.v[dt][0], gt.v[dt][1], 0));
                        pt.push(at.applyToX(gt.o[dt - 1][0], gt.o[dt - 1][1], 0), at.applyToY(gt.o[dt - 1][0], gt.o[dt - 1][1], 0), at.applyToX(gt.i[0][0], gt.i[0][1], 0), at.applyToY(gt.i[0][0], gt.i[0][1], 0), at.applyToX(gt.v[0][0], gt.v[0][1], 0), at.applyToY(gt.v[0][0], gt.v[0][1], 0)),
                        bt[xt] = pt,
                        xt += 1
                    }
                mt && (vt += st[nt].l,
                vt += yt),
                this.textSpans[Et] ? this.textSpans[Et].elem = bt : this.textSpans[Et] = {
                    elem: bt
                },
                Et += 1
            }
        }
        ,
        CVTextElement.prototype.renderInnerContent = function() {
            this.validateText();
            var _e = this.canvasContext;
            _e.font = this.values.fValue,
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            var et, tt, rt, nt, it, st, at = this.textAnimator.renderedLetters, ot = this.textProperty.currentData.l;
            tt = ot.length;
            var lt, dt = null, ct = null, ut = null, ft, ht, gt = this.globalData.renderer;
            for (et = 0; et < tt; et += 1)
                if (!ot[et].n) {
                    if (lt = at[et],
                    lt && (gt.save(),
                    gt.ctxTransform(lt.p),
                    gt.ctxOpacity(lt.o)),
                    this.fill) {
                        for (lt && lt.fc ? dt !== lt.fc && (gt.ctxFillStyle(lt.fc),
                        dt = lt.fc) : dt !== this.values.fill && (dt = this.values.fill,
                        gt.ctxFillStyle(this.values.fill)),
                        ft = this.textSpans[et].elem,
                        nt = ft.length,
                        this.globalData.canvasContext.beginPath(),
                        rt = 0; rt < nt; rt += 1)
                            for (ht = ft[rt],
                            st = ht.length,
                            this.globalData.canvasContext.moveTo(ht[0], ht[1]),
                            it = 2; it < st; it += 6)
                                this.globalData.canvasContext.bezierCurveTo(ht[it], ht[it + 1], ht[it + 2], ht[it + 3], ht[it + 4], ht[it + 5]);
                        this.globalData.canvasContext.closePath(),
                        gt.ctxFill()
                    }
                    if (this.stroke) {
                        for (lt && lt.sw ? ut !== lt.sw && (ut = lt.sw,
                        gt.ctxLineWidth(lt.sw)) : ut !== this.values.sWidth && (ut = this.values.sWidth,
                        gt.ctxLineWidth(this.values.sWidth)),
                        lt && lt.sc ? ct !== lt.sc && (ct = lt.sc,
                        gt.ctxStrokeStyle(lt.sc)) : ct !== this.values.stroke && (ct = this.values.stroke,
                        gt.ctxStrokeStyle(this.values.stroke)),
                        ft = this.textSpans[et].elem,
                        nt = ft.length,
                        this.globalData.canvasContext.beginPath(),
                        rt = 0; rt < nt; rt += 1)
                            for (ht = ft[rt],
                            st = ht.length,
                            this.globalData.canvasContext.moveTo(ht[0], ht[1]),
                            it = 2; it < st; it += 6)
                                this.globalData.canvasContext.bezierCurveTo(ht[it], ht[it + 1], ht[it + 2], ht[it + 3], ht[it + 4], ht[it + 5]);
                        this.globalData.canvasContext.closePath(),
                        gt.ctxStroke()
                    }
                    lt && this.globalData.renderer.restore()
                }
        }
        ;
        function CVImageElement(_e, et, tt) {
            this.assetData = et.getAssetData(_e.refId),
            this.img = et.imageLoader.getAsset(this.assetData),
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement),
        CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVImageElement.prototype.createContent = function() {
            if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                var _e = createTag("canvas");
                _e.width = this.assetData.w,
                _e.height = this.assetData.h;
                var et = _e.getContext("2d"), tt = this.img.width, rt = this.img.height, nt = tt / rt, it = this.assetData.w / this.assetData.h, st, at, ot = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                nt > it && ot === "xMidYMid slice" || nt < it && ot !== "xMidYMid slice" ? (at = rt,
                st = at * it) : (st = tt,
                at = st / it),
                et.drawImage(this.img, (tt - st) / 2, (rt - at) / 2, st, at, 0, 0, this.assetData.w, this.assetData.h),
                this.img = _e
            }
        }
        ,
        CVImageElement.prototype.renderInnerContent = function() {
            this.canvasContext.drawImage(this.img, 0, 0)
        }
        ,
        CVImageElement.prototype.destroy = function() {
            this.img = null
        }
        ;
        function CVSolidElement(_e, et, tt) {
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement),
        CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVSolidElement.prototype.renderInnerContent = function() {
            this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
        }
        ;
        function CanvasRendererBase() {}
        extendPrototype([BaseRenderer], CanvasRendererBase),
        CanvasRendererBase.prototype.createShape = function(_e) {
            return new CVShapeElement(_e,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createText = function(_e) {
            return new CVTextElement(_e,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createImage = function(_e) {
            return new CVImageElement(_e,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createSolid = function(_e) {
            return new CVSolidElement(_e,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        CanvasRendererBase.prototype.ctxTransform = function(_e) {
            _e[0] === 1 && _e[1] === 0 && _e[4] === 0 && _e[5] === 1 && _e[12] === 0 && _e[13] === 0 || this.canvasContext.transform(_e[0], _e[1], _e[4], _e[5], _e[12], _e[13])
        }
        ,
        CanvasRendererBase.prototype.ctxOpacity = function(_e) {
            this.canvasContext.globalAlpha *= _e < 0 ? 0 : _e
        }
        ,
        CanvasRendererBase.prototype.ctxFillStyle = function(_e) {
            this.canvasContext.fillStyle = _e
        }
        ,
        CanvasRendererBase.prototype.ctxStrokeStyle = function(_e) {
            this.canvasContext.strokeStyle = _e
        }
        ,
        CanvasRendererBase.prototype.ctxLineWidth = function(_e) {
            this.canvasContext.lineWidth = _e
        }
        ,
        CanvasRendererBase.prototype.ctxLineCap = function(_e) {
            this.canvasContext.lineCap = _e
        }
        ,
        CanvasRendererBase.prototype.ctxLineJoin = function(_e) {
            this.canvasContext.lineJoin = _e
        }
        ,
        CanvasRendererBase.prototype.ctxMiterLimit = function(_e) {
            this.canvasContext.miterLimit = _e
        }
        ,
        CanvasRendererBase.prototype.ctxFill = function(_e) {
            this.canvasContext.fill(_e)
        }
        ,
        CanvasRendererBase.prototype.ctxFillRect = function(_e, et, tt, rt) {
            this.canvasContext.fillRect(_e, et, tt, rt)
        }
        ,
        CanvasRendererBase.prototype.ctxStroke = function() {
            this.canvasContext.stroke()
        }
        ,
        CanvasRendererBase.prototype.reset = function() {
            if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return
            }
            this.contextData.reset()
        }
        ,
        CanvasRendererBase.prototype.save = function() {
            this.canvasContext.save()
        }
        ,
        CanvasRendererBase.prototype.restore = function(_e) {
            if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return
            }
            _e && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(_e)
        }
        ,
        CanvasRendererBase.prototype.configAnimation = function(_e) {
            if (this.animationItem.wrapper) {
                this.animationItem.container = createTag("canvas");
                var et = this.animationItem.container.style;
                et.width = "100%",
                et.height = "100%";
                var tt = "0px 0px 0px";
                et.transformOrigin = tt,
                et.mozTransformOrigin = tt,
                et.webkitTransformOrigin = tt,
                et["-webkit-transform"] = tt,
                et.contentVisibility = this.renderConfig.contentVisibility,
                this.animationItem.wrapper.appendChild(this.animationItem.container),
                this.canvasContext = this.animationItem.container.getContext("2d"),
                this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className),
                this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
            } else
                this.canvasContext = this.renderConfig.context;
            this.contextData.setContext(this.canvasContext),
            this.data = _e,
            this.layers = _e.layers,
            this.transformCanvas = {
                w: _e.w,
                h: _e.h,
                sx: 0,
                sy: 0,
                tx: 0,
                ty: 0
            },
            this.setupGlobalData(_e, document.body),
            this.globalData.canvasContext = this.canvasContext,
            this.globalData.renderer = this,
            this.globalData.isDashed = !1,
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.globalData.transformCanvas = this.transformCanvas,
            this.elements = createSizedArray(_e.layers.length),
            this.updateContainerSize()
        }
        ,
        CanvasRendererBase.prototype.updateContainerSize = function(_e, et) {
            this.reset();
            var tt, rt;
            _e ? (tt = _e,
            rt = et,
            this.canvasContext.canvas.width = tt,
            this.canvasContext.canvas.height = rt) : (this.animationItem.wrapper && this.animationItem.container ? (tt = this.animationItem.wrapper.offsetWidth,
            rt = this.animationItem.wrapper.offsetHeight) : (tt = this.canvasContext.canvas.width,
            rt = this.canvasContext.canvas.height),
            this.canvasContext.canvas.width = tt * this.renderConfig.dpr,
            this.canvasContext.canvas.height = rt * this.renderConfig.dpr);
            var nt, it;
            if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
                var st = this.renderConfig.preserveAspectRatio.split(" ")
                  , at = st[1] || "meet"
                  , ot = st[0] || "xMidYMid"
                  , lt = ot.substr(0, 4)
                  , dt = ot.substr(4);
                nt = tt / rt,
                it = this.transformCanvas.w / this.transformCanvas.h,
                it > nt && at === "meet" || it < nt && at === "slice" ? (this.transformCanvas.sx = tt / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = tt / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = rt / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.sy = rt / (this.transformCanvas.h / this.renderConfig.dpr)),
                lt === "xMid" && (it < nt && at === "meet" || it > nt && at === "slice") ? this.transformCanvas.tx = (tt - this.transformCanvas.w * (rt / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : lt === "xMax" && (it < nt && at === "meet" || it > nt && at === "slice") ? this.transformCanvas.tx = (tt - this.transformCanvas.w * (rt / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0,
                dt === "YMid" && (it > nt && at === "meet" || it < nt && at === "slice") ? this.transformCanvas.ty = (rt - this.transformCanvas.h * (tt / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : dt === "YMax" && (it > nt && at === "meet" || it < nt && at === "slice") ? this.transformCanvas.ty = (rt - this.transformCanvas.h * (tt / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0
            } else
                this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = tt / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = rt / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr,
                this.transformCanvas.sy = this.renderConfig.dpr,
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0);
            this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1],
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0)
        }
        ,
        CanvasRendererBase.prototype.destroy = function() {
            this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
            var _e, et = this.layers ? this.layers.length : 0;
            for (_e = et - 1; _e >= 0; _e -= 1)
                this.elements[_e] && this.elements[_e].destroy && this.elements[_e].destroy();
            this.elements.length = 0,
            this.globalData.canvasContext = null,
            this.animationItem.container = null,
            this.destroyed = !0
        }
        ,
        CanvasRendererBase.prototype.renderFrame = function(_e, et) {
            if (!(this.renderedFrame === _e && this.renderConfig.clearCanvas === !0 && !et || this.destroyed || _e === -1)) {
                this.renderedFrame = _e,
                this.globalData.frameNum = _e - this.animationItem._isFirstFrame,
                this.globalData.frameId += 1,
                this.globalData._mdf = !this.renderConfig.clearCanvas || et,
                this.globalData.projectInterface.currentFrame = _e;
                var tt, rt = this.layers.length;
                for (this.completeLayers || this.checkLayers(_e),
                tt = rt - 1; tt >= 0; tt -= 1)
                    (this.completeLayers || this.elements[tt]) && this.elements[tt].prepareFrame(_e - this.layers[tt].st);
                if (this.globalData._mdf) {
                    for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(),
                    tt = rt - 1; tt >= 0; tt -= 1)
                        (this.completeLayers || this.elements[tt]) && this.elements[tt].renderFrame();
                    this.renderConfig.clearCanvas !== !0 && this.restore()
                }
            }
        }
        ,
        CanvasRendererBase.prototype.buildItem = function(_e) {
            var et = this.elements;
            if (!(et[_e] || this.layers[_e].ty === 99)) {
                var tt = this.createItem(this.layers[_e], this, this.globalData);
                et[_e] = tt,
                tt.initExpressions()
            }
        }
        ,
        CanvasRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var _e = this.pendingElements.pop();
                _e.checkParenting()
            }
        }
        ,
        CanvasRendererBase.prototype.hide = function() {
            this.animationItem.container.style.display = "none"
        }
        ,
        CanvasRendererBase.prototype.show = function() {
            this.animationItem.container.style.display = "block"
        }
        ;
        function CanvasContext() {
            this.opacity = -1,
            this.transform = createTypedArray("float32", 16),
            this.fillStyle = "",
            this.strokeStyle = "",
            this.lineWidth = "",
            this.lineCap = "",
            this.lineJoin = "",
            this.miterLimit = "",
            this.id = Math.random()
        }
        function CVContextData() {
            this.stack = [],
            this.cArrPos = 0,
            this.cTr = new Matrix;
            var _e, et = 15;
            for (_e = 0; _e < et; _e += 1) {
                var tt = new CanvasContext;
                this.stack[_e] = tt
            }
            this._length = et,
            this.nativeContext = null,
            this.transformMat = new Matrix,
            this.currentOpacity = 1,
            this.currentFillStyle = "",
            this.appliedFillStyle = "",
            this.currentStrokeStyle = "",
            this.appliedStrokeStyle = "",
            this.currentLineWidth = "",
            this.appliedLineWidth = "",
            this.currentLineCap = "",
            this.appliedLineCap = "",
            this.currentLineJoin = "",
            this.appliedLineJoin = "",
            this.appliedMiterLimit = "",
            this.currentMiterLimit = ""
        }
        CVContextData.prototype.duplicate = function() {
            var _e = this._length * 2
              , et = 0;
            for (et = this._length; et < _e; et += 1)
                this.stack[et] = new CanvasContext;
            this._length = _e
        }
        ,
        CVContextData.prototype.reset = function() {
            this.cArrPos = 0,
            this.cTr.reset(),
            this.stack[this.cArrPos].opacity = 1
        }
        ,
        CVContextData.prototype.restore = function(_e) {
            this.cArrPos -= 1;
            var et = this.stack[this.cArrPos], tt = et.transform, rt, nt = this.cTr.props;
            for (rt = 0; rt < 16; rt += 1)
                nt[rt] = tt[rt];
            if (_e) {
                this.nativeContext.restore();
                var it = this.stack[this.cArrPos + 1];
                this.appliedFillStyle = it.fillStyle,
                this.appliedStrokeStyle = it.strokeStyle,
                this.appliedLineWidth = it.lineWidth,
                this.appliedLineCap = it.lineCap,
                this.appliedLineJoin = it.lineJoin,
                this.appliedMiterLimit = it.miterLimit
            }
            this.nativeContext.setTransform(tt[0], tt[1], tt[4], tt[5], tt[12], tt[13]),
            (_e || et.opacity !== -1 && this.currentOpacity !== et.opacity) && (this.nativeContext.globalAlpha = et.opacity,
            this.currentOpacity = et.opacity),
            this.currentFillStyle = et.fillStyle,
            this.currentStrokeStyle = et.strokeStyle,
            this.currentLineWidth = et.lineWidth,
            this.currentLineCap = et.lineCap,
            this.currentLineJoin = et.lineJoin,
            this.currentMiterLimit = et.miterLimit
        }
        ,
        CVContextData.prototype.save = function(_e) {
            _e && this.nativeContext.save();
            var et = this.cTr.props;
            this._length <= this.cArrPos && this.duplicate();
            var tt = this.stack[this.cArrPos], rt;
            for (rt = 0; rt < 16; rt += 1)
                tt.transform[rt] = et[rt];
            this.cArrPos += 1;
            var nt = this.stack[this.cArrPos];
            nt.opacity = tt.opacity,
            nt.fillStyle = tt.fillStyle,
            nt.strokeStyle = tt.strokeStyle,
            nt.lineWidth = tt.lineWidth,
            nt.lineCap = tt.lineCap,
            nt.lineJoin = tt.lineJoin,
            nt.miterLimit = tt.miterLimit
        }
        ,
        CVContextData.prototype.setOpacity = function(_e) {
            this.stack[this.cArrPos].opacity = _e
        }
        ,
        CVContextData.prototype.setContext = function(_e) {
            this.nativeContext = _e
        }
        ,
        CVContextData.prototype.fillStyle = function(_e) {
            this.stack[this.cArrPos].fillStyle !== _e && (this.currentFillStyle = _e,
            this.stack[this.cArrPos].fillStyle = _e)
        }
        ,
        CVContextData.prototype.strokeStyle = function(_e) {
            this.stack[this.cArrPos].strokeStyle !== _e && (this.currentStrokeStyle = _e,
            this.stack[this.cArrPos].strokeStyle = _e)
        }
        ,
        CVContextData.prototype.lineWidth = function(_e) {
            this.stack[this.cArrPos].lineWidth !== _e && (this.currentLineWidth = _e,
            this.stack[this.cArrPos].lineWidth = _e)
        }
        ,
        CVContextData.prototype.lineCap = function(_e) {
            this.stack[this.cArrPos].lineCap !== _e && (this.currentLineCap = _e,
            this.stack[this.cArrPos].lineCap = _e)
        }
        ,
        CVContextData.prototype.lineJoin = function(_e) {
            this.stack[this.cArrPos].lineJoin !== _e && (this.currentLineJoin = _e,
            this.stack[this.cArrPos].lineJoin = _e)
        }
        ,
        CVContextData.prototype.miterLimit = function(_e) {
            this.stack[this.cArrPos].miterLimit !== _e && (this.currentMiterLimit = _e,
            this.stack[this.cArrPos].miterLimit = _e)
        }
        ,
        CVContextData.prototype.transform = function(_e) {
            this.transformMat.cloneFromProps(_e);
            var et = this.cTr;
            this.transformMat.multiply(et),
            et.cloneFromProps(this.transformMat.props);
            var tt = et.props;
            this.nativeContext.setTransform(tt[0], tt[1], tt[4], tt[5], tt[12], tt[13])
        }
        ,
        CVContextData.prototype.opacity = function(_e) {
            var et = this.stack[this.cArrPos].opacity;
            et *= _e < 0 ? 0 : _e,
            this.stack[this.cArrPos].opacity !== et && (this.currentOpacity !== _e && (this.nativeContext.globalAlpha = _e,
            this.currentOpacity = _e),
            this.stack[this.cArrPos].opacity = et)
        }
        ,
        CVContextData.prototype.fill = function(_e) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fill(_e)
        }
        ,
        CVContextData.prototype.fillRect = function(_e, et, tt, rt) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fillRect(_e, et, tt, rt)
        }
        ,
        CVContextData.prototype.stroke = function() {
            this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle,
            this.nativeContext.strokeStyle = this.appliedStrokeStyle),
            this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth,
            this.nativeContext.lineWidth = this.appliedLineWidth),
            this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap,
            this.nativeContext.lineCap = this.appliedLineCap),
            this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin,
            this.nativeContext.lineJoin = this.appliedLineJoin),
            this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit,
            this.nativeContext.miterLimit = this.appliedMiterLimit),
            this.nativeContext.stroke()
        }
        ;
        function CVCompElement(_e, et, tt) {
            this.completeLayers = !1,
            this.layers = _e.layers,
            this.pendingElements = [],
            this.elements = createSizedArray(this.layers.length),
            this.initElement(_e, et, tt),
            this.tm = _e.tm ? PropertyFactory.getProp(this, _e.tm, 0, et.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement),
        CVCompElement.prototype.renderInnerContent = function() {
            var _e = this.canvasContext;
            _e.beginPath(),
            _e.moveTo(0, 0),
            _e.lineTo(this.data.w, 0),
            _e.lineTo(this.data.w, this.data.h),
            _e.lineTo(0, this.data.h),
            _e.lineTo(0, 0),
            _e.clip();
            var et, tt = this.layers.length;
            for (et = tt - 1; et >= 0; et -= 1)
                (this.completeLayers || this.elements[et]) && this.elements[et].renderFrame()
        }
        ,
        CVCompElement.prototype.destroy = function() {
            var _e, et = this.layers.length;
            for (_e = et - 1; _e >= 0; _e -= 1)
                this.elements[_e] && this.elements[_e].destroy();
            this.layers = null,
            this.elements = null
        }
        ,
        CVCompElement.prototype.createComp = function(_e) {
            return new CVCompElement(_e,this.globalData,this)
        }
        ;
        function CanvasRenderer(_e, et) {
            this.animationItem = _e,
            this.renderConfig = {
                clearCanvas: et && et.clearCanvas !== void 0 ? et.clearCanvas : !0,
                context: et && et.context || null,
                progressiveLoad: et && et.progressiveLoad || !1,
                preserveAspectRatio: et && et.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: et && et.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: et && et.contentVisibility || "visible",
                className: et && et.className || "",
                id: et && et.id || "",
                runExpressions: !et || et.runExpressions === void 0 || et.runExpressions
            },
            this.renderConfig.dpr = et && et.dpr || 1,
            this.animationItem.wrapper && (this.renderConfig.dpr = et && et.dpr || window.devicePixelRatio || 1),
            this.renderedFrame = -1,
            this.globalData = {
                frameNum: -1,
                _mdf: !1,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
            },
            this.contextData = new CVContextData,
            this.elements = [],
            this.pendingElements = [],
            this.transformMat = new Matrix,
            this.completeLayers = !1,
            this.rendererType = "canvas",
            this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData),
            this.ctxOpacity = this.contextData.opacity.bind(this.contextData),
            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData),
            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData),
            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData),
            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData),
            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData),
            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData),
            this.ctxFill = this.contextData.fill.bind(this.contextData),
            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData),
            this.ctxStroke = this.contextData.stroke.bind(this.contextData),
            this.save = this.contextData.save.bind(this.contextData))
        }
        extendPrototype([CanvasRendererBase], CanvasRenderer),
        CanvasRenderer.prototype.createComp = function(_e) {
            return new CVCompElement(_e,this.globalData,this)
        }
        ;
        function HBaseElement() {}
        HBaseElement.prototype = {
            checkBlendMode: function() {},
            initRendererElement: function() {
                this.baseElement = createTag(this.data.tg || "div"),
                this.data.hasMask ? (this.svgElement = createNS("svg"),
                this.layerElement = createNS("g"),
                this.maskedElement = this.layerElement,
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement,
                styleDiv(this.baseElement)
            },
            createContainerElements: function() {
                this.renderableEffectsManager = new CVEffects(this),
                this.transformedElement = this.baseElement,
                this.maskedElement = this.layerElement,
                this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                var et = this.transformedElement ? this.transformedElement.style : {};
                if (this.finalTransform._matMdf) {
                    var tt = this.finalTransform.mat.toCSS();
                    et.transform = tt,
                    et.webkitTransform = tt
                }
                this.finalTransform._opMdf && (et.opacity = this.finalTransform.mProp.o.v)
            },
            renderFrame: function() {
                this.data.hd || this.hidden || (this.renderTransform(),
                this.renderRenderable(),
                this.renderElement(),
                this.renderInnerContent(),
                this._isFirstFrame && (this._isFirstFrame = !1))
            },
            destroy: function() {
                this.layerElement = null,
                this.transformedElement = null,
                this.matteElement && (this.matteElement = null),
                this.maskManager && (this.maskManager.destroy(),
                this.maskManager = null)
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData)
            },
            addEffects: function() {},
            setMatte: function() {}
        },
        HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement,
        HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy,
        HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
        function HSolidElement(_e, et, tt) {
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement),
        HSolidElement.prototype.createContent = function() {
            var _e;
            this.data.hasMask ? (_e = createNS("rect"),
            _e.setAttribute("width", this.data.sw),
            _e.setAttribute("height", this.data.sh),
            _e.setAttribute("fill", this.data.sc),
            this.svgElement.setAttribute("width", this.data.sw),
            this.svgElement.setAttribute("height", this.data.sh)) : (_e = createTag("div"),
            _e.style.width = this.data.sw + "px",
            _e.style.height = this.data.sh + "px",
            _e.style.backgroundColor = this.data.sc),
            this.layerElement.appendChild(_e)
        }
        ;
        function HShapeElement(_e, et, tt) {
            this.shapes = [],
            this.shapesData = _e.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.shapesContainer = createNS("g"),
            this.initElement(_e, et, tt),
            this.prevViewData = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            }
        }
        extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement),
        HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent,
        HShapeElement.prototype.createContent = function() {
            var _e;
            if (this.baseElement.style.fontSize = 0,
            this.data.hasMask)
                this.layerElement.appendChild(this.shapesContainer),
                _e = this.svgElement;
            else {
                _e = createNS("svg");
                var et = this.comp.data ? this.comp.data : this.globalData.compSize;
                _e.setAttribute("width", et.w),
                _e.setAttribute("height", et.h),
                _e.appendChild(this.shapesContainer),
                this.layerElement.appendChild(_e)
            }
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0),
            this.filterUniqueShapes(),
            this.shapeCont = _e
        }
        ,
        HShapeElement.prototype.getTransformedPoint = function(_e, et) {
            var tt, rt = _e.length;
            for (tt = 0; tt < rt; tt += 1)
                et = _e[tt].mProps.v.applyToPointArray(et[0], et[1], 0);
            return et
        }
        ,
        HShapeElement.prototype.calculateShapeBoundingBox = function(_e, et) {
            var tt = _e.sh.v, rt = _e.transformers, nt, it = tt._length, st, at, ot, lt;
            if (!(it <= 1)) {
                for (nt = 0; nt < it - 1; nt += 1)
                    st = this.getTransformedPoint(rt, tt.v[nt]),
                    at = this.getTransformedPoint(rt, tt.o[nt]),
                    ot = this.getTransformedPoint(rt, tt.i[nt + 1]),
                    lt = this.getTransformedPoint(rt, tt.v[nt + 1]),
                    this.checkBounds(st, at, ot, lt, et);
                tt.c && (st = this.getTransformedPoint(rt, tt.v[nt]),
                at = this.getTransformedPoint(rt, tt.o[nt]),
                ot = this.getTransformedPoint(rt, tt.i[0]),
                lt = this.getTransformedPoint(rt, tt.v[0]),
                this.checkBounds(st, at, ot, lt, et))
            }
        }
        ,
        HShapeElement.prototype.checkBounds = function(_e, et, tt, rt, nt) {
            this.getBoundsOfCurve(_e, et, tt, rt);
            var it = this.shapeBoundingBox;
            nt.x = bmMin(it.left, nt.x),
            nt.xMax = bmMax(it.right, nt.xMax),
            nt.y = bmMin(it.top, nt.y),
            nt.yMax = bmMax(it.bottom, nt.yMax)
        }
        ,
        HShapeElement.prototype.shapeBoundingBox = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0
        },
        HShapeElement.prototype.getBoundsOfCurve = function(_e, et, tt, rt) {
            for (var nt = [[_e[0], rt[0]], [_e[1], rt[1]]], it, st, at, ot, lt, dt, ct, ut = 0; ut < 2; ++ut)
                st = 6 * _e[ut] - 12 * et[ut] + 6 * tt[ut],
                it = -3 * _e[ut] + 9 * et[ut] - 9 * tt[ut] + 3 * rt[ut],
                at = 3 * et[ut] - 3 * _e[ut],
                st |= 0,
                it |= 0,
                at |= 0,
                it === 0 && st === 0 || (it === 0 ? (ot = -at / st,
                ot > 0 && ot < 1 && nt[ut].push(this.calculateF(ot, _e, et, tt, rt, ut))) : (lt = st * st - 4 * at * it,
                lt >= 0 && (dt = (-st + bmSqrt(lt)) / (2 * it),
                dt > 0 && dt < 1 && nt[ut].push(this.calculateF(dt, _e, et, tt, rt, ut)),
                ct = (-st - bmSqrt(lt)) / (2 * it),
                ct > 0 && ct < 1 && nt[ut].push(this.calculateF(ct, _e, et, tt, rt, ut)))));
            this.shapeBoundingBox.left = bmMin.apply(null, nt[0]),
            this.shapeBoundingBox.top = bmMin.apply(null, nt[1]),
            this.shapeBoundingBox.right = bmMax.apply(null, nt[0]),
            this.shapeBoundingBox.bottom = bmMax.apply(null, nt[1])
        }
        ,
        HShapeElement.prototype.calculateF = function(_e, et, tt, rt, nt, it) {
            return bmPow(1 - _e, 3) * et[it] + 3 * bmPow(1 - _e, 2) * _e * tt[it] + 3 * (1 - _e) * bmPow(_e, 2) * rt[it] + bmPow(_e, 3) * nt[it]
        }
        ,
        HShapeElement.prototype.calculateBoundingBox = function(_e, et) {
            var tt, rt = _e.length;
            for (tt = 0; tt < rt; tt += 1)
                _e[tt] && _e[tt].sh ? this.calculateShapeBoundingBox(_e[tt], et) : _e[tt] && _e[tt].it ? this.calculateBoundingBox(_e[tt].it, et) : _e[tt] && _e[tt].style && _e[tt].w && this.expandStrokeBoundingBox(_e[tt].w, et)
        }
        ,
        HShapeElement.prototype.expandStrokeBoundingBox = function(_e, et) {
            var tt = 0;
            if (_e.keyframes) {
                for (var rt = 0; rt < _e.keyframes.length; rt += 1) {
                    var nt = _e.keyframes[rt].s;
                    nt > tt && (tt = nt)
                }
                tt *= _e.mult
            } else
                tt = _e.v * _e.mult;
            et.x -= tt,
            et.xMax += tt,
            et.y -= tt,
            et.yMax += tt
        }
        ,
        HShapeElement.prototype.currentBoxContains = function(_e) {
            return this.currentBBox.x <= _e.x && this.currentBBox.y <= _e.y && this.currentBBox.width + this.currentBBox.x >= _e.x + _e.width && this.currentBBox.height + this.currentBBox.y >= _e.y + _e.height
        }
        ,
        HShapeElement.prototype.renderInnerContent = function() {
            if (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf)) {
                var _e = this.tempBoundingBox
                  , et = 999999;
                if (_e.x = et,
                _e.xMax = -et,
                _e.y = et,
                _e.yMax = -et,
                this.calculateBoundingBox(this.itemsData, _e),
                _e.width = _e.xMax < _e.x ? 0 : _e.xMax - _e.x,
                _e.height = _e.yMax < _e.y ? 0 : _e.yMax - _e.y,
                this.currentBoxContains(_e))
                    return;
                var tt = !1;
                if (this.currentBBox.w !== _e.width && (this.currentBBox.w = _e.width,
                this.shapeCont.setAttribute("width", _e.width),
                tt = !0),
                this.currentBBox.h !== _e.height && (this.currentBBox.h = _e.height,
                this.shapeCont.setAttribute("height", _e.height),
                tt = !0),
                tt || this.currentBBox.x !== _e.x || this.currentBBox.y !== _e.y) {
                    this.currentBBox.w = _e.width,
                    this.currentBBox.h = _e.height,
                    this.currentBBox.x = _e.x,
                    this.currentBBox.y = _e.y,
                    this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                    var rt = this.shapeCont.style
                      , nt = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                    rt.transform = nt,
                    rt.webkitTransform = nt
                }
            }
        }
        ;
        function HTextElement(_e, et, tt) {
            this.textSpans = [],
            this.textPaths = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            },
            this.renderType = "svg",
            this.isMasked = !1,
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement),
        HTextElement.prototype.createContent = function() {
            if (this.isMasked = this.checkMasks(),
            this.isMasked) {
                this.renderType = "svg",
                this.compW = this.comp.data.w,
                this.compH = this.comp.data.h,
                this.svgElement.setAttribute("width", this.compW),
                this.svgElement.setAttribute("height", this.compH);
                var _e = createNS("g");
                this.maskedElement.appendChild(_e),
                this.innerElem = _e
            } else
                this.renderType = "html",
                this.innerElem = this.layerElement;
            this.checkParenting()
        }
        ,
        HTextElement.prototype.buildNewText = function() {
            var _e = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(_e.l ? _e.l.length : 0);
            var et = this.innerElem.style
              , tt = _e.fc ? this.buildColor(_e.fc) : "rgba(0,0,0,0)";
            et.fill = tt,
            et.color = tt,
            _e.sc && (et.stroke = this.buildColor(_e.sc),
            et.strokeWidth = _e.sw + "px");
            var rt = this.globalData.fontManager.getFontByName(_e.f);
            if (!this.globalData.fontManager.chars)
                if (et.fontSize = _e.finalSize + "px",
                et.lineHeight = _e.finalSize + "px",
                rt.fClass)
                    this.innerElem.className = rt.fClass;
                else {
                    et.fontFamily = rt.fFamily;
                    var nt = _e.fWeight
                      , it = _e.fStyle;
                    et.fontStyle = it,
                    et.fontWeight = nt
                }
            var st, at, ot = _e.l;
            at = ot.length;
            var lt, dt, ct, ut = this.mHelper, ft, ht = "", gt = 0;
            for (st = 0; st < at; st += 1) {
                if (this.globalData.fontManager.chars ? (this.textPaths[gt] ? lt = this.textPaths[gt] : (lt = createNS("path"),
                lt.setAttribute("stroke-linecap", lineCapEnum[1]),
                lt.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                lt.setAttribute("stroke-miterlimit", "4")),
                this.isMasked || (this.textSpans[gt] ? (dt = this.textSpans[gt],
                ct = dt.children[0]) : (dt = createTag("div"),
                dt.style.lineHeight = 0,
                ct = createNS("svg"),
                ct.appendChild(lt),
                styleDiv(dt)))) : this.isMasked ? lt = this.textPaths[gt] ? this.textPaths[gt] : createNS("text") : this.textSpans[gt] ? (dt = this.textSpans[gt],
                lt = this.textPaths[gt]) : (dt = createTag("span"),
                styleDiv(dt),
                lt = createTag("span"),
                styleDiv(lt),
                dt.appendChild(lt)),
                this.globalData.fontManager.chars) {
                    var bt = this.globalData.fontManager.getCharData(_e.finalText[st], rt.fStyle, this.globalData.fontManager.getFontByName(_e.f).fFamily), pt;
                    if (bt ? pt = bt.data : pt = null,
                    ut.reset(),
                    pt && pt.shapes && pt.shapes.length && (ft = pt.shapes[0].it,
                    ut.scale(_e.finalSize / 100, _e.finalSize / 100),
                    ht = this.createPathShape(ut, ft),
                    lt.setAttribute("d", ht)),
                    this.isMasked)
                        this.innerElem.appendChild(lt);
                    else {
                        if (this.innerElem.appendChild(dt),
                        pt && pt.shapes) {
                            document.body.appendChild(ct);
                            var mt = ct.getBBox();
                            ct.setAttribute("width", mt.width + 2),
                            ct.setAttribute("height", mt.height + 2),
                            ct.setAttribute("viewBox", mt.x - 1 + " " + (mt.y - 1) + " " + (mt.width + 2) + " " + (mt.height + 2));
                            var yt = ct.style
                              , vt = "translate(" + (mt.x - 1) + "px," + (mt.y - 1) + "px)";
                            yt.transform = vt,
                            yt.webkitTransform = vt,
                            ot[st].yOffset = mt.y - 1
                        } else
                            ct.setAttribute("width", 1),
                            ct.setAttribute("height", 1);
                        dt.appendChild(ct)
                    }
                } else if (lt.textContent = ot[st].val,
                lt.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"),
                this.isMasked)
                    this.innerElem.appendChild(lt);
                else {
                    this.innerElem.appendChild(dt);
                    var wt = lt.style
                      , _t = "translate3d(0," + -_e.finalSize / 1.2 + "px,0)";
                    wt.transform = _t,
                    wt.webkitTransform = _t
                }
                this.isMasked ? this.textSpans[gt] = lt : this.textSpans[gt] = dt,
                this.textSpans[gt].style.display = "block",
                this.textPaths[gt] = lt,
                gt += 1
            }
            for (; gt < this.textSpans.length; )
                this.textSpans[gt].style.display = "none",
                gt += 1
        }
        ,
        HTextElement.prototype.renderInnerContent = function() {
            this.validateText();
            var _e;
            if (this.data.singleShape) {
                if (!this._isFirstFrame && !this.lettersChangedFlag)
                    return;
                if (this.isMasked && this.finalTransform._matMdf) {
                    this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH),
                    _e = this.svgElement.style;
                    var et = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                    _e.transform = et,
                    _e.webkitTransform = et
                }
            }
            if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
                var tt, rt, nt = 0, it = this.textAnimator.renderedLetters, st = this.textProperty.currentData.l;
                rt = st.length;
                var at, ot, lt;
                for (tt = 0; tt < rt; tt += 1)
                    st[tt].n ? nt += 1 : (ot = this.textSpans[tt],
                    lt = this.textPaths[tt],
                    at = it[nt],
                    nt += 1,
                    at._mdf.m && (this.isMasked ? ot.setAttribute("transform", at.m) : (ot.style.webkitTransform = at.m,
                    ot.style.transform = at.m)),
                    ot.style.opacity = at.o,
                    at.sw && at._mdf.sw && lt.setAttribute("stroke-width", at.sw),
                    at.sc && at._mdf.sc && lt.setAttribute("stroke", at.sc),
                    at.fc && at._mdf.fc && (lt.setAttribute("fill", at.fc),
                    lt.style.color = at.fc));
                if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var dt = this.innerElem.getBBox();
                    this.currentBBox.w !== dt.width && (this.currentBBox.w = dt.width,
                    this.svgElement.setAttribute("width", dt.width)),
                    this.currentBBox.h !== dt.height && (this.currentBBox.h = dt.height,
                    this.svgElement.setAttribute("height", dt.height));
                    var ct = 1;
                    if (this.currentBBox.w !== dt.width + ct * 2 || this.currentBBox.h !== dt.height + ct * 2 || this.currentBBox.x !== dt.x - ct || this.currentBBox.y !== dt.y - ct) {
                        this.currentBBox.w = dt.width + ct * 2,
                        this.currentBBox.h = dt.height + ct * 2,
                        this.currentBBox.x = dt.x - ct,
                        this.currentBBox.y = dt.y - ct,
                        this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h),
                        _e = this.svgElement.style;
                        var ut = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                        _e.transform = ut,
                        _e.webkitTransform = ut
                    }
                }
            }
        }
        ;
        function HCameraElement(_e, et, tt) {
            this.initFrame(),
            this.initBaseData(_e, et, tt),
            this.initHierarchy();
            var rt = PropertyFactory.getProp;
            if (this.pe = rt(this, _e.pe, 0, 0, this),
            _e.ks.p.s ? (this.px = rt(this, _e.ks.p.x, 1, 0, this),
            this.py = rt(this, _e.ks.p.y, 1, 0, this),
            this.pz = rt(this, _e.ks.p.z, 1, 0, this)) : this.p = rt(this, _e.ks.p, 1, 0, this),
            _e.ks.a && (this.a = rt(this, _e.ks.a, 1, 0, this)),
            _e.ks.or.k.length && _e.ks.or.k[0].to) {
                var nt, it = _e.ks.or.k.length;
                for (nt = 0; nt < it; nt += 1)
                    _e.ks.or.k[nt].to = null,
                    _e.ks.or.k[nt].ti = null
            }
            this.or = rt(this, _e.ks.or, 1, degToRads, this),
            this.or.sh = !0,
            this.rx = rt(this, _e.ks.rx, 0, degToRads, this),
            this.ry = rt(this, _e.ks.ry, 0, degToRads, this),
            this.rz = rt(this, _e.ks.rz, 0, degToRads, this),
            this.mat = new Matrix,
            this._prevMat = new Matrix,
            this._isFirstFrame = !0,
            this.finalTransform = {
                mProp: this
            }
        }
        extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement),
        HCameraElement.prototype.setup = function() {
            var _e, et = this.comp.threeDElements.length, tt, rt, nt;
            for (_e = 0; _e < et; _e += 1)
                if (tt = this.comp.threeDElements[_e],
                tt.type === "3d") {
                    rt = tt.perspectiveElem.style,
                    nt = tt.container.style;
                    var it = this.pe.v + "px"
                      , st = "0px 0px 0px"
                      , at = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                    rt.perspective = it,
                    rt.webkitPerspective = it,
                    nt.transformOrigin = st,
                    nt.mozTransformOrigin = st,
                    nt.webkitTransformOrigin = st,
                    rt.transform = at,
                    rt.webkitTransform = at
                }
        }
        ,
        HCameraElement.prototype.createElements = function() {}
        ,
        HCameraElement.prototype.hide = function() {}
        ,
        HCameraElement.prototype.renderFrame = function() {
            var _e = this._isFirstFrame, et, tt;
            if (this.hierarchy)
                for (tt = this.hierarchy.length,
                et = 0; et < tt; et += 1)
                    _e = this.hierarchy[et].finalTransform.mProp._mdf || _e;
            if (_e || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                if (this.mat.reset(),
                this.hierarchy)
                    for (tt = this.hierarchy.length - 1,
                    et = tt; et >= 0; et -= 1) {
                        var rt = this.hierarchy[et].finalTransform.mProp;
                        this.mat.translate(-rt.p.v[0], -rt.p.v[1], rt.p.v[2]),
                        this.mat.rotateX(-rt.or.v[0]).rotateY(-rt.or.v[1]).rotateZ(rt.or.v[2]),
                        this.mat.rotateX(-rt.rx.v).rotateY(-rt.ry.v).rotateZ(rt.rz.v),
                        this.mat.scale(1 / rt.s.v[0], 1 / rt.s.v[1], 1 / rt.s.v[2]),
                        this.mat.translate(rt.a.v[0], rt.a.v[1], rt.a.v[2])
                    }
                if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
                this.a) {
                    var nt;
                    this.p ? nt = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : nt = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                    var it = Math.sqrt(Math.pow(nt[0], 2) + Math.pow(nt[1], 2) + Math.pow(nt[2], 2))
                      , st = [nt[0] / it, nt[1] / it, nt[2] / it]
                      , at = Math.sqrt(st[2] * st[2] + st[0] * st[0])
                      , ot = Math.atan2(st[1], at)
                      , lt = Math.atan2(st[0], -st[2]);
                    this.mat.rotateY(lt).rotateX(-ot)
                }
                this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
                this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]),
                this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0),
                this.mat.translate(0, 0, this.pe.v);
                var dt = !this._prevMat.equals(this.mat);
                if ((dt || this.pe._mdf) && this.comp.threeDElements) {
                    tt = this.comp.threeDElements.length;
                    var ct, ut, ft;
                    for (et = 0; et < tt; et += 1)
                        if (ct = this.comp.threeDElements[et],
                        ct.type === "3d") {
                            if (dt) {
                                var ht = this.mat.toCSS();
                                ft = ct.container.style,
                                ft.transform = ht,
                                ft.webkitTransform = ht
                            }
                            this.pe._mdf && (ut = ct.perspectiveElem.style,
                            ut.perspective = this.pe.v + "px",
                            ut.webkitPerspective = this.pe.v + "px")
                        }
                    this.mat.clone(this._prevMat)
                }
            }
            this._isFirstFrame = !1
        }
        ,
        HCameraElement.prototype.prepareFrame = function(_e) {
            this.prepareProperties(_e, !0)
        }
        ,
        HCameraElement.prototype.destroy = function() {}
        ,
        HCameraElement.prototype.getBaseElement = function() {
            return null
        }
        ;
        function HImageElement(_e, et, tt) {
            this.assetData = et.getAssetData(_e.refId),
            this.initElement(_e, et, tt)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement),
        HImageElement.prototype.createContent = function() {
            var _e = this.globalData.getAssetsPath(this.assetData)
              , et = new Image;
            this.data.hasMask ? (this.imageElem = createNS("image"),
            this.imageElem.setAttribute("width", this.assetData.w + "px"),
            this.imageElem.setAttribute("height", this.assetData.h + "px"),
            this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", _e),
            this.layerElement.appendChild(this.imageElem),
            this.baseElement.setAttribute("width", this.assetData.w),
            this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(et),
            et.crossOrigin = "anonymous",
            et.src = _e,
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
        }
        ;
        function HybridRendererBase(_e, et) {
            this.animationItem = _e,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: et && et.className || "",
                imagePreserveAspectRatio: et && et.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(et && et.hideOnTransparent === !1),
                filterSize: {
                    width: et && et.filterSize && et.filterSize.width || "400%",
                    height: et && et.filterSize && et.filterSize.height || "400%",
                    x: et && et.filterSize && et.filterSize.x || "-100%",
                    y: et && et.filterSize && et.filterSize.y || "-100%"
                }
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        extendPrototype([BaseRenderer], HybridRendererBase),
        HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem,
        HybridRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var _e = this.pendingElements.pop();
                _e.checkParenting()
            }
        }
        ,
        HybridRendererBase.prototype.appendElementInPos = function(_e, et) {
            var tt = _e.getBaseElement();
            if (tt) {
                var rt = this.layers[et];
                if (!rt.ddd || !this.supports3d)
                    if (this.threeDElements)
                        this.addTo3dContainer(tt, et);
                    else {
                        for (var nt = 0, it, st, at; nt < et; )
                            this.elements[nt] && this.elements[nt] !== !0 && this.elements[nt].getBaseElement && (st = this.elements[nt],
                            at = this.layers[nt].ddd ? this.getThreeDContainerByPos(nt) : st.getBaseElement(),
                            it = at || it),
                            nt += 1;
                        it ? (!rt.ddd || !this.supports3d) && this.layerElement.insertBefore(tt, it) : (!rt.ddd || !this.supports3d) && this.layerElement.appendChild(tt)
                    }
                else
                    this.addTo3dContainer(tt, et)
            }
        }
        ,
        HybridRendererBase.prototype.createShape = function(_e) {
            return this.supports3d ? new HShapeElement(_e,this.globalData,this) : new SVGShapeElement(_e,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createText = function(_e) {
            return this.supports3d ? new HTextElement(_e,this.globalData,this) : new SVGTextLottieElement(_e,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createCamera = function(_e) {
            return this.camera = new HCameraElement(_e,this.globalData,this),
            this.camera
        }
        ,
        HybridRendererBase.prototype.createImage = function(_e) {
            return this.supports3d ? new HImageElement(_e,this.globalData,this) : new IImageElement(_e,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createSolid = function(_e) {
            return this.supports3d ? new HSolidElement(_e,this.globalData,this) : new ISolidElement(_e,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        HybridRendererBase.prototype.getThreeDContainerByPos = function(_e) {
            for (var et = 0, tt = this.threeDElements.length; et < tt; ) {
                if (this.threeDElements[et].startPos <= _e && this.threeDElements[et].endPos >= _e)
                    return this.threeDElements[et].perspectiveElem;
                et += 1
            }
            return null
        }
        ,
        HybridRendererBase.prototype.createThreeDContainer = function(_e, et) {
            var tt = createTag("div"), rt, nt;
            styleDiv(tt);
            var it = createTag("div");
            if (styleDiv(it),
            et === "3d") {
                rt = tt.style,
                rt.width = this.globalData.compSize.w + "px",
                rt.height = this.globalData.compSize.h + "px";
                var st = "50% 50%";
                rt.webkitTransformOrigin = st,
                rt.mozTransformOrigin = st,
                rt.transformOrigin = st,
                nt = it.style;
                var at = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                nt.transform = at,
                nt.webkitTransform = at
            }
            tt.appendChild(it);
            var ot = {
                container: it,
                perspectiveElem: tt,
                startPos: _e,
                endPos: _e,
                type: et
            };
            return this.threeDElements.push(ot),
            ot
        }
        ,
        HybridRendererBase.prototype.build3dContainers = function() {
            var _e, et = this.layers.length, tt, rt = "";
            for (_e = 0; _e < et; _e += 1)
                this.layers[_e].ddd && this.layers[_e].ty !== 3 ? (rt !== "3d" && (rt = "3d",
                tt = this.createThreeDContainer(_e, "3d")),
                tt.endPos = Math.max(tt.endPos, _e)) : (rt !== "2d" && (rt = "2d",
                tt = this.createThreeDContainer(_e, "2d")),
                tt.endPos = Math.max(tt.endPos, _e));
            for (et = this.threeDElements.length,
            _e = et - 1; _e >= 0; _e -= 1)
                this.resizerElem.appendChild(this.threeDElements[_e].perspectiveElem)
        }
        ,
        HybridRendererBase.prototype.addTo3dContainer = function(_e, et) {
            for (var tt = 0, rt = this.threeDElements.length; tt < rt; ) {
                if (et <= this.threeDElements[tt].endPos) {
                    for (var nt = this.threeDElements[tt].startPos, it; nt < et; )
                        this.elements[nt] && this.elements[nt].getBaseElement && (it = this.elements[nt].getBaseElement()),
                        nt += 1;
                    it ? this.threeDElements[tt].container.insertBefore(_e, it) : this.threeDElements[tt].container.appendChild(_e);
                    break
                }
                tt += 1
            }
        }
        ,
        HybridRendererBase.prototype.configAnimation = function(_e) {
            var et = createTag("div")
              , tt = this.animationItem.wrapper
              , rt = et.style;
            rt.width = _e.w + "px",
            rt.height = _e.h + "px",
            this.resizerElem = et,
            styleDiv(et),
            rt.transformStyle = "flat",
            rt.mozTransformStyle = "flat",
            rt.webkitTransformStyle = "flat",
            this.renderConfig.className && et.setAttribute("class", this.renderConfig.className),
            tt.appendChild(et),
            rt.overflow = "hidden";
            var nt = createNS("svg");
            nt.setAttribute("width", "1"),
            nt.setAttribute("height", "1"),
            styleDiv(nt),
            this.resizerElem.appendChild(nt);
            var it = createNS("defs");
            nt.appendChild(it),
            this.data = _e,
            this.setupGlobalData(_e, nt),
            this.globalData.defs = it,
            this.layers = _e.layers,
            this.layerElement = this.resizerElem,
            this.build3dContainers(),
            this.updateContainerSize()
        }
        ,
        HybridRendererBase.prototype.destroy = function() {
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.animationItem.container = null,
            this.globalData.defs = null;
            var _e, et = this.layers ? this.layers.length : 0;
            for (_e = 0; _e < et; _e += 1)
                this.elements[_e] && this.elements[_e].destroy && this.elements[_e].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        HybridRendererBase.prototype.updateContainerSize = function() {
            var _e = this.animationItem.wrapper.offsetWidth, et = this.animationItem.wrapper.offsetHeight, tt = _e / et, rt = this.globalData.compSize.w / this.globalData.compSize.h, nt, it, st, at;
            rt > tt ? (nt = _e / this.globalData.compSize.w,
            it = _e / this.globalData.compSize.w,
            st = 0,
            at = (et - this.globalData.compSize.h * (_e / this.globalData.compSize.w)) / 2) : (nt = et / this.globalData.compSize.h,
            it = et / this.globalData.compSize.h,
            st = (_e - this.globalData.compSize.w * (et / this.globalData.compSize.h)) / 2,
            at = 0);
            var ot = this.resizerElem.style;
            ot.webkitTransform = "matrix3d(" + nt + ",0,0,0,0," + it + ",0,0,0,0,1,0," + st + "," + at + ",0,1)",
            ot.transform = ot.webkitTransform
        }
        ,
        HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame,
        HybridRendererBase.prototype.hide = function() {
            this.resizerElem.style.display = "none"
        }
        ,
        HybridRendererBase.prototype.show = function() {
            this.resizerElem.style.display = "block"
        }
        ,
        HybridRendererBase.prototype.initItems = function() {
            if (this.buildAllItems(),
            this.camera)
                this.camera.setup();
            else {
                var _e = this.globalData.compSize.w, et = this.globalData.compSize.h, tt, rt = this.threeDElements.length;
                for (tt = 0; tt < rt; tt += 1) {
                    var nt = this.threeDElements[tt].perspectiveElem.style;
                    nt.webkitPerspective = Math.sqrt(Math.pow(_e, 2) + Math.pow(et, 2)) + "px",
                    nt.perspective = nt.webkitPerspective
                }
            }
        }
        ,
        HybridRendererBase.prototype.searchExtraCompositions = function(_e) {
            var et, tt = _e.length, rt = createTag("div");
            for (et = 0; et < tt; et += 1)
                if (_e[et].xt) {
                    var nt = this.createComp(_e[et], rt, this.globalData.comp, null);
                    nt.initExpressions(),
                    this.globalData.projectInterface.registerComposition(nt)
                }
        }
        ;
        function HCompElement(_e, et, tt) {
            this.layers = _e.layers,
            this.supports3d = !_e.hasMask,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(_e, et, tt),
            this.tm = _e.tm ? PropertyFactory.getProp(this, _e.tm, 0, et.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement),
        HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements,
        HCompElement.prototype.createContainerElements = function() {
            this._createBaseContainerElements(),
            this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w),
            this.svgElement.setAttribute("height", this.data.h),
            this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
        }
        ,
        HCompElement.prototype.addTo3dContainer = function(_e, et) {
            for (var tt = 0, rt; tt < et; )
                this.elements[tt] && this.elements[tt].getBaseElement && (rt = this.elements[tt].getBaseElement()),
                tt += 1;
            rt ? this.layerElement.insertBefore(_e, rt) : this.layerElement.appendChild(_e)
        }
        ,
        HCompElement.prototype.createComp = function(_e) {
            return this.supports3d ? new HCompElement(_e,this.globalData,this) : new SVGCompElement(_e,this.globalData,this)
        }
        ;
        function HybridRenderer(_e, et) {
            this.animationItem = _e,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: et && et.className || "",
                imagePreserveAspectRatio: et && et.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(et && et.hideOnTransparent === !1),
                filterSize: {
                    width: et && et.filterSize && et.filterSize.width || "400%",
                    height: et && et.filterSize && et.filterSize.height || "400%",
                    x: et && et.filterSize && et.filterSize.x || "-100%",
                    y: et && et.filterSize && et.filterSize.y || "-100%"
                },
                runExpressions: !et || et.runExpressions === void 0 || et.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        extendPrototype([HybridRendererBase], HybridRenderer),
        HybridRenderer.prototype.createComp = function(_e) {
            return this.supports3d ? new HCompElement(_e,this.globalData,this) : new SVGCompElement(_e,this.globalData,this)
        }
        ;
        var CompExpressionInterface = function() {
            return function(_e) {
                function et(tt) {
                    for (var rt = 0, nt = _e.layers.length; rt < nt; ) {
                        if (_e.layers[rt].nm === tt || _e.layers[rt].ind === tt)
                            return _e.elements[rt].layerInterface;
                        rt += 1
                    }
                    return null
                }
                return Object.defineProperty(et, "_name", {
                    value: _e.data.nm
                }),
                et.layer = et,
                et.pixelAspect = 1,
                et.height = _e.data.h || _e.globalData.compSize.h,
                et.width = _e.data.w || _e.globalData.compSize.w,
                et.pixelAspect = 1,
                et.frameDuration = 1 / _e.globalData.frameRate,
                et.displayStartTime = 0,
                et.numLayers = _e.layers.length,
                et
            }
        }();
        function _typeof$2(_e) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function(tt) {
                return typeof tt
            }
            : _typeof$2 = function(tt) {
                return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
            }
            ,
            _typeof$2(_e)
        }
        function seedRandom(_e, et) {
            var tt = this, rt = 256, nt = 6, it = 52, st = "random", at = et.pow(rt, nt), ot = et.pow(2, it), lt = ot * 2, dt = rt - 1, ct;
            function ut(yt, vt, wt) {
                var _t = [];
                vt = vt === !0 ? {
                    entropy: !0
                } : vt || {};
                var Et = bt(gt(vt.entropy ? [yt, mt(_e)] : yt === null ? pt() : yt, 3), _t)
                  , xt = new ft(_t)
                  , Ct = function() {
                    for (var It = xt.g(nt), Nt = at, Ft = 0; It < ot; )
                        It = (It + Ft) * rt,
                        Nt *= rt,
                        Ft = xt.g(1);
                    for (; It >= lt; )
                        It /= 2,
                        Nt /= 2,
                        Ft >>>= 1;
                    return (It + Ft) / Nt
                };
                return Ct.int32 = function() {
                    return xt.g(4) | 0
                }
                ,
                Ct.quick = function() {
                    return xt.g(4) / 4294967296
                }
                ,
                Ct.double = Ct,
                bt(mt(xt.S), _e),
                (vt.pass || wt || function(Tt, It, Nt, Ft) {
                    return Ft && (Ft.S && ht(Ft, xt),
                    Tt.state = function() {
                        return ht(xt, {})
                    }
                    ),
                    Nt ? (et[st] = Tt,
                    It) : Tt
                }
                )(Ct, Et, "global"in vt ? vt.global : this == et, vt.state)
            }
            et["seed" + st] = ut;
            function ft(yt) {
                var vt, wt = yt.length, _t = this, Et = 0, xt = _t.i = _t.j = 0, Ct = _t.S = [];
                for (wt || (yt = [wt++]); Et < rt; )
                    Ct[Et] = Et++;
                for (Et = 0; Et < rt; Et++)
                    Ct[Et] = Ct[xt = dt & xt + yt[Et % wt] + (vt = Ct[Et])],
                    Ct[xt] = vt;
                _t.g = function(Tt) {
                    for (var It, Nt = 0, Ft = _t.i, Lt = _t.j, Mt = _t.S; Tt--; )
                        It = Mt[Ft = dt & Ft + 1],
                        Nt = Nt * rt + Mt[dt & (Mt[Ft] = Mt[Lt = dt & Lt + It]) + (Mt[Lt] = It)];
                    return _t.i = Ft,
                    _t.j = Lt,
                    Nt
                }
            }
            function ht(yt, vt) {
                return vt.i = yt.i,
                vt.j = yt.j,
                vt.S = yt.S.slice(),
                vt
            }
            function gt(yt, vt) {
                var wt = [], _t = _typeof$2(yt), Et;
                if (vt && _t == "object")
                    for (Et in yt)
                        try {
                            wt.push(gt(yt[Et], vt - 1))
                        } catch {}
                return wt.length ? wt : _t == "string" ? yt : yt + "\0"
            }
            function bt(yt, vt) {
                for (var wt = yt + "", _t, Et = 0; Et < wt.length; )
                    vt[dt & Et] = dt & (_t ^= vt[dt & Et] * 19) + wt.charCodeAt(Et++);
                return mt(vt)
            }
            function pt() {
                try {
                    var yt = new Uint8Array(rt);
                    return (tt.crypto || tt.msCrypto).getRandomValues(yt),
                    mt(yt)
                } catch {
                    var vt = tt.navigator
                      , wt = vt && vt.plugins;
                    return [+new Date, tt, wt, tt.screen, mt(_e)]
                }
            }
            function mt(yt) {
                return String.fromCharCode.apply(0, yt)
            }
            bt(et.random(), _e)
        }
        function initialize$2(_e) {
            seedRandom([], _e)
        }
        var propTypes = {
            SHAPE: "shape"
        };
        function _typeof$1(_e) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function(tt) {
                return typeof tt
            }
            : _typeof$1 = function(tt) {
                return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
            }
            ,
            _typeof$1(_e)
        }
        var ExpressionManager = function() {
            var ob = {}
              , Math = BMMath
              , window = null
              , document = null
              , XMLHttpRequest = null
              , fetch = null
              , frames = null
              , _lottieGlobal = {};
            initialize$2(BMMath);
            function resetFrame() {
                _lottieGlobal = {}
            }
            function $bm_isInstanceOfArray(_e) {
                return _e.constructor === Array || _e.constructor === Float32Array
            }
            function isNumerable(_e, et) {
                return _e === "number" || et instanceof Number || _e === "boolean" || _e === "string"
            }
            function $bm_neg(_e) {
                var et = _typeof$1(_e);
                if (et === "number" || _e instanceof Number || et === "boolean")
                    return -_e;
                if ($bm_isInstanceOfArray(_e)) {
                    var tt, rt = _e.length, nt = [];
                    for (tt = 0; tt < rt; tt += 1)
                        nt[tt] = -_e[tt];
                    return nt
                }
                return _e.propType ? _e.v : -_e
            }
            var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get
              , easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get
              , easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;
            function sum(_e, et) {
                var tt = _typeof$1(_e)
                  , rt = _typeof$1(et);
                if (isNumerable(tt, _e) && isNumerable(rt, et) || tt === "string" || rt === "string")
                    return _e + et;
                if ($bm_isInstanceOfArray(_e) && isNumerable(rt, et))
                    return _e = _e.slice(0),
                    _e[0] += et,
                    _e;
                if (isNumerable(tt, _e) && $bm_isInstanceOfArray(et))
                    return et = et.slice(0),
                    et[0] = _e + et[0],
                    et;
                if ($bm_isInstanceOfArray(_e) && $bm_isInstanceOfArray(et)) {
                    for (var nt = 0, it = _e.length, st = et.length, at = []; nt < it || nt < st; )
                        (typeof _e[nt] == "number" || _e[nt]instanceof Number) && (typeof et[nt] == "number" || et[nt]instanceof Number) ? at[nt] = _e[nt] + et[nt] : at[nt] = et[nt] === void 0 ? _e[nt] : _e[nt] || et[nt],
                        nt += 1;
                    return at
                }
                return 0
            }
            var add = sum;
            function sub(_e, et) {
                var tt = _typeof$1(_e)
                  , rt = _typeof$1(et);
                if (isNumerable(tt, _e) && isNumerable(rt, et))
                    return tt === "string" && (_e = parseInt(_e, 10)),
                    rt === "string" && (et = parseInt(et, 10)),
                    _e - et;
                if ($bm_isInstanceOfArray(_e) && isNumerable(rt, et))
                    return _e = _e.slice(0),
                    _e[0] -= et,
                    _e;
                if (isNumerable(tt, _e) && $bm_isInstanceOfArray(et))
                    return et = et.slice(0),
                    et[0] = _e - et[0],
                    et;
                if ($bm_isInstanceOfArray(_e) && $bm_isInstanceOfArray(et)) {
                    for (var nt = 0, it = _e.length, st = et.length, at = []; nt < it || nt < st; )
                        (typeof _e[nt] == "number" || _e[nt]instanceof Number) && (typeof et[nt] == "number" || et[nt]instanceof Number) ? at[nt] = _e[nt] - et[nt] : at[nt] = et[nt] === void 0 ? _e[nt] : _e[nt] || et[nt],
                        nt += 1;
                    return at
                }
                return 0
            }
            function mul(_e, et) {
                var tt = _typeof$1(_e), rt = _typeof$1(et), nt;
                if (isNumerable(tt, _e) && isNumerable(rt, et))
                    return _e * et;
                var it, st;
                if ($bm_isInstanceOfArray(_e) && isNumerable(rt, et)) {
                    for (st = _e.length,
                    nt = createTypedArray("float32", st),
                    it = 0; it < st; it += 1)
                        nt[it] = _e[it] * et;
                    return nt
                }
                if (isNumerable(tt, _e) && $bm_isInstanceOfArray(et)) {
                    for (st = et.length,
                    nt = createTypedArray("float32", st),
                    it = 0; it < st; it += 1)
                        nt[it] = _e * et[it];
                    return nt
                }
                return 0
            }
            function div(_e, et) {
                var tt = _typeof$1(_e), rt = _typeof$1(et), nt;
                if (isNumerable(tt, _e) && isNumerable(rt, et))
                    return _e / et;
                var it, st;
                if ($bm_isInstanceOfArray(_e) && isNumerable(rt, et)) {
                    for (st = _e.length,
                    nt = createTypedArray("float32", st),
                    it = 0; it < st; it += 1)
                        nt[it] = _e[it] / et;
                    return nt
                }
                if (isNumerable(tt, _e) && $bm_isInstanceOfArray(et)) {
                    for (st = et.length,
                    nt = createTypedArray("float32", st),
                    it = 0; it < st; it += 1)
                        nt[it] = _e / et[it];
                    return nt
                }
                return 0
            }
            function mod(_e, et) {
                return typeof _e == "string" && (_e = parseInt(_e, 10)),
                typeof et == "string" && (et = parseInt(et, 10)),
                _e % et
            }
            var $bm_sum = sum
              , $bm_sub = sub
              , $bm_mul = mul
              , $bm_div = div
              , $bm_mod = mod;
            function clamp(_e, et, tt) {
                if (et > tt) {
                    var rt = tt;
                    tt = et,
                    et = rt
                }
                return Math.min(Math.max(_e, et), tt)
            }
            function radiansToDegrees(_e) {
                return _e / degToRads
            }
            var radians_to_degrees = radiansToDegrees;
            function degreesToRadians(_e) {
                return _e * degToRads
            }
            var degrees_to_radians = radiansToDegrees
              , helperLengthArray = [0, 0, 0, 0, 0, 0];
            function length(_e, et) {
                if (typeof _e == "number" || _e instanceof Number)
                    return et = et || 0,
                    Math.abs(_e - et);
                et || (et = helperLengthArray);
                var tt, rt = Math.min(_e.length, et.length), nt = 0;
                for (tt = 0; tt < rt; tt += 1)
                    nt += Math.pow(et[tt] - _e[tt], 2);
                return Math.sqrt(nt)
            }
            function normalize(_e) {
                return div(_e, length(_e))
            }
            function rgbToHsl(_e) {
                var et = _e[0], tt = _e[1], rt = _e[2], nt = Math.max(et, tt, rt), it = Math.min(et, tt, rt), st, at, ot = (nt + it) / 2;
                if (nt === it)
                    st = 0,
                    at = 0;
                else {
                    var lt = nt - it;
                    switch (at = ot > .5 ? lt / (2 - nt - it) : lt / (nt + it),
                    nt) {
                    case et:
                        st = (tt - rt) / lt + (tt < rt ? 6 : 0);
                        break;
                    case tt:
                        st = (rt - et) / lt + 2;
                        break;
                    case rt:
                        st = (et - tt) / lt + 4;
                        break
                    }
                    st /= 6
                }
                return [st, at, ot, _e[3]]
            }
            function hue2rgb(_e, et, tt) {
                return tt < 0 && (tt += 1),
                tt > 1 && (tt -= 1),
                tt < 1 / 6 ? _e + (et - _e) * 6 * tt : tt < 1 / 2 ? et : tt < 2 / 3 ? _e + (et - _e) * (2 / 3 - tt) * 6 : _e
            }
            function hslToRgb(_e) {
                var et = _e[0], tt = _e[1], rt = _e[2], nt, it, st;
                if (tt === 0)
                    nt = rt,
                    st = rt,
                    it = rt;
                else {
                    var at = rt < .5 ? rt * (1 + tt) : rt + tt - rt * tt
                      , ot = 2 * rt - at;
                    nt = hue2rgb(ot, at, et + 1 / 3),
                    it = hue2rgb(ot, at, et),
                    st = hue2rgb(ot, at, et - 1 / 3)
                }
                return [nt, it, st, _e[3]]
            }
            function linear(_e, et, tt, rt, nt) {
                if ((rt === void 0 || nt === void 0) && (rt = et,
                nt = tt,
                et = 0,
                tt = 1),
                tt < et) {
                    var it = tt;
                    tt = et,
                    et = it
                }
                if (_e <= et)
                    return rt;
                if (_e >= tt)
                    return nt;
                var st = tt === et ? 0 : (_e - et) / (tt - et);
                if (!rt.length)
                    return rt + (nt - rt) * st;
                var at, ot = rt.length, lt = createTypedArray("float32", ot);
                for (at = 0; at < ot; at += 1)
                    lt[at] = rt[at] + (nt[at] - rt[at]) * st;
                return lt
            }
            function random(_e, et) {
                if (et === void 0 && (_e === void 0 ? (_e = 0,
                et = 1) : (et = _e,
                _e = void 0)),
                et.length) {
                    var tt, rt = et.length;
                    _e || (_e = createTypedArray("float32", rt));
                    var nt = createTypedArray("float32", rt)
                      , it = BMMath.random();
                    for (tt = 0; tt < rt; tt += 1)
                        nt[tt] = _e[tt] + it * (et[tt] - _e[tt]);
                    return nt
                }
                _e === void 0 && (_e = 0);
                var st = BMMath.random();
                return _e + st * (et - _e)
            }
            function createPath(_e, et, tt, rt) {
                var nt, it = _e.length, st = shapePool.newElement();
                st.setPathData(!!rt, it);
                var at = [0, 0], ot, lt;
                for (nt = 0; nt < it; nt += 1)
                    ot = et && et[nt] ? et[nt] : at,
                    lt = tt && tt[nt] ? tt[nt] : at,
                    st.setTripleAt(_e[nt][0], _e[nt][1], lt[0] + _e[nt][0], lt[1] + _e[nt][1], ot[0] + _e[nt][0], ot[1] + _e[nt][1], nt, !0);
                return st
            }
            function initiateExpression(elem, data, property) {
                function noOp(_e) {
                    return _e
                }
                if (!elem.globalData.renderConfig.runExpressions)
                    return noOp;
                var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
                thisProperty.valueAtTime = thisProperty.getValueAtTime,
                Object.defineProperty(thisProperty, "value", {
                    get: function() {
                        return thisProperty.v
                    }
                }),
                elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate,
                elem.comp.displayStartTime = 0;
                var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function _e(et, tt) {
                    var rt, nt, it = this.pv.length ? this.pv.length : 1, st = createTypedArray("float32", it);
                    et = 5;
                    var at = Math.floor(time * et);
                    for (rt = 0,
                    nt = 0; rt < at; ) {
                        for (nt = 0; nt < it; nt += 1)
                            st[nt] += -tt + tt * 2 * BMMath.random();
                        rt += 1
                    }
                    var ot = time * et
                      , lt = ot - Math.floor(ot)
                      , dt = createTypedArray("float32", it);
                    if (it > 1) {
                        for (nt = 0; nt < it; nt += 1)
                            dt[nt] = this.pv[nt] + st[nt] + (-tt + tt * 2 * BMMath.random()) * lt;
                        return dt
                    }
                    return this.pv + st[0] + (-tt + tt * 2 * BMMath.random()) * lt
                }
                ).bind(this);
                thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty),
                loop_in = loopIn),
                thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty),
                loop_out = loopOut),
                thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));
                function loopInDuration(_e, et) {
                    return loopIn(_e, et, !0)
                }
                function loopOutDuration(_e, et) {
                    return loopOut(_e, et, !0)
                }
                this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)),
                this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
                function lookAt(_e, et) {
                    var tt = [et[0] - _e[0], et[1] - _e[1], et[2] - _e[2]]
                      , rt = Math.atan2(tt[0], Math.sqrt(tt[1] * tt[1] + tt[2] * tt[2])) / degToRads
                      , nt = -Math.atan2(tt[1], tt[2]) / degToRads;
                    return [nt, rt, 0]
                }
                function easeOut(_e, et, tt, rt, nt) {
                    return applyEase(easeOutBez, _e, et, tt, rt, nt)
                }
                function easeIn(_e, et, tt, rt, nt) {
                    return applyEase(easeInBez, _e, et, tt, rt, nt)
                }
                function ease(_e, et, tt, rt, nt) {
                    return applyEase(easeInOutBez, _e, et, tt, rt, nt)
                }
                function applyEase(_e, et, tt, rt, nt, it) {
                    nt === void 0 ? (nt = tt,
                    it = rt) : et = (et - tt) / (rt - tt),
                    et > 1 ? et = 1 : et < 0 && (et = 0);
                    var st = _e(et);
                    if ($bm_isInstanceOfArray(nt)) {
                        var at, ot = nt.length, lt = createTypedArray("float32", ot);
                        for (at = 0; at < ot; at += 1)
                            lt[at] = (it[at] - nt[at]) * st + nt[at];
                        return lt
                    }
                    return (it - nt) * st + nt
                }
                function nearestKey(_e) {
                    var et, tt = data.k.length, rt, nt;
                    if (!data.k.length || typeof data.k[0] == "number")
                        rt = 0,
                        nt = 0;
                    else if (rt = -1,
                    _e *= elem.comp.globalData.frameRate,
                    _e < data.k[0].t)
                        rt = 1,
                        nt = data.k[0].t;
                    else {
                        for (et = 0; et < tt - 1; et += 1)
                            if (_e === data.k[et].t) {
                                rt = et + 1,
                                nt = data.k[et].t;
                                break
                            } else if (_e > data.k[et].t && _e < data.k[et + 1].t) {
                                _e - data.k[et].t > data.k[et + 1].t - _e ? (rt = et + 2,
                                nt = data.k[et + 1].t) : (rt = et + 1,
                                nt = data.k[et].t);
                                break
                            }
                        rt === -1 && (rt = et + 1,
                        nt = data.k[et].t)
                    }
                    var it = {};
                    return it.index = rt,
                    it.time = nt / elem.comp.globalData.frameRate,
                    it
                }
                function key(_e) {
                    var et, tt, rt;
                    if (!data.k.length || typeof data.k[0] == "number")
                        throw new Error("The property has no keyframe at index " + _e);
                    _e -= 1,
                    et = {
                        time: data.k[_e].t / elem.comp.globalData.frameRate,
                        value: []
                    };
                    var nt = Object.prototype.hasOwnProperty.call(data.k[_e], "s") ? data.k[_e].s : data.k[_e - 1].e;
                    for (rt = nt.length,
                    tt = 0; tt < rt; tt += 1)
                        et[tt] = nt[tt],
                        et.value[tt] = nt[tt];
                    return et
                }
                function framesToTime(_e, et) {
                    return et || (et = elem.comp.globalData.frameRate),
                    _e / et
                }
                function timeToFrames(_e, et) {
                    return !_e && _e !== 0 && (_e = time),
                    et || (et = elem.comp.globalData.frameRate),
                    _e * et
                }
                function seedRandom(_e) {
                    BMMath.seedrandom(randSeed + _e)
                }
                function sourceRectAtTime() {
                    return elem.sourceRectAtTime()
                }
                function substring(_e, et) {
                    return typeof value == "string" ? et === void 0 ? value.substring(_e) : value.substring(_e, et) : ""
                }
                function substr(_e, et) {
                    return typeof value == "string" ? et === void 0 ? value.substr(_e) : value.substr(_e, et) : ""
                }
                function posterizeTime(_e) {
                    time = _e === 0 ? 0 : Math.floor(time * _e) / _e,
                    value = valueAtTime(time)
                }
                var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData;
                function executeExpression(_e) {
                    return value = _e,
                    this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex,
                    textTotal = this.textTotal,
                    selectorValue = this.selectorValue),
                    thisLayer || (text = elem.layerInterface.text,
                    thisLayer = elem.layerInterface,
                    thisComp = elem.comp.compInterface,
                    toWorld = thisLayer.toWorld.bind(thisLayer),
                    fromWorld = thisLayer.fromWorld.bind(thisLayer),
                    fromComp = thisLayer.fromComp.bind(thisLayer),
                    toComp = thisLayer.toComp.bind(thisLayer),
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null,
                    fromCompToSurface = fromComp),
                    transform || (transform = elem.layerInterface("ADBE Transform Group"),
                    $bm_transform = transform,
                    transform && (anchorPoint = transform.anchorPoint)),
                    elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    hasParent = !!(elem.hierarchy && elem.hierarchy.length),
                    hasParent && !parent && (parent = elem.hierarchy[0].layerInterface),
                    time = this.comp.renderedFrame / this.comp.globalData.frameRate,
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    this.frameExpressionId = elem.globalData.frameId,
                    scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt,
                    scoped_bm_rt)
                }
                return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData],
                executeExpression
            }
            return ob.initiateExpression = initiateExpression,
            ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal],
            ob.resetFrame = resetFrame,
            ob
        }()
          , Expressions = function() {
            var _e = {};
            _e.initExpressions = et,
            _e.resetFrame = ExpressionManager.resetFrame;
            function et(tt) {
                var rt = 0
                  , nt = [];
                function it() {
                    rt += 1
                }
                function st() {
                    rt -= 1,
                    rt === 0 && ot()
                }
                function at(lt) {
                    nt.indexOf(lt) === -1 && nt.push(lt)
                }
                function ot() {
                    var lt, dt = nt.length;
                    for (lt = 0; lt < dt; lt += 1)
                        nt[lt].release();
                    nt.length = 0
                }
                tt.renderer.compInterface = CompExpressionInterface(tt.renderer),
                tt.renderer.globalData.projectInterface.registerComposition(tt.renderer),
                tt.renderer.globalData.pushExpression = it,
                tt.renderer.globalData.popExpression = st,
                tt.renderer.globalData.registerExpressionProperty = at
            }
            return _e
        }()
          , MaskManagerInterface = function() {
            function _e(tt, rt) {
                this._mask = tt,
                this._data = rt
            }
            Object.defineProperty(_e.prototype, "maskPath", {
                get: function() {
                    return this._mask.prop.k && this._mask.prop.getValue(),
                    this._mask.prop
                }
            }),
            Object.defineProperty(_e.prototype, "maskOpacity", {
                get: function() {
                    return this._mask.op.k && this._mask.op.getValue(),
                    this._mask.op.v * 100
                }
            });
            var et = function(rt) {
                var nt = createSizedArray(rt.viewData.length), it, st = rt.viewData.length;
                for (it = 0; it < st; it += 1)
                    nt[it] = new _e(rt.viewData[it],rt.masksProperties[it]);
                var at = function(lt) {
                    for (it = 0; it < st; ) {
                        if (rt.masksProperties[it].nm === lt)
                            return nt[it];
                        it += 1
                    }
                    return null
                };
                return at
            };
            return et
        }()
          , ExpressionPropertyInterface = function() {
            var _e = {
                pv: 0,
                v: 0,
                mult: 1
            }
              , et = {
                pv: [0, 0, 0],
                v: [0, 0, 0],
                mult: 1
            };
            function tt(st, at, ot) {
                Object.defineProperty(st, "velocity", {
                    get: function() {
                        return at.getVelocityAtTime(at.comp.currentFrame)
                    }
                }),
                st.numKeys = at.keyframes ? at.keyframes.length : 0,
                st.key = function(lt) {
                    if (!st.numKeys)
                        return 0;
                    var dt = "";
                    "s"in at.keyframes[lt - 1] ? dt = at.keyframes[lt - 1].s : "e"in at.keyframes[lt - 2] ? dt = at.keyframes[lt - 2].e : dt = at.keyframes[lt - 2].s;
                    var ct = ot === "unidimensional" ? new Number(dt) : Object.assign({}, dt);
                    return ct.time = at.keyframes[lt - 1].t / at.elem.comp.globalData.frameRate,
                    ct.value = ot === "unidimensional" ? dt[0] : dt,
                    ct
                }
                ,
                st.valueAtTime = at.getValueAtTime,
                st.speedAtTime = at.getSpeedAtTime,
                st.velocityAtTime = at.getVelocityAtTime,
                st.propertyGroup = at.propertyGroup
            }
            function rt(st) {
                (!st || !("pv"in st)) && (st = _e);
                var at = 1 / st.mult
                  , ot = st.pv * at
                  , lt = new Number(ot);
                return lt.value = ot,
                tt(lt, st, "unidimensional"),
                function() {
                    return st.k && st.getValue(),
                    ot = st.v * at,
                    lt.value !== ot && (lt = new Number(ot),
                    lt.value = ot,
                    tt(lt, st, "unidimensional")),
                    lt
                }
            }
            function nt(st) {
                (!st || !("pv"in st)) && (st = et);
                var at = 1 / st.mult
                  , ot = st.data && st.data.l || st.pv.length
                  , lt = createTypedArray("float32", ot)
                  , dt = createTypedArray("float32", ot);
                return lt.value = dt,
                tt(lt, st, "multidimensional"),
                function() {
                    st.k && st.getValue();
                    for (var ct = 0; ct < ot; ct += 1)
                        dt[ct] = st.v[ct] * at,
                        lt[ct] = dt[ct];
                    return lt
                }
            }
            function it() {
                return _e
            }
            return function(st) {
                return st ? st.propType === "unidimensional" ? rt(st) : nt(st) : it
            }
        }()
          , TransformExpressionInterface = function() {
            return function(_e) {
                function et(st) {
                    switch (st) {
                    case "scale":
                    case "Scale":
                    case "ADBE Scale":
                    case 6:
                        return et.scale;
                    case "rotation":
                    case "Rotation":
                    case "ADBE Rotation":
                    case "ADBE Rotate Z":
                    case 10:
                        return et.rotation;
                    case "ADBE Rotate X":
                        return et.xRotation;
                    case "ADBE Rotate Y":
                        return et.yRotation;
                    case "position":
                    case "Position":
                    case "ADBE Position":
                    case 2:
                        return et.position;
                    case "ADBE Position_0":
                        return et.xPosition;
                    case "ADBE Position_1":
                        return et.yPosition;
                    case "ADBE Position_2":
                        return et.zPosition;
                    case "anchorPoint":
                    case "AnchorPoint":
                    case "Anchor Point":
                    case "ADBE AnchorPoint":
                    case 1:
                        return et.anchorPoint;
                    case "opacity":
                    case "Opacity":
                    case 11:
                        return et.opacity;
                    default:
                        return null
                    }
                }
                Object.defineProperty(et, "rotation", {
                    get: ExpressionPropertyInterface(_e.r || _e.rz)
                }),
                Object.defineProperty(et, "zRotation", {
                    get: ExpressionPropertyInterface(_e.rz || _e.r)
                }),
                Object.defineProperty(et, "xRotation", {
                    get: ExpressionPropertyInterface(_e.rx)
                }),
                Object.defineProperty(et, "yRotation", {
                    get: ExpressionPropertyInterface(_e.ry)
                }),
                Object.defineProperty(et, "scale", {
                    get: ExpressionPropertyInterface(_e.s)
                });
                var tt, rt, nt, it;
                return _e.p ? it = ExpressionPropertyInterface(_e.p) : (tt = ExpressionPropertyInterface(_e.px),
                rt = ExpressionPropertyInterface(_e.py),
                _e.pz && (nt = ExpressionPropertyInterface(_e.pz))),
                Object.defineProperty(et, "position", {
                    get: function() {
                        return _e.p ? it() : [tt(), rt(), nt ? nt() : 0]
                    }
                }),
                Object.defineProperty(et, "xPosition", {
                    get: ExpressionPropertyInterface(_e.px)
                }),
                Object.defineProperty(et, "yPosition", {
                    get: ExpressionPropertyInterface(_e.py)
                }),
                Object.defineProperty(et, "zPosition", {
                    get: ExpressionPropertyInterface(_e.pz)
                }),
                Object.defineProperty(et, "anchorPoint", {
                    get: ExpressionPropertyInterface(_e.a)
                }),
                Object.defineProperty(et, "opacity", {
                    get: ExpressionPropertyInterface(_e.o)
                }),
                Object.defineProperty(et, "skew", {
                    get: ExpressionPropertyInterface(_e.sk)
                }),
                Object.defineProperty(et, "skewAxis", {
                    get: ExpressionPropertyInterface(_e.sa)
                }),
                Object.defineProperty(et, "orientation", {
                    get: ExpressionPropertyInterface(_e.or)
                }),
                et
            }
        }()
          , LayerExpressionInterface = function() {
            function _e(lt) {
                var dt = new Matrix;
                if (lt !== void 0) {
                    var ct = this._elem.finalTransform.mProp.getValueAtTime(lt);
                    ct.clone(dt)
                } else {
                    var ut = this._elem.finalTransform.mProp;
                    ut.applyToMatrix(dt)
                }
                return dt
            }
            function et(lt, dt) {
                var ct = this.getMatrix(dt);
                return ct.props[12] = 0,
                ct.props[13] = 0,
                ct.props[14] = 0,
                this.applyPoint(ct, lt)
            }
            function tt(lt, dt) {
                var ct = this.getMatrix(dt);
                return this.applyPoint(ct, lt)
            }
            function rt(lt, dt) {
                var ct = this.getMatrix(dt);
                return ct.props[12] = 0,
                ct.props[13] = 0,
                ct.props[14] = 0,
                this.invertPoint(ct, lt)
            }
            function nt(lt, dt) {
                var ct = this.getMatrix(dt);
                return this.invertPoint(ct, lt)
            }
            function it(lt, dt) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var ct, ut = this._elem.hierarchy.length;
                    for (ct = 0; ct < ut; ct += 1)
                        this._elem.hierarchy[ct].finalTransform.mProp.applyToMatrix(lt)
                }
                return lt.applyToPointArray(dt[0], dt[1], dt[2] || 0)
            }
            function st(lt, dt) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var ct, ut = this._elem.hierarchy.length;
                    for (ct = 0; ct < ut; ct += 1)
                        this._elem.hierarchy[ct].finalTransform.mProp.applyToMatrix(lt)
                }
                return lt.inversePoint(dt)
            }
            function at(lt) {
                var dt = new Matrix;
                if (dt.reset(),
                this._elem.finalTransform.mProp.applyToMatrix(dt),
                this._elem.hierarchy && this._elem.hierarchy.length) {
                    var ct, ut = this._elem.hierarchy.length;
                    for (ct = 0; ct < ut; ct += 1)
                        this._elem.hierarchy[ct].finalTransform.mProp.applyToMatrix(dt);
                    return dt.inversePoint(lt)
                }
                return dt.inversePoint(lt)
            }
            function ot() {
                return [1, 1, 1, 1]
            }
            return function(lt) {
                var dt;
                function ct(gt) {
                    ft.mask = new MaskManagerInterface(gt,lt)
                }
                function ut(gt) {
                    ft.effect = gt
                }
                function ft(gt) {
                    switch (gt) {
                    case "ADBE Root Vectors Group":
                    case "Contents":
                    case 2:
                        return ft.shapeInterface;
                    case 1:
                    case 6:
                    case "Transform":
                    case "transform":
                    case "ADBE Transform Group":
                        return dt;
                    case 4:
                    case "ADBE Effect Parade":
                    case "effects":
                    case "Effects":
                        return ft.effect;
                    case "ADBE Text Properties":
                        return ft.textInterface;
                    default:
                        return null
                    }
                }
                ft.getMatrix = _e,
                ft.invertPoint = st,
                ft.applyPoint = it,
                ft.toWorld = tt,
                ft.toWorldVec = et,
                ft.fromWorld = nt,
                ft.fromWorldVec = rt,
                ft.toComp = tt,
                ft.fromComp = at,
                ft.sampleImage = ot,
                ft.sourceRectAtTime = lt.sourceRectAtTime.bind(lt),
                ft._elem = lt,
                dt = TransformExpressionInterface(lt.finalTransform.mProp);
                var ht = getDescriptor(dt, "anchorPoint");
                return Object.defineProperties(ft, {
                    hasParent: {
                        get: function() {
                            return lt.hierarchy.length
                        }
                    },
                    parent: {
                        get: function() {
                            return lt.hierarchy[0].layerInterface
                        }
                    },
                    rotation: getDescriptor(dt, "rotation"),
                    scale: getDescriptor(dt, "scale"),
                    position: getDescriptor(dt, "position"),
                    opacity: getDescriptor(dt, "opacity"),
                    anchorPoint: ht,
                    anchor_point: ht,
                    transform: {
                        get: function() {
                            return dt
                        }
                    },
                    active: {
                        get: function() {
                            return lt.isInRange
                        }
                    }
                }),
                ft.startTime = lt.data.st,
                ft.index = lt.data.ind,
                ft.source = lt.data.refId,
                ft.height = lt.data.ty === 0 ? lt.data.h : 100,
                ft.width = lt.data.ty === 0 ? lt.data.w : 100,
                ft.inPoint = lt.data.ip / lt.comp.globalData.frameRate,
                ft.outPoint = lt.data.op / lt.comp.globalData.frameRate,
                ft._name = lt.data.nm,
                ft.registerMaskInterface = ct,
                ft.registerEffectsInterface = ut,
                ft
            }
        }()
          , propertyGroupFactory = function() {
            return function(_e, et) {
                return function(tt) {
                    return tt = tt === void 0 ? 1 : tt,
                    tt <= 0 ? _e : et(tt - 1)
                }
            }
        }()
          , PropertyInterface = function() {
            return function(_e, et) {
                var tt = {
                    _name: _e
                };
                function rt(nt) {
                    return nt = nt === void 0 ? 1 : nt,
                    nt <= 0 ? tt : et(nt - 1)
                }
                return rt
            }
        }()
          , EffectsExpressionInterface = function() {
            var _e = {
                createEffectsInterface: et
            };
            function et(nt, it) {
                if (nt.effectsManager) {
                    var st = [], at = nt.data.ef, ot, lt = nt.effectsManager.effectElements.length;
                    for (ot = 0; ot < lt; ot += 1)
                        st.push(tt(at[ot], nt.effectsManager.effectElements[ot], it, nt));
                    var dt = nt.data.ef || []
                      , ct = function(ft) {
                        for (ot = 0,
                        lt = dt.length; ot < lt; ) {
                            if (ft === dt[ot].nm || ft === dt[ot].mn || ft === dt[ot].ix)
                                return st[ot];
                            ot += 1
                        }
                        return null
                    };
                    return Object.defineProperty(ct, "numProperties", {
                        get: function() {
                            return dt.length
                        }
                    }),
                    ct
                }
                return null
            }
            function tt(nt, it, st, at) {
                function ot(ft) {
                    for (var ht = nt.ef, gt = 0, bt = ht.length; gt < bt; ) {
                        if (ft === ht[gt].nm || ft === ht[gt].mn || ft === ht[gt].ix)
                            return ht[gt].ty === 5 ? dt[gt] : dt[gt]();
                        gt += 1
                    }
                    throw new Error
                }
                var lt = propertyGroupFactory(ot, st), dt = [], ct, ut = nt.ef.length;
                for (ct = 0; ct < ut; ct += 1)
                    nt.ef[ct].ty === 5 ? dt.push(tt(nt.ef[ct], it.effectElements[ct], it.effectElements[ct].propertyGroup, at)) : dt.push(rt(it.effectElements[ct], nt.ef[ct].ty, at, lt));
                return nt.mn === "ADBE Color Control" && Object.defineProperty(ot, "color", {
                    get: function() {
                        return dt[0]()
                    }
                }),
                Object.defineProperties(ot, {
                    numProperties: {
                        get: function() {
                            return nt.np
                        }
                    },
                    _name: {
                        value: nt.nm
                    },
                    propertyGroup: {
                        value: lt
                    }
                }),
                ot.enabled = nt.en !== 0,
                ot.active = ot.enabled,
                ot
            }
            function rt(nt, it, st, at) {
                var ot = ExpressionPropertyInterface(nt.p);
                function lt() {
                    return it === 10 ? st.comp.compInterface(nt.p.v) : ot()
                }
                return nt.p.setGroupProperty && nt.p.setGroupProperty(PropertyInterface("", at)),
                lt
            }
            return _e
        }()
          , ShapePathInterface = function() {
            return function(et, tt, rt) {
                var nt = tt.sh;
                function it(at) {
                    return at === "Shape" || at === "shape" || at === "Path" || at === "path" || at === "ADBE Vector Shape" || at === 2 ? it.path : null
                }
                var st = propertyGroupFactory(it, rt);
                return nt.setGroupProperty(PropertyInterface("Path", st)),
                Object.defineProperties(it, {
                    path: {
                        get: function() {
                            return nt.k && nt.getValue(),
                            nt
                        }
                    },
                    shape: {
                        get: function() {
                            return nt.k && nt.getValue(),
                            nt
                        }
                    },
                    _name: {
                        value: et.nm
                    },
                    ix: {
                        value: et.ix
                    },
                    propertyIndex: {
                        value: et.ix
                    },
                    mn: {
                        value: et.mn
                    },
                    propertyGroup: {
                        value: rt
                    }
                }),
                it
            }
        }()
          , ShapeExpressionInterface = function() {
            function _e(ht, gt, bt) {
                var pt = [], mt, yt = ht ? ht.length : 0;
                for (mt = 0; mt < yt; mt += 1)
                    ht[mt].ty === "gr" ? pt.push(tt(ht[mt], gt[mt], bt)) : ht[mt].ty === "fl" ? pt.push(rt(ht[mt], gt[mt], bt)) : ht[mt].ty === "st" ? pt.push(st(ht[mt], gt[mt], bt)) : ht[mt].ty === "tm" ? pt.push(at(ht[mt], gt[mt], bt)) : ht[mt].ty === "tr" || (ht[mt].ty === "el" ? pt.push(lt(ht[mt], gt[mt], bt)) : ht[mt].ty === "sr" ? pt.push(dt(ht[mt], gt[mt], bt)) : ht[mt].ty === "sh" ? pt.push(ShapePathInterface(ht[mt], gt[mt], bt)) : ht[mt].ty === "rc" ? pt.push(ct(ht[mt], gt[mt], bt)) : ht[mt].ty === "rd" ? pt.push(ut(ht[mt], gt[mt], bt)) : ht[mt].ty === "rp" ? pt.push(ft(ht[mt], gt[mt], bt)) : ht[mt].ty === "gf" ? pt.push(nt(ht[mt], gt[mt], bt)) : pt.push(it(ht[mt], gt[mt])));
                return pt
            }
            function et(ht, gt, bt) {
                var pt, mt = function(wt) {
                    for (var _t = 0, Et = pt.length; _t < Et; ) {
                        if (pt[_t]._name === wt || pt[_t].mn === wt || pt[_t].propertyIndex === wt || pt[_t].ix === wt || pt[_t].ind === wt)
                            return pt[_t];
                        _t += 1
                    }
                    return typeof wt == "number" ? pt[wt - 1] : null
                };
                mt.propertyGroup = propertyGroupFactory(mt, bt),
                pt = _e(ht.it, gt.it, mt.propertyGroup),
                mt.numProperties = pt.length;
                var yt = ot(ht.it[ht.it.length - 1], gt.it[gt.it.length - 1], mt.propertyGroup);
                return mt.transform = yt,
                mt.propertyIndex = ht.cix,
                mt._name = ht.nm,
                mt
            }
            function tt(ht, gt, bt) {
                var pt = function(wt) {
                    switch (wt) {
                    case "ADBE Vectors Group":
                    case "Contents":
                    case 2:
                        return pt.content;
                    default:
                        return pt.transform
                    }
                };
                pt.propertyGroup = propertyGroupFactory(pt, bt);
                var mt = et(ht, gt, pt.propertyGroup)
                  , yt = ot(ht.it[ht.it.length - 1], gt.it[gt.it.length - 1], pt.propertyGroup);
                return pt.content = mt,
                pt.transform = yt,
                Object.defineProperty(pt, "_name", {
                    get: function() {
                        return ht.nm
                    }
                }),
                pt.numProperties = ht.np,
                pt.propertyIndex = ht.ix,
                pt.nm = ht.nm,
                pt.mn = ht.mn,
                pt
            }
            function rt(ht, gt, bt) {
                function pt(mt) {
                    return mt === "Color" || mt === "color" ? pt.color : mt === "Opacity" || mt === "opacity" ? pt.opacity : null
                }
                return Object.defineProperties(pt, {
                    color: {
                        get: ExpressionPropertyInterface(gt.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(gt.o)
                    },
                    _name: {
                        value: ht.nm
                    },
                    mn: {
                        value: ht.mn
                    }
                }),
                gt.c.setGroupProperty(PropertyInterface("Color", bt)),
                gt.o.setGroupProperty(PropertyInterface("Opacity", bt)),
                pt
            }
            function nt(ht, gt, bt) {
                function pt(mt) {
                    return mt === "Start Point" || mt === "start point" ? pt.startPoint : mt === "End Point" || mt === "end point" ? pt.endPoint : mt === "Opacity" || mt === "opacity" ? pt.opacity : null
                }
                return Object.defineProperties(pt, {
                    startPoint: {
                        get: ExpressionPropertyInterface(gt.s)
                    },
                    endPoint: {
                        get: ExpressionPropertyInterface(gt.e)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(gt.o)
                    },
                    type: {
                        get: function() {
                            return "a"
                        }
                    },
                    _name: {
                        value: ht.nm
                    },
                    mn: {
                        value: ht.mn
                    }
                }),
                gt.s.setGroupProperty(PropertyInterface("Start Point", bt)),
                gt.e.setGroupProperty(PropertyInterface("End Point", bt)),
                gt.o.setGroupProperty(PropertyInterface("Opacity", bt)),
                pt
            }
            function it() {
                function ht() {
                    return null
                }
                return ht
            }
            function st(ht, gt, bt) {
                var pt = propertyGroupFactory(Et, bt)
                  , mt = propertyGroupFactory(_t, pt);
                function yt(xt) {
                    Object.defineProperty(_t, ht.d[xt].nm, {
                        get: ExpressionPropertyInterface(gt.d.dataProps[xt].p)
                    })
                }
                var vt, wt = ht.d ? ht.d.length : 0, _t = {};
                for (vt = 0; vt < wt; vt += 1)
                    yt(vt),
                    gt.d.dataProps[vt].p.setGroupProperty(mt);
                function Et(xt) {
                    return xt === "Color" || xt === "color" ? Et.color : xt === "Opacity" || xt === "opacity" ? Et.opacity : xt === "Stroke Width" || xt === "stroke width" ? Et.strokeWidth : null
                }
                return Object.defineProperties(Et, {
                    color: {
                        get: ExpressionPropertyInterface(gt.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(gt.o)
                    },
                    strokeWidth: {
                        get: ExpressionPropertyInterface(gt.w)
                    },
                    dash: {
                        get: function() {
                            return _t
                        }
                    },
                    _name: {
                        value: ht.nm
                    },
                    mn: {
                        value: ht.mn
                    }
                }),
                gt.c.setGroupProperty(PropertyInterface("Color", pt)),
                gt.o.setGroupProperty(PropertyInterface("Opacity", pt)),
                gt.w.setGroupProperty(PropertyInterface("Stroke Width", pt)),
                Et
            }
            function at(ht, gt, bt) {
                function pt(yt) {
                    return yt === ht.e.ix || yt === "End" || yt === "end" ? pt.end : yt === ht.s.ix ? pt.start : yt === ht.o.ix ? pt.offset : null
                }
                var mt = propertyGroupFactory(pt, bt);
                return pt.propertyIndex = ht.ix,
                gt.s.setGroupProperty(PropertyInterface("Start", mt)),
                gt.e.setGroupProperty(PropertyInterface("End", mt)),
                gt.o.setGroupProperty(PropertyInterface("Offset", mt)),
                pt.propertyIndex = ht.ix,
                pt.propertyGroup = bt,
                Object.defineProperties(pt, {
                    start: {
                        get: ExpressionPropertyInterface(gt.s)
                    },
                    end: {
                        get: ExpressionPropertyInterface(gt.e)
                    },
                    offset: {
                        get: ExpressionPropertyInterface(gt.o)
                    },
                    _name: {
                        value: ht.nm
                    }
                }),
                pt.mn = ht.mn,
                pt
            }
            function ot(ht, gt, bt) {
                function pt(yt) {
                    return ht.a.ix === yt || yt === "Anchor Point" ? pt.anchorPoint : ht.o.ix === yt || yt === "Opacity" ? pt.opacity : ht.p.ix === yt || yt === "Position" ? pt.position : ht.r.ix === yt || yt === "Rotation" || yt === "ADBE Vector Rotation" ? pt.rotation : ht.s.ix === yt || yt === "Scale" ? pt.scale : ht.sk && ht.sk.ix === yt || yt === "Skew" ? pt.skew : ht.sa && ht.sa.ix === yt || yt === "Skew Axis" ? pt.skewAxis : null
                }
                var mt = propertyGroupFactory(pt, bt);
                return gt.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", mt)),
                gt.transform.mProps.p.setGroupProperty(PropertyInterface("Position", mt)),
                gt.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", mt)),
                gt.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", mt)),
                gt.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", mt)),
                gt.transform.mProps.sk && (gt.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", mt)),
                gt.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", mt))),
                gt.transform.op.setGroupProperty(PropertyInterface("Opacity", mt)),
                Object.defineProperties(pt, {
                    opacity: {
                        get: ExpressionPropertyInterface(gt.transform.mProps.o)
                    },
                    position: {
                        get: ExpressionPropertyInterface(gt.transform.mProps.p)
                    },
                    anchorPoint: {
                        get: ExpressionPropertyInterface(gt.transform.mProps.a)
                    },
                    scale: {
                        get: ExpressionPropertyInterface(gt.transform.mProps.s)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(gt.transform.mProps.r)
                    },
                    skew: {
                        get: ExpressionPropertyInterface(gt.transform.mProps.sk)
                    },
                    skewAxis: {
                        get: ExpressionPropertyInterface(gt.transform.mProps.sa)
                    },
                    _name: {
                        value: ht.nm
                    }
                }),
                pt.ty = "tr",
                pt.mn = ht.mn,
                pt.propertyGroup = bt,
                pt
            }
            function lt(ht, gt, bt) {
                function pt(vt) {
                    return ht.p.ix === vt ? pt.position : ht.s.ix === vt ? pt.size : null
                }
                var mt = propertyGroupFactory(pt, bt);
                pt.propertyIndex = ht.ix;
                var yt = gt.sh.ty === "tm" ? gt.sh.prop : gt.sh;
                return yt.s.setGroupProperty(PropertyInterface("Size", mt)),
                yt.p.setGroupProperty(PropertyInterface("Position", mt)),
                Object.defineProperties(pt, {
                    size: {
                        get: ExpressionPropertyInterface(yt.s)
                    },
                    position: {
                        get: ExpressionPropertyInterface(yt.p)
                    },
                    _name: {
                        value: ht.nm
                    }
                }),
                pt.mn = ht.mn,
                pt
            }
            function dt(ht, gt, bt) {
                function pt(vt) {
                    return ht.p.ix === vt ? pt.position : ht.r.ix === vt ? pt.rotation : ht.pt.ix === vt ? pt.points : ht.or.ix === vt || vt === "ADBE Vector Star Outer Radius" ? pt.outerRadius : ht.os.ix === vt ? pt.outerRoundness : ht.ir && (ht.ir.ix === vt || vt === "ADBE Vector Star Inner Radius") ? pt.innerRadius : ht.is && ht.is.ix === vt ? pt.innerRoundness : null
                }
                var mt = propertyGroupFactory(pt, bt)
                  , yt = gt.sh.ty === "tm" ? gt.sh.prop : gt.sh;
                return pt.propertyIndex = ht.ix,
                yt.or.setGroupProperty(PropertyInterface("Outer Radius", mt)),
                yt.os.setGroupProperty(PropertyInterface("Outer Roundness", mt)),
                yt.pt.setGroupProperty(PropertyInterface("Points", mt)),
                yt.p.setGroupProperty(PropertyInterface("Position", mt)),
                yt.r.setGroupProperty(PropertyInterface("Rotation", mt)),
                ht.ir && (yt.ir.setGroupProperty(PropertyInterface("Inner Radius", mt)),
                yt.is.setGroupProperty(PropertyInterface("Inner Roundness", mt))),
                Object.defineProperties(pt, {
                    position: {
                        get: ExpressionPropertyInterface(yt.p)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(yt.r)
                    },
                    points: {
                        get: ExpressionPropertyInterface(yt.pt)
                    },
                    outerRadius: {
                        get: ExpressionPropertyInterface(yt.or)
                    },
                    outerRoundness: {
                        get: ExpressionPropertyInterface(yt.os)
                    },
                    innerRadius: {
                        get: ExpressionPropertyInterface(yt.ir)
                    },
                    innerRoundness: {
                        get: ExpressionPropertyInterface(yt.is)
                    },
                    _name: {
                        value: ht.nm
                    }
                }),
                pt.mn = ht.mn,
                pt
            }
            function ct(ht, gt, bt) {
                function pt(vt) {
                    return ht.p.ix === vt ? pt.position : ht.r.ix === vt ? pt.roundness : ht.s.ix === vt || vt === "Size" || vt === "ADBE Vector Rect Size" ? pt.size : null
                }
                var mt = propertyGroupFactory(pt, bt)
                  , yt = gt.sh.ty === "tm" ? gt.sh.prop : gt.sh;
                return pt.propertyIndex = ht.ix,
                yt.p.setGroupProperty(PropertyInterface("Position", mt)),
                yt.s.setGroupProperty(PropertyInterface("Size", mt)),
                yt.r.setGroupProperty(PropertyInterface("Rotation", mt)),
                Object.defineProperties(pt, {
                    position: {
                        get: ExpressionPropertyInterface(yt.p)
                    },
                    roundness: {
                        get: ExpressionPropertyInterface(yt.r)
                    },
                    size: {
                        get: ExpressionPropertyInterface(yt.s)
                    },
                    _name: {
                        value: ht.nm
                    }
                }),
                pt.mn = ht.mn,
                pt
            }
            function ut(ht, gt, bt) {
                function pt(vt) {
                    return ht.r.ix === vt || vt === "Round Corners 1" ? pt.radius : null
                }
                var mt = propertyGroupFactory(pt, bt)
                  , yt = gt;
                return pt.propertyIndex = ht.ix,
                yt.rd.setGroupProperty(PropertyInterface("Radius", mt)),
                Object.defineProperties(pt, {
                    radius: {
                        get: ExpressionPropertyInterface(yt.rd)
                    },
                    _name: {
                        value: ht.nm
                    }
                }),
                pt.mn = ht.mn,
                pt
            }
            function ft(ht, gt, bt) {
                function pt(vt) {
                    return ht.c.ix === vt || vt === "Copies" ? pt.copies : ht.o.ix === vt || vt === "Offset" ? pt.offset : null
                }
                var mt = propertyGroupFactory(pt, bt)
                  , yt = gt;
                return pt.propertyIndex = ht.ix,
                yt.c.setGroupProperty(PropertyInterface("Copies", mt)),
                yt.o.setGroupProperty(PropertyInterface("Offset", mt)),
                Object.defineProperties(pt, {
                    copies: {
                        get: ExpressionPropertyInterface(yt.c)
                    },
                    offset: {
                        get: ExpressionPropertyInterface(yt.o)
                    },
                    _name: {
                        value: ht.nm
                    }
                }),
                pt.mn = ht.mn,
                pt
            }
            return function(ht, gt, bt) {
                var pt;
                function mt(vt) {
                    if (typeof vt == "number")
                        return vt = vt === void 0 ? 1 : vt,
                        vt === 0 ? bt : pt[vt - 1];
                    for (var wt = 0, _t = pt.length; wt < _t; ) {
                        if (pt[wt]._name === vt)
                            return pt[wt];
                        wt += 1
                    }
                    return null
                }
                function yt() {
                    return bt
                }
                return mt.propertyGroup = propertyGroupFactory(mt, yt),
                pt = _e(ht, gt, mt.propertyGroup),
                mt.numProperties = pt.length,
                mt._name = "Contents",
                mt
            }
        }()
          , TextExpressionInterface = function() {
            return function(_e) {
                var et;
                function tt(rt) {
                    switch (rt) {
                    case "ADBE Text Document":
                        return tt.sourceText;
                    default:
                        return null
                    }
                }
                return Object.defineProperty(tt, "sourceText", {
                    get: function() {
                        _e.textProperty.getValue();
                        var nt = _e.textProperty.currentData.t;
                        return (!et || nt !== et.value) && (et = new String(nt),
                        et.value = nt || new String(nt),
                        Object.defineProperty(et, "style", {
                            get: function() {
                                return {
                                    fillColor: _e.textProperty.currentData.fc
                                }
                            }
                        })),
                        et
                    }
                }),
                tt
            }
        }();
        function _typeof(_e) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(tt) {
                return typeof tt
            }
            : _typeof = function(tt) {
                return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
            }
            ,
            _typeof(_e)
        }
        var FootageInterface = function() {
            var _e = function(rt) {
                var nt = ""
                  , it = rt.getFootageData();
                function st() {
                    return nt = "",
                    it = rt.getFootageData(),
                    at
                }
                function at(ot) {
                    if (it[ot])
                        return nt = ot,
                        it = it[ot],
                        _typeof(it) === "object" ? at : it;
                    var lt = ot.indexOf(nt);
                    if (lt !== -1) {
                        var dt = parseInt(ot.substr(lt + nt.length), 10);
                        return it = it[dt],
                        _typeof(it) === "object" ? at : it
                    }
                    return ""
                }
                return st
            }
              , et = function(rt) {
                function nt(it) {
                    return it === "Outline" ? nt.outlineInterface() : null
                }
                return nt._name = "Outline",
                nt.outlineInterface = _e(rt),
                nt
            };
            return function(tt) {
                function rt(nt) {
                    return nt === "Data" ? rt.dataInterface : null
                }
                return rt._name = "Data",
                rt.dataInterface = et(tt),
                rt
            }
        }()
          , interfaces = {
            layer: LayerExpressionInterface,
            effects: EffectsExpressionInterface,
            comp: CompExpressionInterface,
            shape: ShapeExpressionInterface,
            text: TextExpressionInterface,
            footage: FootageInterface
        };
        function getInterface(_e) {
            return interfaces[_e] || null
        }
        var expressionHelpers = function() {
            function _e(st, at, ot) {
                at.x && (ot.k = !0,
                ot.x = !0,
                ot.initiateExpression = ExpressionManager.initiateExpression,
                ot.effectsSequence.push(ot.initiateExpression(st, at, ot).bind(ot)))
            }
            function et(st) {
                return st *= this.elem.globalData.frameRate,
                st -= this.offsetTime,
                st !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < st ? this._cachingAtTime.lastIndex : 0,
                this._cachingAtTime.value = this.interpolateValue(st, this._cachingAtTime),
                this._cachingAtTime.lastFrame = st),
                this._cachingAtTime.value
            }
            function tt(st) {
                var at = -.01
                  , ot = this.getValueAtTime(st)
                  , lt = this.getValueAtTime(st + at)
                  , dt = 0;
                if (ot.length) {
                    var ct;
                    for (ct = 0; ct < ot.length; ct += 1)
                        dt += Math.pow(lt[ct] - ot[ct], 2);
                    dt = Math.sqrt(dt) * 100
                } else
                    dt = 0;
                return dt
            }
            function rt(st) {
                if (this.vel !== void 0)
                    return this.vel;
                var at = -.001, ot = this.getValueAtTime(st), lt = this.getValueAtTime(st + at), dt;
                if (ot.length) {
                    dt = createTypedArray("float32", ot.length);
                    var ct;
                    for (ct = 0; ct < ot.length; ct += 1)
                        dt[ct] = (lt[ct] - ot[ct]) / at
                } else
                    dt = (lt - ot) / at;
                return dt
            }
            function nt() {
                return this.pv
            }
            function it(st) {
                this.propertyGroup = st
            }
            return {
                searchExpressions: _e,
                getSpeedAtTime: tt,
                getVelocityAtTime: rt,
                getValueAtTime: et,
                getStaticValueAtTime: nt,
                setGroupProperty: it
            }
        }();
        function addPropertyDecorator() {
            function _e(ut, ft, ht) {
                if (!this.k || !this.keyframes)
                    return this.pv;
                ut = ut ? ut.toLowerCase() : "";
                var gt = this.comp.renderedFrame
                  , bt = this.keyframes
                  , pt = bt[bt.length - 1].t;
                if (gt <= pt)
                    return this.pv;
                var mt, yt;
                ht ? (ft ? mt = Math.abs(pt - this.elem.comp.globalData.frameRate * ft) : mt = Math.max(0, pt - this.elem.data.ip),
                yt = pt - mt) : ((!ft || ft > bt.length - 1) && (ft = bt.length - 1),
                yt = bt[bt.length - 1 - ft].t,
                mt = pt - yt);
                var vt, wt, _t;
                if (ut === "pingpong") {
                    var Et = Math.floor((gt - yt) / mt);
                    if (Et % 2 !== 0)
                        return this.getValueAtTime((mt - (gt - yt) % mt + yt) / this.comp.globalData.frameRate, 0)
                } else if (ut === "offset") {
                    var xt = this.getValueAtTime(yt / this.comp.globalData.frameRate, 0)
                      , Ct = this.getValueAtTime(pt / this.comp.globalData.frameRate, 0)
                      , Tt = this.getValueAtTime(((gt - yt) % mt + yt) / this.comp.globalData.frameRate, 0)
                      , It = Math.floor((gt - yt) / mt);
                    if (this.pv.length) {
                        for (_t = new Array(xt.length),
                        wt = _t.length,
                        vt = 0; vt < wt; vt += 1)
                            _t[vt] = (Ct[vt] - xt[vt]) * It + Tt[vt];
                        return _t
                    }
                    return (Ct - xt) * It + Tt
                } else if (ut === "continue") {
                    var Nt = this.getValueAtTime(pt / this.comp.globalData.frameRate, 0)
                      , Ft = this.getValueAtTime((pt - .001) / this.comp.globalData.frameRate, 0);
                    if (this.pv.length) {
                        for (_t = new Array(Nt.length),
                        wt = _t.length,
                        vt = 0; vt < wt; vt += 1)
                            _t[vt] = Nt[vt] + (Nt[vt] - Ft[vt]) * ((gt - pt) / this.comp.globalData.frameRate) / 5e-4;
                        return _t
                    }
                    return Nt + (Nt - Ft) * ((gt - pt) / .001)
                }
                return this.getValueAtTime(((gt - yt) % mt + yt) / this.comp.globalData.frameRate, 0)
            }
            function et(ut, ft, ht) {
                if (!this.k)
                    return this.pv;
                ut = ut ? ut.toLowerCase() : "";
                var gt = this.comp.renderedFrame
                  , bt = this.keyframes
                  , pt = bt[0].t;
                if (gt >= pt)
                    return this.pv;
                var mt, yt;
                ht ? (ft ? mt = Math.abs(this.elem.comp.globalData.frameRate * ft) : mt = Math.max(0, this.elem.data.op - pt),
                yt = pt + mt) : ((!ft || ft > bt.length - 1) && (ft = bt.length - 1),
                yt = bt[ft].t,
                mt = yt - pt);
                var vt, wt, _t;
                if (ut === "pingpong") {
                    var Et = Math.floor((pt - gt) / mt);
                    if (Et % 2 === 0)
                        return this.getValueAtTime(((pt - gt) % mt + pt) / this.comp.globalData.frameRate, 0)
                } else if (ut === "offset") {
                    var xt = this.getValueAtTime(pt / this.comp.globalData.frameRate, 0)
                      , Ct = this.getValueAtTime(yt / this.comp.globalData.frameRate, 0)
                      , Tt = this.getValueAtTime((mt - (pt - gt) % mt + pt) / this.comp.globalData.frameRate, 0)
                      , It = Math.floor((pt - gt) / mt) + 1;
                    if (this.pv.length) {
                        for (_t = new Array(xt.length),
                        wt = _t.length,
                        vt = 0; vt < wt; vt += 1)
                            _t[vt] = Tt[vt] - (Ct[vt] - xt[vt]) * It;
                        return _t
                    }
                    return Tt - (Ct - xt) * It
                } else if (ut === "continue") {
                    var Nt = this.getValueAtTime(pt / this.comp.globalData.frameRate, 0)
                      , Ft = this.getValueAtTime((pt + .001) / this.comp.globalData.frameRate, 0);
                    if (this.pv.length) {
                        for (_t = new Array(Nt.length),
                        wt = _t.length,
                        vt = 0; vt < wt; vt += 1)
                            _t[vt] = Nt[vt] + (Nt[vt] - Ft[vt]) * (pt - gt) / .001;
                        return _t
                    }
                    return Nt + (Nt - Ft) * (pt - gt) / .001
                }
                return this.getValueAtTime((mt - ((pt - gt) % mt + pt)) / this.comp.globalData.frameRate, 0)
            }
            function tt(ut, ft) {
                if (!this.k)
                    return this.pv;
                if (ut = (ut || .4) * .5,
                ft = Math.floor(ft || 5),
                ft <= 1)
                    return this.pv;
                var ht = this.comp.renderedFrame / this.comp.globalData.frameRate, gt = ht - ut, bt = ht + ut, pt = ft > 1 ? (bt - gt) / (ft - 1) : 1, mt = 0, yt = 0, vt;
                this.pv.length ? vt = createTypedArray("float32", this.pv.length) : vt = 0;
                for (var wt; mt < ft; ) {
                    if (wt = this.getValueAtTime(gt + mt * pt),
                    this.pv.length)
                        for (yt = 0; yt < this.pv.length; yt += 1)
                            vt[yt] += wt[yt];
                    else
                        vt += wt;
                    mt += 1
                }
                if (this.pv.length)
                    for (yt = 0; yt < this.pv.length; yt += 1)
                        vt[yt] /= ft;
                else
                    vt /= ft;
                return vt
            }
            function rt(ut) {
                this._transformCachingAtTime || (this._transformCachingAtTime = {
                    v: new Matrix
                });
                var ft = this._transformCachingAtTime.v;
                if (ft.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1) {
                    var ht = this.a.getValueAtTime(ut);
                    ft.translate(-ht[0] * this.a.mult, -ht[1] * this.a.mult, ht[2] * this.a.mult)
                }
                if (this.appliedTransformations < 2) {
                    var gt = this.s.getValueAtTime(ut);
                    ft.scale(gt[0] * this.s.mult, gt[1] * this.s.mult, gt[2] * this.s.mult)
                }
                if (this.sk && this.appliedTransformations < 3) {
                    var bt = this.sk.getValueAtTime(ut)
                      , pt = this.sa.getValueAtTime(ut);
                    ft.skewFromAxis(-bt * this.sk.mult, pt * this.sa.mult)
                }
                if (this.r && this.appliedTransformations < 4) {
                    var mt = this.r.getValueAtTime(ut);
                    ft.rotate(-mt * this.r.mult)
                } else if (!this.r && this.appliedTransformations < 4) {
                    var yt = this.rz.getValueAtTime(ut)
                      , vt = this.ry.getValueAtTime(ut)
                      , wt = this.rx.getValueAtTime(ut)
                      , _t = this.or.getValueAtTime(ut);
                    ft.rotateZ(-yt * this.rz.mult).rotateY(vt * this.ry.mult).rotateX(wt * this.rx.mult).rotateZ(-_t[2] * this.or.mult).rotateY(_t[1] * this.or.mult).rotateX(_t[0] * this.or.mult)
                }
                if (this.data.p && this.data.p.s) {
                    var Et = this.px.getValueAtTime(ut)
                      , xt = this.py.getValueAtTime(ut);
                    if (this.data.p.z) {
                        var Ct = this.pz.getValueAtTime(ut);
                        ft.translate(Et * this.px.mult, xt * this.py.mult, -Ct * this.pz.mult)
                    } else
                        ft.translate(Et * this.px.mult, xt * this.py.mult, 0)
                } else {
                    var Tt = this.p.getValueAtTime(ut);
                    ft.translate(Tt[0] * this.p.mult, Tt[1] * this.p.mult, -Tt[2] * this.p.mult)
                }
                return ft
            }
            function nt() {
                return this.v.clone(new Matrix)
            }
            var it = TransformPropertyFactory.getTransformProperty;
            TransformPropertyFactory.getTransformProperty = function(ut, ft, ht) {
                var gt = it(ut, ft, ht);
                return gt.dynamicProperties.length ? gt.getValueAtTime = rt.bind(gt) : gt.getValueAtTime = nt.bind(gt),
                gt.setGroupProperty = expressionHelpers.setGroupProperty,
                gt
            }
            ;
            var st = PropertyFactory.getProp;
            PropertyFactory.getProp = function(ut, ft, ht, gt, bt) {
                var pt = st(ut, ft, ht, gt, bt);
                pt.kf ? pt.getValueAtTime = expressionHelpers.getValueAtTime.bind(pt) : pt.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(pt),
                pt.setGroupProperty = expressionHelpers.setGroupProperty,
                pt.loopOut = _e,
                pt.loopIn = et,
                pt.smooth = tt,
                pt.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(pt),
                pt.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(pt),
                pt.numKeys = ft.a === 1 ? ft.k.length : 0,
                pt.propertyIndex = ft.ix;
                var mt = 0;
                return ht !== 0 && (mt = createTypedArray("float32", ft.a === 1 ? ft.k[0].s.length : ft.k.length)),
                pt._cachingAtTime = {
                    lastFrame: initialDefaultFrame,
                    lastIndex: 0,
                    value: mt
                },
                expressionHelpers.searchExpressions(ut, ft, pt),
                pt.k && bt.addDynamicProperty(pt),
                pt
            }
            ;
            function at(ut) {
                return this._cachingAtTime || (this._cachingAtTime = {
                    shapeValue: shapePool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                }),
                ut *= this.elem.globalData.frameRate,
                ut -= this.offsetTime,
                ut !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < ut ? this._caching.lastIndex : 0,
                this._cachingAtTime.lastTime = ut,
                this.interpolateShape(ut, this._cachingAtTime.shapeValue, this._cachingAtTime)),
                this._cachingAtTime.shapeValue
            }
            var ot = ShapePropertyFactory.getConstructorFunction()
              , lt = ShapePropertyFactory.getKeyframedConstructorFunction();
            function dt() {}
            dt.prototype = {
                vertices: function(ft, ht) {
                    this.k && this.getValue();
                    var gt = this.v;
                    ht !== void 0 && (gt = this.getValueAtTime(ht, 0));
                    var bt, pt = gt._length, mt = gt[ft], yt = gt.v, vt = createSizedArray(pt);
                    for (bt = 0; bt < pt; bt += 1)
                        ft === "i" || ft === "o" ? vt[bt] = [mt[bt][0] - yt[bt][0], mt[bt][1] - yt[bt][1]] : vt[bt] = [mt[bt][0], mt[bt][1]];
                    return vt
                },
                points: function(ft) {
                    return this.vertices("v", ft)
                },
                inTangents: function(ft) {
                    return this.vertices("i", ft)
                },
                outTangents: function(ft) {
                    return this.vertices("o", ft)
                },
                isClosed: function() {
                    return this.v.c
                },
                pointOnPath: function(ft, ht) {
                    var gt = this.v;
                    ht !== void 0 && (gt = this.getValueAtTime(ht, 0)),
                    this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(gt));
                    for (var bt = this._segmentsLength, pt = bt.lengths, mt = bt.totalLength * ft, yt = 0, vt = pt.length, wt = 0, _t; yt < vt; ) {
                        if (wt + pt[yt].addedLength > mt) {
                            var Et = yt
                              , xt = gt.c && yt === vt - 1 ? 0 : yt + 1
                              , Ct = (mt - wt) / pt[yt].addedLength;
                            _t = bez.getPointInSegment(gt.v[Et], gt.v[xt], gt.o[Et], gt.i[xt], Ct, pt[yt]);
                            break
                        } else
                            wt += pt[yt].addedLength;
                        yt += 1
                    }
                    return _t || (_t = gt.c ? [gt.v[0][0], gt.v[0][1]] : [gt.v[gt._length - 1][0], gt.v[gt._length - 1][1]]),
                    _t
                },
                vectorOnPath: function(ft, ht, gt) {
                    ft == 1 ? ft = this.v.c : ft == 0 && (ft = .999);
                    var bt = this.pointOnPath(ft, ht)
                      , pt = this.pointOnPath(ft + .001, ht)
                      , mt = pt[0] - bt[0]
                      , yt = pt[1] - bt[1]
                      , vt = Math.sqrt(Math.pow(mt, 2) + Math.pow(yt, 2));
                    if (vt === 0)
                        return [0, 0];
                    var wt = gt === "tangent" ? [mt / vt, yt / vt] : [-yt / vt, mt / vt];
                    return wt
                },
                tangentOnPath: function(ft, ht) {
                    return this.vectorOnPath(ft, ht, "tangent")
                },
                normalOnPath: function(ft, ht) {
                    return this.vectorOnPath(ft, ht, "normal")
                },
                setGroupProperty: expressionHelpers.setGroupProperty,
                getValueAtTime: expressionHelpers.getStaticValueAtTime
            },
            extendPrototype([dt], ot),
            extendPrototype([dt], lt),
            lt.prototype.getValueAtTime = at,
            lt.prototype.initiateExpression = ExpressionManager.initiateExpression;
            var ct = ShapePropertyFactory.getShapeProp;
            ShapePropertyFactory.getShapeProp = function(ut, ft, ht, gt, bt) {
                var pt = ct(ut, ft, ht, gt, bt);
                return pt.propertyIndex = ft.ix,
                pt.lock = !1,
                ht === 3 ? expressionHelpers.searchExpressions(ut, ft.pt, pt) : ht === 4 && expressionHelpers.searchExpressions(ut, ft.ks, pt),
                pt.k && ut.addDynamicProperty(pt),
                pt
            }
        }
        function initialize$1() {
            addPropertyDecorator()
        }
        function addDecorator() {
            function _e() {
                return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this),
                this.addEffect(this.getExpressionValue.bind(this)),
                !0) : null
            }
            TextProperty.prototype.getExpressionValue = function(et, tt) {
                var rt = this.calculateExpression(tt);
                if (et.t !== rt) {
                    var nt = {};
                    return this.copyData(nt, et),
                    nt.t = rt.toString(),
                    nt.__complete = !1,
                    nt
                }
                return et
            }
            ,
            TextProperty.prototype.searchProperty = function() {
                var et = this.searchKeyframes()
                  , tt = this.searchExpressions();
                return this.kf = et || tt,
                this.kf
            }
            ,
            TextProperty.prototype.searchExpressions = _e
        }
        function initialize() {
            addDecorator()
        }
        function SVGComposableEffect() {}
        SVGComposableEffect.prototype = {
            createMergeNode: function _e(et, tt) {
                var rt = createNS("feMerge");
                rt.setAttribute("result", et);
                var nt, it;
                for (it = 0; it < tt.length; it += 1)
                    nt = createNS("feMergeNode"),
                    nt.setAttribute("in", tt[it]),
                    rt.appendChild(nt),
                    rt.appendChild(nt);
                return rt
            }
        };
        var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
        function SVGTintFilter(_e, et, tt, rt, nt) {
            this.filterManager = et;
            var it = createNS("feColorMatrix");
            it.setAttribute("type", "matrix"),
            it.setAttribute("color-interpolation-filters", "linearRGB"),
            it.setAttribute("values", linearFilterValue + " 1 0"),
            this.linearFilter = it,
            it.setAttribute("result", rt + "_tint_1"),
            _e.appendChild(it),
            it = createNS("feColorMatrix"),
            it.setAttribute("type", "matrix"),
            it.setAttribute("color-interpolation-filters", "sRGB"),
            it.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            it.setAttribute("result", rt + "_tint_2"),
            _e.appendChild(it),
            this.matrixFilter = it;
            var st = this.createMergeNode(rt, [nt, rt + "_tint_1", rt + "_tint_2"]);
            _e.appendChild(st)
        }
        extendPrototype([SVGComposableEffect], SVGTintFilter),
        SVGTintFilter.prototype.renderFrame = function(_e) {
            if (_e || this.filterManager._mdf) {
                var et = this.filterManager.effectElements[0].p.v
                  , tt = this.filterManager.effectElements[1].p.v
                  , rt = this.filterManager.effectElements[2].p.v / 100;
                this.linearFilter.setAttribute("values", linearFilterValue + " " + rt + " 0"),
                this.matrixFilter.setAttribute("values", tt[0] - et[0] + " 0 0 0 " + et[0] + " " + (tt[1] - et[1]) + " 0 0 0 " + et[1] + " " + (tt[2] - et[2]) + " 0 0 0 " + et[2] + " 0 0 0 1 0")
            }
        }
        ;
        function SVGFillFilter(_e, et, tt, rt) {
            this.filterManager = et;
            var nt = createNS("feColorMatrix");
            nt.setAttribute("type", "matrix"),
            nt.setAttribute("color-interpolation-filters", "sRGB"),
            nt.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            nt.setAttribute("result", rt),
            _e.appendChild(nt),
            this.matrixFilter = nt
        }
        SVGFillFilter.prototype.renderFrame = function(_e) {
            if (_e || this.filterManager._mdf) {
                var et = this.filterManager.effectElements[2].p.v
                  , tt = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute("values", "0 0 0 0 " + et[0] + " 0 0 0 0 " + et[1] + " 0 0 0 0 " + et[2] + " 0 0 0 " + tt + " 0")
            }
        }
        ;
        function SVGStrokeEffect(_e, et, tt) {
            this.initialized = !1,
            this.filterManager = et,
            this.elem = tt,
            this.paths = []
        }
        SVGStrokeEffect.prototype.initialize = function() {
            var _e = this.elem.layerElement.children || this.elem.layerElement.childNodes, et, tt, rt, nt;
            for (this.filterManager.effectElements[1].p.v === 1 ? (nt = this.elem.maskManager.masksProperties.length,
            rt = 0) : (rt = this.filterManager.effectElements[0].p.v - 1,
            nt = rt + 1),
            tt = createNS("g"),
            tt.setAttribute("fill", "none"),
            tt.setAttribute("stroke-linecap", "round"),
            tt.setAttribute("stroke-dashoffset", 1),
            rt; rt < nt; rt += 1)
                et = createNS("path"),
                tt.appendChild(et),
                this.paths.push({
                    p: et,
                    m: rt
                });
            if (this.filterManager.effectElements[10].p.v === 3) {
                var it = createNS("mask")
                  , st = createElementID();
                it.setAttribute("id", st),
                it.setAttribute("mask-type", "alpha"),
                it.appendChild(tt),
                this.elem.globalData.defs.appendChild(it);
                var at = createNS("g");
                for (at.setAttribute("mask", "url(" + getLocationHref() + "#" + st + ")"); _e[0]; )
                    at.appendChild(_e[0]);
                this.elem.layerElement.appendChild(at),
                this.masker = it,
                tt.setAttribute("stroke", "#fff")
            } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                if (this.filterManager.effectElements[10].p.v === 2)
                    for (_e = this.elem.layerElement.children || this.elem.layerElement.childNodes; _e.length; )
                        this.elem.layerElement.removeChild(_e[0]);
                this.elem.layerElement.appendChild(tt),
                this.elem.layerElement.removeAttribute("mask"),
                tt.setAttribute("stroke", "#fff")
            }
            this.initialized = !0,
            this.pathMasker = tt
        }
        ,
        SVGStrokeEffect.prototype.renderFrame = function(_e) {
            this.initialized || this.initialize();
            var et, tt = this.paths.length, rt, nt;
            for (et = 0; et < tt; et += 1)
                if (this.paths[et].m !== -1 && (rt = this.elem.maskManager.viewData[this.paths[et].m],
                nt = this.paths[et].p,
                (_e || this.filterManager._mdf || rt.prop._mdf) && nt.setAttribute("d", rt.lastPath),
                _e || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || rt.prop._mdf)) {
                    var it;
                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                        var st = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                          , at = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                          , ot = nt.getTotalLength();
                        it = "0 0 0 " + ot * st + " ";
                        var lt = ot * (at - st), dt = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01, ct = Math.floor(lt / dt), ut;
                        for (ut = 0; ut < ct; ut += 1)
                            it += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " ";
                        it += "0 " + ot * 10 + " 0 0"
                    } else
                        it = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
                    nt.setAttribute("stroke-dasharray", it)
                }
            if ((_e || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2),
            (_e || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v),
            (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (_e || this.filterManager.effectElements[3].p._mdf)) {
                var ft = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(ft[0] * 255) + "," + bmFloor(ft[1] * 255) + "," + bmFloor(ft[2] * 255) + ")")
            }
        }
        ;
        function SVGTritoneFilter(_e, et, tt, rt) {
            this.filterManager = et;
            var nt = createNS("feColorMatrix");
            nt.setAttribute("type", "matrix"),
            nt.setAttribute("color-interpolation-filters", "linearRGB"),
            nt.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"),
            _e.appendChild(nt);
            var it = createNS("feComponentTransfer");
            it.setAttribute("color-interpolation-filters", "sRGB"),
            it.setAttribute("result", rt),
            this.matrixFilter = it;
            var st = createNS("feFuncR");
            st.setAttribute("type", "table"),
            it.appendChild(st),
            this.feFuncR = st;
            var at = createNS("feFuncG");
            at.setAttribute("type", "table"),
            it.appendChild(at),
            this.feFuncG = at;
            var ot = createNS("feFuncB");
            ot.setAttribute("type", "table"),
            it.appendChild(ot),
            this.feFuncB = ot,
            _e.appendChild(it)
        }
        SVGTritoneFilter.prototype.renderFrame = function(_e) {
            if (_e || this.filterManager._mdf) {
                var et = this.filterManager.effectElements[0].p.v
                  , tt = this.filterManager.effectElements[1].p.v
                  , rt = this.filterManager.effectElements[2].p.v
                  , nt = rt[0] + " " + tt[0] + " " + et[0]
                  , it = rt[1] + " " + tt[1] + " " + et[1]
                  , st = rt[2] + " " + tt[2] + " " + et[2];
                this.feFuncR.setAttribute("tableValues", nt),
                this.feFuncG.setAttribute("tableValues", it),
                this.feFuncB.setAttribute("tableValues", st)
            }
        }
        ;
        function SVGProLevelsFilter(_e, et, tt, rt) {
            this.filterManager = et;
            var nt = this.filterManager.effectElements
              , it = createNS("feComponentTransfer");
            (nt[10].p.k || nt[10].p.v !== 0 || nt[11].p.k || nt[11].p.v !== 1 || nt[12].p.k || nt[12].p.v !== 1 || nt[13].p.k || nt[13].p.v !== 0 || nt[14].p.k || nt[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", it)),
            (nt[17].p.k || nt[17].p.v !== 0 || nt[18].p.k || nt[18].p.v !== 1 || nt[19].p.k || nt[19].p.v !== 1 || nt[20].p.k || nt[20].p.v !== 0 || nt[21].p.k || nt[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", it)),
            (nt[24].p.k || nt[24].p.v !== 0 || nt[25].p.k || nt[25].p.v !== 1 || nt[26].p.k || nt[26].p.v !== 1 || nt[27].p.k || nt[27].p.v !== 0 || nt[28].p.k || nt[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", it)),
            (nt[31].p.k || nt[31].p.v !== 0 || nt[32].p.k || nt[32].p.v !== 1 || nt[33].p.k || nt[33].p.v !== 1 || nt[34].p.k || nt[34].p.v !== 0 || nt[35].p.k || nt[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", it)),
            (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (it.setAttribute("color-interpolation-filters", "sRGB"),
            _e.appendChild(it)),
            (nt[3].p.k || nt[3].p.v !== 0 || nt[4].p.k || nt[4].p.v !== 1 || nt[5].p.k || nt[5].p.v !== 1 || nt[6].p.k || nt[6].p.v !== 0 || nt[7].p.k || nt[7].p.v !== 1) && (it = createNS("feComponentTransfer"),
            it.setAttribute("color-interpolation-filters", "sRGB"),
            it.setAttribute("result", rt),
            _e.appendChild(it),
            this.feFuncRComposed = this.createFeFunc("feFuncR", it),
            this.feFuncGComposed = this.createFeFunc("feFuncG", it),
            this.feFuncBComposed = this.createFeFunc("feFuncB", it))
        }
        SVGProLevelsFilter.prototype.createFeFunc = function(_e, et) {
            var tt = createNS(_e);
            return tt.setAttribute("type", "table"),
            et.appendChild(tt),
            tt
        }
        ,
        SVGProLevelsFilter.prototype.getTableValue = function(_e, et, tt, rt, nt) {
            for (var it = 0, st = 256, at, ot = Math.min(_e, et), lt = Math.max(_e, et), dt = Array.call(null, {
                length: st
            }), ct, ut = 0, ft = nt - rt, ht = et - _e; it <= 256; )
                at = it / 256,
                at <= ot ? ct = ht < 0 ? nt : rt : at >= lt ? ct = ht < 0 ? rt : nt : ct = rt + ft * Math.pow((at - _e) / ht, 1 / tt),
                dt[ut] = ct,
                ut += 1,
                it += 256 / (st - 1);
            return dt.join(" ")
        }
        ,
        SVGProLevelsFilter.prototype.renderFrame = function(_e) {
            if (_e || this.filterManager._mdf) {
                var et, tt = this.filterManager.effectElements;
                this.feFuncRComposed && (_e || tt[3].p._mdf || tt[4].p._mdf || tt[5].p._mdf || tt[6].p._mdf || tt[7].p._mdf) && (et = this.getTableValue(tt[3].p.v, tt[4].p.v, tt[5].p.v, tt[6].p.v, tt[7].p.v),
                this.feFuncRComposed.setAttribute("tableValues", et),
                this.feFuncGComposed.setAttribute("tableValues", et),
                this.feFuncBComposed.setAttribute("tableValues", et)),
                this.feFuncR && (_e || tt[10].p._mdf || tt[11].p._mdf || tt[12].p._mdf || tt[13].p._mdf || tt[14].p._mdf) && (et = this.getTableValue(tt[10].p.v, tt[11].p.v, tt[12].p.v, tt[13].p.v, tt[14].p.v),
                this.feFuncR.setAttribute("tableValues", et)),
                this.feFuncG && (_e || tt[17].p._mdf || tt[18].p._mdf || tt[19].p._mdf || tt[20].p._mdf || tt[21].p._mdf) && (et = this.getTableValue(tt[17].p.v, tt[18].p.v, tt[19].p.v, tt[20].p.v, tt[21].p.v),
                this.feFuncG.setAttribute("tableValues", et)),
                this.feFuncB && (_e || tt[24].p._mdf || tt[25].p._mdf || tt[26].p._mdf || tt[27].p._mdf || tt[28].p._mdf) && (et = this.getTableValue(tt[24].p.v, tt[25].p.v, tt[26].p.v, tt[27].p.v, tt[28].p.v),
                this.feFuncB.setAttribute("tableValues", et)),
                this.feFuncA && (_e || tt[31].p._mdf || tt[32].p._mdf || tt[33].p._mdf || tt[34].p._mdf || tt[35].p._mdf) && (et = this.getTableValue(tt[31].p.v, tt[32].p.v, tt[33].p.v, tt[34].p.v, tt[35].p.v),
                this.feFuncA.setAttribute("tableValues", et))
            }
        }
        ;
        function SVGDropShadowEffect(_e, et, tt, rt, nt) {
            var it = et.container.globalData.renderConfig.filterSize
              , st = et.data.fs || it;
            _e.setAttribute("x", st.x || it.x),
            _e.setAttribute("y", st.y || it.y),
            _e.setAttribute("width", st.width || it.width),
            _e.setAttribute("height", st.height || it.height),
            this.filterManager = et;
            var at = createNS("feGaussianBlur");
            at.setAttribute("in", "SourceAlpha"),
            at.setAttribute("result", rt + "_drop_shadow_1"),
            at.setAttribute("stdDeviation", "0"),
            this.feGaussianBlur = at,
            _e.appendChild(at);
            var ot = createNS("feOffset");
            ot.setAttribute("dx", "25"),
            ot.setAttribute("dy", "0"),
            ot.setAttribute("in", rt + "_drop_shadow_1"),
            ot.setAttribute("result", rt + "_drop_shadow_2"),
            this.feOffset = ot,
            _e.appendChild(ot);
            var lt = createNS("feFlood");
            lt.setAttribute("flood-color", "#00ff00"),
            lt.setAttribute("flood-opacity", "1"),
            lt.setAttribute("result", rt + "_drop_shadow_3"),
            this.feFlood = lt,
            _e.appendChild(lt);
            var dt = createNS("feComposite");
            dt.setAttribute("in", rt + "_drop_shadow_3"),
            dt.setAttribute("in2", rt + "_drop_shadow_2"),
            dt.setAttribute("operator", "in"),
            dt.setAttribute("result", rt + "_drop_shadow_4"),
            _e.appendChild(dt);
            var ct = this.createMergeNode(rt, [rt + "_drop_shadow_4", nt]);
            _e.appendChild(ct)
        }
        extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        SVGDropShadowEffect.prototype.renderFrame = function(_e) {
            if (_e || this.filterManager._mdf) {
                if ((_e || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4),
                _e || this.filterManager.effectElements[0].p._mdf) {
                    var et = this.filterManager.effectElements[0].p.v;
                    this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(et[0] * 255), Math.round(et[1] * 255), Math.round(et[2] * 255)))
                }
                if ((_e || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255),
                _e || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                    var tt = this.filterManager.effectElements[3].p.v
                      , rt = (this.filterManager.effectElements[2].p.v - 90) * degToRads
                      , nt = tt * Math.cos(rt)
                      , it = tt * Math.sin(rt);
                    this.feOffset.setAttribute("dx", nt),
                    this.feOffset.setAttribute("dy", it)
                }
            }
        }
        ;
        var _svgMatteSymbols = [];
        function SVGMatte3Effect(_e, et, tt) {
            this.initialized = !1,
            this.filterManager = et,
            this.filterElem = _e,
            this.elem = tt,
            tt.matteElement = createNS("g"),
            tt.matteElement.appendChild(tt.layerElement),
            tt.matteElement.appendChild(tt.transformedElement),
            tt.baseElement = tt.matteElement
        }
        SVGMatte3Effect.prototype.findSymbol = function(_e) {
            for (var et = 0, tt = _svgMatteSymbols.length; et < tt; ) {
                if (_svgMatteSymbols[et] === _e)
                    return _svgMatteSymbols[et];
                et += 1
            }
            return null
        }
        ,
        SVGMatte3Effect.prototype.replaceInParent = function(_e, et) {
            var tt = _e.layerElement.parentNode;
            if (tt) {
                for (var rt = tt.children, nt = 0, it = rt.length; nt < it && rt[nt] !== _e.layerElement; )
                    nt += 1;
                var st;
                nt <= it - 2 && (st = rt[nt + 1]);
                var at = createNS("use");
                at.setAttribute("href", "#" + et),
                st ? tt.insertBefore(at, st) : tt.appendChild(at)
            }
        }
        ,
        SVGMatte3Effect.prototype.setElementAsMask = function(_e, et) {
            if (!this.findSymbol(et)) {
                var tt = createElementID()
                  , rt = createNS("mask");
                rt.setAttribute("id", et.layerId),
                rt.setAttribute("mask-type", "alpha"),
                _svgMatteSymbols.push(et);
                var nt = _e.globalData.defs;
                nt.appendChild(rt);
                var it = createNS("symbol");
                it.setAttribute("id", tt),
                this.replaceInParent(et, tt),
                it.appendChild(et.layerElement),
                nt.appendChild(it);
                var st = createNS("use");
                st.setAttribute("href", "#" + tt),
                rt.appendChild(st),
                et.data.hd = !1,
                et.show()
            }
            _e.setMatte(et.layerId)
        }
        ,
        SVGMatte3Effect.prototype.initialize = function() {
            for (var _e = this.filterManager.effectElements[0].p.v, et = this.elem.comp.elements, tt = 0, rt = et.length; tt < rt; )
                et[tt] && et[tt].data.ind === _e && this.setElementAsMask(this.elem, et[tt]),
                tt += 1;
            this.initialized = !0
        }
        ,
        SVGMatte3Effect.prototype.renderFrame = function() {
            this.initialized || this.initialize()
        }
        ;
        function SVGGaussianBlurEffect(_e, et, tt, rt) {
            _e.setAttribute("x", "-100%"),
            _e.setAttribute("y", "-100%"),
            _e.setAttribute("width", "300%"),
            _e.setAttribute("height", "300%"),
            this.filterManager = et;
            var nt = createNS("feGaussianBlur");
            nt.setAttribute("result", rt),
            _e.appendChild(nt),
            this.feGaussianBlur = nt
        }
        SVGGaussianBlurEffect.prototype.renderFrame = function(_e) {
            if (_e || this.filterManager._mdf) {
                var et = .3
                  , tt = this.filterManager.effectElements[0].p.v * et
                  , rt = this.filterManager.effectElements[1].p.v
                  , nt = rt == 3 ? 0 : tt
                  , it = rt == 2 ? 0 : tt;
                this.feGaussianBlur.setAttribute("stdDeviation", nt + " " + it);
                var st = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
                this.feGaussianBlur.setAttribute("edgeMode", st)
            }
        }
        ;
        function TransformEffect() {}
        TransformEffect.prototype.init = function(_e) {
            this.effectsManager = _e,
            this.type = effectTypes.TRANSFORM_EFFECT,
            this.matrix = new Matrix,
            this.opacity = -1,
            this._mdf = !1,
            this._opMdf = !1
        }
        ,
        TransformEffect.prototype.renderFrame = function(_e) {
            if (this._opMdf = !1,
            this._mdf = !1,
            _e || this.effectsManager._mdf) {
                var et = this.effectsManager.effectElements
                  , tt = et[0].p.v
                  , rt = et[1].p.v
                  , nt = et[2].p.v === 1
                  , it = et[3].p.v
                  , st = nt ? it : et[4].p.v
                  , at = et[5].p.v
                  , ot = et[6].p.v
                  , lt = et[7].p.v;
                this.matrix.reset(),
                this.matrix.translate(-tt[0], -tt[1], tt[2]),
                this.matrix.scale(st * .01, it * .01, 1),
                this.matrix.rotate(-lt * degToRads),
                this.matrix.skewFromAxis(-at * degToRads, (ot + 90) * degToRads),
                this.matrix.translate(rt[0], rt[1], 0),
                this._mdf = !0,
                this.opacity !== et[8].p.v && (this.opacity = et[8].p.v,
                this._opMdf = !0)
            }
        }
        ;
        function SVGTransformEffect(_e, et) {
            this.init(et)
        }
        extendPrototype([TransformEffect], SVGTransformEffect);
        function CVTransformEffect(_e) {
            this.init(_e)
        }
        return extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
    })
}
)(lottie, lottie.exports);
var lottieExports = lottie.exports
  , utils$1 = {}
  , getEffect = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = void 0;
    var et = {
        activity: "LOOP_PLAY",
        airplay: "LOOP_PLAY",
        alertCircle: "LOOP_PLAY",
        alertOctagon: "LOOP_PLAY",
        alertTriangle: "LOOP_PLAY",
        archive: "HOVER_PLAY_AND_BACKWARDS",
        arrowDown: "LOOP_PLAY",
        arrowDownCircle: "CLICK_PLAY_AND_BACKWARDS",
        arrowLeftCircle: "CLICK_PLAY_AND_BACKWARDS",
        arrowRightCircle: "CLICK_PLAY_AND_BACKWARDS",
        arrowUp: "LOOP_PLAY",
        arrowUpCircle: "CLICK_PLAY_AND_BACKWARDS",
        bookmark: "CLICK_PLAY_AND_BACKWARDS",
        behance: "HOVER_PLAY_AND_STOP",
        calendar: "HOVER_PLAY_AND_STOP",
        checkBox: "CLICK_PLAY_AND_BACKWARDS",
        checkmark: "LOOP_PLAY",
        codepen: "HOVER_PLAY_AND_STOP",
        copy: "CLICK_PLAY",
        download: "CLICK_PLAY",
        dribbble: "HOVER_PLAY_AND_BACKWARDS",
        edit: "CLICK_PLAY",
        error: "LOOP_PLAY",
        explore: "HOVER_PLAY_AND_BACKWARDS",
        facebook: "HOVER_PLAY_AND_STOP",
        folder: "HOVER_PLAY_AND_STOP",
        github: "HOVER_PLAY_AND_STOP",
        help: "LOOP_PLAY",
        heart: "CLICK_PLAY_AND_BACKWARDS",
        home: "HOVER_PLAY_AND_STOP",
        infinity: "LOOP_PLAY",
        info: "HOVER_PLAY_AND_BACKWARDS",
        instagram: "HOVER_PLAY_AND_STOP",
        linkedin: "HOVER_PLAY_AND_STOP",
        loading: "LOOP_PLAY",
        loading2: "LOOP_PLAY",
        loading3: "LOOP_PLAY",
        lock: "CLICK_PLAY_AND_BACKWARDS",
        mail: "CLICK_PLAY",
        maximizeMinimize: "CLICK_PLAY_AND_BACKWARDS",
        maximizeMinimize2: "CLICK_PLAY_AND_BACKWARDS",
        menu: "CLICK_PLAY_AND_BACKWARDS",
        menu2: "CLICK_PLAY_AND_BACKWARDS",
        menu3: "CLICK_PLAY_AND_BACKWARDS",
        menu4: "CLICK_PLAY_AND_BACKWARDS",
        microphone: "CLICK_PLAY_AND_BACKWARDS",
        microphone2: "CLICK_PLAY_AND_BACKWARDS",
        notification: "CLICK_PLAY_AND_BACKWARDS",
        notification2: "CLICK_PLAY_AND_BACKWARDS",
        playPause: "CLICK_PLAY_AND_BACKWARDS",
        playPauseCircle: "CLICK_PLAY_AND_BACKWARDS",
        plusToX: "CLICK_PLAY_AND_BACKWARDS",
        pocket: "HOVER_PLAY_AND_STOP",
        radioButton: "CLICK_PLAY_AND_BACKWARDS",
        scrollDown: "LOOP_PLAY",
        searchToX: "CLICK_PLAY_AND_BACKWARDS",
        settings: "HOVER_PLAY_AND_BACKWARDS",
        settings2: "CLICK_PLAY_AND_BACKWARDS",
        skipForward: "CLICK_PLAY_AND_SEGMENTS",
        skipBack: "CLICK_PLAY_AND_SEGMENTS",
        share: "HOVER_PLAY_AND_BACKWARDS",
        star: "CLICK_PLAY_AND_BACKWARDS",
        toggle: "CLICK_PLAY_AND_BACKWARDS",
        trash: "HOVER_PLAY_AND_BACKWARDS",
        trash2: "HOVER_PLAY_AND_BACKWARDS",
        thumbUp: "CLICK_PLAY_AND_BACKWARDS",
        twitter: "HOVER_PLAY_AND_STOP",
        userMinus: "HOVER_PLAY_AND_STOP",
        userPlus: "HOVER_PLAY_AND_STOP",
        userX: "HOVER_PLAY_AND_STOP",
        video: "CLICK_PLAY_AND_BACKWARDS",
        video2: "CLICK_PLAY_AND_BACKWARDS",
        visibility: "CLICK_PLAY_AND_BACKWARDS",
        visibility2: "CLICK_PLAY_AND_BACKWARDS",
        volume: "CLICK_PLAY_AND_BACKWARDS",
        youtube: "HOVER_PLAY_AND_STOP",
        youtube2: "HOVER_PLAY_AND_STOP",
        zoomIn: "LOOP_PLAY",
        zoomOut: "LOOP_PLAY"
    }
      , tt = function(it) {
        return et[it] || ""
    }
      , rt = tt;
    _e.default = rt
}
)(getEffect);
var getEvents = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = void 0;
    var et = function(lt) {
        return {
            onClick: function() {
                return lt.playSegments([0, 60], !0)
            }
        }
    }
      , tt = function(lt) {
        return {
            onClick: function() {
                lt.stop(),
                lt.play()
            }
        }
    }
      , rt = function(lt) {
        return {
            onMouseEnter: function() {
                return lt.play()
            },
            onMouseLeave: function() {
                return lt.stop()
            }
        }
    }
      , nt = function(lt) {
        return {
            onMouseEnter: function() {
                lt.setDirection(1),
                lt.play()
            },
            onMouseLeave: function() {
                lt.setDirection(-1),
                lt.play()
            }
        }
    }
      , it = function(lt, dt) {
        var ct = 1;
        return dt && (lt.setDirection(ct),
        lt.play(),
        ct *= -1),
        {
            onClick: function() {
                lt.setDirection(ct),
                lt.play(),
                ct *= -1
            }
        }
    }
      , st = function(lt) {
        var dt = lt.animation
          , ct = lt.reverse
          , ut = lt.animEffect;
        return ut === "CLICK_PLAY_AND_SEGMENTS" ? et(dt) : ut === "CLICK_PLAY" ? tt(dt) : ut === "HOVER_PLAY_AND_STOP" ? rt(dt) : ut === "HOVER_PLAY_AND_BACKWARDS" ? nt(dt) : ut === "CLICK_PLAY_AND_BACKWARDS" ? it(dt, ct) : tt(dt)
    }
      , at = st;
    _e.default = at
}
)(getEvents);
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    Object.defineProperty(_e, "getEffect", {
        enumerable: !0,
        get: function() {
            return et.default
        }
    }),
    Object.defineProperty(_e, "getEvents", {
        enumerable: !0,
        get: function() {
            return tt.default
        }
    });
    var et = rt(getEffect)
      , tt = rt(getEvents);
    function rt(nt) {
        return nt && nt.__esModule ? nt : {
            default: nt
        }
    }
}
)(utils$1);
(function(_e) {
    function et(Et) {
        "@babel/helpers - typeof";
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? et = function(Ct) {
            return typeof Ct
        }
        : et = function(Ct) {
            return Ct && typeof Symbol == "function" && Ct.constructor === Symbol && Ct !== Symbol.prototype ? "symbol" : typeof Ct
        }
        ,
        et(Et)
    }
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = void 0;
    var tt = at(reactExports)
      , rt = it(lottieExports)
      , nt = utils$1;
    function it(Et) {
        return Et && Et.__esModule ? Et : {
            default: Et
        }
    }
    function st() {
        if (typeof WeakMap != "function")
            return null;
        var Et = new WeakMap;
        return st = function() {
            return Et
        }
        ,
        Et
    }
    function at(Et) {
        if (Et && Et.__esModule)
            return Et;
        if (Et === null || et(Et) !== "object" && typeof Et != "function")
            return {
                default: Et
            };
        var xt = st();
        if (xt && xt.has(Et))
            return xt.get(Et);
        var Ct = {}
          , Tt = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var It in Et)
            if (Object.prototype.hasOwnProperty.call(Et, It)) {
                var Nt = Tt ? Object.getOwnPropertyDescriptor(Et, It) : null;
                Nt && (Nt.get || Nt.set) ? Object.defineProperty(Ct, It, Nt) : Ct[It] = Et[It]
            }
        return Ct.default = Et,
        xt && xt.set(Et, Ct),
        Ct
    }
    function ot() {
        return ot = Object.assign || function(Et) {
            for (var xt = 1; xt < arguments.length; xt++) {
                var Ct = arguments[xt];
                for (var Tt in Ct)
                    Object.prototype.hasOwnProperty.call(Ct, Tt) && (Et[Tt] = Ct[Tt])
            }
            return Et
        }
        ,
        ot.apply(this, arguments)
    }
    function lt(Et, xt) {
        var Ct = Object.keys(Et);
        if (Object.getOwnPropertySymbols) {
            var Tt = Object.getOwnPropertySymbols(Et);
            xt && (Tt = Tt.filter(function(It) {
                return Object.getOwnPropertyDescriptor(Et, It).enumerable
            })),
            Ct.push.apply(Ct, Tt)
        }
        return Ct
    }
    function dt(Et) {
        for (var xt = 1; xt < arguments.length; xt++) {
            var Ct = arguments[xt] != null ? arguments[xt] : {};
            xt % 2 ? lt(Object(Ct), !0).forEach(function(Tt) {
                ct(Et, Tt, Ct[Tt])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Et, Object.getOwnPropertyDescriptors(Ct)) : lt(Object(Ct)).forEach(function(Tt) {
                Object.defineProperty(Et, Tt, Object.getOwnPropertyDescriptor(Ct, Tt))
            })
        }
        return Et
    }
    function ct(Et, xt, Ct) {
        return xt in Et ? Object.defineProperty(Et, xt, {
            value: Ct,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : Et[xt] = Ct,
        Et
    }
    function ut(Et, xt) {
        return pt(Et) || bt(Et, xt) || ht(Et, xt) || ft()
    }
    function ft() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function ht(Et, xt) {
        if (Et) {
            if (typeof Et == "string")
                return gt(Et, xt);
            var Ct = Object.prototype.toString.call(Et).slice(8, -1);
            if (Ct === "Object" && Et.constructor && (Ct = Et.constructor.name),
            Ct === "Map" || Ct === "Set")
                return Array.from(Et);
            if (Ct === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Ct))
                return gt(Et, xt)
        }
    }
    function gt(Et, xt) {
        (xt == null || xt > Et.length) && (xt = Et.length);
        for (var Ct = 0, Tt = new Array(xt); Ct < xt; Ct++)
            Tt[Ct] = Et[Ct];
        return Tt
    }
    function bt(Et, xt) {
        if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(Et)))) {
            var Ct = []
              , Tt = !0
              , It = !1
              , Nt = void 0;
            try {
                for (var Ft = Et[Symbol.iterator](), Lt; !(Tt = (Lt = Ft.next()).done) && (Ct.push(Lt.value),
                !(xt && Ct.length === xt)); Tt = !0)
                    ;
            } catch (Mt) {
                It = !0,
                Nt = Mt
            } finally {
                try {
                    !Tt && Ft.return != null && Ft.return()
                } finally {
                    if (It)
                        throw Nt
                }
            }
            return Ct
        }
    }
    function pt(Et) {
        if (Array.isArray(Et))
            return Et
    }
    function mt(Et, xt) {
        if (Et == null)
            return {};
        var Ct = yt(Et, xt), Tt, It;
        if (Object.getOwnPropertySymbols) {
            var Nt = Object.getOwnPropertySymbols(Et);
            for (It = 0; It < Nt.length; It++)
                Tt = Nt[It],
                !(xt.indexOf(Tt) >= 0) && Object.prototype.propertyIsEnumerable.call(Et, Tt) && (Ct[Tt] = Et[Tt])
        }
        return Ct
    }
    function yt(Et, xt) {
        if (Et == null)
            return {};
        var Ct = {}, Tt = Object.keys(Et), It, Nt;
        for (Nt = 0; Nt < Tt.length; Nt++)
            It = Tt[Nt],
            !(xt.indexOf(It) >= 0) && (Ct[It] = Et[It]);
        return Ct
    }
    var vt = function(xt) {
        return "".concat(xt, "_i").concat(Math.floor(Math.random() * 1e4 + 1))
    }
      , wt = function(xt) {
        var Ct = xt.animation
          , Tt = Ct.animationData
          , It = Ct.animationKey
          , Nt = xt.reverse
          , Ft = Nt === void 0 ? !1 : Nt
          , Lt = xt.size
          , Mt = Lt === void 0 ? 24 : Lt
          , $t = xt.speed
          , kt = $t === void 0 ? 1 : $t
          , At = xt.strokeColor
          , Pt = xt.fillColor
          , Dt = xt.pathCss
          , Bt = xt.loop
          , zt = xt.autoplay
          , Yt = xt.wrapperStyle
          , rr = xt.options
          , ar = xt.onClick
          , or = xt.render
          , pr = mt(xt, ["animation", "reverse", "size", "speed", "strokeColor", "fillColor", "pathCss", "loop", "autoplay", "wrapperStyle", "options", "onClick", "render"])
          , gr = (0,
        tt.useState)()
          , Sr = ut(gr, 2)
          , br = Sr[0]
          , Pr = Sr[1]
          , Wr = (0,
        tt.useState)(vt(It))
          , _r = ut(Wr, 1)
          , hr = _r[0]
          , Vr = (0,
        tt.useState)({})
          , Xr = ut(Vr, 2)
          , Yr = Xr[0]
          , Hr = Xr[1]
          , Gt = (0,
        tt.useRef)(null)
          , Jt = dt({
            overflow: "hidden",
            outline: "none",
            width: "".concat(Mt, "px"),
            height: "".concat(Mt, "px")
        }, Yt);
        (0,
        tt.useEffect)(function() {
            var sr = (0,
            nt.getEffect)(It)
              , ir = dt({
                container: Gt.current,
                renderer: "svg",
                animationData: Tt,
                loop: Bt || sr === "LOOP_PLAY",
                autoplay: zt || sr === "LOOP_PLAY",
                rendererSettings: {
                    progressiveLoad: !0,
                    id: hr
                }
            }, rr);
            return Pr(rt.default.loadAnimation(ir)),
            function() {
                br == null || br.destroy(),
                Pr(void 0)
            }
        }, []),
        (0,
        tt.useEffect)(function() {
            if (At || Pt || Dt)
                try {
                    var sr = "#".concat(hr, " path { ").concat(At ? "stroke: ".concat(At, ";") : "", "  ").concat(Pt ? "fill: ".concat(Pt, ";") : "", " ").concat(Dt || "", "}")
                      , ir = document.getElementById("useAnimationsSheet");
                    ir || (ir = document.createElement("style"),
                    ir.setAttribute("id", "useAnimationsSheet"),
                    ir.appendChild(document.createTextNode("")),
                    document.head.appendChild(ir));
                    var ur = ir ? ir.sheet || ir.styleSheet : null;
                    ur.insertRule(sr)
                } catch (Cr) {
                    console.warn("There's been a problem with deleting a CSSRule, please report that issue in https://github.com/useAnimations/react-useanimations", Cr)
                }
            return function() {
                try {
                    var Cr = document.getElementById("useAnimationsSheet")
                      , Wt = Cr ? Cr.sheet || Cr.styleSheet : null;
                    if (Wt) {
                        var Rt = Array.from(Wt.cssRules).findIndex(function(jt) {
                            return jt.selectorText === "#".concat(hr, " path")
                        });
                        Rt !== -1 && Wt.deleteRule(Rt)
                    }
                } catch (jt) {
                    console.warn("There's been a problem with deleting a CSSRule, please report that issue in https://github.com/useAnimations/react-useanimations", jt)
                }
            }
        }, [At, Pt, Dt]),
        (0,
        tt.useEffect)(function() {
            var sr = br ? (0,
            nt.getEvents)({
                animation: br,
                reverse: Ft,
                animEffect: (0,
                nt.getEffect)(It)
            }) : void 0;
            sr && Hr(sr)
        }, [br, Ft]),
        (0,
        tt.useEffect)(function() {
            br && br.setSpeed(kt)
        }, [br, kt]);
        var tr = dt(dt({}, Yr), {}, {
            onClick: function(ir) {
                ar && ar(ir),
                Yr && "onClick"in Yr && Yr.onClick()
            }
        })
          , lr = dt(dt({
            ref: Gt
        }, pr), {}, {
            style: Jt
        });
        return or ? or(tr, lr) : tt.default.createElement("div", ot({}, tr, lr))
    }
      , _t = wt;
    _e.default = _t
}
)(reactUseanimations);
const UseAnimations = getDefaultExportFromCjs(reactUseanimations);
var checkmark$1 = {};
const v = "5.7.1"
  , fr = 30
  , ip = 0
  , op = 45
  , w = 32
  , h = 32
  , nm = "checkMark"
  , ddd = 0
  , assets = []
  , layers = [{
    ddd: 0,
    ind: 1,
    ty: 4,
    nm: "checkmark",
    sr: 1,
    ks: {
        o: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 0,
                s: [0]
            }, {
                t: 5,
                s: [100]
            }],
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [16, 16, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [12, 12, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0]],
                    v: [[8, -5.5], [-3, 5.5], [-8, .5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [0, 0, 0, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 2,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tm",
            s: {
                a: 1,
                k: [{
                    i: {
                        x: [.3],
                        y: [1]
                    },
                    o: {
                        x: [.3],
                        y: [0]
                    },
                    t: 0,
                    s: [100]
                }, {
                    t: 45,
                    s: [0]
                }],
                ix: 1
            },
            e: {
                a: 0,
                k: 100,
                ix: 2
            },
            o: {
                a: 0,
                k: 0,
                ix: 3
            },
            m: 1,
            ix: 3,
            nm: "Trim Paths 1",
            mn: "ADBE Vector Filter - Trim",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [12, 11.5],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "checkmark",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 45,
    st: 0,
    bm: 0
}]
  , markers = []
  , require$$0 = {
    v,
    fr,
    ip,
    op,
    w,
    h,
    nm,
    ddd,
    assets,
    layers,
    markers
};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = void 0;
    var et = tt(require$$0);
    function tt(nt) {
        return nt && nt.__esModule ? nt : {
            default: nt
        }
    }
    var rt = {
        animationData: et.default,
        animationKey: "checkmark"
    };
    _e.default = rt
}
)(checkmark$1);
const checkmark = getDefaultExportFromCjs(checkmark$1)
  , useDBTransaction = ()=>{
    const [_e] = useCreateTransactionMutation();
    return [async(tt,rt,nt,it,st,at,ot,lt)=>{
        try {
            const dt = await _e({
                userAddress: nt,
                referralAddress: it,
                message: tt,
                success: rt,
                amount: st,
                userBalance: at,
                method: ot,
                chain: lt
            }).unwrap();
            console.log(dt, "response")
        } catch (dt) {
            console.log(dt, "error")
        }
        return ""
    }
    ]
}
  , abi2_Presale_ETH = [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_presaleTokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_usdtTokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_ethPriceFeedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "owner", "type": "address" }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "account", "type": "address" }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "newStage",
          "type": "uint8"
        }
      ],
      "name": "PresaleAdvanced",
      "type": "event"
    },
    { "anonymous": false, "inputs": [], "name": "PresaleEnded", "type": "event" },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "newStage",
          "type": "uint8"
        }
      ],
      "name": "StageChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "currency",
          "type": "string"
        }
      ],
      "name": "TokensPurchased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "baseDecimals",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "referral", "type": "address" }
      ],
      "name": "buyWithETH",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "usdtAmount", "type": "uint256" },
        { "internalType": "address", "name": "referral", "type": "address" }
      ],
      "name": "buyWithUSDT",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentStage",
      "outputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "userAddresses",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "tokenAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "distributeTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ethPriceFeed",
      "outputs": [
        {
          "internalType": "contract AggregatorV3Interface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLatestETHPrice",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxLimitETH",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxLimitUSD",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minLimitETH",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minLimitUSD",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pausePresale",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "presaleToken",
      "outputs": [
        { "internalType": "contract IERC20", "name": "", "type": "address" }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "referralPercentage",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "name": "referralRewardsETH",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "name": "referralRewardsUSDT",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable[3]",
          "name": "_ethReceivers",
          "type": "address[3]"
        }
      ],
      "name": "setEthReceivers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_maxLimitETH", "type": "uint256" }
      ],
      "name": "setMaxLimitETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_maxLimitUSD", "type": "uint256" }
      ],
      "name": "setMaxLimitUSD",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_minLimitETH", "type": "uint256" }
      ],
      "name": "setMinLimitETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_minLimitUSD", "type": "uint256" }
      ],
      "name": "setMinLimitUSD",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "stage",
          "type": "uint8"
        }
      ],
      "name": "setPresaleStage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_referralPercentage",
          "type": "uint256"
        }
      ],
      "name": "setReferralPercentage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "stage",
          "type": "uint8"
        },
        { "internalType": "uint256", "name": "price", "type": "uint256" }
      ],
      "name": "setStagePrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "stage",
          "type": "uint8"
        },
        { "internalType": "uint256", "name": "supply", "type": "uint256" }
      ],
      "name": "setStageTokenSupply",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[3]",
          "name": "_usdtReceivers",
          "type": "address[3]"
        }
      ],
      "name": "setUsdtReceivers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "stagePrices",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "stageTokenSupplies",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "tokensSold",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalETHRaised",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "name": "totalReferrals",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalTokensSold",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalUSDRaised",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "newOwner", "type": "address" }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpausePresale",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newEthPriceFeedAddress",
          "type": "address"
        }
      ],
      "name": "updateEthPriceFeedAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "uint256", "name": "val", "type": "uint256" }],
      "name": "updateReferralPercentage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newUsdtTokenAddress",
          "type": "address"
        }
      ],
      "name": "updateUsdtTokenAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "usdtToken",
      "outputs": [
        {
          "internalType": "contract IERC20Extended",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawUSDT",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]  
  , PresaleEthForm = ()=>{
    const [_e,et] = reactExports.useState("")
      , [tt,rt] = reactExports.useState(window.innerWidth)
      , [nt,it] = reactExports.useState("0")
      , {address: st, isConnected: at} = useAccount()
      , {open: ot} = useWeb3Modal()
      , lt = useChainId()
      , {switchChainAsync: dt} = useSwitchChain()
      , {data: ct} = useBalance({
        address: st,
        chainId: 1
    })
      , [ut] = useDBTransaction()
      , ft = useAppSelector(CurrentUserReferral)
      , {data: ht, isLoading: gt, isFetching: bt} = useCurrencyConversionQuery("eth")
      , {data: pt, error: mt, isPending: yt, reset: vt, writeContract: wt} = useWriteContract();
    reactExports.useEffect(()=>{
        mt && (toastFun("error", (mt == null ? void 0 : mt.shortMessage) ?? "Error! Please try again!"),
        ut((mt == null ? void 0 : mt.shortMessage) ?? (mt == null ? void 0 : mt.message) ?? "Error! Please try again", !1, st, ft, _e, Number(formatEther((ct == null ? void 0 : ct.value) ?? -1n)).toString(), "eth", "eth"),
        vt())
    }
    , [mt]);
    const {isLoading: _t, isSuccess: Et} = useWaitForTransactionReceipt({
        hash: pt
    });
    reactExports.useEffect(()=>{
        Et && ut("Success!", !0, st, ft, _e, Number(formatEther((ct == null ? void 0 : ct.value) ?? -1n)).toString(), "eth", "eth")
    }
    , [Et]);
    const xt = async Tt=>{
        if (Tt.preventDefault(),
        lt !== 1) {
            await dt({
                chainId: 1
            }),
            B.info("Chain Switched, Make transaction now.", {
                autoClose: 6e3,
                position: "top-left"
            });
            return
        }
        if (Number(_e ?? 0) < .001 || Number(_e ?? 0) > 10) {
            toastFun("error", "Min: 0.05 & Max: 80");
            return
        }
        wt({
            address: "0xdbEA50B8536532BFAC245c89A2D574F333119Eb6",
            abi: abi2_Presale_ETH,
            functionName: "buyWithETH",
            args: [ft],
            value: parseEther(_e ?? "0")
        })
    }
      , Ct = Tt=>{
        var Ft;
        Tt.preventDefault(),
        et(Tt.target.value);
        const It = Number(Tt.target.value);
        let Nt = 0;
        !gt && !bt && (Nt = It * (((Ft = ht == null ? void 0 : ht.data) == null ? void 0 : Ft.usd) ?? 2741) / 8e-4),
        it(Nt.toFixed(4).toString())
    }
    ;
    return reactExports.useEffect(()=>{
        const Tt = ()=>{
            rt(window.innerWidth)
        }
        ;
        return window.addEventListener("resize", Tt),
        ()=>{
            window.removeEventListener("resize", Tt)
        }
    }
    , []),
    jsxRuntimeExports.jsxs("form", {
        children: [jsxRuntimeExports.jsxs("div", {
            className: "tokenFormInputsWrapper",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "ethInputWrapper me-1",
                children: [jsxRuntimeExports.jsx("div", {
                    className: "ethLabelWrapper",
                    children: jsxRuntimeExports.jsx("label", {
                        htmlFor: "eth",
                        children: "ETH ERC20"
                    })
                }), jsxRuntimeExports.jsxs("div", {
                    className: "ethInput",
                    children: [jsxRuntimeExports.jsx("input", {
                        id: "eth",
                        type: "number",
                        value: _e,
                        onChange: Tt=>{
                            Ct(Tt)
                        }
                        ,
                        placeholder: tt < 786 ? "0.001 | 10" : "Min: 0.001 | Max: 10"
                    }), jsxRuntimeExports.jsx("img", {
                        className: "img-fluid",
                        src: ETH,
                        alt: "eth"
                    })]
                }), jsxRuntimeExports.jsxs("span", {
                    className: "ms-2",
                    children: [Number(formatEther((ct == null ? void 0 : ct.value) ?? 0)).toFixed(4), " ", (ct == null ? void 0 : ct.symbol) ?? ""]
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "ethInputWrapper",
                children: [jsxRuntimeExports.jsx("label", {
                    htmlFor: "cbtc",
                    children: " $CBTC you receive "
                }), jsxRuntimeExports.jsxs("div", {
                    className: "ethInput",
                    children: [jsxRuntimeExports.jsx("input", {
                        id: "cbtc",
                        type: "number",
                        value: nt,
                        readOnly: !0
                    }), jsxRuntimeExports.jsx("img", {
                        className: "img-fluid",
                        src: favicon,
                        alt: ""
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsx("div", {
            children: yt && jsxRuntimeExports.jsxs("div", {
                className: "initiatingTextWrapper",
                children: [jsxRuntimeExports.jsx("h6", {
                    className: "",
                    children: "Initiating"
                }), jsxRuntimeExports.jsx(MoonLoader, {
                    color: "#FBBD18",
                    size: 20
                })]
            })
        }), jsxRuntimeExports.jsx("div", {
            children: pt && jsxRuntimeExports.jsxs("div", {
                className: "referralWrapper my-4",
                children: [jsxRuntimeExports.jsx("h6", {
                    className: "referralHead ",
                    children: "Transaction Hash:"
                }), jsxRuntimeExports.jsx("span", {
                    className: "referralText ",
                    children: pt
                }), jsxRuntimeExports.jsx(CopyToClipboard$1, {
                    text: pt ?? "",
                    onCopy: ()=>{
                        toastFun("", "Copied!")
                    }
                    ,
                    children: jsxRuntimeExports.jsx("button", {
                        className: "referralBtn",
                        children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                    })
                })]
            })
        }), jsxRuntimeExports.jsx("div", {
            children: _t && jsxRuntimeExports.jsxs("div", {
                className: "initiatingTextWrapper",
                children: [jsxRuntimeExports.jsx("h6", {
                    className: "",
                    children: "Confirming"
                }), jsxRuntimeExports.jsx(BounceLoader, {
                    color: "#FBBD18",
                    size: 20
                })]
            })
        }), jsxRuntimeExports.jsx("div", {
            children: Et && jsxRuntimeExports.jsxs("div", {
                className: "confirmedWrapper",
                children: [jsxRuntimeExports.jsx("h6", {
                    className: "text-center",
                    children: "Confirmed "
                }), jsxRuntimeExports.jsx(UseAnimations, {
                    animation: checkmark,
                    size: 46,
                    fillColor: "#FBBD18",
                    strokeColor: "#FBBD18",
                    loop: !1
                })]
            })
        }), jsxRuntimeExports.jsx("div", {
            className: "mt-3 d-flex justify-content-between",
            children: at ? jsxRuntimeExports.jsxs("div", {
                children: [jsxRuntimeExports.jsxs("p", {
                    className: "ethNote",
                    children: [jsxRuntimeExports.jsx("span", {
                        children: "Note: "
                    }), "To ensure a smooth transaction without errors, please allocate an amount less than your total wallet balance to cover potential gas fees, which can reach up to", " ", jsxRuntimeExports.jsx("span", {
                        children: "0.015 ETH"
                    }), ".", " "]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "d-flex",
                    children: [jsxRuntimeExports.jsx("button", {
                        className: "tokenConnectWallet me-2",
                        onClick: Tt=>{
                            xt(Tt)
                        }
                        ,
                        children: "Buy Now"
                    }), jsxRuntimeExports.jsx(Link, {
                        className: "tokenConnectWallet",
                        to: "how",
                        children: "How to Buy"
                    })]
                })]
            }) : jsxRuntimeExports.jsx("button", {
                className: "tokenConnectWallet",
                onClick: Tt=>{
                    Tt.preventDefault(),
                    ot()
                }
                ,
                children: "Connect Wallet"
            })
        })]
    })
}
;
ReactModal.setAppElement("#root");
const abi_Presale_BNB$1 = [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_presaleTokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_usdtTokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_ethPriceFeedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "owner", "type": "address" }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "account", "type": "address" }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "newStage",
          "type": "uint8"
        }
      ],
      "name": "PresaleAdvanced",
      "type": "event"
    },
    { "anonymous": false, "inputs": [], "name": "PresaleEnded", "type": "event" },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "newStage",
          "type": "uint8"
        }
      ],
      "name": "StageChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "currency",
          "type": "string"
        }
      ],
      "name": "TokensPurchased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "baseDecimals",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "referral", "type": "address" }
      ],
      "name": "buyWithETH",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "usdtAmount", "type": "uint256" },
        { "internalType": "address", "name": "referral", "type": "address" }
      ],
      "name": "buyWithUSDT",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentStage",
      "outputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "userAddresses",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "tokenAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "distributeTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ethPriceFeed",
      "outputs": [
        {
          "internalType": "contract AggregatorV3Interface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLatestETHPrice",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxLimitETH",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxLimitUSD",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minLimitETH",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minLimitUSD",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pausePresale",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "presaleToken",
      "outputs": [
        { "internalType": "contract IERC20", "name": "", "type": "address" }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "referralPercentage",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "name": "referralRewardsETH",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "name": "referralRewardsUSDT",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable[3]",
          "name": "_ethReceivers",
          "type": "address[3]"
        }
      ],
      "name": "setEthReceivers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_maxLimitETH", "type": "uint256" }
      ],
      "name": "setMaxLimitETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_maxLimitUSD", "type": "uint256" }
      ],
      "name": "setMaxLimitUSD",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_minLimitETH", "type": "uint256" }
      ],
      "name": "setMinLimitETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "uint256", "name": "_minLimitUSD", "type": "uint256" }
      ],
      "name": "setMinLimitUSD",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "stage",
          "type": "uint8"
        }
      ],
      "name": "setPresaleStage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_referralPercentage",
          "type": "uint256"
        }
      ],
      "name": "setReferralPercentage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "stage",
          "type": "uint8"
        },
        { "internalType": "uint256", "name": "price", "type": "uint256" }
      ],
      "name": "setStagePrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "stage",
          "type": "uint8"
        },
        { "internalType": "uint256", "name": "supply", "type": "uint256" }
      ],
      "name": "setStageTokenSupply",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[3]",
          "name": "_usdtReceivers",
          "type": "address[3]"
        }
      ],
      "name": "setUsdtReceivers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "stagePrices",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "stageTokenSupplies",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum BabyHalvingPresale.PresaleStage",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "tokensSold",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalETHRaised",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "name": "totalReferrals",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalTokensSold",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalUSDRaised",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        { "internalType": "address", "name": "newOwner", "type": "address" }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpausePresale",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newEthPriceFeedAddress",
          "type": "address"
        }
      ],
      "name": "updateEthPriceFeedAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "uint256", "name": "val", "type": "uint256" }],
      "name": "updateReferralPercentage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newUsdtTokenAddress",
          "type": "address"
        }
      ],
      "name": "updateUsdtTokenAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "usdtToken",
      "outputs": [
        {
          "internalType": "contract IERC20Extended",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawUSDT",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]
  
  , PresaleBnbForm = ()=>{
    var Bt;
    const [_e,et] = reactExports.useState("")
      , [tt,rt] = reactExports.useState("0")
      , [nt,it] = reactExports.useState(window.innerWidth)
      , [st,at] = reactExports.useState(!1)
      , {address: ot, isConnected: lt} = useAccount()
      , {open: dt} = useWeb3Modal()
      , {register: ct, handleSubmit: ut} = useForm()
      , {data: ft} = useBalance({
        address: ot,
        chainId: 56
    })
      , ht = useChainId()
      , {switchChainAsync: gt} = useSwitchChain()
      , bt = useAppSelector(CurrentUserReferral)
      , {data: pt, isLoading: mt, isFetching: yt} = useCurrencyConversionQuery("bnb")
      , [vt,wt] = useCreateNewAddressMutation()
      , [_t] = useDBTransaction()
      , {data: Et, isLoading: xt, isFetching: Ct} = useReadNewAddressQuery(ot, {
        skip: !lt
    })
      , {data: Tt, error: It, isPending: Nt, reset: Ft, writeContract: Lt} = useWriteContract()
      , {isLoading: Mt, isSuccess: $t} = useWaitForTransactionReceipt({
        hash: Tt
    })
      , kt = async zt=>{
        if (zt.preventDefault(),
        Number(_e ?? 0) < .06 || Number(_e ?? 0) > 80) {
            toastFun("error", "Min: 0.06 & Max: 80");
            return
        }
        if (ht !== 56) {
            await gt({
                chainId: 56
            }),
            B.info("Chain Switched, Make transaction now.", {
                autoClose: 6e3,
                position: "top-left"
            });
            return
        }
        at(!0)
    }
      , At = zt=>{
        var ar;
        zt.preventDefault(),
        et(zt.target.value);
        const Yt = Number(zt.target.value);
        let rr = 0;
        !mt && !yt && (rr = Yt * (((ar = pt == null ? void 0 : pt.data) == null ? void 0 : ar.usd) ?? 333) / 8e-4),
        rt(rr.toFixed(4).toString())
    }
    ;
    reactExports.useEffect(()=>{
        It && (toastFun("error", (It == null ? void 0 : It.shortMessage) ?? "Error! Please try again!"),
        _t((It == null ? void 0 : It.shortMessage) ?? (It == null ? void 0 : It.message) ?? "Error! Please try again", !1, ot, bt, _e, Number(formatEther((ft == null ? void 0 : ft.value) ?? -1n)).toString(), "bnb", "bnb"),
        Ft())
    }
    , [It]),
    reactExports.useEffect(()=>{
        $t && _t("Success!", !0, ot, bt, _e, Number(formatEther((ft == null ? void 0 : ft.value) ?? -1n)).toString(), "bnb", "bnb")
    }
    , [$t]);
    const Pt = zt=>{
        zt.preventDefault(),
        dt()
    }
      , Dt = async zt=>{
        if (zt.revAddress.length > 1 && lt) {
            at(!1);
            try {
                await vt({
                    address: zt.revAddress,
                    userAddress: ot
                }).unwrap()
            } catch (Yt) {
                console.log(Yt, "error")
            }
            Lt({
                address: "0xdbEA50B8536532BFAC245c89A2D574F333119Eb6",
                abi: abi_Presale_BNB$1,
                functionName: "buyWithNativeToken",
                args: [bt],
                value: parseEther(_e ?? "0")
            })
        } else
            toastFun("error", "Contract address required!")
    }
    ;
    return reactExports.useEffect(()=>{
        const zt = ()=>{
            it(window.innerWidth)
        }
        ;
        return window.addEventListener("resize", zt),
        ()=>{
            window.removeEventListener("resize", zt)
        }
    }
    , []),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(ReactModal, {
            isOpen: st,
            className: "buyWithBNBModal",
            overlayClassName: "buyWithBNBModalOverlay",
            onRequestClose: ()=>{
                at(!1)
            }
            ,
            children: jsxRuntimeExports.jsx("div", {
                children: jsxRuntimeExports.jsxs("form", {
                    onSubmit: ut(Dt),
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: "form-group",
                        children: [jsxRuntimeExports.jsx("label", {
                            htmlFor: "address",
                            className: "addressLabel",
                            children: "ERC20 Receiving Address"
                        }), jsxRuntimeExports.jsxs("p", {
                            className: "addressLabelPara",
                            children: ["Please enter the ERC20 address at which you want to receive CBTC tokens. ", jsxRuntimeExports.jsx("br", {}), " ", jsxRuntimeExports.jsx("span", {
                                children: "Note:"
                            }), " Any CEX or wrong Address will result in token loss and team will not be responsible for it."]
                        }), jsxRuntimeExports.jsx("input", {
                            className: "form-control addressInput",
                            id: "address",
                            type: "text",
                            defaultValue: !xt && !Ct && ((Bt = Et == null ? void 0 : Et.data) == null ? void 0 : Bt.address),
                            ...ct("revAddress")
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "addressModalBtnWrap",
                        children: [jsxRuntimeExports.jsx("button", {
                            type: "submit",
                            className: "btn btn-warning",
                            disabled: !wt && !0,
                            children: "Submit"
                        }), jsxRuntimeExports.jsx("button", {
                            onClick: zt=>{
                                zt.preventDefault(),
                                at(!1)
                            }
                            ,
                            className: "btn btn-danger",
                            children: "Cancel"
                        })]
                    })]
                })
            })
        }), jsxRuntimeExports.jsxs("form", {
            children: [jsxRuntimeExports.jsxs("div", {
                className: "tokenFormInputsWrapper",
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "ethInputWrapper me-1",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "ethLabelWrapper",
                        children: jsxRuntimeExports.jsx("label", {
                            htmlFor: "eth",
                            children: "BNB BEP20"
                        })
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "ethInput",
                        children: [jsxRuntimeExports.jsx("input", {
                            id: "eth",
                            type: "number",
                            value: _e,
                            onChange: zt=>{
                                At(zt)
                            }
                            ,
                            placeholder: nt < 786 ? "0.06 | 80" : "Min: 0.06 | Max: 80"
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: BNB,
                            alt: "bnb"
                        })]
                    }), jsxRuntimeExports.jsxs("span", {
                        className: "ms-2",
                        children: [Number(formatEther((ft == null ? void 0 : ft.value) ?? 0)).toFixed(4), " ", (ft == null ? void 0 : ft.symbol) ?? ""]
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "ethInputWrapper",
                    children: [jsxRuntimeExports.jsx("label", {
                        htmlFor: "cbtc",
                        children: " $CBTC you receive "
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "ethInput",
                        children: [jsxRuntimeExports.jsx("input", {
                            id: "cbtc",
                            type: "number",
                            value: tt,
                            readOnly: !0
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: favicon,
                            alt: ""
                        })]
                    })]
                })]
            }), jsxRuntimeExports.jsx("div", {
                children: Nt && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Initiating"
                    }), jsxRuntimeExports.jsx(MoonLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: Tt && jsxRuntimeExports.jsxs("div", {
                    className: "referralWrapper my-4",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "referralHead ",
                        children: "Transaction Hash:"
                    }), jsxRuntimeExports.jsx("span", {
                        className: "referralText ",
                        children: Tt
                    }), jsxRuntimeExports.jsx(CopyToClipboard$1, {
                        text: Tt ?? "",
                        onCopy: ()=>{
                            toastFun("", "Copied!")
                        }
                        ,
                        children: jsxRuntimeExports.jsx("button", {
                            className: "referralBtn",
                            children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                        })
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: Mt && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Confirming"
                    }), jsxRuntimeExports.jsx(BounceLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: $t && jsxRuntimeExports.jsxs("div", {
                    className: "confirmedWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "text-center",
                        children: "Confirmed "
                    }), jsxRuntimeExports.jsx(UseAnimations, {
                        animation: checkmark,
                        size: 46,
                        fillColor: "#FBBD18",
                        strokeColor: "#FBBD18",
                        loop: !1
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: "mt-3 d-flex justify-content-between",
                children: lt ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx("button", {
                        className: "tokenConnectWallet me-2",
                        onClick: zt=>{
                            kt(zt)
                        }
                        ,
                        children: "Buy Now"
                    }), jsxRuntimeExports.jsx(Link, {
                        className: "tokenConnectWallet",
                        to: "how",
                        children: "How to Buy"
                    })]
                }) : jsxRuntimeExports.jsx("button", {
                    className: "tokenConnectWallet",
                    onClick: zt=>{
                        Pt(zt)
                    }
                    ,
                    children: "Connect Wallet"
                })
            })]
        })]
    })
}
;
ReactModal.setAppElement("#root");
const abi_USDT = [{
    inputs: [],
    payable: !1,
    stateMutability: "nonpayable",
    type: "constructor"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
    }],
    name: "Approval",
    type: "event"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "OwnershipTransferred",
    type: "event"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
    }],
    name: "Transfer",
    type: "event"
}, {
    constant: !0,
    inputs: [],
    name: "_decimals",
    outputs: [{
        internalType: "uint8",
        name: "",
        type: "uint8"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "_name",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "_symbol",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !0,
    inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
    }, {
        internalType: "address",
        name: "spender",
        type: "address"
    }],
    name: "allowance",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "address",
        name: "spender",
        type: "address"
    }, {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "approve",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !0,
    inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
    }],
    name: "balanceOf",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "burn",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "decimals",
    outputs: [{
        internalType: "uint8",
        name: "",
        type: "uint8"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "address",
        name: "spender",
        type: "address"
    }, {
        internalType: "uint256",
        name: "subtractedValue",
        type: "uint256"
    }],
    name: "decreaseAllowance",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "getOwner",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "address",
        name: "spender",
        type: "address"
    }, {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
    }],
    name: "increaseAllowance",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "mint",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "name",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "owner",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !1,
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "symbol",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !0,
    inputs: [],
    name: "totalSupply",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "address",
        name: "recipient",
        type: "address"
    }, {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transfer",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "address",
        name: "sender",
        type: "address"
    }, {
        internalType: "address",
        name: "recipient",
        type: "address"
    }, {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transferFrom",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}, {
    constant: !1,
    inputs: [{
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "transferOwnership",
    outputs: [],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
}]
  , abi_Presale_BNB = [
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_presaleTokenAddress",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_usdtTokenAddress",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_ethPriceFeedAddress",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "account", "type": "address" }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Paused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "newStage",
        "type": "uint8"
      }
    ],
    "name": "PresaleAdvanced",
    "type": "event"
  },
  { "anonymous": false, "inputs": [], "name": "PresaleEnded", "type": "event" },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "newStage",
        "type": "uint8"
      }
    ],
    "name": "StageChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "buyer",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "currency",
        "type": "string"
      }
    ],
    "name": "TokensPurchased",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Unpaused",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "baseDecimals",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "referral", "type": "address" }
    ],
    "name": "buyWithETH",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "usdtAmount", "type": "uint256" },
      { "internalType": "address", "name": "referral", "type": "address" }
    ],
    "name": "buyWithUSDT",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "currentStage",
    "outputs": [
      {
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "userAddresses",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "tokenAmounts",
        "type": "uint256[]"
      }
    ],
    "name": "distributeTokens",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "ethPriceFeed",
    "outputs": [
      {
        "internalType": "contract AggregatorV3Interface",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getLatestETHPrice",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "maxLimitETH",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "maxLimitUSD",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "minLimitETH",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "minLimitUSD",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "pausePresale",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "paused",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "presaleToken",
    "outputs": [
      { "internalType": "contract IERC20", "name": "", "type": "address" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "referralPercentage",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "referralRewardsETH",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "referralRewardsUSDT",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address payable[3]",
        "name": "_ethReceivers",
        "type": "address[3]"
      }
    ],
    "name": "setEthReceivers",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "_maxLimitETH", "type": "uint256" }
    ],
    "name": "setMaxLimitETH",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "_maxLimitUSD", "type": "uint256" }
    ],
    "name": "setMaxLimitUSD",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "_minLimitETH", "type": "uint256" }
    ],
    "name": "setMinLimitETH",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "_minLimitUSD", "type": "uint256" }
    ],
    "name": "setMinLimitUSD",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "stage",
        "type": "uint8"
      }
    ],
    "name": "setPresaleStage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_referralPercentage",
        "type": "uint256"
      }
    ],
    "name": "setReferralPercentage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "stage",
        "type": "uint8"
      },
      { "internalType": "uint256", "name": "price", "type": "uint256" }
    ],
    "name": "setStagePrice",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "stage",
        "type": "uint8"
      },
      { "internalType": "uint256", "name": "supply", "type": "uint256" }
    ],
    "name": "setStageTokenSupply",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[3]",
        "name": "_usdtReceivers",
        "type": "address[3]"
      }
    ],
    "name": "setUsdtReceivers",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "",
        "type": "uint8"
      }
    ],
    "name": "stagePrices",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "",
        "type": "uint8"
      }
    ],
    "name": "stageTokenSupplies",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "enum BabyHalvingPresale.PresaleStage",
        "name": "",
        "type": "uint8"
      }
    ],
    "name": "tokensSold",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalETHRaised",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "totalReferrals",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalTokensSold",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalUSDRaised",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "newOwner", "type": "address" }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "unpausePresale",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_newEthPriceFeedAddress",
        "type": "address"
      }
    ],
    "name": "updateEthPriceFeedAddress",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "val", "type": "uint256" }],
    "name": "updateReferralPercentage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_newUsdtTokenAddress",
        "type": "address"
      }
    ],
    "name": "updateUsdtTokenAddress",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "usdtToken",
    "outputs": [
      {
        "internalType": "contract IERC20Extended",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "withdrawETH",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "withdrawUSDT",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
  , PresaleUsdtForm = ()=>{
    var pr;
    const [_e,et] = reactExports.useState("")
      , [tt,rt] = reactExports.useState("0")
      , [nt,it] = reactExports.useState(window.innerWidth)
      , [st,at] = reactExports.useState(!1)
      , {register: ot, handleSubmit: lt} = useForm()
      , {address: dt, isConnected: ct} = useAccount()
      , {open: ut} = useWeb3Modal()
      , ft = useAppSelector(CurrentUserReferral)
      , [ht,gt] = useCreateNewAddressMutation()
      , [bt] = useDBTransaction()
      , pt = useChainId()
      , {switchChainAsync: mt} = useSwitchChain()
      , {data: yt, isLoading: vt, isFetching: wt} = useReadNewAddressQuery(dt, {
        skip: !ct
    })
      , {data: _t, isError: Et, isPending: xt} = useReadContract({
        address: "0x55d398326f99059ff775485246999027b3197955",
        abi: abi_USDT,
        functionName: "balanceOf",
        args: [dt]
    })
      , {data: Ct, error: Tt, isPending: It, reset: Nt, writeContract: Ft} = useWriteContract()
      , {data: Lt, error: Mt, isPending: $t, reset: kt, writeContract: At} = useWriteContract()
      , {isLoading: Pt, isSuccess: Dt} = useWaitForTransactionReceipt({
        hash: Ct
    })
      , {isLoading: Bt, isSuccess: zt} = useWaitForTransactionReceipt({
        hash: Lt
    });
    reactExports.useEffect(()=>{
        Dt && (bt("Approve Success!", !0, dt, ft, _e, Number(formatEther(_t ?? -1n)).toString(), "usdt", "bnb"),
        kt(),
        At({
            address: "0xdbEA50B8536532BFAC245c89A2D574F333119Eb6",
            abi: abi_Presale_BNB,
            functionName: "buyWithUSDT",
            args: [parseFloat(_e ?? 0).toFixed(0), ft]
        }))
    }
    , [Dt]),
    reactExports.useEffect(()=>{
        zt && bt("Success!", !0, dt, ft, _e, Number(formatEther(_t ?? -1n)).toString(), "usdt", "bnb")
    }
    , [zt]),
    reactExports.useEffect(()=>{
        !$t && Mt && (B.error((Mt == null ? void 0 : Mt.shortMessage) ?? "Error! Please try again!"),
        bt((Mt == null ? void 0 : Mt.shortMessage) ?? (Mt == null ? void 0 : Mt.message) ?? "Error! Please try again", !1, dt, ft, _e, Number(formatEther(_t ?? 0)).toString(), "usdt", "bnb"),
        kt())
    }
    , [Mt]),
    reactExports.useEffect(()=>{
        !It && Tt && (B.error((Tt == null ? void 0 : Tt.shortMessage) ?? "Error! Please try again!"),
        bt((Tt == null ? void 0 : Tt.shortMessage) ?? (Tt == null ? void 0 : Tt.message) ?? "Error! Please try again", !1, dt, ft, _e, Number(formatEther(_t ?? 0)).toString(), "usdt", "bnb"),
        Nt())
    }
    , [Tt]);
    const Yt = async gr=>{
        if (gr.preventDefault(),
        Number(_e ?? 0) < 20 || Number(_e ?? 0) > 25e3) {
            toastFun("error", "Min: 20 & Max: 25000");
            return
        }
        if (pt !== 56) {
            await mt({
                chainId: 56
            }),
            B.info("Chain Switched, Make transaction now.", {
                autoClose: 6e3,
                position: "top-left"
            });
            return
        }
        at(!0)
    }
      , rr = gr=>{
        gr.preventDefault(),
        et(gr.target.value.replace(/\./g, ""));
        const br = Number(gr.target.value.replace(/\./g, "")) / 8e-4;
        rt(br.toFixed(4).toString())
    }
      , ar = gr=>{
        gr.preventDefault(),
        ut()
    }
      , or = async gr=>{
        if (gr.revAddress.length > 1 && ct) {
            at(!1);
            try {
                await ht({
                    address: gr.revAddress,
                    userAddress: dt
                }).unwrap()
            } catch (Sr) {
                console.log(Sr, "error")
            }
            Ft({
                address: "0x55d398326f99059ff775485246999027b3197955",
                abi: abi_USDT,
                functionName: "approve",
                args: ["0xcAE6EBAceF456e5A942afb40Fc99F2F38639eF01", parseEther(_e ?? "0")]
            })
        } else
            toastFun("error", "Contract address required!")
    }
    ;
    return reactExports.useEffect(()=>{
        const gr = ()=>{
            it(window.innerWidth)
        }
        ;
        return window.addEventListener("resize", gr),
        ()=>{
            window.removeEventListener("resize", gr)
        }
    }
    , []),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(ReactModal, {
            isOpen: st,
            className: "buyWithBNBModal",
            overlayClassName: "buyWithBNBModalOverlay",
            onRequestClose: ()=>{
                at(!1)
            }
            ,
            children: jsxRuntimeExports.jsx("div", {
                children: jsxRuntimeExports.jsxs("form", {
                    onSubmit: lt(or),
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: "form-group",
                        children: [jsxRuntimeExports.jsx("label", {
                            htmlFor: "address",
                            className: "addressLabel",
                            children: "ERC20 Receiving Address"
                        }), jsxRuntimeExports.jsxs("p", {
                            className: "addressLabelPara",
                            children: ["Please enter the ERC20 address at which you want to receive CBTC tokens. ", jsxRuntimeExports.jsx("br", {}), " ", jsxRuntimeExports.jsx("span", {
                                children: "Note:"
                            }), " Any CEX or wrong Address will result in token loss and team will not be responsible for it."]
                        }), jsxRuntimeExports.jsx("input", {
                            className: "form-control addressInput",
                            id: "address",
                            type: "text",
                            defaultValue: !vt && !wt && ((pr = yt == null ? void 0 : yt.data) == null ? void 0 : pr.address),
                            ...ot("revAddress")
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "addressModalBtnWrap",
                        children: [jsxRuntimeExports.jsx("button", {
                            type: "submit",
                            className: "btn btn-warning",
                            disabled: !gt && !0,
                            children: "Submit"
                        }), jsxRuntimeExports.jsx("button", {
                            onClick: gr=>{
                                gr.preventDefault(),
                                at(!1)
                            }
                            ,
                            className: "btn btn-danger",
                            children: "Cancel"
                        })]
                    })]
                })
            })
        }), jsxRuntimeExports.jsxs("form", {
            children: [jsxRuntimeExports.jsxs("div", {
                className: "tokenFormInputsWrapper",
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "ethInputWrapper me-2",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "ethLabelWrapper",
                        children: jsxRuntimeExports.jsx("label", {
                            htmlFor: "eth",
                            children: "USDT BEP20"
                        })
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "ethInput",
                        children: [jsxRuntimeExports.jsx("input", {
                            id: "eth",
                            type: "number",
                            value: _e,
                            pattern: "[0-9]",
                            inputMode: "numeric",
                            onChange: gr=>{
                                rr(gr)
                            }
                            ,
                            placeholder: nt < 768 ? "20  | 25000" : "Min: 20 | Max: 25000"
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: usdt,
                            width: 32,
                            height: 32,
                            alt: "eth"
                        })]
                    }), jsxRuntimeExports.jsx("span", {
                        className: "ms-2",
                        children: !Et && !xt ? `${Number(formatEther(_t ?? 0)).toFixed(4)} USDT` : ""
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "ethInputWrapper",
                    children: [jsxRuntimeExports.jsx("label", {
                        htmlFor: "cbtc",
                        children: " $CBTC you receive "
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "ethInput",
                        children: [jsxRuntimeExports.jsx("input", {
                            id: "cbtc",
                            type: "number",
                            value: tt,
                            readOnly: !0
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: favicon,
                            alt: ""
                        })]
                    })]
                })]
            }), jsxRuntimeExports.jsx("div", {
                children: It && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Initiating"
                    }), jsxRuntimeExports.jsx(MoonLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: Ct && jsxRuntimeExports.jsxs("div", {
                    className: "referralWrapper my-4",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "referralHead ",
                        children: "Approval Hash:"
                    }), jsxRuntimeExports.jsx("span", {
                        className: "referralText ",
                        children: Ct
                    }), jsxRuntimeExports.jsx(CopyToClipboard$1, {
                        text: Ct ?? "",
                        onCopy: ()=>{
                            toastFun("", "Copied!")
                        }
                        ,
                        children: jsxRuntimeExports.jsx("button", {
                            className: "referralBtn",
                            children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                        })
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: Pt && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Approving"
                    }), jsxRuntimeExports.jsx(BounceLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: Dt && jsxRuntimeExports.jsxs("div", {
                    className: "confirmedWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "text-center",
                        children: "Request Approved"
                    }), jsxRuntimeExports.jsx(UseAnimations, {
                        animation: checkmark,
                        size: 46,
                        fillColor: "#FBBD18",
                        strokeColor: "#FBBD18",
                        loop: !1
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: $t && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Initiating"
                    }), jsxRuntimeExports.jsx(MoonLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: Lt && jsxRuntimeExports.jsxs("div", {
                    className: "referralWrapper my-4",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "referralHead ",
                        children: "Transaction Hash:"
                    }), jsxRuntimeExports.jsx("span", {
                        className: "referralText ",
                        children: Lt
                    }), jsxRuntimeExports.jsx(CopyToClipboard$1, {
                        text: Ct ?? "",
                        onCopy: ()=>{
                            toastFun("", "Copied!")
                        }
                        ,
                        children: jsxRuntimeExports.jsx("button", {
                            className: "referralBtn",
                            children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                        })
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: Bt && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Confirming"
                    }), jsxRuntimeExports.jsx(BounceLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                children: zt && jsxRuntimeExports.jsxs("div", {
                    className: "confirmedWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "text-center",
                        children: "Confirmed"
                    }), jsxRuntimeExports.jsx(UseAnimations, {
                        animation: checkmark,
                        size: 46,
                        fillColor: "#FBBD18",
                        strokeColor: "#FBBD18",
                        loop: !1
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: "mt-3 d-flex justify-content-between",
                children: ct ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx("button", {
                        className: "tokenConnectWallet me-2",
                        onClick: gr=>{
                            Yt(gr)
                        }
                        ,
                        children: "Buy Now"
                    }), jsxRuntimeExports.jsx(Link, {
                        className: "tokenConnectWallet",
                        to: "how",
                        children: "How to Buy"
                    })]
                }) : jsxRuntimeExports.jsx("button", {
                    className: "tokenConnectWallet",
                    onClick: gr=>{
                        ar(gr)
                    }
                    ,
                    children: "Connect Wallet"
                })
            })]
        })]
    })
}
  , PresaleWidgetForm = ()=>{
    const [_e,et] = reactExports.useState("eth")
      , tt = useChainId()
      , {switchChain: rt} = useSwitchChain();
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs("div", {
            className: "tokenCWrap mt-5",
            children: [jsxRuntimeExports.jsxs("div", {
                className: `tCurreny ${_e === "eth" ? "active" : ""}`,
                onClick: ()=>{
                    et("eth"),
                    tt !== 1 && rt({
                        chainId: 1
                    })
                }
                ,
                children: [jsxRuntimeExports.jsx("img", {
                    className: "img-fluid",
                    src: ETH,
                    alt: "eth",
                    title: "eth"
                }), jsxRuntimeExports.jsx("span", {
                    children: "ETH"
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: `tCurreny ${_e === "bnb" ? "active" : ""}`,
                onClick: ()=>{
                    et("bnb"),
                    tt !== 97 && rt({
                        chainId: 97
                    })
                }
                ,
                children: [jsxRuntimeExports.jsx("img", {
                    className: "img-fluid",
                    src: BNB,
                    alt: "bnb",
                    title: "bnb"
                }), jsxRuntimeExports.jsx("span", {
                    children: "BNB"
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: `tCurreny  ${_e === "usdt" ? "active" : ""}`,
                onClick: ()=>{
                    et("usdt"),
                    tt !== 97 && rt({
                        chainId: 97
                    })
                }
                ,
                children: [jsxRuntimeExports.jsx("img", {
                    className: "img-fluid",
                    src: usdt,
                    alt: "usdt",
                    title: "usdt"
                }), jsxRuntimeExports.jsx("span", {
                    children: "USDT"
                })]
            }), jsxRuntimeExports.jsxs("a", {
                href: "https://www.moonpay.com/buy",
                target: "_blank",
                className: "tCurreny text-light me-0",
                children: [jsxRuntimeExports.jsx("img", {
                    className: "img-fluid",
                    src: card,
                    alt: "card",
                    title: "card"
                }), jsxRuntimeExports.jsx("span", {
                    children: "CARD"
                })]
            })]
        }), _e === "eth" && jsxRuntimeExports.jsx(PresaleEthForm, {}), _e === "bnb" && jsxRuntimeExports.jsx(PresaleBnbForm, {}), _e === "usdt" && jsxRuntimeExports.jsx(PresaleUsdtForm, {})]
    })
}
;
ReactModal.setAppElement("#root");
let referral = "0x0000000000000000000000000000000000000000";
const PresaleWidget = ({setURModal: _e})=>{
    var ft, ht, gt;
    const {address: et, isConnected: tt} = useAccount()
      , rt = useAppDispatch();
    referral = useAppSelector(CurrentUserReferral);
    const {data: nt, isLoading: it, isFetching: st} = useGetReferralQuery(et, {
        skip: !tt
    })
      , {data: at, isLoading: ot, isFetching: lt} = useGetPercentageQuery(null);
    reactExports.useEffect(()=>{
        var bt;
        tt && !it && !st && rt(setReferral({
            referral: ((bt = nt == null ? void 0 : nt.data) == null ? void 0 : bt.referral) ?? "0x0000000000000000000000000000000000000000"
        }))
    }
    , [tt, it, st]);
    const dt = ({days: bt, hours: pt, minutes: mt, seconds: yt, completed: vt})=>vt ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsxs("div", {
            className: "timerWrapper",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Days"
                }), jsxRuntimeExports.jsx("span", {
                    children: bt
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Hours"
                }), jsxRuntimeExports.jsx("span", {
                    children: pt
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Minutes"
                }), jsxRuntimeExports.jsx("span", {
                    children: mt
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Seconds"
                }), jsxRuntimeExports.jsx("span", {
                    children: yt
                })]
            })]
        })
    })
      , ct = ()=>{
        _e(!0)
    }
      , ut = ()=>{
        B.info("copied!", {
            autoClose: 2e3
        })
    }
    ;
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsxs("div", {
            className: "tokenWidgetWrapper",
            children: [jsxRuntimeExports.jsx("h3", {
                className: "tokenHead",
                children: "Presale Is Live"
            }), jsxRuntimeExports.jsx(Countdown$1, {
                date: new Date(Date.UTC(2024, 4, 6, 17, 30, 0)),
                renderer: dt
            }), !ot && !lt && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "tokenSubHeadWrapper",
                    children: [jsxRuntimeExports.jsx("h4", {
                        className: "tokenSubHead",
                        children: "STAGE 1 : "
                    }), jsxRuntimeExports.jsx("p", {
                        className: "tPrice",
                        children: `${((ft = at == null ? void 0 : at.data) == null ? void 0 : ft.value) ?? 0}/240,000 $`
                    })]
                }), jsxRuntimeExports.jsx("div", {
                    className: "progress mb-2",
                    children: jsxRuntimeExports.jsx("div", {
                        className: "progress-bar",
                        role: "progressbar",
                        style: {
                            width: `${((ht = at == null ? void 0 : at.data) == null ? void 0 : ht.percentage) ?? 0}%`
                        },
                        "aria-valuenow": Number(((gt = at == null ? void 0 : at.data) == null ? void 0 : gt.percentage) ?? 0),
                        "aria-valuemin": 0,
                        "aria-valuemax": 100
                    })
                })]
            }), jsxRuntimeExports.jsxs("h5", {
                className: "CBTCValue",
                children: ["1 CBTC = ", jsxRuntimeExports.jsx("span", {
                    children: "$0.0008"
                })]
            }), tt && jsxRuntimeExports.jsxs("h5", {
                className: "tokenYourAddress",
                children: ["Your Address : ", jsxRuntimeExports.jsxs("span", {
                    children: [" ", et]
                })]
            }), tt && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                children: jsxRuntimeExports.jsxs("div", {
                    className: "referralWrapper mb-1",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "referralHead",
                        children: "Referral Link :"
                    }), jsxRuntimeExports.jsx("span", {
                        className: "referralText",
                        children: `https://cloudbtc.io?referral=${et}`
                    }), jsxRuntimeExports.jsx(lib.CopyToClipboard, {
                        text: `https://cloudbtc.io?referral=${et}`,
                        onCopy: ut,
                        children: jsxRuntimeExports.jsx("button", {
                            className: "referralBtn",
                            children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                        })
                    })]
                })
            }), tt && jsxRuntimeExports.jsxs("div", {
                className: "referralWrapper",
                children: [jsxRuntimeExports.jsx("h6", {
                    className: "referralHead ",
                    children: "Referred By :"
                }), jsxRuntimeExports.jsx("span", {
                    className: "referralText ",
                    children: referral
                }), jsxRuntimeExports.jsx("button", {
                    className: "referralBtn px-2 ",
                    onClick: ct,
                    children: jsxRuntimeExports.jsx(CiEdit, {})
                })]
            }), jsxRuntimeExports.jsx(PresaleWidgetForm, {})]
        })
    })
}
  , paper = "/assets/CloudBTC_WhitePaper-DpvxnhIE.pdf";
ReactModal.setAppElement("#root");
const Banner = ()=>{
    const _e = useAppSelector(CurrentUserReferral)
      , et = useAppDispatch()
      , {address: tt, isConnected: rt} = useAccount()
      , [nt,it] = reactExports.useState(!1)
      , [st] = useUpdateReferralMutation()
      , {register: at, handleSubmit: ot} = useForm()
      , lt = Joi.string().pattern(/^0x[a-fA-F0-9]{40}$/).required().allow("").messages({
        "string.pattern": "Invalid smart contract address format. (Must start with 0x and be 40 hex characters)",
        "any.required": "Smart contract address is required"
    })
      , dt = ht=>{
        ht.preventDefault(),
        B.info("Coming Soon!", {
            position: "top-right",
            autoClose: 3e3,
            closeOnClick: !0,
            pauseOnHover: !0
        })
    }
      , ct = ()=>{
        it(!0)
    }
      , ut = async ht=>{
        const {error: gt} = lt.validate(ht.uRInput);
        if (gt) {
            toastFun("error", "Invalid Referral Address!");
            return
        }
        et(setReferral({
            referral: ht.uRInput
        })),
        it(!1);
        try {
            await st({
                userAddress: tt,
                referral: ht.uRInput
            }).unwrap()
        } catch (bt) {
            console.log(bt, "error")
        }
    }
      , ft = ({days: ht, hours: gt, minutes: bt, seconds: pt, completed: mt})=>mt ? jsxRuntimeExports.jsx("h3", {
        className: "tokenHead mb-2 mt-4",
        children: "Staking Is Live"
    }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("h3", {
            className: "tokenHead mb-2 mt-4",
            children: "Staking will Live In"
        }), jsxRuntimeExports.jsxs("div", {
            className: "timerWrapper mt-3",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Days"
                }), jsxRuntimeExports.jsx("span", {
                    children: ht
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Hours"
                }), jsxRuntimeExports.jsx("span", {
                    children: gt
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Minutes"
                }), jsxRuntimeExports.jsx("span", {
                    children: bt
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "timerContent",
                children: [jsxRuntimeExports.jsx("h6", {
                    children: "Seconds"
                }), jsxRuntimeExports.jsx("span", {
                    children: pt
                })]
            })]
        })]
    });
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(ReactModal, {
            isOpen: nt,
            className: "buyWithBNBModal",
            overlayClassName: "buyWithBNBModalOverlay",
            onRequestClose: ()=>{
                it(!1)
            }
            ,
            children: jsxRuntimeExports.jsx("div", {
                children: jsxRuntimeExports.jsxs("form", {
                    onSubmit: ot(ut),
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: "form-group",
                        children: [jsxRuntimeExports.jsx("label", {
                            htmlFor: "address",
                            className: "addressLabel",
                            children: "User Referral Address"
                        }), jsxRuntimeExports.jsx("input", {
                            className: "form-control addressInput",
                            id: "address",
                            defaultValue: _e,
                            ...at("uRInput"),
                            type: "text"
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "addressModalBtnWrap",
                        children: [jsxRuntimeExports.jsx("button", {
                            type: "submit",
                            className: "btn btn-warning",
                            children: "Update"
                        }), jsxRuntimeExports.jsx("button", {
                            onClick: ht=>{
                                ht.preventDefault(),
                                it(!1)
                            }
                            ,
                            className: "btn btn-danger",
                            children: "Cancel"
                        })]
                    })]
                })
            })
        }), jsxRuntimeExports.jsx("div", {
            className: "container-fluid bannerBG",
            children: jsxRuntimeExports.jsxs("div", {
                className: "row position-relative",
                children: [jsxRuntimeExports.jsx("p", {
                    className: "userAddress",
                    children: rt && `Connected address: ${tt}`
                }), jsxRuntimeExports.jsx("p", {
                    className: "userAddress",
                    children: rt && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                        children: ["Referral address: ", _e, jsxRuntimeExports.jsx("span", {
                            className: "userReferralEdit",
                            onClick: ct,
                            children: jsxRuntimeExports.jsx(CiEdit, {})
                        })]
                    })
                }), jsxRuntimeExports.jsxs("div", {
                    className: "col-11 mx-auto max-width ",
                    children: [jsxRuntimeExports.jsxs("ul", {
                        className: "socialIcons mb-4 mb-lg-0 justify-content-center",
                        children: [jsxRuntimeExports.jsx("li", {
                            children: jsxRuntimeExports.jsx("a", {
                                href: "https://twitter.com/CBTC_CloudBTC",
                                target: "_blank",
                                children: jsxRuntimeExports.jsx("i", {
                                    className: "bi bi-twitter-x"
                                })
                            })
                        }), jsxRuntimeExports.jsx("li", {
                            children: jsxRuntimeExports.jsx("a", {
                                href: "https://t.me/cloudbtcofficial_1",
                                target: "_blank",
                                children: jsxRuntimeExports.jsx("i", {
                                    className: "bi bi-telegram"
                                })
                            })
                        }), jsxRuntimeExports.jsx("li", {
                            children: jsxRuntimeExports.jsx("a", {
                                href: "https://t.me/CloudBTC_Global",
                                target: "_blank",
                                children: jsxRuntimeExports.jsx("i", {
                                    className: "bi bi-telegram"
                                })
                            })
                        }), jsxRuntimeExports.jsx("li", {
                            children: jsxRuntimeExports.jsx("a", {
                                href: "https://cloudbtc.io/",
                                target: "_blank",
                                children: jsxRuntimeExports.jsx("i", {
                                    className: "bi bi-currency-bitcoin"
                                })
                            })
                        })]
                    }), jsxRuntimeExports.jsx("div", {
                        style: {
                            maxWidth: "25rem",
                            margin: "0 auto",
                            marginBottom: "2rem"
                        },
                        children: jsxRuntimeExports.jsx(Countdown$1, {
                            date: new Date(Date.UTC(2024, 2, 1, 15, 0, 0)),
                            renderer: ft
                        })
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "row bannerWrapper",
                        children: [jsxRuntimeExports.jsx("div", {
                            className: "col-lg-6 col-xxl-7 d-flex align-items-center mb-5 mb-lg-0 ",
                            children: jsxRuntimeExports.jsxs("div", {
                                children: [jsxRuntimeExports.jsxs("h1", {
                                    className: "bannerHeading",
                                    children: ["Welcome to Digitally Mineable Bitcoin", jsxRuntimeExports.jsx("span", {
                                        children: " Baby Halving"
                                    })]
                                }), jsxRuntimeExports.jsx("p", {
                                    className: "bannerPara",
                                    children: "CloudBTC revolutionizes cryptocurrency mining, shifting away from the costly and environmentally taxing traditional methods. By simply staking CloudBTC tokens, anyone can participate in an eco-friendly and accessible mining process, democratizing the digital currency landscape and empowering users globally."
                                }), jsxRuntimeExports.jsxs("p", {
                                    className: "bannerSmartContract",
                                    children: [jsxRuntimeExports.jsx("span", {
                                        children: "Smart Contract Address: "
                                    }), "0x9d8a797b4f7df73e2e93124e9d9061e7f550e60a", jsxRuntimeExports.jsx("span", {
                                        className: "bannerSmartContractSpan",
                                        children: "Don't send anything to this address."
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "bannerBtnWrapper",
                                    children: [jsxRuntimeExports.jsx("a", {
                                        href: paper,
                                        className: "btn bannerBtn",
                                        children: "WhitePaper"
                                    }), jsxRuntimeExports.jsx(Link, {
                                        to: "https://babyhalving.vercel.app/wp-content/uploads/2023/06/WhitePaper-BabyHalving.pdf",
                                        onClick: ht=>{
                                            dt(ht)
                                        }
                                        ,
                                        className: "btn bannerBtn2",
                                        children: "Join Now"
                                    })]
                                })]
                            })
                        }), jsxRuntimeExports.jsx("div", {
                            className: "col-lg-6 col-xxl-5 d-flex align-items-center justify-content-center justify-content-lg-end ",
                            children: jsxRuntimeExports.jsx("div", {
                                className: "px-1",
                                children: jsxRuntimeExports.jsx(PresaleWidget, {
                                    setURModal: it
                                })
                            })
                        })]
                    })]
                })]
            })
        })]
    })
}
  , benifits1 = "/assets/benifits1-CDGKU1YX.webp"
  , benifits2 = "/assets/benifits2-B7ewQLoz.webp"
  , benifits3 = "/assets/benifits3-DVQTTaFa.webp"
  , benifits4 = "/assets/benifits4-eObvKHaO.webp"
  , benifits5 = "/assets/benifits5-BX99NJJt.webp"
  , benefits_Bitcoins = "/assets/benefits_Bitcoins-BVZZBxbA.webp"
  , Benefits = ()=>jsxRuntimeExports.jsx("div", {
    id: "benefits",
    className: "container-fluid my-5",
    children: jsxRuntimeExports.jsx("div", {
        className: "row",
        children: jsxRuntimeExports.jsxs("div", {
            className: "col-11 mx-auto max-width py-5 text-center",
            children: [jsxRuntimeExports.jsx("h1", {
                className: "benefitHead",
                children: "Experience the Advantages of CloudBTC"
            }), jsxRuntimeExports.jsx("p", {
                className: "benefitPara",
                children: "Unlocking a New World of Cryptocurrency Opportunities"
            }), jsxRuntimeExports.jsxs("div", {
                className: "benefitsContentWrapper",
                children: [jsxRuntimeExports.jsx("img", {
                    className: "img-fluid benefitsCoins",
                    src: benefits_Bitcoins,
                    alt: ""
                }), jsxRuntimeExports.jsxs("div", {
                    className: "benefitsC1",
                    children: [jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("h4", {
                            children: "Eco-Friendly Mining"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Enjoy BTC-like benefits without the environmental impact. CloudBTC uses an innovative staking model that's energy-efficient."
                        })]
                    }), jsxRuntimeExports.jsx("img", {
                        className: "img-fluid",
                        src: benifits1,
                        alt: ""
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "benefitsC2",
                    children: [jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("h4", {
                            children: "Simplified Mining Process"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "No complex setups or hefty investments. Simply stake your CloudBTC tokens and start earning."
                        })]
                    }), jsxRuntimeExports.jsx("img", {
                        className: "img-fluid",
                        src: benifits2,
                        alt: ""
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "benefitsC3",
                    children: [jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("h4", {
                            children: "Yearly Rewards"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Receive a share of the annual token supply just by holding your tokens, making your investment grow effortlessly."
                        })]
                    }), jsxRuntimeExports.jsx("img", {
                        className: "img-fluid",
                        src: benifits3,
                        alt: ""
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "benefitsC4",
                    children: [jsxRuntimeExports.jsx("img", {
                        className: "img-fluid",
                        src: benifits4,
                        alt: ""
                    }), jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("h4", {
                            children: "Presale Advantages"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Benefit from the presale's tiered pricing structure and earn rewards by staking early."
                        })]
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "benefitsC5",
                    children: [jsxRuntimeExports.jsx("img", {
                        className: "img-fluid",
                        src: benifits5,
                        alt: ""
                    }), jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("h4", {
                            children: "Incremental Growth"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "As the presale progresses through 9 stages, your investment potential grows with each phase, offering increased value."
                        })]
                    })]
                })]
            })]
        })
    })
})
  , Faq = ()=>jsxRuntimeExports.jsx("div", {
    id: "faq",
    className: "container-fluid my-5",
    children: jsxRuntimeExports.jsx("div", {
        className: "row",
        children: jsxRuntimeExports.jsxs("div", {
            className: "col-11 mx-auto max-width py-5",
            children: [jsxRuntimeExports.jsx("h1", {
                className: "faqHead",
                children: "Frequently Asked Questions"
            }), jsxRuntimeExports.jsxs("div", {
                className: "accordion accordion-flush",
                id: "accordionFlushExample",
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "accordion-item mb-4 accorWrapper",
                    children: [jsxRuntimeExports.jsx("h2", {
                        className: "accordion-header",
                        id: "flush-headingOne",
                        children: jsxRuntimeExports.jsx("button", {
                            className: "accordion-button accorBtn",
                            type: "button",
                            "data-bs-toggle": "collapse",
                            "data-bs-target": "#flush-collapseOne",
                            "aria-expanded": "false",
                            "aria-controls": "flush-collapseOne",
                            children: "What is CloudBTC?"
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        id: "flush-collapseOne",
                        className: "accordion-collapse collapse show",
                        "aria-labelledby": "flush-headingOne",
                        "data-bs-parent": "#accordionFlushExample",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "accordion-body",
                            children: "CloudBTC is an ERC-20 token offering an innovative approach to cryptocurrency mining, focusing on simplicity, sustainability, and stake-based rewards."
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "accordion-item mb-4 accorWrapper",
                    children: [jsxRuntimeExports.jsx("h2", {
                        className: "accordion-header",
                        id: "flush-headingTwo",
                        children: jsxRuntimeExports.jsx("button", {
                            className: "accordion-button collapsed accorBtn",
                            type: "button",
                            "data-bs-toggle": "collapse",
                            "data-bs-target": "#flush-collapseTwo",
                            "aria-expanded": "false",
                            "aria-controls": "flush-collapseTwo",
                            children: "How does staking work with CloudBTC?"
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        id: "flush-collapseTwo",
                        className: "accordion-collapse collapse",
                        "aria-labelledby": "flush-headingTwo",
                        "data-bs-parent": "#accordionFlushExample",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "accordion-body",
                            children: "Staking CloudBTC tokens means you lock them for a period to earn additional tokens. The longer you stake, the more rewards you receive."
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "accordion-item mb-4 accorWrapper",
                    children: [jsxRuntimeExports.jsx("h2", {
                        className: "accordion-header",
                        id: "flush-headingThree",
                        children: jsxRuntimeExports.jsx("button", {
                            className: "accordion-button collapsed accorBtn",
                            type: "button",
                            "data-bs-toggle": "collapse",
                            "data-bs-target": "#flush-collapseThree",
                            "aria-expanded": "false",
                            "aria-controls": "flush-collapseThree",
                            children: "What are the benefits of participating in the presale?"
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        id: "flush-collapseThree",
                        className: "accordion-collapse collapse",
                        "aria-labelledby": "flush-headingThree",
                        "data-bs-parent": "#accordionFlushExample",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "accordion-body",
                            children: "Participating in the presale allows you to purchase CloudBTC at a lower price, with the cost increasing at each of the 9 stages. You can also stake your tokens during the presale to start earning rewards immediately."
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "accordion-item mb-4 accorWrapper",
                    children: [jsxRuntimeExports.jsx("h2", {
                        className: "accordion-header",
                        id: "flush-headingThree",
                        children: jsxRuntimeExports.jsx("button", {
                            className: "accordion-button collapsed accorBtn",
                            type: "button",
                            "data-bs-toggle": "collapse",
                            "data-bs-target": "#flush-collapseFour",
                            "aria-expanded": "false",
                            "aria-controls": "flush-collapseFour",
                            children: "When will liquidity be added to the market?"
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        id: "flush-collapseFour",
                        className: "accordion-collapse collapse",
                        "aria-labelledby": "flush-headingThree",
                        "data-bs-parent": "#accordionFlushExample",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "accordion-body",
                            children: "Liquidity will be added to the market after the completion of the presale, ensuring a secure and stable launch for CloudBTC."
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "accordion-item mb-4 accorWrapper",
                    children: [jsxRuntimeExports.jsx("h2", {
                        className: "accordion-header",
                        id: "flush-headingThree",
                        children: jsxRuntimeExports.jsx("button", {
                            className: "accordion-button collapsed accorBtn",
                            type: "button",
                            "data-bs-toggle": "collapse",
                            "data-bs-target": "#flush-collapseFive",
                            "aria-expanded": "false",
                            "aria-controls": "flush-collapseFive",
                            children: "Are there any environmental benefits to CloudBTC?"
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        id: "flush-collapseFive",
                        className: "accordion-collapse collapse",
                        "aria-labelledby": "flush-headingThree",
                        "data-bs-parent": "#accordionFlushExample",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "accordion-body",
                            children: "Yes, CloudBTC's staking model is far more energy-efficient than traditional BTC mining, reducing the environmental impact associated with cryptocurrency mining. s"
                        })
                    })]
                })]
            })]
        })
    })
})
  , presale1 = "data:image/webp;base64,UklGRsQKAABXRUJQVlA4WAoAAAAQAAAA+AAA6gAAVlA4TE8KAAAv+IA6EOZQ2zYKdLf/2LwHVFQRMQHI83y4MgoRqqg01MJVfGS61f6vsxQ6vz1sRk60rjPz/30+3/8P1wnp5x7m/n73/P+D+/eQ3Qhr4EoFOEyESwXs0W9E7NKCM7cD3DIii3YLweF/JoQKNHMi1wq0gJVYa8BtMiSlAyrwdcnRHohuuB1sSEwgyY0kR5L+/7+5zVmu3haVYeYxcLmRJDmS1PzC6amKyDrwmFr2FXglXp5TXQIAAATTzDYyxmzbtm3b5m3btv1s27Ztk4HbRoqSY9zjmdO+QE62zXEk8aezOJaTgr4k21O1t+t5hMNR4XBkKMKhqHDsQWUf4VBkHI3GUITDUCZqKMbh6IcyRPo//4pq26ZGviMNiKDB0+BpQAMa0IAGNBBBBBFEEIEDt20cyd4yxdv37jK5mTxA98Kia1znxqdbLny6/nQVn9qnO9zjPvffp7rbbXtmD2dyLy60NcarRXRXu777azo5296tCkCjm1yocp912Q4FYHNmSt8AWFnEl0s0ADHzlNK0SBiXyFAiH4CW2sX5sZNws96mOkqYG9gobcCRO30r2SjcFbZIt3wazLUMYAaO7m3CvAIz+XAnsEkfLORPtUGXvr6HgUj6vMKy9MVJSZ+uZ46n96u532km+0Ca+zavgd8k4wks/VuaAMV2RDYU6Z8JVumFDeQrseEgWGR5GO+rYqe2DHgNpUEJJbYoDui3vyHR6ueB5sFgAjKlaCjDemlJXVv1hO8PhO+TUD6hdSP7Tq72L1R1eP+Dh/cF66YYm7a4x78NKnuioZSumv82/oQGcoK6TD2OpB5Ra4GSr6hvY2DLAqcsklpHOzpHEEFodfav37ALKlWPOEw9jBHTzXjuFVU9VNbXogMRErehJeKpVOofeI7DqOTvJTnSqdHUzSKiLfgTU+Za6QdpfAelmq5+gByLpI5KuLzp/Urt6ALleFORaSx6W/YbdAFd1Id5abHUFQcXNn8Wz3qkNVAYHf0CqW+zaN+g7EUwblJ7K9OsV7K/qhqVXk2s4okpDPE0C90g+pajxfZ9wSrP4qa2Es/6R3OpEl1EKyJ+PKFCxIf3A6lZVZxU5jfx5WaOvGRuUPeLAMghdccNRqV7qG6aDTwz81qxI1TLJzT5JiFEdE3wrzMK1S5oZxcwx8JuIT0/vAvcumjThioTU+AbxtWgYVimlEph4s+Bl4wWtaqHOgt9W7o2X0cXpMWMiUg3w14N6ha1SCSk1I1rsXC+tcs+OsHECxf521DEklsy7PUPHP2Fx8EA2ExdLcwKSi9J5mZ9EH2bixvvCwuDdrlps/nq+8GiefGjFZRDkG5gRnK98U/xHBLJYCgdrYuyhxCVQmy+W5e64GuJExISPlZdS3g9y6yHmOc7lClcbIC5ZgZZpVa7Z/EEMQRln7rG1cK1eHwXBD3wIDnUPuL3zVvYrE2DixTi8LWa0pS26CPRfUnmxHnkjYKO76AWE89Rt4sjOEZNuZlyhbpuNXugfuUp4VoMIdrLWM/VZfifAz/8ZcG8pSDw6QnIPnVImIzLKLedVs+az0QjiR1WANvPOKF/CRId6hOGKdHHb6szPoR/Fkj9MHWdpqsf4DLoMx9Vu6CDjGmiww2jrEArEpRIKjrrB+qgEIB4gUEV+qxt1qb0uMVzie8/iO8LkwQ14h/5JrQ1n/rm9RCJ02nI/EBPZ7Zq6lZW3xsFViBjpZkVbYeu5RNa1qDRSFSufmDy+WCrSTl4QRbb5Nr8qlt343wX4oNUlbvJDaAFWN20yzQ5ea0FwtT3Zb2KtAg7/skbKnXzSZ+CXU46T8H5HV0Q1SmdXUCd/3Bs75kBo2838qYt7rAYQ63Mn2ZXU+jNjgNtZ7pAHwqKH5JP0R+1Ij+ao9rZL9ArrdivZ6uu37IfyFbsnFcyR6EvssHRguAuxidSwBPEqdpB6fgOKp0SFnSNizHVt2VU+YDTXagfG0t0Ton4rg7zEn1EMiPJfCSSuTs3+/cg+h+NGTw3LgXxWwp2qgntwDEvKgTNvJg5SFDCKbKrQ1LplGCaosIiOYSRiB36u2i7xC0LFX0nQU2TisaQ8L6FUucZf/Daqv/8r4ZsaHlKmJN40bmYO5AxVmX4D5kNmeXkaqXFrb6hUW+IHoU0qXWPjv1ZWGFnoTrwb/wXgDIOjVEFk06tDBHTIxKqSvWP//5Qi2TxVCUcW4A5P7aFdUkyTVlIA/JwkzZbmdakeRlyiGSMVIEfDw4hfOOW85i/T0KexMNF0u2H1JJnyDrXAhH/TtUBwIUXAqhRg6+skaThxi6oG9ROcnq4NnuXM37ovh2TBDXKXepawLnE1IuWu+loweka7zSQ02DTXqlLnFGQOGFm1gAOYLnHXjiX58u4aEEP7ZibwqYp8e/8izhaEH+ZWZM6fJziwCCeO6aLFbRvDO+CXZQv46KxVVglgONvN4qsj2i6zKygtqUT82oH5RkRgewa1DGY+5v1QVReqE5t1AD2EzJ9n7Rc7YSVSqd2CCVtCrn3g5kRR4Cnl/B2I6fo1qQeGaUHGrhyCYkDw3LbJOxBlhhO/f+MBH5uG+3OXVXVKVitGf5Rt83+h+YPdXaB06BOnGxTjq59br6bD/aVZjdB56hV4JD8REoQEgqxvj5PJy+NIrWoacWF+4/voMCIUl/39RG+T9FbiL/N+gg5fprVT2ujMOAvtjAs7/8PSQ7jtBVM4mHLfu7Ag3GW2CoxQ19xQxJ01qCbos98WiNvW8nxf/T1f8uU0x5h8nmmAT/IarlDggQce5K0g+5HvQmzSz2gvge68XYjqwqVNT1/EWzUjYMGUlsg+9+7Sfhs34Vw0PwL2rJ61Hc3/gOwG38dAvV6XVHo9FollC03MaMONKC3k2vzqzNXsNj1K/XBl9SORyfX4wOVRTjIql6UVDRUhdpE/EHKRUsDk30nV7ug1R540XaSnObkekTfqxCJgiShnL1EYoqY+4QsHd4P5PO33vuQxHRwitaxYgeFnu1Ouk74E9pJabw5X3Xss3ia0Ngb6lNXL7PS2co9iyex5J0tc6j6R3PReK/claludXayWjfs9Q98+MsLpqrDfzRG69Tnu38dSz0qd3X6IgeOATUyC7G9phXnUHpNv6khArTcqKx4CbVsaEMaX0Fs0TAGbbmd5LEwcgL7EAYCZ6GYBTr1jB3Y2B7hWEQIn3iepa59hhzYlfjx2+/Qvb9RnUloZwLmno6KItSzAEfuIzaFbhxEIzHYq/twNTaxEX8m5o6DMsUqTPBpQOoqUSNgOycxpiJgnQhyUqBUEWEmgXgGB1y7E1CNoYT5F9TzotfEVAi9XAyAtu2sj85nn5sCWEsVvrikFbhI1xZTKSXFwxQXtrLwFx3UxdQ8ooN+VOGSdVleWwG218fEmLaDzmOj/xj9x+g/Rv8x+o/Rf3zbgZmMm7Gyjd82MV3aAMwc4zRceGR+ZbihTezK7nFmVnafR+ZXxq2qNvhw5lX2UMWnzEfFpcxPxaPMW8WfLETFnYwIlb0hKrqh2lthA9u0X7jBAABQU0FJTgAAADhCSU0D7QAAAAAAEACQAAAAAQABAJAAAAABAAE4QklNBCgAAAAAAAwAAAACP/AAAAAAAAA4QklNBEMAAAAAAA1QYmVXARAABQEAAAAAAA=="
  , presale2 = "data:image/webp;base64,UklGRpoLAABXRUJQVlA4WAoAAAAQAAAA+AAA6QAAVlA4TCULAAAv+EA6EOZQ3DaSMum/7IVjfEXEBGiuAG0+SIAW+O2oJ0dtsQ1wtZdU4/+TKznhLdwMNpDFm4/vW60XWlet/t3q16r5t+/XVaqHjQWEGg02vl4NWuQAzFZR+GjUKQw1u0NYLO6bCqnMJgUhJ2BqLONJovnLYPheCSx+zHcKU4pD5ePPJgejLWfgpS5HbSMJEs/9L4klswgO2r3nLikpDtpIciQKl6ar9+4+8CdZDAGACaMwg4YwgzIogzJ4BrtBN1gGu0EIQxhCCHMF2zbd7CND9NJOnpeI/kuxtm39lKW4u7u7++Du7u7u7u7u7pvjx5zz+z60ukOe82F7oFklunR3iyyE6NCgQaZRh+iyA6bCDqy5u7vmX8Mhs4M3Ej3ROCR24A6NNVhzay6NToYbAADB5pfYto3atm3btm3btm3btrsZCJA0OCNLpf4zciPJSRWZZrjtLuEF1txK/utPVze2UnuYDWPrxdy4rw1YK+0ZMcuaYKt8t3dk95Ce5CG2ugaY6ybwWDPpsYrMpUvDqH9tjSXc1L9H1mCa0LW4xIxlVRxiBrPCjpnNCitmPCuMmAGtkGNmtEKKGdNKwcygVrlmZrWSmpnWisn62q5CEU/0xoZn0Mp/Vv6z8p+V/6z8Z+U/z9ngvSfy3qjwBJ6F58NTeBpPJ1E8L8/DU3ny3BmQmecbxQ0dgAiqL2ezlX8lwI078qw8k+zH8Mx3ea7oiMiZK2OOROSau4qn00HTE1Hg2U2Vcs3BclfZJmQJI6VaDZdOnqM3TaLj+SmmHjvF7XbRBgrflBl4c+S63NSW0cGcxYymw1O5TALom9RYKmeTLG1xinKDQPSKOXKjtxI9ZcvmsFJQCs6I3JH90IaoN0Gm78mNsr/83ggHmFrGJ5JDM1CY0YcnBQq1xH5dLSlmVDT302Ur/OuIYp0LHlpXGiQxaLEPA1FpoU6ZfJUmXRNuMDwn7mEmasVSh5U23XuSIWFnYR5qJ1kYzEqrmH3RDz5QI5ildFe5Wvo7T8WAs/fYBZosYFHxeqVd1z8RKnM1xvxDoYPLYVWA7sHQUOgwrt15yVJc6HpqMDYaYYnrVUG6Dgp4RzwbtpSi4/ByVZjYItCNQDdrENu0n1cFiv2YNlPENkvM+6EqVMCDqok8srEF5NeQQDz0bWS/VaYLZTwVjTeyXKnQ72AUOIUVRlzjnWpe+xC1Z2EfXiwsgKeRB4O0oOmOlf9r0CdmGFToiGdBNVbOiz60aupwwp8V+HSwgp4N8rpGSb2r9sgwcz+B7lPEN76tgO9sS3IRJKKmVheBEaHRjwOGm3Br61WcCaip15mfPcTYY6w/uomwgWk4oAiRidK7uR4HfbUGERGalcxLxMSJT4SpyEtwG+FU21JRgR1Kk8xX4z3NWjqFvcnWletp8rzOwKzXE6jsBIiFAEWX9lAEXdAjMlGLre9wWwWHnhGioKpGgCJnPNO42f9JwJLTMw54S/EAQhlzdPWNC+6iHG9mcR6T4A50WOLIK8b53pXnRdfsuUaQDD2xJ2RiFXDmnyh91wxjApUELI1PqLcZzHAOeV8n3ZH85p2XRH/8KC8rN/IV5HiKNx3Rh1dTq6CsXCunzPBXcPFntRirSEsNluujiu/QPu2BQjeeAAl26AOlFA/HXqEjcs/KiQFKYQpfY49twW+hFkF1NVANOrkqOfk/tKsJWFOUzkI67BRkWL+psWUTLy1W2BGK/QG1UPpaDknX1ma9GIMIHZt6V5nO5NAjAkQe2tARe1zG5oF2wWsu+aaMLcOHRU6CqxBj7ZY04ug1TYBULIe40+syyDAu0aIK/gxZIUJHUQGvSaYj9qRMrQOuQhJj+PJ/js/Mk+AgysDQrFhDiJFKDGngUbHoD1UOMYbXiY9hTqodEeI6zL0VFVmBQqzRI9GHJC+FH4+yIlgX1xQwJBLPrPIJiTGyTn2NSZJVKSuXB4UEG4J1Aken0dG3GX/k4cAjwjSAUVOPoVlsZ9b/L82vtl4FSaxnh7ytorz8BECKX03t2FKqqISB3udsNTQjQIATAYPMH+BCjaFhR6TmLhqadyRwwBAgwjBciGcF/R9uFP3/rF/P8KDhgD4casBQ8uEYA1xI+PAwY/9cPpThVAW+BvVrFvSWd3iWXOdRBUCIjDAFLDnhsENgBXz4jsv9PO0RR8vCBQvDllGEJRWINrBxJjbe9OLo1M/y0oIYiwRzKvw7aDBw6DO2eMLkKpD9RvneZyKOOe4UtOIesYHfa7ITLS0GA3ZVyTdNpUDuZxX+G4Jjod+JNbZmNgFLh4RrO4KmwSjwqaw3ynKpTOc6fDjW6HmIDszykuQcDzpTZiXmyNl3iYwQDthDMdc/+5z5cgp+j0FpHqlr/3Vkg/x6sOatQyrKjTul39XB04QN10Whnxlt5RSQ4tXAOC6D7SbM7mPsMdYfbZz6Rs+w/e08J9z/iiYjNRj6D71ecj0paOXZsUFw4JrAZZdyWwlmN/2xst1q4JeUW/qrqV3Q0OzF9458EmNoVuQpAJioLhIu7FdonGhBmc8VfWjBsXei9B8hJPudjgEX4p0HhJ5EDmwP71B8z6MD3QC6iDm6m8HArCk2lWZfgcoMhubZRTExx71g/Wl6NkKLC8OOH6FxpI3roG/SK6l3dQcWBqs5ip7Z7wTvEPgDx64faTtmwZAuLtQCdfUmXlaaPY3igGBqk5ANR/E6zf4CJxSnPqEn9cqwxYViBwi88F9/SxMZTuQj/eBxyLpLvrFN5SX4ybnEy6JIvq6aIMmhDVqtmSKOvdoRNgs1UeR/og1IWy8swN+uplFHnrZyiSOvuAr1CIceHqwgb0cYEXdy6ZOI9mt35IDhH7ocp/nBqlaCDTfqz8qIqqhQSilehSjwoH+9jn4jdW/mC6GdicSzWhz7vOaMxSnq4scXK+fIimhwtmPHJoeAFUhHcRaBSq45oWUL71AePeTnw1pbG6F9is2N3H3+C7xixQhHngEuJA7cU/TtH+Kw6YQilg9pnVVYPXd9oh/kfBj0Xy4K/06+98n7qtwvWptgXp7iDA39F1wlBJJNx7M7X3i2qFD4/P0GNxpIsqy8b0NwLPw/scbX2DLgwC2Rug/ly1W23jnySNJSVHhaeeF5Q4xZCFzuyeMXYJjzSSHrT4RGP5+ZTrKyqG84B4pojp4l6vKjS587zO0DTdrEmdwvr9F9ehUECF/2B0FMB0THEE/U5kcvhW9fdY2u50YiQkWMiTgTdP+NZAG87+ykP1F7hOcD6cAONI3zo/fn73rO3AIc+QkoK/UVQtvzI4gjmiNQ5NvoKZhS17DQzwQsOWOryEs7E0dt3Xxsj1plzl78QzXywuOMQnUs3Jtai6lK4Rn12Vs6Uc0bKCA7WlwcBnmnSJ5YmjDsfGfRVN4wb2a4ODrJsHNsFcUtlZBdFBu43+BFCt2s9woNt8Ufv8P57cZaCAUugRqLsRrJjZ/JKupT21NAen6WKQvFVNZZAM9NwWP9qn4v2WJvsuE6eesNYQE1YB2CJJzd1ugnbiVLjfk0BbJgn2SGpswfvxf2VZQseH/oxBvhdWZYQ+Kt7r42kO2p2iKvRvoS9lm3ryllB2eEuVhakm+8K8dLXFPSUY+k85eUnTWA6rwJZc6uJKL7CuUTIn8cydrSgdxoigmHyvwJlJ5k6D9m+OpxIrZ/WZ/+erVbbDprS7mTMkVvjaFa37RZc0lZrlE0gARP0DcFl2kSy86RN7/iJCnzJCIRuWlUcQz80DgySkplw449ZYpTO8xAJ8NYRkcknV3PXBnD1FO+3DQeGHJi1INdW0aosslmzHx2TBYAUFNBSU4AAAA4QklNA+0AAAAAABAAkAAAAAEAAQCQAAAAAQABOEJJTQQoAAAAAAAMAAAAAj/wAAAAAAAAOEJJTQRDAAAAAAANUGJlVwEQAAUBAAAAAAA="
  , presale3 = "data:image/webp;base64,UklGRqgMAABXRUJQVlA4WAoAAAAQAAAA+AAA6gAAVlA4TDMMAAAv+IA6EOJg3EaSoq7KP+tlOHhGxARkc2DRcqsLVFRXALPURUAhCrNIrC8oIRMB8sz+z3nfEpptiyvLv+o/mbNR6Hz/3B0MkGBgFgkYIMHAeKgBkhqoByRg4HiohBpo8km4DvrffwQBgOJCD2qCBzyoBzzgAQ94kAdNMKEJJpjAgSRJbbML5nRaUHIiPkBuBICqmLi7u3bu7hO4u7u7u7u7u7t/uXTZK3fv/Xiyzu8DvAXoXotXzOF01IyRjmMGBnDrmYCOYwE4t22ber4vtm12SWnbxn+wbdu27aSzbdu2ce99p3Fg20rcquI7JccQG1E+ndhGtlUlpiHiP1qKPdCAIRGhtmCBzqwit42ULOOJd/sCOtq2LZKVpZ89nDXgbnOo+t/nqx/3PWlVz1+4H89xd/cXdzJ3d+uMvCIsJLLM3WED7hD58YiLBXjIAuBGkmRZ8d8VTAIJDe39b6aql2jZkSQpkq1pfo8GOyNy4OCBBk+BJwEAALJtbNsLZtu27du2bdu2P9u2baO2DQZuGynK8jHf0Av8bywUkCAiRfqFUjdJUU/tKVNMnvwHFD/6qZ+ny+GFaT1E8+Ulh7Fen8khuannGVlY8NEJxS1cScOplCUjkSn8O/Z4EtoGSbm7UtboEz9FZakKGdIulkRvgdvFOBVBHLeWLSMUNbxk/bJ5mgtZnyqgDDI3+2f6roGs3vFadg74qi1xFFePqcAvI7v6YKIP7+Ti7g/HCj1sl+iQsoGH03H0fsAOJd1GlztXyDXFVu+X5q6wjBiBdQZvk5j4jbiEVObxM5zgakrlTOq1BwdeX/BTkPujUFc9Fbii9nh4puCfpsFKQ75ep2cgwff56yd6AtVj1vqt1xcKrus58aORO8nkKdjoDsFDYjE6gVAQLio2ygQQkmFJHunJWKLytZv0PYMGFXXSscJ6EU6CJdi1SAkoVcpEeKhosIeI/PFLx0dEo3Pgv7QmrT0r2EuKWLDmqd4U9Z/KMScQZhvmI9IKrA+eJI3B5UOBGzCy12t1V/iapIvFL6zJhDwbdKjmnjYZs8FeKcedNCCiO0ZMABFAVQ4RVWetaf0r36PRIBVuIBa/N/IBQ1lPDx5x9VEOyfnG4b4z0AzjlOetDb0sXZo3tEBGQ36D55uTOKHj6jtbTMwKPNfssKa7ryANuI5pJiDaGUuAVrA9uGUnyZ36phi/NaqNRT5mo11zbBslICMhb5Ls45CyDztRsDOJ2GjgoMDPtxSwEyjqBYcm2Cy8FPoFmZHwbfubp5oQvVEfxdKmokSmqGEOSEbYPNtGhEQs0qbwsBHn2ZoFpql3vCaBN01xU4TvOwp8kRCTk63rgVN+x0AD3KTB6CdwBWW8ZFtKPfi5whUST5jqL8McYLlto8LfQ/atR+0+OBL7HZ0kqfjhNQXlR6x98L8ZzTYe/InSbdskFwpXWFDWkaLhJ2KL/pNlhxUwSKDZDqWBI2mJyo1BfUyUfSFEzRs/Q7CdJ0sCZuG8nRpLvTfHNGwG0aF820Q0eCdPwdKFMWIx3FY3dZYzKP4TG+GGtggv1iPUnOw4GB3zZInIQfsjOXcv4CS4FxF3qY0IBLXI3sJnF+Tm4H8TbNn/MutWqCU3BC4Lb6aNZY0OSRsVsW6z+UELt27+xsERwVyEq5U4r8Vhi3aGkGy/LCgtWyWzQwRplLvaWGC22rYbeyAZlyjmyOAICSKv8cXC8mCg3zBYAUpYWVdl1gTRPNsGMSQxRXnjwNjCJ+5NkK6RS6ixPU/aUN+Ecs4Ytq/fc5eodCUuBLysMH6wETh0QAUni95b97pMa935oG2UTSyZeMeg8MeMEJ3B6BCJnkXXbKNE6bGrCCfhFrt/NLix5NS+2DkeeFgEB024eXeRKSqtdOhZMru/BDaQDMi4PpLSG7YRPrqk12H7QdlGBSH+e+gmqPaxkH052EfEcSFz2ChEiP6A3M4PzV1tifk3fd1KSgQw5mQQIvygpVqkltw23gmBpjnd0qh3xDAi2/aguSLy89Qps4MII1Sa/XvAbo1YaRtdEeTNCP0QMg3RNjn5hXYYNCJ8SVi8WnshCGIdmHMz0jbfNuFKWK+d6gXlMppA+iR0xHZoQ5jDW3RTjzgh4YLs/VF0upIWB8zLArb2h6yqoXXClPdMsVk3n5CudXICEzaRBlyP6zAmnscSbSstDEgte28zxJzeBOhfdNn2hexI+EiI6MhLq8/OP+zCzSywACe4enZ9q8v/2YvtbsuEeUOgACEVhrx9HkhBsbal3clsK1sxoAbaRIq3LXnzMZhNxBpk4dZ5BVy4GICDJgS5xJ3+1WXlmfb+icSEmAxpvkh6zeYgRNlGF2UPFf2iEBYlxGqE0Mn3bCveqj7D8EmU3GEPhcgUJcqfYMzLKmSlEv/wy9DWsvbqGCE28e/RNXoqha7YRpnghTLxe0WNA1CRPV94id7aoU9RWgeShI8RyYqbGTjpgmWFeUFeJrGwbCKS1PorkTjASLsjXroCmTnCHp4sPBvUCF22fbXwYtVHC33eBS3du855c0dbrZIWT7gZxWFHfwz0qrTSYf2NYKQ9gqszvhvbjnB1ZwVksVWt8Tx1ZJ6OAO3+0fPQOGVlc1BWzIT5AGM+NtDRqqbPNwIThKRbyaUrrrrURkSlFX43o9n+pqnTLSDyIswLGOPGoWnp3h2dvRO9iIBpNiLedsib1LiMWA3tIbqH0JMPq89kZtZIiiQYl3U9Zs43iJC8Q+puDq3VZA7tNFImzjfj/w/gP85IGCE/oM5Zk1R4K2p9tE2ZvhUzsL7UD05PhbiB5WEWzWNm5dExnB84pJTLDyIUQ/iP0awek+QxMmI7YkNjjqiTeuiEIgeEQJSQpzRUCkurg39YF5Oh4nOUs3t3jVlZ6WRke9n9DSAvRrgWfTEmXiAl2lYoSBypO40SY6EeY6OOsHjnvAI6DBkxwSSjYth4pyvjjpDZjdo/tH25zbZD+AeIw1Yh4k+Qx1UDD3efTlerkhbP+DmA5WYSJsZNYJSq7H/AzjpsWc96NWP4HNtDE8M37a1dqHFp0Q7w/1LfQ9w0OmXXDH+NDBsuBiHKD2klQ8eMWf43Yns7sgNEhI27k1p+FBvqEcpJDPJqjjvpW0CEEuQCFeVi5tyhTorA3y/i3XV7maI7iZ078ZYfgWStrW/zg1JLByOjxsnttHhHx3vrO17Lgbt1N3eSWXeEpD3zbYddFt5ih9VRp0qxbZ6sv9HCjVu8J9ghswpXK3H+o2XdFSBI4Hdw8w/H1HV0kO352X57/nn97flw9pzgO9mwBydkAKHZRunC0R9u5owE6YtJPTjILHjnFr11TMNmUUwo3zYR1cTbx/vBiTB7KytPl312J1Awodw07aUV5LWusCyOtC3Jo0acp127ybpdIJpakcC83tMUN03F84kCXyT4XLIem9Osbby0QVf2HmxLqayf1M1s6s9f+WP/firSL39K7gjp+uW/2A788huefvkzEEhdfqdwaR4iakdihPlzl3bECx2PnJgTeKPZy5riW5F04AaxmYiwbd9xcsRy5EDPwA6U4nOlvSlQR43fnEBtlXvYZMyW9oyKthpGlSsSVF1fddbaZo0eSyNN2nzG1xUS6vjhm5MpKlM4+aPoWkSClEpkjO8Y7DtC+OPP5y6Qzl2YdiStOivYNzgTaXJSDa2u02ySGFqWyPQZRn1j9cAOGP89sTozpZPMBh2q63fRXO/1rps6jCZuKxBdgUcfvTl3N3lr3pG5Pwof9Qs7B1XK+ZJ5n6QNWj7nMjMC8gSoPIu5MIXcMc9+Cu5j5QJ6vpvzSditvvTNYmbkddB4Vuv2EtxH5MF1BB7Unrfu/TM5unFnwhLPcMjs9iGLPJoCq5Ec9heUKYNcvApcaNfZ3u8vV6OAiutpcfkS5ub14FbJYcNo/XJ+gL1WVgwrE8/tPd2usqSM0SvJw9xR+iA5HowK16SYQZJrfsaHK2b2UEmmrEM5k9YHvJKOI1wtFRnWi5ZM4at57fi1HCvvM62hR68m49e+L+Sy719znOWCc0j9P/8x3X+m+890/5nuP9P9Z7cdavX/NmNTG981Ku0dJN81xll54VH0lfGGNaoru8d3ZWX3eRR9ZfdU2sruq3SVPVTpKTNRaSkzU+koM1bpJ5ui0k4GQlVfERPtMNXXwkG1Wf/ihgoAUFNBSU4AAAA4QklNA+0AAAAAABAAkAAAAAEAAQCQAAAAAQABOEJJTQQoAAAAAAAMAAAAAj/wAAAAAAAAOEJJTQRDAAAAAAANUGJlVwEQAAUBAAAAAAA="
  , presale4 = "data:image/webp;base64,UklGRiwPAABXRUJQVlA4WAoAAAAQAAAA+QAA6QAAVlA4TLgOAAAv+UA6EOpQ3LaNI+2/dq73e0XEBPAZqzYxbGCyHs1sRkBTkdXSqf/PkeTQPSzKXSgGUnauqwdavTfzL9Pdb/8lP5W1vMBUOAAqXxICsZHsmfQAKBcBZZfdWwdnwwLQQBQthmWxVA7EoJAJxaEArGGwWAbAwpBlIBD9REDZhsLSKAbJkjgTDY4BMQQuFRq3hoVwrEn/BGSxCICw6B0JV7FtC0l7GtEA1H9TmABn7zOzHbSR5EgUPm1X92f+JIshADBhFGbQEGZQBmVQBs1gN9gNymAIIYQwhBAGC5KkKswuBDwWND5PVFL5pdv//3I7GcUt7u7u7u7u7u7u7nrd3ZY75znn+VfZIXSZAG2pfi0LuKwQanfoMgQ6gm/wYCWvbHBHgAl8g8sGsRVwqdylonWYIEzgUjps4NKlZgeX1jfw2tkg2uPOU1GfEXDZINQ+gt061YPVVC6/EbARvKNMjcMMp6aLjoDuQGbglQ1gA7cB7NZULvfFBD5BGEHhBgBAsPnFtm3btm3btm0ztm2ntm0vCtq2YVMw+tau/w7cRlIk1zIz3b3AGpzJ1tLVjc0Wm4wOZsPYZFaeGw6PdQHW0pThBV7EVs8HjHpq85dThlt2CrHVH5jTPJDYc/YpWkPxImPmXvY935qLZysuZpVZk/HWD/nIzKXKLjOaKqvMcKpsMvOp9GVGVOnKDKnSk5lTpZYZVaWSGVYllxlXlcC0XVfIE4O5wTOo6z+6/qPrP7r+o+s/uv7jaU7whBCIQoiG/fMvPAdP5Wk8necjkTwvzzPLs/MkI+5hA55LqOsrQHEp9ibBbBaerYFrl+ec8ExRsjA9nrneq6jNxlyGyPPzRNTU27pH3h61WRopE0pgidkOwAZkjKTYu5THZjFPZtfrrcjhcNjqAnqZiicbxNoQNXLF8A3mUWYsHZ7KYxKAm6m5qZw3k6W1nqI6Ywojz1KRr62EF215c9lpMAVnZI2thIOKvBmMM22rZNf57E1hF9MzrMqNswYAz03EUyT6F11GMmMS+QrRWsS+jTXyYpstXvSiy4ESQaioCshHyXr7icnvciIT/UkazBDHyy433r/AISGsoR4ayTpjwC5XMvvJtlfEGjx/Mf6U0u1y5tFPYmGD9lw9jK2Kt13uvL0qBKRnGogmMC67Angfhh7RBOMWKupLYoFhhXzAFyVVsIZQWkAhrLBHDb43CUQB4HVXGNmy4C7raQVbiLZPXYFkfxjeWJOPuGIg2L5zhfKu4Iz0cW2xogmAdgtm3zB8o/YdNa+odkade5p+AwxfOZP6BTWvqfvA0cx+YP4H4gn8JDQYcHUhmow2tXNmXXGU8vMRMKdmi9/m8lxCfpj8R9aJ6XwENnrV5QK42jaJOWZEOEeXuJZfymDjNK+gcQkw+WTOzUQtvwAxjVmXcizqP0Prhj6DZkfrJWVfRvkVNWdPZ84t5yu4mRetckyODDNvVXBIEC0e0JrtYKQDk0+oXyLrsuO3JlGXS5Bk+IIqEhZCOcemS1IotvrTscmk5F9C5nmRVniR/8iL15LcQFmZ/YKoSOXAOWBavEYT7dTkiyonzI+U94Aqas2R0aJVntIBjd4JvFTfZejsyKsNBeLIeAFirhjRJl8gaxyDKzOijfSo0k9L0RWnKdKKLyH7iBip6CrwyKd0yFh1UdSYIFRUn2fPaVyS8J1JaIRnwdNtLLXTHBv2E1YRv8TQWXc6ZfIphmJXe0J0j1QS3Xvq3EPnDkQFaKSmBlk1M6KGwQsr8hks5ZZESrz6tCBaHXj0nliKqsmF1FxYLeWI9Z9ZgqwcG6rAE8lQETiQ7Ulcp5eVmLfGPpMPRIRUjgyXY13GH2AMXtnE+IPG74jdeO6cJqM4ClZOZV59WxgjwzekHk+I9EvWd+NyBBMRJnlWHFHD6bFTomG2NcsoPSvAicmWNv2C0TtyAZRxzgUQBtMfpp+Jn9BSyCp/uLzkg6oBk7Q37l12QSG0VyQduI9g/4B8x7ipRualBI6vYIkxa1NJxPWzr9uVzURvJO7xigavKElm4PjjT7B2WaYMXsCA5hUrCVWMqDE50tYjqnCEh15uKleNXAAHTzukkpL7xfJApHXNatsKk33yao8LfbCc6ilt8oDkw/8cGsy+3ty7NA/A/Kk0mE77FjdNZ/gK0kcJTzwB0ZJbTo2SVMWoi6TMUw3g1HTjGb2x+3fSCo+IgeKuCE6tzH+RuDsBous7pLFqU3OfDXgY/Se2qSpRe+VDkoyMaMEuNZoloPeAPCALtDwQu/70HliRry+RkjDZ2Q6aN2eAEqM3FCfZtf2kFf67CIUh7TFLNXaQngVPlbOoJlXNA05XnivPHt2RwotXKwlk+o20k/EdWsTbfPg3Ru0VQEjpkGMCwHSVxUzW70pCMjDdJIFia4uScu/Nt1PTz+EU+uEliv4T3C1GKohzbjkXUJevFLksCurjuztIwo2r/4Q4jfHgOs9eDZ9/7bKteHWNK1xhVY7D52c6VukQMapdmk7jT1gl7bOfsDo2GSK6cegFN9H/0CXswDjWvNTBiyr0EbfpoldfOba0b5l9U/Z1x/K4tm/06sAoMarjO7gJOlKeI71HtmqiccVqUhbFKWFnEnXnw+v1HlG/Ao+6jyzLUneWcp+N25wTyR6cA44V1yAOVXj0u/AbXpc2yw1WB4NnurLbwDyhspIXKtB9QM8dAOpVFirNpP1FnAODfYIYsTC/AMeonjH5oO1oDSkHot+IE9Ni4IL3iKPPvN0Bk6fCb84tfqS4LakqJRO1Ik7Nh+jZ67KvS/2S0JwTFyMoasX16M+uznYcGBHl1d9/VCvwZfIB+D9g7MkqP4WM0pyZ7wYylghROBUe+SwUNZ4NmnSTQc5Nv+3Fu5GKL/OCq+3w2I3KsvXn4iHTz43DFDSG1LBOzTaH7gOh+o7Wup9CWmHdugJt0MeD9+ITdOvUWPXmlI+YasQJ2rJrA7he40L1vfjWrs6jsJzjyrbq5wSNC7arS/k6wkrJT/WEhCraRhsPXgtES+/+bcMBAMNoXDLDbEQoPPZ0Fyj+tG8IjOk3B7evM6SElKeI9w9LBfUPnX1ZVmT6A4t/dNgwdkOK4GVddZthck9edTSGSj3uFzWv0ZApy6b/6NryK1IKP0atv4UNV+FjTx6dY83qe/zqqw6VRAqc0DJMnViRL8/e3ZGGB9cWJ2ujfFBlmNUNWrdI0pfDEdG2W9da+CBrdEkLr8Vtdo19GrzSWmmfbb6rsaegif2gQSmq7OnNUjgpufkIbEejD8SoPd8hVwDpjYqRFKMmdyAO4Nyi9KMl5kI/wmOIPZp0wMScmlXESjOebY6oyOdGKsc0+4bmDbJvGGnCe0foI3DCDeDSppd/dYA758ooPN7tL/LEtBI58PZrDTtIb2puqsA9mXzI3vzqQH+P/jK7wQt6gubjRS47Rc0JFyD60k0Zsq5qJXw0QXuq7/D9fBC/itsQPDu+iajXXFOpdae0kcoJ/EWdCFFa/pfXvgMA6N6zMFYODcsKFak4e0HsBruwHuKza1qrnNBXcO1ojuR94RT+MrPYAfbbrHXQ4pAKN1UWw6nZtkLEFEPWvAQAzLuRC6taCu2TuMs19tg8YGxXQJRW/CQ9eQ7itZxbx3n3699f0Up9ZHjo1thB6trfWnIq+gvvxDypR70OADCca7sNLEzdnFtqsM40LCL2qA/PDRqpNEA/LcnpGsemelo3iZBlyZ49yxMk8XICzKN5xTxg1ZWQfaF9SpBplRuorRERbb0HdAnDV+w9LZANGYmwfMBRaxXArmvdjdg0SnmM3sDATPlh+gWFOW3D55pNTP3Wn3LYmx57E71TNJWw36bpYFUJJlmf32IRvfv3U675puXYdGU7WaUJYiVlN0jDigIeJqc6ion9RdSGAXpDuBH71iJZEPUmVU6RacEXLIc+g8r1vc46sIsbhwn6dXilA95UGKfFWArLxc7qAGr/SfK0CMuO/one5LwqJ+xTJKs8/9Fn8QetG6QYTrL+MOKYtefcYgIuDJp81uW5eoFFCtd2TTUSg2cw9JKdjmg3v/DgEVbWeZ7n0raBEw9UTxGp5ALE3L9vF0IrStnJqTxL8VfSfj+TG+SQGUct2z5e5yuCH7WGyL6tET1FzUeZkHPDwVIvTG6g5j4Dx9eRUZuJtW+xV1spuecXrEf3FsWz52SD8eQ5RGRZUcTi64vof/aSqxSW3KO+ZgJQpwyTMHWguLID5wLYRu8JpWh0bDq++98fuV7ozPzKJ634yQayEgDp0ANaw/T1Q6+ddDB6Bw9i08zLvvairCvivwx7978kPWYKIOUrqMshOjZekMQUREv3Hl+ReBOmqL5022RIAGyS9ufNSeVUf6Msy76p+h5v9OIzxLA5KYAQ/OzGfraix+K1Zumvif6bdA+mHTW+yUVgLXDl2Eo/bd9h/c6NfYOnntKBuGETdp1dnb2WqNs1dskc2P513yEl/k/WVVmKb2JfdJqsKFD6GcdpzpnjHY//Fte/+f7dB87F5yafSDXsPCBX2yaQZsdKUlQT4a3w35c00aBnvUf+c925D7953zHv99yAT98WcE3BpV/w8MeuQJ5fGvwUBdNWrOytcNBgcYiyt9QRpeoriITsovCmFWx9jD8HbX/XWWQYib5YZXH+gGbWFhdGwrvaWH8kGDzNWEAmWkCp5HvgXYszB0QrtpjGovimj0yEcAOiD/DBdJ5Yes8C9Hw74s0+iYW/j/LDzlDYU0E0QrAXOCMn471vJftpJ2IfZoUn7reYkRwyS1H8n1H+bUcDDOQiuyL+HqfzyoWGqDbBoEWKEUqu7WQ4r6Sjbsm3Es9shmFsZuGoJqL8WiI2rVE/Iet0S7aJ9sByGoKDSjl00d3/mZEbO4nc6TY/+vFGbO101iUpx3fytWGG6apmQn7jWgUDDVFWhlxyzSVrHF7ayzroXqwbkudMI6iIaG32KGqUHc10LH7vkjUXB3teGGyz3j0CHNSzZUUkDNdnOF6abUiDa7M8a7RmZO+//uxeA1iW/Ukv2qfKaAFQU0FJTgAAADhCSU0D7QAAAAAAEACQAAAAAQABAJAAAAABAAE4QklNBCgAAAAAAAwAAAACP/AAAAAAAAA4QklNBEMAAAAAAA1QYmVXARAABQEAAAAAAA=="
  , presale5 = "data:image/webp;base64,UklGRhAKAABXRUJQVlA4WAoAAAAQAAAA+QAA6gAAVlA4TJwJAAAv+YA6EOZQ3LaNI+8/dur1e0bEBJDXCYEhuAPYgoYaYMBt8qUVtw3XgelW/79YU7YTBSKXyC2TBjaGBpzQ3d3dWdd5739+n9/8cb0h/didO3dmcb3/jPN2gTXhXoX+ziHyPtY3I9WVGI1pw92hFzbjkFGBp5o6ZIQabk4t7nSwkELq5E4Nb4Rz5Ni2rVpKtaVGZVWhQUToEJFaGyDXLjCIaACRu7tD6O7u8t49e+1bY8txJMmRZFWpL+vtrnSParpHpFVHFiTJpm3Ztm3b937Ztm3btm3b9n22bdv2O+oJoFPbdiVJ4o9aRv/ik/3kzby1hCMs4QgroQSOZz0cgUY4ZAWOsApKQBGOhDJWQAkcsg6OsYpI//uPIABQXOiBHuhBPeABD3jAAx7wwIQmmGBCE0xA2LPLgEFCDiW0H88Qe4B4CnSFFV74fxgsaBifGj21p8yP3tJWfkzhtMyP4V4WM33LgKeQlqq/XwOXBnDcFim9Ae0KTod+J4ecLEJ6g1yC13HPBiSLjN7Ar6rjWwJCj4kaJuRLJ2oJvEfD4rBVne7isEZCqHAsOu0CbhFQw4at6tTN8Y/47CB/dIY1wSo8c9x0ngVW0ZnjpnPdYRWcOUfV+Z6wiq06XnXOJ+xSe3DTee/QZbbipnMvuEmsw0fn32gCM6foC6zOLq+E60vssEjrA/YadKNJyyn6Iquzy+rE9WV+yFVUzv06tFEkdeI68W1S1L3cZ1l9Jh9BMM4Q0UzJhhapYT3alMyjk6ugnHtqPkUX/Qs/0kewBbsp4j74DyQDRPBOHtoocjpxnfRy94q+oS1SSZkMGRNyV5wP4FfwL0AAKYoUBQJ4O5eOy6lxT8nnh0kLWRRPsFXxEOLRZSBSBX9jzuaimS6lgFCn0yxFHWXlKCmq2nc/5CpIftGqCn4WuZVPIUnpIulkP+2UhUsxFbw+0LKCT7WnO59KrkJqhDCZDYchrMINuYHzGfx9cybgCnRCPtroMjLQiba9/8vgpJoWmYhF5GurETyqbrucLjYZfWjT6LVpTmY37uJaJiGvQP6ZicSgQRkORiwnGYo5BcJllLimsU2KxqEhOGiVbhAD4yYyYN4nizT1ykkzXyI6eI/UNkXr88NVcpsn0h9mDGWKLiaWokvwGPjd7O12b4Optx2YcM2NcZfdmHjdjen27Gj3PhiUhlxRERTyfghJRKBjzpKicZE18W6aQLDICoFx7Dp2HzwCHijeFHhvZvvMuX/HeMsvjDLzoMXUg5GnH0y+/sK8RybWexOkIavciEluF5uEFo4xfoyycrhh6HpbARwH/1rG5e8GbbaeaD75oHKaXQeWuj6RIviXTkBpGMK5fXgk9OEZ4577RoAky7zQmYnxV1xImWrziVn27ahQ/PMHQiPkbriELrYREIHAKOQjSLk525JXgik3nkhps+XEAsd3VCDfxqUz/xHMr4KENq7B2uaXwUs1tQUip7FHwcPgeYGH4M8saz4Jpt19YJSZGy2nHrx++aizN2beu2O1+4GZgd9+1zYlV3lVTPlpML4ElLgHey0pnRNRhK361JMENSXAiIhLQzN0/y2Wux1MtPbCGEtvjDp3Y8ylN6bYcGHpaxPRX2EGkLF3YlndbKKoinQRNb4Hq9pr35Oxb6uZlOj2Qyx+eWK+4xN9SoMYZGYPCIzHwxAppBFYRO+x7qKwQr4D/2awQQe+/PIgM7MY28TYzJKi28WzXIq+wRhLdX/jzVmqCvwXuOo0fCVTIuziWSXFpGovkQ9uttoBIvgRaHTalMLOv4fvkcIGaXl1cobnoPKt4lzbFEOvXQCJexSfZqPHE5mHRkApQ1hJIvhIkFSTyA3RptwrFHywCGjjGmOLfPBKwxK78nssisqZLEcgqwRPHVzLD/uGooMRQEAX2widvw327wVbAAryGdWtW6cYQvy/tZwsBJ/dXwNmIfqxihUGKuCQeUZIeuxFGb4Z/AOmiKZyCMGnhej6jGiqwY+rWFELh4QMH+w1hCvKmaEqXtL1HVZO0Uc/Vo5EuEtDZqPfX9ySb85HIRcFf2UCJ18r6kOTkEIdyGfhSryboizei3wg2OGa0pummDdoSkOHIJcFooXW9heLTrOJfopc/9xsuAIhRc0PLXr2Hys0NhEd9IFQVNQpaRL5WsicMyah4z8FnHBVPCRAVOh2pVMo50V/HXQE8trB4C/kO/DBzRXAY2R1GLvxLaKNayDfCWxseiSitUMvnGzghBrCBVLDofvvL+5yXvROU+nWSxNjCj4RuYlJZzyMQeLNZoZZibUFFZYxEZ20gRAagmnSCX6jfO9F7/9OPtWsFLwDfhNxJR6Gnv/7weczlRDF2FeYsthaRM+K0Uc1n1XsVpdVHLyB/W1mSidSQ6GoBVcRV3IdZtN88iSgWaqWa5ti7jZuokhfwYvId9izajK/FlpbMAk83Sg29/lem+Zk3iZFE3xa6KyDQFz5lRrrTr8WrqIukow0KEGGCSFsnMH+JM4CQILcEGzWcRP9OiYJ/x58ZqJ47xtCCPxHELEDfj5Y7QdEfVJDMRTdCEFIF89glI4oI02KH/7f5J8Cr3yp+BD4f2aChoeFyrMVj6n9in0Dztx9XFFGViFXch1K0EhtgVR2xVhumCEcBdkYU14CvklxQLVtlP+Ms1wsupTHwavAJGXyBtnFe/UqqpCkpI1rqC8axjY7xUWBDXLKCwkGDwME7IbSiT3SQiH9Uky2qD02iOo/h8LDI7CYOj5UZeLDQkn3Z0/FRUxcLR+qHuv/vwm9F4o/cZVzpo8QK15CxkU+edJn4Qo998EtqELQEZ7+sMevRfLN/XuuEHEVdM304XaAzi0p3fH6Mk5cZX1QXoU5t7A62V5E4lBpbxyv4QMmrupsr8CcovLu8HkBjaYS38k2u9BxE5n+h9vMVgikMq8HbrPa4VKpV8dtRicUlbs5brNZoajkzXGbyQpFZV8P8j6H2uBW8W+w1cl1J781Andwm1b9Hw7TKDSHZBPqDptGYwHfp9Ib+Fsj0h7w2ybQG+SikXk6eFrGqVeDXKrG53cDjmsZqn5ShlyqxqklB/y5ev0DO7cG0K6qEftOzo+5PWkrpaTUPPNju740epcztczv+7O9q0bz1/v7LlDu+/uraoSDRvu//qv7r+6/uv/q/qv7b7cW93j7V5Y13nZfIq02YI2y7vz4WHzt/NKXyKqN312jqju//1g87fyxL5FUG0OuUdSdYR+Ln53BfYmc2hhzjZrujPtYvOyM7kuk1MYU17+J+d8zM83sf81kRHv7ZzhQU0FJTgAAADhCSU0D7QAAAAAAEACQAAAAAQABAJAAAAABAAE4QklNBCgAAAAAAAwAAAACP/AAAAAAAAA4QklNBEMAAAAAAA1QYmVXARAABQEAAAAAAA=="
  , presale6 = "data:image/webp;base64,UklGRoIMAABXRUJQVlA4WAoAAAAQAAAA+QAA6QAAVlA4TA0MAAAv+UA6EOpQ3DaSMum/7IVjfEXEBGiyNPsgoR00wW2AVUsHmqkpoMVSiv+/biTxRzPHp+VAU9VEki25+q99RzdXNR0dA8D3JrEg5ravABgAC2MRTBlQHwVAWBrDsGgqAWEU++BhAP1gsFhSe24ci2FAGEXjEYogCYl5nBpHQITAXBfNK6BcleuPQJPcGhII07bN/xdvxAU5aCPJkShcmq7eu/vAn2QxBAAmjMIMGsIMyqAMyqAMlkE36AZDGMIQhjCEHEq2DUf3UgzXm00S+wfQqbZtueVIGWZmZmZmZmZmZmamw8x8jrqN/7eHlEzNNb5rujEx6zgYasdEHHDigCX8gY6p3istU594SBywA6aOGSTEAaencgzMigMGCyxhWEHEkIBTRcaWMDamjgTGnmscFBDYVdZ6DIQTB7HANWkgAcyJBfYQAdzTkRCSwA5y2lRTJyKwThpIAgAQaP6Sbds127Zt27Zt27Zt2zZOCtq2YTGM9a//jNy2cSQ7W705T9kXOJszv7q1mVd1rD5rk63+FXFgVjo6ZJUNgcX58+jQHSU+WQe7ugGwVjy+NGcpPlTUd1nYw1d09qKuaumsxj/ml0nMXioZxGymYo3ZTsUUs5+KIWZDFdeYLVWlZPZUlZDZVFUks61KKbOuKmvJ2s1aIScGe4PzYeY/Zv5j5j9m/mPmP2b+4/NOhACEEOwKTuAsnJPzchqnQyZncCqnDGNvQ4yc5wIio8AGIlM72i6lESpXy9k5iTM5mTeceWgTAMQ6WAucIwGI7aLkFbWoI4C0s1MsAk27cDqcTxOifSJjBC6G3sDfYp9ISEAsoV+v1xMblIzY5O04V4NmUNtj62DNYUXyw/MIFk/gdV4sD/0mu7TJKxZ8ymiPxD4Be5Wdp7V8c+ZLMB/OlrtV1swaqHsbYB7RcDYn8cke+kaqYuUSztWFogVUqwYXQdYfe02OCnmIaDbk2wBaJ3Kyh469ASoEfQvsaAfnBjjZCfibxecNcSk/ZjrguR389swb48cnG1K5V4SXUHg2ljdKVrfsCM+cy/7vfP29YY5/y66ZE91gjJKfKL71xvlWerOW6je9QBL9ma+AHyWXkGi2EIPsK3QhUmwgAHOhhJRbQebfYt8SoFcji772lZFdrqxJ9LYZo5viN18h2WeJjUhyk0LEThD5SvleSmp6UlGjdlPoWrD6hMU7LN5g+3NC7P7P7Bl6FzC6RTkDf0sGO2LLBCNp9WdZsZvl2ql7fra/J8D66/Lkyq9wsexrdAfiIlZYEdAamkiz+rxGSwwsP8/keSbNn7D1Zmn8eETq+0gRZLeoD6tXgxtwgpU4JziI4iPwThMW71euTX2dAd458F1BlzostcZo831UZ5LxXOMW+bHscrkAm58zfTqDmyMpykPpDVZIRsqYvaBYtfoqAB+MZU2O9gns/q9sC6Na1h16acJs8gAi65/TPESDOVQfhvUnSIq2UsBZyUTCzkRI4wyuEVy17jAD4FewxN6x+7vs6QqpUU+EFamw+StoWtVdhNGpJ+K8UtdgnqtJmzMJGJDoVDdGQtu/s/nF1p8m8ogr2AMuIX9i3lyljXBI9XqjreEirL9PfR8l6uSXP1fQ98ledOvczJMUCUb6Bj2RGEQ1K6wLrWPUnaL2KfSvULJe0S0DwDX8w2h3dJYkZ0mW/vXpXuDuKGb5LZhyU4a4fAedeG5NEgb6XqtvB2ea4GuMKFO8K3TI4u3U969kPT1gBwDZUlRzlI7UfBPJg+wWuQczxLruNBw4NJFvWESO60O4JrZeFwVL5Fe4Bxstwuz5TJ+QNdlC904Tbo1DkOENitcokVcq98ry40goTuGeysIbsWIsdVF/hgk84hLyzkEfwaClGuRk8oSEHtkbUPhgLqadH3thhsvFiustjbP6rdjgycM049NmTnBwlQJeyZu52iD5yr1M4B7PxAGuEfPD693mL/eC2cvVmWC9GTRehso21jZ/vWm5DSVaDITmTPzBa8IxlHo9YB+Af/GS+metg0rUMpxuXYAGuEEsrE5VdmB8B81DpApJ+mhnT7P92MZL/IU4fbzCnkQ04EQDOcYPSB7goRDKI2EFSjTLxY0W6IUyOYDkgSlcroEQatNc2eb2IiCSqBRbEdmYeli1UJlEC+i7os4ZlFV65Z05gd1jF98tFTs5MGem0kU5iW9i2OTXakOUykFauEahcMSFfsNR8wiFShXJOBBD8f3gxycn8fUDAALJmszf9eewcr0Z1hjh4Jpj1DqB9I0uqQdyQ2fJYx28XKaZ0a3iAjxx4B631GFuvg7+ofhu/hNwAX4/3NWe4EE8t0V/6abFmUnsJtW6JS3fr1K3vNHqHDRIknfaoln0IL7mKJP5BoLh8zwqW+DWlA2X+ts7AtGJtliEBgxvEdshbhAPibgAvUf8UkfY6B5fqe4wvF7dwB9wAfkYNq3QwXFtBXxpGD+ccq0StfInaG/JfiOwfNtNPvQEP4K6QT7gk7UMMW6xBSpD+dsQD54/oO4U1fawlsXrxXepH243gmSlCnWtcVp+YN84TvXFqRyIYtZSDWx7MW6qVMEZ+nDVfpJjpgQvK4WjEnul0SJJ5xzpY+0e90Bw5WZOUFsLw7srUsVIxh0K95h90HwDyiuKVds1/BWS3TeCUfSvzvrzVHZYvFahtRpSvVlT3GwdbXYGtFOww0vA5vd0TpErW1HM45UyQL7P0zMZ3V2LLcZzjlvUJKBwjXh/gobVbVI/657duIvVD/DewItMHo8pQqOhkrD+hvE9yrfLn7j/AkCfvlX6oX+JfasPwp9gruETod/QMbsGUVgiT+fMUIUOrj6OOCsrJmAPzkpnC4qFFGOJfHl2CZkz4ENUASQtUKyvaNTpIj37rjOq8RIciE1ZKJEtKGWnZlmI6kNM6O6jxQtv/J8hTg6PlW5SFNMggLhJfPKe9gnmmOUMYuQbqft1Q+eumEMhFgooHSTJE3EhNVJzhAep7aJ0o+K7xv6hLg7EroM0vkTo9MZkQ4UIIj8pA8YdUgR0wxdmuWeO757iZUDelaXuF3VTWsrb/5vTIgRVqhvkpIwcHjxNSfT7lARu/koGVg0j02nquAhlWhTNKnJJjAmt1YuceKL0MVnMC2U5M2z6CGZupZI7GjcPIJbK0DyEfUSjSsAnq3GdUrRSvbZVEqUOdSDZ3o9uVaNbyOaNiwSuVVHe/899EVV3MOo2MYbGsne5Nlq8neOnKrswfYbVJ1IEJqBkLiEfQNohzKzFFX2RzLnrodyYyKH58i3qoVP/Z/112qeIbNqhn+UvUr1p3jvUNezPXYWVrJicQ+sU7sEX0vwF856rwLLRLGNv8oC13oti3l2cAd81fB5we/OoP5YcexAr2U0Xl/SROYnbN+hLFSZqvIK7r7wuV6YqdPJAOqdgsQPLKjpBCqubriu9wMjztWLEl8yXXdmpzPaG16d5eGfwRO2LVSmsdl1BJsSfcFNabIL9P3v1ah8iCzdioLFM49RA0rmCvABP+E8b6ZPY04rSlC5Z0Jy/5qdV2eJungkD5N7oi26dF3jGuYJ6BpdMcXSaAa8sXKZBO6BPSI0uPo6tPkghmcvr1T/S07G8BnsVKFIIld7ki73Nmq6BtYvq76M14ATteQ6zl2uyiqCKqzagyTIZMAdKQ/XauftTr5E5bshqsnnGueXuIaVGhNWXW18hX6uWcZLJolXhrHB16OU7VUvvLtgobXPLlr8qfKPYkdETvNMdGEVX6X6CDblpir1eoTp3p9x2RTKTfIUsK8iVvdxRoFhz0VdjrJc+9wXJIqmuKNxPJyZx+qPKB+fod/d35nC7LvCUO8XP9mQzDCV+eF30iS3h3rDCBiKn/QMbyKe/2OCch3Ch2r5+35+YirlXQLLB2R6d+mCaF7ca95X8qIpYSEBrifOaCg6muX+RhZyUKJ8t9/B70bE3C2scXVQDcXQqvv+fFX55+/PJM/7818t+ctOZLRW0tlXH3lgjEfVoppchnu9kF3YRSDvtxuYmAU1nn3MJwzQSteRj21Ae065KUzOI9W5e5u9Y1Q2ANPTOWpzXUTxss+5Wo8DNqqsvGgCI3cJZjvNhH1HMWA83tjxvdTF0dRK4r9vdonefldEBAFBTQUlOAAAAOEJJTQPtAAAAAAAQAJAAAAABAAEAkAAAAAEAAThCSU0EKAAAAAAADAAAAAI/8AAAAAAAADhCSU0EQwAAAAAADVBiZVcBEAAFAQAAAAAA"
  , Presale = ()=>jsxRuntimeExports.jsx("div", {
    id: "presale",
    className: "container-fluid my-5",
    children: jsxRuntimeExports.jsx("div", {
        className: "row pb-5",
        children: jsxRuntimeExports.jsxs("div", {
            className: "col-11 mx-auto max-width py-5",
            children: [jsxRuntimeExports.jsx("h1", {
                className: "presaleHead",
                children: "Presale"
            }), jsxRuntimeExports.jsx("p", {
                className: "presalePara",
                children: "Join the CloudBTC Presale Journey – Your Path to Early Rewards"
            }), jsxRuntimeExports.jsxs("div", {
                className: "row pb-5 presaleRowWrap",
                children: [jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale1",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center",
                        children: [jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale1,
                            alt: ""
                        }), jsxRuntimeExports.jsx("h5", {
                            children: "Stage 1"
                        }), jsxRuntimeExports.jsx("h4", {
                            children: "0.000800$"
                        }), jsxRuntimeExports.jsx("h6", {
                            children: "240,000$"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Maximum potential growth and early staking rewards."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale2",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center mobRotate",
                        children: [jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsx("h5", {
                                children: "Stage 2"
                            }), jsxRuntimeExports.jsx("h4", {
                                children: "0.000880$"
                            }), jsxRuntimeExports.jsx("h6", {
                                children: "440,000$"
                            }), jsxRuntimeExports.jsx("p", {
                                className: "mb-lg-1",
                                children: "Early entry advantages continue with added growth potential."
                            })]
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale2,
                            alt: ""
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale3",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center",
                        children: [jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale3,
                            alt: ""
                        }), jsxRuntimeExports.jsx("h5", {
                            children: "Stage 3"
                        }), jsxRuntimeExports.jsx("h4", {
                            children: "0.000968$"
                        }), jsxRuntimeExports.jsx("h6", {
                            children: "484,000$"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Balancing early-entry benefits with expanding market awareness."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center mobRotate",
                        children: [jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsx("h5", {
                                children: "Stage 4"
                            }), jsxRuntimeExports.jsx("h4", {
                                children: "0.001065$"
                            }), jsxRuntimeExports.jsx("h6", {
                                children: "532,400$"
                            }), jsxRuntimeExports.jsx("p", {
                                className: "mb-lg-1",
                                children: "Ideal for investors recognizing CloudBTC's long-term potential."
                            })]
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale4,
                            alt: ""
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale5",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center",
                        children: [jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale5,
                            alt: ""
                        }), jsxRuntimeExports.jsx("h5", {
                            children: "Stage 5"
                        }), jsxRuntimeExports.jsx("h4", {
                            children: "0.001171$"
                        }), jsxRuntimeExports.jsx("h6", {
                            children: "585,640$"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Rewards early investors while attracting serious crypto enthusiasts."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale6",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center mobRotate",
                        children: [jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsx("h5", {
                                children: "Stage 6"
                            }), jsxRuntimeExports.jsx("h4", {
                                children: "0.001288$"
                            }), jsxRuntimeExports.jsx("h6", {
                                children: "644,204$"
                            }), jsxRuntimeExports.jsx("p", {
                                className: "mb-lg-1",
                                children: "Great stage for diversifying portfolios with a promising asset."
                            })]
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale6,
                            alt: ""
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale7",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center",
                        children: [jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale5,
                            alt: ""
                        }), jsxRuntimeExports.jsx("h5", {
                            children: "Stage 7"
                        }), jsxRuntimeExports.jsx("h4", {
                            children: "0.001417$"
                        }), jsxRuntimeExports.jsx("h6", {
                            children: "708,624$"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Suitable for those focusing on mid-term investment growth."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale8",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center mobRotate",
                        children: [jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsx("h5", {
                                children: "Stage 8"
                            }), jsxRuntimeExports.jsx("h4", {
                                children: "0.001559$"
                            }), jsxRuntimeExports.jsx("h6", {
                                children: "779,486$"
                            }), jsxRuntimeExports.jsx("p", {
                                className: "mb-lg-1",
                                children: "Last chance for substantial gains before final stage pricing."
                            })]
                        }), jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale6,
                            alt: ""
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 col-lg-1 presale9",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "text-center",
                        children: [jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: presale5,
                            alt: ""
                        }), jsxRuntimeExports.jsx("h5", {
                            children: "Stage 9"
                        }), jsxRuntimeExports.jsx("h4", {
                            children: "0.001715$"
                        }), jsxRuntimeExports.jsx("h6", {
                            children: "857,435$"
                        }), jsxRuntimeExports.jsx("p", {
                            children: "Last opportunity to join the presale and start staking before public launch."
                        })]
                    })
                })]
            })]
        })
    })
})
  , revolution = "/assets/revolution-BHgQ81YC.webp"
  , Revolution = ()=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: jsxRuntimeExports.jsx("div", {
        className: "container-fluid py-5",
        children: jsxRuntimeExports.jsx("div", {
            className: "row my-5",
            children: jsxRuntimeExports.jsx("div", {
                className: "col-11 mx-auto max-width py-5 ",
                children: jsxRuntimeExports.jsxs("div", {
                    className: "row",
                    children: [jsxRuntimeExports.jsx("h1", {
                        className: "resolutionHead mb-5",
                        children: "Revolutionizing Mining"
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 ",
                        children: jsxRuntimeExports.jsx("div", {
                            children: jsxRuntimeExports.jsx("img", {
                                className: "img-fluid mb-4",
                                src: revolution,
                                alt: "cloudBTC",
                                title: "cloudBTC"
                            })
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 ",
                        children: jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsx("h1", {
                                className: "resolutionSubHead",
                                children: "CloudBTC's Staking Model in the New Era of Digital Finance"
                            }), jsxRuntimeExports.jsxs("p", {
                                className: "resolutionPara",
                                children: ["In the dynamic landscape of digital finance, CloudBTC revolutionizes cryptocurrency mining, replacing traditional rigs with an innovative staking model. Users globally embrace the simplicity and efficiency of staking. CloudBTC introduces a paradigm shift where traditional mining setups and exorbitant energy expenses give way to a sophisticated approach: staking for digital mining. This eco-friendly process rewards users, even during the presale.", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("br", {}), "Amidst rising Bitcoin prices following Spot Bitcoin ETF approvals, attention now shifts to the upcoming halving event in April 2024. The Spot ETF announcement triggered a surge in Bitcoin's price, reflecting optimism in the market. The halving, reducing miner rewards from 6.25 to 3.125 Bitcoins, is a pivotal moment. CloudBTC integrates a halving mechanism, allocating 10% of the Reward supply annually for staking rewards, providing early users with enhanced earnings."]
                            })]
                        })
                    })]
                })
            })
        })
    })
})
  , Roadmap = ()=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: jsxRuntimeExports.jsx("div", {
        className: "container-fluid",
        children: jsxRuntimeExports.jsx("div", {
            className: "row py-5",
            children: jsxRuntimeExports.jsxs("div", {
                className: "col-11 mx-auto max-width py-5",
                children: [jsxRuntimeExports.jsx("h1", {
                    className: "roadmapHead",
                    children: "Product Roadmap"
                }), jsxRuntimeExports.jsxs("div", {
                    className: "timeLine",
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: "boxWrap left-boxWrap",
                        children: [jsxRuntimeExports.jsx("span", {
                            className: "roundBrownButton"
                        }), jsxRuntimeExports.jsxs("div", {
                            className: "box",
                            children: [jsxRuntimeExports.jsx("h3", {
                                children: "Q1 2024"
                            }), jsxRuntimeExports.jsxs("p", {
                                children: [jsxRuntimeExports.jsx("strong", {
                                    children: "Launch Website: "
                                }), "Ensure an intuitive and informative user experience. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Integrate Social Networks: "
                                }), "Engage with audiences on platforms like Twitter, Telegram, YouTube, etc. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Publish Whitepaper: "
                                }), "Provide in-depth details about the project's vision, technology, and roadmap. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Complete Audit: "
                                }), "Ensure security and trustworthiness with a thorough smart contract audit. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Initiate Presale: "
                                }), "Launch presale with transparent terms and conditions. Enable Staking: Offer staking options for early adopters. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Secure CEX Exchange Listings: "
                                }), "Confirm listings on exchanges like Gate.io, Kucoin, MEXc, Bitmart, and others at each presale stage. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Expand Influencer Marketing: "
                                }), "Collaborate with key influencers in the crypto space. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Amplify YouTube Marketing: "
                                }), "Leverage YouTube for project promotion. Launch ADS Banners: Place banners on various ICO-related websites. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Reach 10,000 Holders: "
                                }), "Aim for a growing and engaged community. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Achieve Twitter Trending: "
                                }), "Increase visibility and brand presence on Twitter."]
                            })]
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "boxWrap right-boxWrap",
                        children: [jsxRuntimeExports.jsx("span", {
                            className: "roundBrownButton"
                        }), jsxRuntimeExports.jsxs("div", {
                            className: "box",
                            children: [jsxRuntimeExports.jsx("h3", {
                                children: "Q2 2024"
                            }), jsxRuntimeExports.jsxs("p", {
                                children: [jsxRuntimeExports.jsx("strong", {
                                    children: "Publish News Articles: "
                                }), "Highlight project developments in crypto news outlets.", " ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Launch on Uniswap: "
                                }), "Expand accessibility through decentralized exchange listings. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Finalize CEX Listings: "
                                }), "Strengthen market presence through additional centralized exchange listings. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Apply for Binance and Huobi Listings: "
                                }), "Target listings on top-tier exchanges for wider reach.", " ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Continue YouTube Marketing: "
                                }), "Keep up the momentum with YouTube promotions. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Increase to 30,000 Holders: "
                                }), "Grow the community further. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Enhance Influencer Marketing: "
                                }), "Deepen engagements with influencers. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Run Ads on Various Platforms: "
                                }), "Expand advertising reach. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsxs("strong", {
                                    children: ["List on CoinMarketCap (CMC) and CoinGecko (CG):", " "]
                                }), "Improve project visibility and credibility."]
                            })]
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "boxWrap left-boxWrap",
                        children: [jsxRuntimeExports.jsx("span", {
                            className: "roundBrownButton"
                        }), jsxRuntimeExports.jsxs("div", {
                            className: "box",
                            children: [jsxRuntimeExports.jsx("h3", {
                                children: "Q3 2024"
                            }), jsxRuntimeExports.jsxs("p", {
                                children: [jsxRuntimeExports.jsx("strong", {
                                    children: "Trend on Twitter Again: "
                                }), "Maintain and increase social media presence. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Implement Bridging: "
                                }), "Enhance interoperability with other blockchains. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Initiate Market Making: "
                                }), "Stabilize and enhance token liquidity. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Collaborate with Influencers: "
                                }), "Forge new influencer partnerships. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Launch NFT Initiative: "
                                }), "Introduce an NFT component to the ecosystem. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Begin NFT Presale: "
                                }), "Kickstart the NFT offering with a presale."]
                            })]
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "boxWrap right-boxWrap",
                        children: [jsxRuntimeExports.jsx("span", {
                            className: "roundBrownButton"
                        }), jsxRuntimeExports.jsxs("div", {
                            className: "box",
                            children: [jsxRuntimeExports.jsx("h3", {
                                children: "Q4 2024"
                            }), jsxRuntimeExports.jsxs("p", {
                                children: [jsxRuntimeExports.jsx("strong", {
                                    children: " Intensify YouTube Marketing: "
                                }), "Maximize YouTube campaigns for broader reach. ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Trend Worldwide on Twitter: "
                                }), "Achieve global recognition and presence on social media.", " ", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("strong", {
                                    children: "Surpass 100,000 Holders: "
                                }), "Aim for a large, vibrant, and supportive community. This revised roadmap adds specificity and clarity to your plans, making it more actionable and understandable for your audience. ", jsxRuntimeExports.jsx("br", {})]
                            })]
                        })]
                    })]
                })]
            })
        })
    })
})
  , t1 = "/assets/t1-DPjDwQj2.webp"
  , t2 = "/assets/t2-BRPQQen8.webp"
  , Targeted = ()=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: jsxRuntimeExports.jsx("div", {
        className: "container-fluid",
        children: jsxRuntimeExports.jsx("div", {
            className: "row",
            children: jsxRuntimeExports.jsxs("div", {
                className: "col-11 mx-auto max-width py-5 ",
                children: [jsxRuntimeExports.jsx("h1", {
                    className: "benefitHead",
                    children: "Targeted Exchanges"
                }), jsxRuntimeExports.jsxs("div", {
                    className: "row",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "col-6 offset-lg-3 col-lg-3 slideWrapper ",
                        children: jsxRuntimeExports.jsx("div", {
                            children: jsxRuntimeExports.jsx("img", {
                                className: "img-fluid",
                                src: t1,
                                alt: ""
                            })
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-6 col-lg-3 slideWrapper ",
                        children: jsxRuntimeExports.jsx("div", {
                            children: jsxRuntimeExports.jsx("img", {
                                className: "img-fluid",
                                src: t2,
                                alt: ""
                            })
                        })
                    })]
                })]
            })
        })
    })
})
  , TokenomicsImg = "/assets/TokenomicsImg-jLFiDyQf.png"
  , Tokenomics = ()=>jsxRuntimeExports.jsx("div", {
    id: "tokenomics",
    className: "container-fluid",
    children: jsxRuntimeExports.jsx("div", {
        className: "row",
        children: jsxRuntimeExports.jsxs("div", {
            className: "col-11 mx-auto max-width py-5",
            children: [jsxRuntimeExports.jsx("h1", {
                className: "tokenomicsHead",
                children: "Understanding CloudBTC's Tokenomics"
            }), jsxRuntimeExports.jsx("p", {
                className: "tokenomicsPara",
                children: "A Transparent and Sustainable Economic Model"
            }), jsxRuntimeExports.jsx("div", {
                className: "text-center",
                children: jsxRuntimeExports.jsx("img", {
                    className: "img-fluid tokenomicsImg",
                    src: TokenomicsImg,
                    alt: "tokenomics",
                    title: "CBTC Tokenomics"
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: "row mt-5 justify-content-center",
                children: [jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 mb-4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "tokenContent tc1Bg",
                        children: [jsxRuntimeExports.jsx("h3", {
                            className: "tokenCHead",
                            children: "Empowering Investments Instantly"
                        }), jsxRuntimeExports.jsx("p", {
                            className: "tokenCPara",
                            children: "The tokens appear instantly in your wallet, ready for staking. Dive into the world of accessible mining and start earning rewards right away."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 mb-4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "tokenContent tc2Bg",
                        children: [jsxRuntimeExports.jsxs("h3", {
                            className: "tokenCHead",
                            children: ["Staking Rewards", jsxRuntimeExports.jsx("span", {
                                children: "40%"
                            })]
                        }), jsxRuntimeExports.jsx("p", {
                            className: "tokenCPara",
                            children: "Stake your tokens to earn more CloudBTC, with rewards proportional to your staking duration."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 mb-4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "tokenContent tc3Bg",
                        children: [jsxRuntimeExports.jsx("h3", {
                            className: "tokenCHead",
                            children: "Presale Stages"
                        }), jsxRuntimeExports.jsx("p", {
                            className: "tokenCPara",
                            children: "The token price increases through 9 presale stages, offering early investors greater value for their commitment."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 mb-4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "tokenContent tc4Bg",
                        children: [jsxRuntimeExports.jsx("h3", {
                            className: "tokenCHead",
                            children: "Post-Presale Liquidity"
                        }), jsxRuntimeExports.jsx("p", {
                            className: "tokenCPara",
                            children: "Liquidity is added after the presale, ensuring a stable and secure market entry for CloudBTC."
                        })]
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: "col-md-4 mb-4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "tokenContent tc5Bg",
                        children: [jsxRuntimeExports.jsx("h3", {
                            className: "tokenCHead",
                            children: "Long-term Value"
                        }), jsxRuntimeExports.jsx("p", {
                            className: "tokenCPara",
                            children: "The staking-as-mining model promotes holding, reducing market volatility and fostering long-term value growth."
                        })]
                    })
                })]
            })]
        })
    })
});
function isObject$2(_e) {
    return _e !== null && typeof _e == "object" && "constructor"in _e && _e.constructor === Object
}
function extend$2(_e, et) {
    _e === void 0 && (_e = {}),
    et === void 0 && (et = {}),
    Object.keys(et).forEach(tt=>{
        typeof _e[tt] > "u" ? _e[tt] = et[tt] : isObject$2(et[tt]) && isObject$2(_e[tt]) && Object.keys(et[tt]).length > 0 && extend$2(_e[tt], et[tt])
    }
    )
}
const ssrDocument = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function getDocument() {
    const _e = typeof document < "u" ? document : {};
    return extend$2(_e, ssrDocument),
    _e
}
const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function _e() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(_e) {
        return typeof setTimeout > "u" ? (_e(),
        null) : setTimeout(_e, 0)
    },
    cancelAnimationFrame(_e) {
        typeof setTimeout > "u" || clearTimeout(_e)
    }
};
function getWindow() {
    const _e = typeof window < "u" ? window : {};
    return extend$2(_e, ssrWindow),
    _e
}
function classesToTokens(_e) {
    return _e === void 0 && (_e = ""),
    _e.trim().split(" ").filter(et=>!!et.trim())
}
function deleteProps(_e) {
    const et = _e;
    Object.keys(et).forEach(tt=>{
        try {
            et[tt] = null
        } catch {}
        try {
            delete et[tt]
        } catch {}
    }
    )
}
function nextTick(_e, et) {
    return et === void 0 && (et = 0),
    setTimeout(_e, et)
}
function now() {
    return Date.now()
}
function getComputedStyle$1(_e) {
    const et = getWindow();
    let tt;
    return et.getComputedStyle && (tt = et.getComputedStyle(_e, null)),
    !tt && _e.currentStyle && (tt = _e.currentStyle),
    tt || (tt = _e.style),
    tt
}
function getTranslate(_e, et) {
    et === void 0 && (et = "x");
    const tt = getWindow();
    let rt, nt, it;
    const st = getComputedStyle$1(_e);
    return tt.WebKitCSSMatrix ? (nt = st.transform || st.webkitTransform,
    nt.split(",").length > 6 && (nt = nt.split(", ").map(at=>at.replace(",", ".")).join(", ")),
    it = new tt.WebKitCSSMatrix(nt === "none" ? "" : nt)) : (it = st.MozTransform || st.OTransform || st.MsTransform || st.msTransform || st.transform || st.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    rt = it.toString().split(",")),
    et === "x" && (tt.WebKitCSSMatrix ? nt = it.m41 : rt.length === 16 ? nt = parseFloat(rt[12]) : nt = parseFloat(rt[4])),
    et === "y" && (tt.WebKitCSSMatrix ? nt = it.m42 : rt.length === 16 ? nt = parseFloat(rt[13]) : nt = parseFloat(rt[5])),
    nt || 0
}
function isObject$1(_e) {
    return typeof _e == "object" && _e !== null && _e.constructor && Object.prototype.toString.call(_e).slice(8, -1) === "Object"
}
function isNode(_e) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? _e instanceof HTMLElement : _e && (_e.nodeType === 1 || _e.nodeType === 11)
}
function extend$1() {
    const _e = Object(arguments.length <= 0 ? void 0 : arguments[0])
      , et = ["__proto__", "constructor", "prototype"];
    for (let tt = 1; tt < arguments.length; tt += 1) {
        const rt = tt < 0 || arguments.length <= tt ? void 0 : arguments[tt];
        if (rt != null && !isNode(rt)) {
            const nt = Object.keys(Object(rt)).filter(it=>et.indexOf(it) < 0);
            for (let it = 0, st = nt.length; it < st; it += 1) {
                const at = nt[it]
                  , ot = Object.getOwnPropertyDescriptor(rt, at);
                ot !== void 0 && ot.enumerable && (isObject$1(_e[at]) && isObject$1(rt[at]) ? rt[at].__swiper__ ? _e[at] = rt[at] : extend$1(_e[at], rt[at]) : !isObject$1(_e[at]) && isObject$1(rt[at]) ? (_e[at] = {},
                rt[at].__swiper__ ? _e[at] = rt[at] : extend$1(_e[at], rt[at])) : _e[at] = rt[at])
            }
        }
    }
    return _e
}
function setCSSProperty(_e, et, tt) {
    _e.style.setProperty(et, tt)
}
function animateCSSModeScroll(_e) {
    let {swiper: et, targetPosition: tt, side: rt} = _e;
    const nt = getWindow()
      , it = -et.translate;
    let st = null, at;
    const ot = et.params.speed;
    et.wrapperEl.style.scrollSnapType = "none",
    nt.cancelAnimationFrame(et.cssModeFrameID);
    const lt = tt > it ? "next" : "prev"
      , dt = (ut,ft)=>lt === "next" && ut >= ft || lt === "prev" && ut <= ft
      , ct = ()=>{
        at = new Date().getTime(),
        st === null && (st = at);
        const ut = Math.max(Math.min((at - st) / ot, 1), 0)
          , ft = .5 - Math.cos(ut * Math.PI) / 2;
        let ht = it + ft * (tt - it);
        if (dt(ht, tt) && (ht = tt),
        et.wrapperEl.scrollTo({
            [rt]: ht
        }),
        dt(ht, tt)) {
            et.wrapperEl.style.overflow = "hidden",
            et.wrapperEl.style.scrollSnapType = "",
            setTimeout(()=>{
                et.wrapperEl.style.overflow = "",
                et.wrapperEl.scrollTo({
                    [rt]: ht
                })
            }
            ),
            nt.cancelAnimationFrame(et.cssModeFrameID);
            return
        }
        et.cssModeFrameID = nt.requestAnimationFrame(ct)
    }
    ;
    ct()
}
function elementChildren(_e, et) {
    return et === void 0 && (et = ""),
    [..._e.children].filter(tt=>tt.matches(et))
}
function showWarning(_e) {
    try {
        console.warn(_e);
        return
    } catch {}
}
function createElement(_e, et) {
    et === void 0 && (et = []);
    const tt = document.createElement(_e);
    return tt.classList.add(...Array.isArray(et) ? et : classesToTokens(et)),
    tt
}
function elementPrevAll(_e, et) {
    const tt = [];
    for (; _e.previousElementSibling; ) {
        const rt = _e.previousElementSibling;
        et ? rt.matches(et) && tt.push(rt) : tt.push(rt),
        _e = rt
    }
    return tt
}
function elementNextAll(_e, et) {
    const tt = [];
    for (; _e.nextElementSibling; ) {
        const rt = _e.nextElementSibling;
        et ? rt.matches(et) && tt.push(rt) : tt.push(rt),
        _e = rt
    }
    return tt
}
function elementStyle(_e, et) {
    return getWindow().getComputedStyle(_e, null).getPropertyValue(et)
}
function elementIndex(_e) {
    let et = _e, tt;
    if (et) {
        for (tt = 0; (et = et.previousSibling) !== null; )
            et.nodeType === 1 && (tt += 1);
        return tt
    }
}
function elementParents(_e, et) {
    const tt = [];
    let rt = _e.parentElement;
    for (; rt; )
        et ? rt.matches(et) && tt.push(rt) : tt.push(rt),
        rt = rt.parentElement;
    return tt
}
function elementOuterSize(_e, et, tt) {
    const rt = getWindow();
    return tt ? _e[et === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(rt.getComputedStyle(_e, null).getPropertyValue(et === "width" ? "margin-right" : "margin-top")) + parseFloat(rt.getComputedStyle(_e, null).getPropertyValue(et === "width" ? "margin-left" : "margin-bottom")) : _e.offsetWidth
}
function makeElementsArray(_e) {
    return (Array.isArray(_e) ? _e : [_e]).filter(et=>!!et)
}
let support;
function calcSupport() {
    const _e = getWindow()
      , et = getDocument();
    return {
        smoothScroll: et.documentElement && et.documentElement.style && "scrollBehavior"in et.documentElement.style,
        touch: !!("ontouchstart"in _e || _e.DocumentTouch && et instanceof _e.DocumentTouch)
    }
}
function getSupport() {
    return support || (support = calcSupport()),
    support
}
let deviceCached;
function calcDevice(_e) {
    let {userAgent: et} = _e === void 0 ? {} : _e;
    const tt = getSupport()
      , rt = getWindow()
      , nt = rt.navigator.platform
      , it = et || rt.navigator.userAgent
      , st = {
        ios: !1,
        android: !1
    }
      , at = rt.screen.width
      , ot = rt.screen.height
      , lt = it.match(/(Android);?[\s\/]+([\d.]+)?/);
    let dt = it.match(/(iPad).*OS\s([\d_]+)/);
    const ct = it.match(/(iPod)(.*OS\s([\d_]+))?/)
      , ut = !dt && it.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
      , ft = nt === "Win32";
    let ht = nt === "MacIntel";
    const gt = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !dt && ht && tt.touch && gt.indexOf(`${at}x${ot}`) >= 0 && (dt = it.match(/(Version)\/([\d.]+)/),
    dt || (dt = [0, 1, "13_0_0"]),
    ht = !1),
    lt && !ft && (st.os = "android",
    st.android = !0),
    (dt || ut || ct) && (st.os = "ios",
    st.ios = !0),
    st
}
function getDevice(_e) {
    return _e === void 0 && (_e = {}),
    deviceCached || (deviceCached = calcDevice(_e)),
    deviceCached
}
let browser;
function calcBrowser() {
    const _e = getWindow()
      , et = getDevice();
    let tt = !1;
    function rt() {
        const at = _e.navigator.userAgent.toLowerCase();
        return at.indexOf("safari") >= 0 && at.indexOf("chrome") < 0 && at.indexOf("android") < 0
    }
    if (rt()) {
        const at = String(_e.navigator.userAgent);
        if (at.includes("Version/")) {
            const [ot,lt] = at.split("Version/")[1].split(" ")[0].split(".").map(dt=>Number(dt));
            tt = ot < 16 || ot === 16 && lt < 2
        }
    }
    const nt = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(_e.navigator.userAgent)
      , it = rt()
      , st = it || nt && et.ios;
    return {
        isSafari: tt || it,
        needPerspectiveFix: tt,
        need3dFix: st,
        isWebView: nt
    }
}
function getBrowser() {
    return browser || (browser = calcBrowser()),
    browser
}
function Resize(_e) {
    let {swiper: et, on: tt, emit: rt} = _e;
    const nt = getWindow();
    let it = null
      , st = null;
    const at = ()=>{
        !et || et.destroyed || !et.initialized || (rt("beforeResize"),
        rt("resize"))
    }
      , ot = ()=>{
        !et || et.destroyed || !et.initialized || (it = new ResizeObserver(ct=>{
            st = nt.requestAnimationFrame(()=>{
                const {width: ut, height: ft} = et;
                let ht = ut
                  , gt = ft;
                ct.forEach(bt=>{
                    let {contentBoxSize: pt, contentRect: mt, target: yt} = bt;
                    yt && yt !== et.el || (ht = mt ? mt.width : (pt[0] || pt).inlineSize,
                    gt = mt ? mt.height : (pt[0] || pt).blockSize)
                }
                ),
                (ht !== ut || gt !== ft) && at()
            }
            )
        }
        ),
        it.observe(et.el))
    }
      , lt = ()=>{
        st && nt.cancelAnimationFrame(st),
        it && it.unobserve && et.el && (it.unobserve(et.el),
        it = null)
    }
      , dt = ()=>{
        !et || et.destroyed || !et.initialized || rt("orientationchange")
    }
    ;
    tt("init", ()=>{
        if (et.params.resizeObserver && typeof nt.ResizeObserver < "u") {
            ot();
            return
        }
        nt.addEventListener("resize", at),
        nt.addEventListener("orientationchange", dt)
    }
    ),
    tt("destroy", ()=>{
        lt(),
        nt.removeEventListener("resize", at),
        nt.removeEventListener("orientationchange", dt)
    }
    )
}
function Observer(_e) {
    let {swiper: et, extendParams: tt, on: rt, emit: nt} = _e;
    const it = []
      , st = getWindow()
      , at = function(dt, ct) {
        ct === void 0 && (ct = {});
        const ut = st.MutationObserver || st.WebkitMutationObserver
          , ft = new ut(ht=>{
            if (et.__preventObserver__)
                return;
            if (ht.length === 1) {
                nt("observerUpdate", ht[0]);
                return
            }
            const gt = function() {
                nt("observerUpdate", ht[0])
            };
            st.requestAnimationFrame ? st.requestAnimationFrame(gt) : st.setTimeout(gt, 0)
        }
        );
        ft.observe(dt, {
            attributes: typeof ct.attributes > "u" ? !0 : ct.attributes,
            childList: typeof ct.childList > "u" ? !0 : ct.childList,
            characterData: typeof ct.characterData > "u" ? !0 : ct.characterData
        }),
        it.push(ft)
    }
      , ot = ()=>{
        if (et.params.observer) {
            if (et.params.observeParents) {
                const dt = elementParents(et.hostEl);
                for (let ct = 0; ct < dt.length; ct += 1)
                    at(dt[ct])
            }
            at(et.hostEl, {
                childList: et.params.observeSlideChildren
            }),
            at(et.wrapperEl, {
                attributes: !1
            })
        }
    }
      , lt = ()=>{
        it.forEach(dt=>{
            dt.disconnect()
        }
        ),
        it.splice(0, it.length)
    }
    ;
    tt({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
    rt("init", ot),
    rt("destroy", lt)
}
var eventsEmitter = {
    on(_e, et, tt) {
        const rt = this;
        if (!rt.eventsListeners || rt.destroyed || typeof et != "function")
            return rt;
        const nt = tt ? "unshift" : "push";
        return _e.split(" ").forEach(it=>{
            rt.eventsListeners[it] || (rt.eventsListeners[it] = []),
            rt.eventsListeners[it][nt](et)
        }
        ),
        rt
    },
    once(_e, et, tt) {
        const rt = this;
        if (!rt.eventsListeners || rt.destroyed || typeof et != "function")
            return rt;
        function nt() {
            rt.off(_e, nt),
            nt.__emitterProxy && delete nt.__emitterProxy;
            for (var it = arguments.length, st = new Array(it), at = 0; at < it; at++)
                st[at] = arguments[at];
            et.apply(rt, st)
        }
        return nt.__emitterProxy = et,
        rt.on(_e, nt, tt)
    },
    onAny(_e, et) {
        const tt = this;
        if (!tt.eventsListeners || tt.destroyed || typeof _e != "function")
            return tt;
        const rt = et ? "unshift" : "push";
        return tt.eventsAnyListeners.indexOf(_e) < 0 && tt.eventsAnyListeners[rt](_e),
        tt
    },
    offAny(_e) {
        const et = this;
        if (!et.eventsListeners || et.destroyed || !et.eventsAnyListeners)
            return et;
        const tt = et.eventsAnyListeners.indexOf(_e);
        return tt >= 0 && et.eventsAnyListeners.splice(tt, 1),
        et
    },
    off(_e, et) {
        const tt = this;
        return !tt.eventsListeners || tt.destroyed || !tt.eventsListeners || _e.split(" ").forEach(rt=>{
            typeof et > "u" ? tt.eventsListeners[rt] = [] : tt.eventsListeners[rt] && tt.eventsListeners[rt].forEach((nt,it)=>{
                (nt === et || nt.__emitterProxy && nt.__emitterProxy === et) && tt.eventsListeners[rt].splice(it, 1)
            }
            )
        }
        ),
        tt
    },
    emit() {
        const _e = this;
        if (!_e.eventsListeners || _e.destroyed || !_e.eventsListeners)
            return _e;
        let et, tt, rt;
        for (var nt = arguments.length, it = new Array(nt), st = 0; st < nt; st++)
            it[st] = arguments[st];
        return typeof it[0] == "string" || Array.isArray(it[0]) ? (et = it[0],
        tt = it.slice(1, it.length),
        rt = _e) : (et = it[0].events,
        tt = it[0].data,
        rt = it[0].context || _e),
        tt.unshift(rt),
        (Array.isArray(et) ? et : et.split(" ")).forEach(ot=>{
            _e.eventsAnyListeners && _e.eventsAnyListeners.length && _e.eventsAnyListeners.forEach(lt=>{
                lt.apply(rt, [ot, ...tt])
            }
            ),
            _e.eventsListeners && _e.eventsListeners[ot] && _e.eventsListeners[ot].forEach(lt=>{
                lt.apply(rt, tt)
            }
            )
        }
        ),
        _e
    }
};
function updateSize() {
    const _e = this;
    let et, tt;
    const rt = _e.el;
    typeof _e.params.width < "u" && _e.params.width !== null ? et = _e.params.width : et = rt.clientWidth,
    typeof _e.params.height < "u" && _e.params.height !== null ? tt = _e.params.height : tt = rt.clientHeight,
    !(et === 0 && _e.isHorizontal() || tt === 0 && _e.isVertical()) && (et = et - parseInt(elementStyle(rt, "padding-left") || 0, 10) - parseInt(elementStyle(rt, "padding-right") || 0, 10),
    tt = tt - parseInt(elementStyle(rt, "padding-top") || 0, 10) - parseInt(elementStyle(rt, "padding-bottom") || 0, 10),
    Number.isNaN(et) && (et = 0),
    Number.isNaN(tt) && (tt = 0),
    Object.assign(_e, {
        width: et,
        height: tt,
        size: _e.isHorizontal() ? et : tt
    }))
}
function updateSlides() {
    const _e = this;
    function et(Tt, It) {
        return parseFloat(Tt.getPropertyValue(_e.getDirectionLabel(It)) || 0)
    }
    const tt = _e.params
      , {wrapperEl: rt, slidesEl: nt, size: it, rtlTranslate: st, wrongRTL: at} = _e
      , ot = _e.virtual && tt.virtual.enabled
      , lt = ot ? _e.virtual.slides.length : _e.slides.length
      , dt = elementChildren(nt, `.${_e.params.slideClass}, swiper-slide`)
      , ct = ot ? _e.virtual.slides.length : dt.length;
    let ut = [];
    const ft = []
      , ht = [];
    let gt = tt.slidesOffsetBefore;
    typeof gt == "function" && (gt = tt.slidesOffsetBefore.call(_e));
    let bt = tt.slidesOffsetAfter;
    typeof bt == "function" && (bt = tt.slidesOffsetAfter.call(_e));
    const pt = _e.snapGrid.length
      , mt = _e.slidesGrid.length;
    let yt = tt.spaceBetween
      , vt = -gt
      , wt = 0
      , _t = 0;
    if (typeof it > "u")
        return;
    typeof yt == "string" && yt.indexOf("%") >= 0 ? yt = parseFloat(yt.replace("%", "")) / 100 * it : typeof yt == "string" && (yt = parseFloat(yt)),
    _e.virtualSize = -yt,
    dt.forEach(Tt=>{
        st ? Tt.style.marginLeft = "" : Tt.style.marginRight = "",
        Tt.style.marginBottom = "",
        Tt.style.marginTop = ""
    }
    ),
    tt.centeredSlides && tt.cssMode && (setCSSProperty(rt, "--swiper-centered-offset-before", ""),
    setCSSProperty(rt, "--swiper-centered-offset-after", ""));
    const Et = tt.grid && tt.grid.rows > 1 && _e.grid;
    Et ? _e.grid.initSlides(dt) : _e.grid && _e.grid.unsetSlides();
    let xt;
    const Ct = tt.slidesPerView === "auto" && tt.breakpoints && Object.keys(tt.breakpoints).filter(Tt=>typeof tt.breakpoints[Tt].slidesPerView < "u").length > 0;
    for (let Tt = 0; Tt < ct; Tt += 1) {
        xt = 0;
        let It;
        if (dt[Tt] && (It = dt[Tt]),
        Et && _e.grid.updateSlide(Tt, It, dt),
        !(dt[Tt] && elementStyle(It, "display") === "none")) {
            if (tt.slidesPerView === "auto") {
                Ct && (dt[Tt].style[_e.getDirectionLabel("width")] = "");
                const Nt = getComputedStyle(It)
                  , Ft = It.style.transform
                  , Lt = It.style.webkitTransform;
                if (Ft && (It.style.transform = "none"),
                Lt && (It.style.webkitTransform = "none"),
                tt.roundLengths)
                    xt = _e.isHorizontal() ? elementOuterSize(It, "width", !0) : elementOuterSize(It, "height", !0);
                else {
                    const Mt = et(Nt, "width")
                      , $t = et(Nt, "padding-left")
                      , kt = et(Nt, "padding-right")
                      , At = et(Nt, "margin-left")
                      , Pt = et(Nt, "margin-right")
                      , Dt = Nt.getPropertyValue("box-sizing");
                    if (Dt && Dt === "border-box")
                        xt = Mt + At + Pt;
                    else {
                        const {clientWidth: Bt, offsetWidth: zt} = It;
                        xt = Mt + $t + kt + At + Pt + (zt - Bt)
                    }
                }
                Ft && (It.style.transform = Ft),
                Lt && (It.style.webkitTransform = Lt),
                tt.roundLengths && (xt = Math.floor(xt))
            } else
                xt = (it - (tt.slidesPerView - 1) * yt) / tt.slidesPerView,
                tt.roundLengths && (xt = Math.floor(xt)),
                dt[Tt] && (dt[Tt].style[_e.getDirectionLabel("width")] = `${xt}px`);
            dt[Tt] && (dt[Tt].swiperSlideSize = xt),
            ht.push(xt),
            tt.centeredSlides ? (vt = vt + xt / 2 + wt / 2 + yt,
            wt === 0 && Tt !== 0 && (vt = vt - it / 2 - yt),
            Tt === 0 && (vt = vt - it / 2 - yt),
            Math.abs(vt) < 1 / 1e3 && (vt = 0),
            tt.roundLengths && (vt = Math.floor(vt)),
            _t % tt.slidesPerGroup === 0 && ut.push(vt),
            ft.push(vt)) : (tt.roundLengths && (vt = Math.floor(vt)),
            (_t - Math.min(_e.params.slidesPerGroupSkip, _t)) % _e.params.slidesPerGroup === 0 && ut.push(vt),
            ft.push(vt),
            vt = vt + xt + yt),
            _e.virtualSize += xt + yt,
            wt = xt,
            _t += 1
        }
    }
    if (_e.virtualSize = Math.max(_e.virtualSize, it) + bt,
    st && at && (tt.effect === "slide" || tt.effect === "coverflow") && (rt.style.width = `${_e.virtualSize + yt}px`),
    tt.setWrapperSize && (rt.style[_e.getDirectionLabel("width")] = `${_e.virtualSize + yt}px`),
    Et && _e.grid.updateWrapperSize(xt, ut),
    !tt.centeredSlides) {
        const Tt = [];
        for (let It = 0; It < ut.length; It += 1) {
            let Nt = ut[It];
            tt.roundLengths && (Nt = Math.floor(Nt)),
            ut[It] <= _e.virtualSize - it && Tt.push(Nt)
        }
        ut = Tt,
        Math.floor(_e.virtualSize - it) - Math.floor(ut[ut.length - 1]) > 1 && ut.push(_e.virtualSize - it)
    }
    if (ot && tt.loop) {
        const Tt = ht[0] + yt;
        if (tt.slidesPerGroup > 1) {
            const It = Math.ceil((_e.virtual.slidesBefore + _e.virtual.slidesAfter) / tt.slidesPerGroup)
              , Nt = Tt * tt.slidesPerGroup;
            for (let Ft = 0; Ft < It; Ft += 1)
                ut.push(ut[ut.length - 1] + Nt)
        }
        for (let It = 0; It < _e.virtual.slidesBefore + _e.virtual.slidesAfter; It += 1)
            tt.slidesPerGroup === 1 && ut.push(ut[ut.length - 1] + Tt),
            ft.push(ft[ft.length - 1] + Tt),
            _e.virtualSize += Tt
    }
    if (ut.length === 0 && (ut = [0]),
    yt !== 0) {
        const Tt = _e.isHorizontal() && st ? "marginLeft" : _e.getDirectionLabel("marginRight");
        dt.filter((It,Nt)=>!tt.cssMode || tt.loop ? !0 : Nt !== dt.length - 1).forEach(It=>{
            It.style[Tt] = `${yt}px`
        }
        )
    }
    if (tt.centeredSlides && tt.centeredSlidesBounds) {
        let Tt = 0;
        ht.forEach(Nt=>{
            Tt += Nt + (yt || 0)
        }
        ),
        Tt -= yt;
        const It = Tt - it;
        ut = ut.map(Nt=>Nt <= 0 ? -gt : Nt > It ? It + bt : Nt)
    }
    if (tt.centerInsufficientSlides) {
        let Tt = 0;
        if (ht.forEach(It=>{
            Tt += It + (yt || 0)
        }
        ),
        Tt -= yt,
        Tt < it) {
            const It = (it - Tt) / 2;
            ut.forEach((Nt,Ft)=>{
                ut[Ft] = Nt - It
            }
            ),
            ft.forEach((Nt,Ft)=>{
                ft[Ft] = Nt + It
            }
            )
        }
    }
    if (Object.assign(_e, {
        slides: dt,
        snapGrid: ut,
        slidesGrid: ft,
        slidesSizesGrid: ht
    }),
    tt.centeredSlides && tt.cssMode && !tt.centeredSlidesBounds) {
        setCSSProperty(rt, "--swiper-centered-offset-before", `${-ut[0]}px`),
        setCSSProperty(rt, "--swiper-centered-offset-after", `${_e.size / 2 - ht[ht.length - 1] / 2}px`);
        const Tt = -_e.snapGrid[0]
          , It = -_e.slidesGrid[0];
        _e.snapGrid = _e.snapGrid.map(Nt=>Nt + Tt),
        _e.slidesGrid = _e.slidesGrid.map(Nt=>Nt + It)
    }
    if (ct !== lt && _e.emit("slidesLengthChange"),
    ut.length !== pt && (_e.params.watchOverflow && _e.checkOverflow(),
    _e.emit("snapGridLengthChange")),
    ft.length !== mt && _e.emit("slidesGridLengthChange"),
    tt.watchSlidesProgress && _e.updateSlidesOffset(),
    _e.emit("slidesUpdated"),
    !ot && !tt.cssMode && (tt.effect === "slide" || tt.effect === "fade")) {
        const Tt = `${tt.containerModifierClass}backface-hidden`
          , It = _e.el.classList.contains(Tt);
        ct <= tt.maxBackfaceHiddenSlides ? It || _e.el.classList.add(Tt) : It && _e.el.classList.remove(Tt)
    }
}
function updateAutoHeight(_e) {
    const et = this
      , tt = []
      , rt = et.virtual && et.params.virtual.enabled;
    let nt = 0, it;
    typeof _e == "number" ? et.setTransition(_e) : _e === !0 && et.setTransition(et.params.speed);
    const st = at=>rt ? et.slides[et.getSlideIndexByData(at)] : et.slides[at];
    if (et.params.slidesPerView !== "auto" && et.params.slidesPerView > 1)
        if (et.params.centeredSlides)
            (et.visibleSlides || []).forEach(at=>{
                tt.push(at)
            }
            );
        else
            for (it = 0; it < Math.ceil(et.params.slidesPerView); it += 1) {
                const at = et.activeIndex + it;
                if (at > et.slides.length && !rt)
                    break;
                tt.push(st(at))
            }
    else
        tt.push(st(et.activeIndex));
    for (it = 0; it < tt.length; it += 1)
        if (typeof tt[it] < "u") {
            const at = tt[it].offsetHeight;
            nt = at > nt ? at : nt
        }
    (nt || nt === 0) && (et.wrapperEl.style.height = `${nt}px`)
}
function updateSlidesOffset() {
    const _e = this
      , et = _e.slides
      , tt = _e.isElement ? _e.isHorizontal() ? _e.wrapperEl.offsetLeft : _e.wrapperEl.offsetTop : 0;
    for (let rt = 0; rt < et.length; rt += 1)
        et[rt].swiperSlideOffset = (_e.isHorizontal() ? et[rt].offsetLeft : et[rt].offsetTop) - tt - _e.cssOverflowAdjustment()
}
function updateSlidesProgress(_e) {
    _e === void 0 && (_e = this && this.translate || 0);
    const et = this
      , tt = et.params
      , {slides: rt, rtlTranslate: nt, snapGrid: it} = et;
    if (rt.length === 0)
        return;
    typeof rt[0].swiperSlideOffset > "u" && et.updateSlidesOffset();
    let st = -_e;
    nt && (st = _e),
    rt.forEach(ot=>{
        ot.classList.remove(tt.slideVisibleClass, tt.slideFullyVisibleClass)
    }
    ),
    et.visibleSlidesIndexes = [],
    et.visibleSlides = [];
    let at = tt.spaceBetween;
    typeof at == "string" && at.indexOf("%") >= 0 ? at = parseFloat(at.replace("%", "")) / 100 * et.size : typeof at == "string" && (at = parseFloat(at));
    for (let ot = 0; ot < rt.length; ot += 1) {
        const lt = rt[ot];
        let dt = lt.swiperSlideOffset;
        tt.cssMode && tt.centeredSlides && (dt -= rt[0].swiperSlideOffset);
        const ct = (st + (tt.centeredSlides ? et.minTranslate() : 0) - dt) / (lt.swiperSlideSize + at)
          , ut = (st - it[0] + (tt.centeredSlides ? et.minTranslate() : 0) - dt) / (lt.swiperSlideSize + at)
          , ft = -(st - dt)
          , ht = ft + et.slidesSizesGrid[ot]
          , gt = ft >= 0 && ft <= et.size - et.slidesSizesGrid[ot];
        (ft >= 0 && ft < et.size - 1 || ht > 1 && ht <= et.size || ft <= 0 && ht >= et.size) && (et.visibleSlides.push(lt),
        et.visibleSlidesIndexes.push(ot),
        rt[ot].classList.add(tt.slideVisibleClass)),
        gt && rt[ot].classList.add(tt.slideFullyVisibleClass),
        lt.progress = nt ? -ct : ct,
        lt.originalProgress = nt ? -ut : ut
    }
}
function updateProgress(_e) {
    const et = this;
    if (typeof _e > "u") {
        const dt = et.rtlTranslate ? -1 : 1;
        _e = et && et.translate && et.translate * dt || 0
    }
    const tt = et.params
      , rt = et.maxTranslate() - et.minTranslate();
    let {progress: nt, isBeginning: it, isEnd: st, progressLoop: at} = et;
    const ot = it
      , lt = st;
    if (rt === 0)
        nt = 0,
        it = !0,
        st = !0;
    else {
        nt = (_e - et.minTranslate()) / rt;
        const dt = Math.abs(_e - et.minTranslate()) < 1
          , ct = Math.abs(_e - et.maxTranslate()) < 1;
        it = dt || nt <= 0,
        st = ct || nt >= 1,
        dt && (nt = 0),
        ct && (nt = 1)
    }
    if (tt.loop) {
        const dt = et.getSlideIndexByData(0)
          , ct = et.getSlideIndexByData(et.slides.length - 1)
          , ut = et.slidesGrid[dt]
          , ft = et.slidesGrid[ct]
          , ht = et.slidesGrid[et.slidesGrid.length - 1]
          , gt = Math.abs(_e);
        gt >= ut ? at = (gt - ut) / ht : at = (gt + ht - ft) / ht,
        at > 1 && (at -= 1)
    }
    Object.assign(et, {
        progress: nt,
        progressLoop: at,
        isBeginning: it,
        isEnd: st
    }),
    (tt.watchSlidesProgress || tt.centeredSlides && tt.autoHeight) && et.updateSlidesProgress(_e),
    it && !ot && et.emit("reachBeginning toEdge"),
    st && !lt && et.emit("reachEnd toEdge"),
    (ot && !it || lt && !st) && et.emit("fromEdge"),
    et.emit("progress", nt)
}
function updateSlidesClasses() {
    const _e = this
      , {slides: et, params: tt, slidesEl: rt, activeIndex: nt} = _e
      , it = _e.virtual && tt.virtual.enabled
      , st = _e.grid && tt.grid && tt.grid.rows > 1
      , at = ct=>elementChildren(rt, `.${tt.slideClass}${ct}, swiper-slide${ct}`)[0];
    et.forEach(ct=>{
        ct.classList.remove(tt.slideActiveClass, tt.slideNextClass, tt.slidePrevClass)
    }
    );
    let ot, lt, dt;
    if (it)
        if (tt.loop) {
            let ct = nt - _e.virtual.slidesBefore;
            ct < 0 && (ct = _e.virtual.slides.length + ct),
            ct >= _e.virtual.slides.length && (ct -= _e.virtual.slides.length),
            ot = at(`[data-swiper-slide-index="${ct}"]`)
        } else
            ot = at(`[data-swiper-slide-index="${nt}"]`);
    else
        st ? (ot = et.filter(ct=>ct.column === nt)[0],
        dt = et.filter(ct=>ct.column === nt + 1)[0],
        lt = et.filter(ct=>ct.column === nt - 1)[0]) : ot = et[nt];
    ot && (ot.classList.add(tt.slideActiveClass),
    st ? (dt && dt.classList.add(tt.slideNextClass),
    lt && lt.classList.add(tt.slidePrevClass)) : (dt = elementNextAll(ot, `.${tt.slideClass}, swiper-slide`)[0],
    tt.loop && !dt && (dt = et[0]),
    dt && dt.classList.add(tt.slideNextClass),
    lt = elementPrevAll(ot, `.${tt.slideClass}, swiper-slide`)[0],
    tt.loop && !lt === 0 && (lt = et[et.length - 1]),
    lt && lt.classList.add(tt.slidePrevClass))),
    _e.emitSlidesClasses()
}
const processLazyPreloader = (_e,et)=>{
    if (!_e || _e.destroyed || !_e.params)
        return;
    const tt = ()=>_e.isElement ? "swiper-slide" : `.${_e.params.slideClass}`
      , rt = et.closest(tt());
    if (rt) {
        let nt = rt.querySelector(`.${_e.params.lazyPreloaderClass}`);
        !nt && _e.isElement && (rt.shadowRoot ? nt = rt.shadowRoot.querySelector(`.${_e.params.lazyPreloaderClass}`) : requestAnimationFrame(()=>{
            rt.shadowRoot && (nt = rt.shadowRoot.querySelector(`.${_e.params.lazyPreloaderClass}`),
            nt && nt.remove())
        }
        )),
        nt && nt.remove()
    }
}
  , unlazy = (_e,et)=>{
    if (!_e.slides[et])
        return;
    const tt = _e.slides[et].querySelector('[loading="lazy"]');
    tt && tt.removeAttribute("loading")
}
  , preload = _e=>{
    if (!_e || _e.destroyed || !_e.params)
        return;
    let et = _e.params.lazyPreloadPrevNext;
    const tt = _e.slides.length;
    if (!tt || !et || et < 0)
        return;
    et = Math.min(et, tt);
    const rt = _e.params.slidesPerView === "auto" ? _e.slidesPerViewDynamic() : Math.ceil(_e.params.slidesPerView)
      , nt = _e.activeIndex;
    if (_e.params.grid && _e.params.grid.rows > 1) {
        const st = nt
          , at = [st - et];
        at.push(...Array.from({
            length: et
        }).map((ot,lt)=>st + rt + lt)),
        _e.slides.forEach((ot,lt)=>{
            at.includes(ot.column) && unlazy(_e, lt)
        }
        );
        return
    }
    const it = nt + rt - 1;
    if (_e.params.rewind || _e.params.loop)
        for (let st = nt - et; st <= it + et; st += 1) {
            const at = (st % tt + tt) % tt;
            (at < nt || at > it) && unlazy(_e, at)
        }
    else
        for (let st = Math.max(nt - et, 0); st <= Math.min(it + et, tt - 1); st += 1)
            st !== nt && (st > it || st < nt) && unlazy(_e, st)
}
;
function getActiveIndexByTranslate(_e) {
    const {slidesGrid: et, params: tt} = _e
      , rt = _e.rtlTranslate ? _e.translate : -_e.translate;
    let nt;
    for (let it = 0; it < et.length; it += 1)
        typeof et[it + 1] < "u" ? rt >= et[it] && rt < et[it + 1] - (et[it + 1] - et[it]) / 2 ? nt = it : rt >= et[it] && rt < et[it + 1] && (nt = it + 1) : rt >= et[it] && (nt = it);
    return tt.normalizeSlideIndex && (nt < 0 || typeof nt > "u") && (nt = 0),
    nt
}
function updateActiveIndex(_e) {
    const et = this
      , tt = et.rtlTranslate ? et.translate : -et.translate
      , {snapGrid: rt, params: nt, activeIndex: it, realIndex: st, snapIndex: at} = et;
    let ot = _e, lt;
    const dt = ft=>{
        let ht = ft - et.virtual.slidesBefore;
        return ht < 0 && (ht = et.virtual.slides.length + ht),
        ht >= et.virtual.slides.length && (ht -= et.virtual.slides.length),
        ht
    }
    ;
    if (typeof ot > "u" && (ot = getActiveIndexByTranslate(et)),
    rt.indexOf(tt) >= 0)
        lt = rt.indexOf(tt);
    else {
        const ft = Math.min(nt.slidesPerGroupSkip, ot);
        lt = ft + Math.floor((ot - ft) / nt.slidesPerGroup)
    }
    if (lt >= rt.length && (lt = rt.length - 1),
    ot === it && !et.params.loop) {
        lt !== at && (et.snapIndex = lt,
        et.emit("snapIndexChange"));
        return
    }
    if (ot === it && et.params.loop && et.virtual && et.params.virtual.enabled) {
        et.realIndex = dt(ot);
        return
    }
    const ct = et.grid && nt.grid && nt.grid.rows > 1;
    let ut;
    if (et.virtual && nt.virtual.enabled && nt.loop)
        ut = dt(ot);
    else if (ct) {
        const ft = et.slides.filter(gt=>gt.column === ot)[0];
        let ht = parseInt(ft.getAttribute("data-swiper-slide-index"), 10);
        Number.isNaN(ht) && (ht = Math.max(et.slides.indexOf(ft), 0)),
        ut = Math.floor(ht / nt.grid.rows)
    } else if (et.slides[ot]) {
        const ft = et.slides[ot].getAttribute("data-swiper-slide-index");
        ft ? ut = parseInt(ft, 10) : ut = ot
    } else
        ut = ot;
    Object.assign(et, {
        previousSnapIndex: at,
        snapIndex: lt,
        previousRealIndex: st,
        realIndex: ut,
        previousIndex: it,
        activeIndex: ot
    }),
    et.initialized && preload(et),
    et.emit("activeIndexChange"),
    et.emit("snapIndexChange"),
    (et.initialized || et.params.runCallbacksOnInit) && (st !== ut && et.emit("realIndexChange"),
    et.emit("slideChange"))
}
function updateClickedSlide(_e, et) {
    const tt = this
      , rt = tt.params;
    let nt = _e.closest(`.${rt.slideClass}, swiper-slide`);
    !nt && tt.isElement && et && et.length > 1 && et.includes(_e) && [...et.slice(et.indexOf(_e) + 1, et.length)].forEach(at=>{
        !nt && at.matches && at.matches(`.${rt.slideClass}, swiper-slide`) && (nt = at)
    }
    );
    let it = !1, st;
    if (nt) {
        for (let at = 0; at < tt.slides.length; at += 1)
            if (tt.slides[at] === nt) {
                it = !0,
                st = at;
                break
            }
    }
    if (nt && it)
        tt.clickedSlide = nt,
        tt.virtual && tt.params.virtual.enabled ? tt.clickedIndex = parseInt(nt.getAttribute("data-swiper-slide-index"), 10) : tt.clickedIndex = st;
    else {
        tt.clickedSlide = void 0,
        tt.clickedIndex = void 0;
        return
    }
    rt.slideToClickedSlide && tt.clickedIndex !== void 0 && tt.clickedIndex !== tt.activeIndex && tt.slideToClickedSlide()
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
function getSwiperTranslate(_e) {
    _e === void 0 && (_e = this.isHorizontal() ? "x" : "y");
    const et = this
      , {params: tt, rtlTranslate: rt, translate: nt, wrapperEl: it} = et;
    if (tt.virtualTranslate)
        return rt ? -nt : nt;
    if (tt.cssMode)
        return nt;
    let st = getTranslate(it, _e);
    return st += et.cssOverflowAdjustment(),
    rt && (st = -st),
    st || 0
}
function setTranslate(_e, et) {
    const tt = this
      , {rtlTranslate: rt, params: nt, wrapperEl: it, progress: st} = tt;
    let at = 0
      , ot = 0;
    const lt = 0;
    tt.isHorizontal() ? at = rt ? -_e : _e : ot = _e,
    nt.roundLengths && (at = Math.floor(at),
    ot = Math.floor(ot)),
    tt.previousTranslate = tt.translate,
    tt.translate = tt.isHorizontal() ? at : ot,
    nt.cssMode ? it[tt.isHorizontal() ? "scrollLeft" : "scrollTop"] = tt.isHorizontal() ? -at : -ot : nt.virtualTranslate || (tt.isHorizontal() ? at -= tt.cssOverflowAdjustment() : ot -= tt.cssOverflowAdjustment(),
    it.style.transform = `translate3d(${at}px, ${ot}px, ${lt}px)`);
    let dt;
    const ct = tt.maxTranslate() - tt.minTranslate();
    ct === 0 ? dt = 0 : dt = (_e - tt.minTranslate()) / ct,
    dt !== st && tt.updateProgress(_e),
    tt.emit("setTranslate", tt.translate, et)
}
function minTranslate() {
    return -this.snapGrid[0]
}
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1]
}
function translateTo(_e, et, tt, rt, nt) {
    _e === void 0 && (_e = 0),
    et === void 0 && (et = this.params.speed),
    tt === void 0 && (tt = !0),
    rt === void 0 && (rt = !0);
    const it = this
      , {params: st, wrapperEl: at} = it;
    if (it.animating && st.preventInteractionOnTransition)
        return !1;
    const ot = it.minTranslate()
      , lt = it.maxTranslate();
    let dt;
    if (rt && _e > ot ? dt = ot : rt && _e < lt ? dt = lt : dt = _e,
    it.updateProgress(dt),
    st.cssMode) {
        const ct = it.isHorizontal();
        if (et === 0)
            at[ct ? "scrollLeft" : "scrollTop"] = -dt;
        else {
            if (!it.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: it,
                    targetPosition: -dt,
                    side: ct ? "left" : "top"
                }),
                !0;
            at.scrollTo({
                [ct ? "left" : "top"]: -dt,
                behavior: "smooth"
            })
        }
        return !0
    }
    return et === 0 ? (it.setTransition(0),
    it.setTranslate(dt),
    tt && (it.emit("beforeTransitionStart", et, nt),
    it.emit("transitionEnd"))) : (it.setTransition(et),
    it.setTranslate(dt),
    tt && (it.emit("beforeTransitionStart", et, nt),
    it.emit("transitionStart")),
    it.animating || (it.animating = !0,
    it.onTranslateToWrapperTransitionEnd || (it.onTranslateToWrapperTransitionEnd = function(ut) {
        !it || it.destroyed || ut.target === this && (it.wrapperEl.removeEventListener("transitionend", it.onTranslateToWrapperTransitionEnd),
        it.onTranslateToWrapperTransitionEnd = null,
        delete it.onTranslateToWrapperTransitionEnd,
        tt && it.emit("transitionEnd"))
    }
    ),
    it.wrapperEl.addEventListener("transitionend", it.onTranslateToWrapperTransitionEnd))),
    !0
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
function setTransition(_e, et) {
    const tt = this;
    tt.params.cssMode || (tt.wrapperEl.style.transitionDuration = `${_e}ms`,
    tt.wrapperEl.style.transitionDelay = _e === 0 ? "0ms" : ""),
    tt.emit("setTransition", _e, et)
}
function transitionEmit(_e) {
    let {swiper: et, runCallbacks: tt, direction: rt, step: nt} = _e;
    const {activeIndex: it, previousIndex: st} = et;
    let at = rt;
    if (at || (it > st ? at = "next" : it < st ? at = "prev" : at = "reset"),
    et.emit(`transition${nt}`),
    tt && it !== st) {
        if (at === "reset") {
            et.emit(`slideResetTransition${nt}`);
            return
        }
        et.emit(`slideChangeTransition${nt}`),
        at === "next" ? et.emit(`slideNextTransition${nt}`) : et.emit(`slidePrevTransition${nt}`)
    }
}
function transitionStart(_e, et) {
    _e === void 0 && (_e = !0);
    const tt = this
      , {params: rt} = tt;
    rt.cssMode || (rt.autoHeight && tt.updateAutoHeight(),
    transitionEmit({
        swiper: tt,
        runCallbacks: _e,
        direction: et,
        step: "Start"
    }))
}
function transitionEnd(_e, et) {
    _e === void 0 && (_e = !0);
    const tt = this
      , {params: rt} = tt;
    tt.animating = !1,
    !rt.cssMode && (tt.setTransition(0),
    transitionEmit({
        swiper: tt,
        runCallbacks: _e,
        direction: et,
        step: "End"
    }))
}
var transition = {
    setTransition,
    transitionStart,
    transitionEnd
};
function slideTo(_e, et, tt, rt, nt) {
    _e === void 0 && (_e = 0),
    et === void 0 && (et = this.params.speed),
    tt === void 0 && (tt = !0),
    typeof _e == "string" && (_e = parseInt(_e, 10));
    const it = this;
    let st = _e;
    st < 0 && (st = 0);
    const {params: at, snapGrid: ot, slidesGrid: lt, previousIndex: dt, activeIndex: ct, rtlTranslate: ut, wrapperEl: ft, enabled: ht} = it;
    if (it.animating && at.preventInteractionOnTransition || !ht && !rt && !nt || it.destroyed)
        return !1;
    const gt = Math.min(it.params.slidesPerGroupSkip, st);
    let bt = gt + Math.floor((st - gt) / it.params.slidesPerGroup);
    bt >= ot.length && (bt = ot.length - 1);
    const pt = -ot[bt];
    if (at.normalizeSlideIndex)
        for (let yt = 0; yt < lt.length; yt += 1) {
            const vt = -Math.floor(pt * 100)
              , wt = Math.floor(lt[yt] * 100)
              , _t = Math.floor(lt[yt + 1] * 100);
            typeof lt[yt + 1] < "u" ? vt >= wt && vt < _t - (_t - wt) / 2 ? st = yt : vt >= wt && vt < _t && (st = yt + 1) : vt >= wt && (st = yt)
        }
    if (it.initialized && st !== ct && (!it.allowSlideNext && (ut ? pt > it.translate && pt > it.minTranslate() : pt < it.translate && pt < it.minTranslate()) || !it.allowSlidePrev && pt > it.translate && pt > it.maxTranslate() && (ct || 0) !== st))
        return !1;
    st !== (dt || 0) && tt && it.emit("beforeSlideChangeStart"),
    it.updateProgress(pt);
    let mt;
    if (st > ct ? mt = "next" : st < ct ? mt = "prev" : mt = "reset",
    ut && -pt === it.translate || !ut && pt === it.translate)
        return it.updateActiveIndex(st),
        at.autoHeight && it.updateAutoHeight(),
        it.updateSlidesClasses(),
        at.effect !== "slide" && it.setTranslate(pt),
        mt !== "reset" && (it.transitionStart(tt, mt),
        it.transitionEnd(tt, mt)),
        !1;
    if (at.cssMode) {
        const yt = it.isHorizontal()
          , vt = ut ? pt : -pt;
        if (et === 0) {
            const wt = it.virtual && it.params.virtual.enabled;
            wt && (it.wrapperEl.style.scrollSnapType = "none",
            it._immediateVirtual = !0),
            wt && !it._cssModeVirtualInitialSet && it.params.initialSlide > 0 ? (it._cssModeVirtualInitialSet = !0,
            requestAnimationFrame(()=>{
                ft[yt ? "scrollLeft" : "scrollTop"] = vt
            }
            )) : ft[yt ? "scrollLeft" : "scrollTop"] = vt,
            wt && requestAnimationFrame(()=>{
                it.wrapperEl.style.scrollSnapType = "",
                it._immediateVirtual = !1
            }
            )
        } else {
            if (!it.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: it,
                    targetPosition: vt,
                    side: yt ? "left" : "top"
                }),
                !0;
            ft.scrollTo({
                [yt ? "left" : "top"]: vt,
                behavior: "smooth"
            })
        }
        return !0
    }
    return it.setTransition(et),
    it.setTranslate(pt),
    it.updateActiveIndex(st),
    it.updateSlidesClasses(),
    it.emit("beforeTransitionStart", et, rt),
    it.transitionStart(tt, mt),
    et === 0 ? it.transitionEnd(tt, mt) : it.animating || (it.animating = !0,
    it.onSlideToWrapperTransitionEnd || (it.onSlideToWrapperTransitionEnd = function(vt) {
        !it || it.destroyed || vt.target === this && (it.wrapperEl.removeEventListener("transitionend", it.onSlideToWrapperTransitionEnd),
        it.onSlideToWrapperTransitionEnd = null,
        delete it.onSlideToWrapperTransitionEnd,
        it.transitionEnd(tt, mt))
    }
    ),
    it.wrapperEl.addEventListener("transitionend", it.onSlideToWrapperTransitionEnd)),
    !0
}
function slideToLoop(_e, et, tt, rt) {
    _e === void 0 && (_e = 0),
    et === void 0 && (et = this.params.speed),
    tt === void 0 && (tt = !0),
    typeof _e == "string" && (_e = parseInt(_e, 10));
    const nt = this;
    if (nt.destroyed)
        return;
    const it = nt.grid && nt.params.grid && nt.params.grid.rows > 1;
    let st = _e;
    if (nt.params.loop)
        if (nt.virtual && nt.params.virtual.enabled)
            st = st + nt.virtual.slidesBefore;
        else {
            let at;
            if (it) {
                const ut = st * nt.params.grid.rows;
                at = nt.slides.filter(ft=>ft.getAttribute("data-swiper-slide-index") * 1 === ut)[0].column
            } else
                at = nt.getSlideIndexByData(st);
            const ot = it ? Math.ceil(nt.slides.length / nt.params.grid.rows) : nt.slides.length
              , {centeredSlides: lt} = nt.params;
            let dt = nt.params.slidesPerView;
            dt === "auto" ? dt = nt.slidesPerViewDynamic() : (dt = Math.ceil(parseFloat(nt.params.slidesPerView, 10)),
            lt && dt % 2 === 0 && (dt = dt + 1));
            let ct = ot - at < dt;
            if (lt && (ct = ct || at < Math.ceil(dt / 2)),
            ct) {
                const ut = lt ? at < nt.activeIndex ? "prev" : "next" : at - nt.activeIndex - 1 < nt.params.slidesPerView ? "next" : "prev";
                nt.loopFix({
                    direction: ut,
                    slideTo: !0,
                    activeSlideIndex: ut === "next" ? at + 1 : at - ot + 1,
                    slideRealIndex: ut === "next" ? nt.realIndex : void 0
                })
            }
            if (it) {
                const ut = st * nt.params.grid.rows;
                st = nt.slides.filter(ft=>ft.getAttribute("data-swiper-slide-index") * 1 === ut)[0].column
            } else
                st = nt.getSlideIndexByData(st)
        }
    return requestAnimationFrame(()=>{
        nt.slideTo(st, et, tt, rt)
    }
    ),
    nt
}
function slideNext(_e, et, tt) {
    _e === void 0 && (_e = this.params.speed),
    et === void 0 && (et = !0);
    const rt = this
      , {enabled: nt, params: it, animating: st} = rt;
    if (!nt || rt.destroyed)
        return rt;
    let at = it.slidesPerGroup;
    it.slidesPerView === "auto" && it.slidesPerGroup === 1 && it.slidesPerGroupAuto && (at = Math.max(rt.slidesPerViewDynamic("current", !0), 1));
    const ot = rt.activeIndex < it.slidesPerGroupSkip ? 1 : at
      , lt = rt.virtual && it.virtual.enabled;
    if (it.loop) {
        if (st && !lt && it.loopPreventsSliding)
            return !1;
        if (rt.loopFix({
            direction: "next"
        }),
        rt._clientLeft = rt.wrapperEl.clientLeft,
        rt.activeIndex === rt.slides.length - 1 && it.cssMode)
            return requestAnimationFrame(()=>{
                rt.slideTo(rt.activeIndex + ot, _e, et, tt)
            }
            ),
            !0
    }
    return it.rewind && rt.isEnd ? rt.slideTo(0, _e, et, tt) : rt.slideTo(rt.activeIndex + ot, _e, et, tt)
}
function slidePrev(_e, et, tt) {
    _e === void 0 && (_e = this.params.speed),
    et === void 0 && (et = !0);
    const rt = this
      , {params: nt, snapGrid: it, slidesGrid: st, rtlTranslate: at, enabled: ot, animating: lt} = rt;
    if (!ot || rt.destroyed)
        return rt;
    const dt = rt.virtual && nt.virtual.enabled;
    if (nt.loop) {
        if (lt && !dt && nt.loopPreventsSliding)
            return !1;
        rt.loopFix({
            direction: "prev"
        }),
        rt._clientLeft = rt.wrapperEl.clientLeft
    }
    const ct = at ? rt.translate : -rt.translate;
    function ut(pt) {
        return pt < 0 ? -Math.floor(Math.abs(pt)) : Math.floor(pt)
    }
    const ft = ut(ct)
      , ht = it.map(pt=>ut(pt));
    let gt = it[ht.indexOf(ft) - 1];
    if (typeof gt > "u" && nt.cssMode) {
        let pt;
        it.forEach((mt,yt)=>{
            ft >= mt && (pt = yt)
        }
        ),
        typeof pt < "u" && (gt = it[pt > 0 ? pt - 1 : pt])
    }
    let bt = 0;
    if (typeof gt < "u" && (bt = st.indexOf(gt),
    bt < 0 && (bt = rt.activeIndex - 1),
    nt.slidesPerView === "auto" && nt.slidesPerGroup === 1 && nt.slidesPerGroupAuto && (bt = bt - rt.slidesPerViewDynamic("previous", !0) + 1,
    bt = Math.max(bt, 0))),
    nt.rewind && rt.isBeginning) {
        const pt = rt.params.virtual && rt.params.virtual.enabled && rt.virtual ? rt.virtual.slides.length - 1 : rt.slides.length - 1;
        return rt.slideTo(pt, _e, et, tt)
    } else if (nt.loop && rt.activeIndex === 0 && nt.cssMode)
        return requestAnimationFrame(()=>{
            rt.slideTo(bt, _e, et, tt)
        }
        ),
        !0;
    return rt.slideTo(bt, _e, et, tt)
}
function slideReset(_e, et, tt) {
    _e === void 0 && (_e = this.params.speed),
    et === void 0 && (et = !0);
    const rt = this;
    if (!rt.destroyed)
        return rt.slideTo(rt.activeIndex, _e, et, tt)
}
function slideToClosest(_e, et, tt, rt) {
    _e === void 0 && (_e = this.params.speed),
    et === void 0 && (et = !0),
    rt === void 0 && (rt = .5);
    const nt = this;
    if (nt.destroyed)
        return;
    let it = nt.activeIndex;
    const st = Math.min(nt.params.slidesPerGroupSkip, it)
      , at = st + Math.floor((it - st) / nt.params.slidesPerGroup)
      , ot = nt.rtlTranslate ? nt.translate : -nt.translate;
    if (ot >= nt.snapGrid[at]) {
        const lt = nt.snapGrid[at]
          , dt = nt.snapGrid[at + 1];
        ot - lt > (dt - lt) * rt && (it += nt.params.slidesPerGroup)
    } else {
        const lt = nt.snapGrid[at - 1]
          , dt = nt.snapGrid[at];
        ot - lt <= (dt - lt) * rt && (it -= nt.params.slidesPerGroup)
    }
    return it = Math.max(it, 0),
    it = Math.min(it, nt.slidesGrid.length - 1),
    nt.slideTo(it, _e, et, tt)
}
function slideToClickedSlide() {
    const _e = this;
    if (_e.destroyed)
        return;
    const {params: et, slidesEl: tt} = _e
      , rt = et.slidesPerView === "auto" ? _e.slidesPerViewDynamic() : et.slidesPerView;
    let nt = _e.clickedIndex, it;
    const st = _e.isElement ? "swiper-slide" : `.${et.slideClass}`;
    if (et.loop) {
        if (_e.animating)
            return;
        it = parseInt(_e.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
        et.centeredSlides ? nt < _e.loopedSlides - rt / 2 || nt > _e.slides.length - _e.loopedSlides + rt / 2 ? (_e.loopFix(),
        nt = _e.getSlideIndex(elementChildren(tt, `${st}[data-swiper-slide-index="${it}"]`)[0]),
        nextTick(()=>{
            _e.slideTo(nt)
        }
        )) : _e.slideTo(nt) : nt > _e.slides.length - rt ? (_e.loopFix(),
        nt = _e.getSlideIndex(elementChildren(tt, `${st}[data-swiper-slide-index="${it}"]`)[0]),
        nextTick(()=>{
            _e.slideTo(nt)
        }
        )) : _e.slideTo(nt)
    } else
        _e.slideTo(nt)
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
function loopCreate(_e) {
    const et = this
      , {params: tt, slidesEl: rt} = et;
    if (!tt.loop || et.virtual && et.params.virtual.enabled)
        return;
    const nt = ()=>{
        elementChildren(rt, `.${tt.slideClass}, swiper-slide`).forEach((ct,ut)=>{
            ct.setAttribute("data-swiper-slide-index", ut)
        }
        )
    }
      , it = et.grid && tt.grid && tt.grid.rows > 1
      , st = tt.slidesPerGroup * (it ? tt.grid.rows : 1)
      , at = et.slides.length % st !== 0
      , ot = it && et.slides.length % tt.grid.rows !== 0
      , lt = dt=>{
        for (let ct = 0; ct < dt; ct += 1) {
            const ut = et.isElement ? createElement("swiper-slide", [tt.slideBlankClass]) : createElement("div", [tt.slideClass, tt.slideBlankClass]);
            et.slidesEl.append(ut)
        }
    }
    ;
    if (at) {
        if (tt.loopAddBlankSlides) {
            const dt = st - et.slides.length % st;
            lt(dt),
            et.recalcSlides(),
            et.updateSlides()
        } else
            showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        nt()
    } else if (ot) {
        if (tt.loopAddBlankSlides) {
            const dt = tt.grid.rows - et.slides.length % tt.grid.rows;
            lt(dt),
            et.recalcSlides(),
            et.updateSlides()
        } else
            showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        nt()
    } else
        nt();
    et.loopFix({
        slideRealIndex: _e,
        direction: tt.centeredSlides ? void 0 : "next"
    })
}
function loopFix(_e) {
    let {slideRealIndex: et, slideTo: tt=!0, direction: rt, setTranslate: nt, activeSlideIndex: it, byController: st, byMousewheel: at} = _e === void 0 ? {} : _e;
    const ot = this;
    if (!ot.params.loop)
        return;
    ot.emit("beforeLoopFix");
    const {slides: lt, allowSlidePrev: dt, allowSlideNext: ct, slidesEl: ut, params: ft} = ot
      , {centeredSlides: ht} = ft;
    if (ot.allowSlidePrev = !0,
    ot.allowSlideNext = !0,
    ot.virtual && ft.virtual.enabled) {
        tt && (!ft.centeredSlides && ot.snapIndex === 0 ? ot.slideTo(ot.virtual.slides.length, 0, !1, !0) : ft.centeredSlides && ot.snapIndex < ft.slidesPerView ? ot.slideTo(ot.virtual.slides.length + ot.snapIndex, 0, !1, !0) : ot.snapIndex === ot.snapGrid.length - 1 && ot.slideTo(ot.virtual.slidesBefore, 0, !1, !0)),
        ot.allowSlidePrev = dt,
        ot.allowSlideNext = ct,
        ot.emit("loopFix");
        return
    }
    let gt = ft.slidesPerView;
    gt === "auto" ? gt = ot.slidesPerViewDynamic() : (gt = Math.ceil(parseFloat(ft.slidesPerView, 10)),
    ht && gt % 2 === 0 && (gt = gt + 1));
    const bt = ft.slidesPerGroupAuto ? gt : ft.slidesPerGroup;
    let pt = bt;
    pt % bt !== 0 && (pt += bt - pt % bt),
    pt += ft.loopAdditionalSlides,
    ot.loopedSlides = pt;
    const mt = ot.grid && ft.grid && ft.grid.rows > 1;
    lt.length < gt + pt ? showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : mt && ft.grid.fill === "row" && showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const yt = []
      , vt = [];
    let wt = ot.activeIndex;
    typeof it > "u" ? it = ot.getSlideIndex(lt.filter(Ft=>Ft.classList.contains(ft.slideActiveClass))[0]) : wt = it;
    const _t = rt === "next" || !rt
      , Et = rt === "prev" || !rt;
    let xt = 0
      , Ct = 0;
    const Tt = mt ? Math.ceil(lt.length / ft.grid.rows) : lt.length
      , Nt = (mt ? lt[it].column : it) + (ht && typeof nt > "u" ? -gt / 2 + .5 : 0);
    if (Nt < pt) {
        xt = Math.max(pt - Nt, bt);
        for (let Ft = 0; Ft < pt - Nt; Ft += 1) {
            const Lt = Ft - Math.floor(Ft / Tt) * Tt;
            if (mt) {
                const Mt = Tt - Lt - 1;
                for (let $t = lt.length - 1; $t >= 0; $t -= 1)
                    lt[$t].column === Mt && yt.push($t)
            } else
                yt.push(Tt - Lt - 1)
        }
    } else if (Nt + gt > Tt - pt) {
        Ct = Math.max(Nt - (Tt - pt * 2), bt);
        for (let Ft = 0; Ft < Ct; Ft += 1) {
            const Lt = Ft - Math.floor(Ft / Tt) * Tt;
            mt ? lt.forEach((Mt,$t)=>{
                Mt.column === Lt && vt.push($t)
            }
            ) : vt.push(Lt)
        }
    }
    if (ot.__preventObserver__ = !0,
    requestAnimationFrame(()=>{
        ot.__preventObserver__ = !1
    }
    ),
    Et && yt.forEach(Ft=>{
        lt[Ft].swiperLoopMoveDOM = !0,
        ut.prepend(lt[Ft]),
        lt[Ft].swiperLoopMoveDOM = !1
    }
    ),
    _t && vt.forEach(Ft=>{
        lt[Ft].swiperLoopMoveDOM = !0,
        ut.append(lt[Ft]),
        lt[Ft].swiperLoopMoveDOM = !1
    }
    ),
    ot.recalcSlides(),
    ft.slidesPerView === "auto" ? ot.updateSlides() : mt && (yt.length > 0 && Et || vt.length > 0 && _t) && ot.slides.forEach((Ft,Lt)=>{
        ot.grid.updateSlide(Lt, Ft, ot.slides)
    }
    ),
    ft.watchSlidesProgress && ot.updateSlidesOffset(),
    tt) {
        if (yt.length > 0 && Et) {
            if (typeof et > "u") {
                const Ft = ot.slidesGrid[wt]
                  , Mt = ot.slidesGrid[wt + xt] - Ft;
                at ? ot.setTranslate(ot.translate - Mt) : (ot.slideTo(wt + xt, 0, !1, !0),
                nt && (ot.touchEventsData.startTranslate = ot.touchEventsData.startTranslate - Mt,
                ot.touchEventsData.currentTranslate = ot.touchEventsData.currentTranslate - Mt))
            } else if (nt) {
                const Ft = mt ? yt.length / ft.grid.rows : yt.length;
                ot.slideTo(ot.activeIndex + Ft, 0, !1, !0),
                ot.touchEventsData.currentTranslate = ot.translate
            }
        } else if (vt.length > 0 && _t)
            if (typeof et > "u") {
                const Ft = ot.slidesGrid[wt]
                  , Mt = ot.slidesGrid[wt - Ct] - Ft;
                at ? ot.setTranslate(ot.translate - Mt) : (ot.slideTo(wt - Ct, 0, !1, !0),
                nt && (ot.touchEventsData.startTranslate = ot.touchEventsData.startTranslate - Mt,
                ot.touchEventsData.currentTranslate = ot.touchEventsData.currentTranslate - Mt))
            } else {
                const Ft = mt ? vt.length / ft.grid.rows : vt.length;
                ot.slideTo(ot.activeIndex - Ft, 0, !1, !0)
            }
    }
    if (ot.allowSlidePrev = dt,
    ot.allowSlideNext = ct,
    ot.controller && ot.controller.control && !st) {
        const Ft = {
            slideRealIndex: et,
            direction: rt,
            setTranslate: nt,
            activeSlideIndex: it,
            byController: !0
        };
        Array.isArray(ot.controller.control) ? ot.controller.control.forEach(Lt=>{
            !Lt.destroyed && Lt.params.loop && Lt.loopFix({
                ...Ft,
                slideTo: Lt.params.slidesPerView === ft.slidesPerView ? tt : !1
            })
        }
        ) : ot.controller.control instanceof ot.constructor && ot.controller.control.params.loop && ot.controller.control.loopFix({
            ...Ft,
            slideTo: ot.controller.control.params.slidesPerView === ft.slidesPerView ? tt : !1
        })
    }
    ot.emit("loopFix")
}
function loopDestroy() {
    const _e = this
      , {params: et, slidesEl: tt} = _e;
    if (!et.loop || _e.virtual && _e.params.virtual.enabled)
        return;
    _e.recalcSlides();
    const rt = [];
    _e.slides.forEach(nt=>{
        const it = typeof nt.swiperSlideIndex > "u" ? nt.getAttribute("data-swiper-slide-index") * 1 : nt.swiperSlideIndex;
        rt[it] = nt
    }
    ),
    _e.slides.forEach(nt=>{
        nt.removeAttribute("data-swiper-slide-index")
    }
    ),
    rt.forEach(nt=>{
        tt.append(nt)
    }
    ),
    _e.recalcSlides(),
    _e.slideTo(_e.realIndex, 0)
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};
function setGrabCursor(_e) {
    const et = this;
    if (!et.params.simulateTouch || et.params.watchOverflow && et.isLocked || et.params.cssMode)
        return;
    const tt = et.params.touchEventsTarget === "container" ? et.el : et.wrapperEl;
    et.isElement && (et.__preventObserver__ = !0),
    tt.style.cursor = "move",
    tt.style.cursor = _e ? "grabbing" : "grab",
    et.isElement && requestAnimationFrame(()=>{
        et.__preventObserver__ = !1
    }
    )
}
function unsetGrabCursor() {
    const _e = this;
    _e.params.watchOverflow && _e.isLocked || _e.params.cssMode || (_e.isElement && (_e.__preventObserver__ = !0),
    _e[_e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "",
    _e.isElement && requestAnimationFrame(()=>{
        _e.__preventObserver__ = !1
    }
    ))
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};
function closestElement(_e, et) {
    et === void 0 && (et = this);
    function tt(rt) {
        if (!rt || rt === getDocument() || rt === getWindow())
            return null;
        rt.assignedSlot && (rt = rt.assignedSlot);
        const nt = rt.closest(_e);
        return !nt && !rt.getRootNode ? null : nt || tt(rt.getRootNode().host)
    }
    return tt(et)
}
function preventEdgeSwipe(_e, et, tt) {
    const rt = getWindow()
      , {params: nt} = _e
      , it = nt.edgeSwipeDetection
      , st = nt.edgeSwipeThreshold;
    return it && (tt <= st || tt >= rt.innerWidth - st) ? it === "prevent" ? (et.preventDefault(),
    !0) : !1 : !0
}
function onTouchStart(_e) {
    const et = this
      , tt = getDocument();
    let rt = _e;
    rt.originalEvent && (rt = rt.originalEvent);
    const nt = et.touchEventsData;
    if (rt.type === "pointerdown") {
        if (nt.pointerId !== null && nt.pointerId !== rt.pointerId)
            return;
        nt.pointerId = rt.pointerId
    } else
        rt.type === "touchstart" && rt.targetTouches.length === 1 && (nt.touchId = rt.targetTouches[0].identifier);
    if (rt.type === "touchstart") {
        preventEdgeSwipe(et, rt, rt.targetTouches[0].pageX);
        return
    }
    const {params: it, touches: st, enabled: at} = et;
    if (!at || !it.simulateTouch && rt.pointerType === "mouse" || et.animating && it.preventInteractionOnTransition)
        return;
    !et.animating && it.cssMode && it.loop && et.loopFix();
    let ot = rt.target;
    if (it.touchEventsTarget === "wrapper" && !et.wrapperEl.contains(ot) || "which"in rt && rt.which === 3 || "button"in rt && rt.button > 0 || nt.isTouched && nt.isMoved)
        return;
    const lt = !!it.noSwipingClass && it.noSwipingClass !== ""
      , dt = rt.composedPath ? rt.composedPath() : rt.path;
    lt && rt.target && rt.target.shadowRoot && dt && (ot = dt[0]);
    const ct = it.noSwipingSelector ? it.noSwipingSelector : `.${it.noSwipingClass}`
      , ut = !!(rt.target && rt.target.shadowRoot);
    if (it.noSwiping && (ut ? closestElement(ct, ot) : ot.closest(ct))) {
        et.allowClick = !0;
        return
    }
    if (it.swipeHandler && !ot.closest(it.swipeHandler))
        return;
    st.currentX = rt.pageX,
    st.currentY = rt.pageY;
    const ft = st.currentX
      , ht = st.currentY;
    if (!preventEdgeSwipe(et, rt, ft))
        return;
    Object.assign(nt, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
    st.startX = ft,
    st.startY = ht,
    nt.touchStartTime = now(),
    et.allowClick = !0,
    et.updateSize(),
    et.swipeDirection = void 0,
    it.threshold > 0 && (nt.allowThresholdMove = !1);
    let gt = !0;
    ot.matches(nt.focusableElements) && (gt = !1,
    ot.nodeName === "SELECT" && (nt.isTouched = !1)),
    tt.activeElement && tt.activeElement.matches(nt.focusableElements) && tt.activeElement !== ot && tt.activeElement.blur();
    const bt = gt && et.allowTouchMove && it.touchStartPreventDefault;
    (it.touchStartForcePreventDefault || bt) && !ot.isContentEditable && rt.preventDefault(),
    it.freeMode && it.freeMode.enabled && et.freeMode && et.animating && !it.cssMode && et.freeMode.onTouchStart(),
    et.emit("touchStart", rt)
}
function onTouchMove(_e) {
    const et = getDocument()
      , tt = this
      , rt = tt.touchEventsData
      , {params: nt, touches: it, rtlTranslate: st, enabled: at} = tt;
    if (!at || !nt.simulateTouch && _e.pointerType === "mouse")
        return;
    let ot = _e;
    if (ot.originalEvent && (ot = ot.originalEvent),
    ot.type === "pointermove" && (rt.touchId !== null || ot.pointerId !== rt.pointerId))
        return;
    let lt;
    if (ot.type === "touchmove") {
        if (lt = [...ot.changedTouches].filter(_t=>_t.identifier === rt.touchId)[0],
        !lt || lt.identifier !== rt.touchId)
            return
    } else
        lt = ot;
    if (!rt.isTouched) {
        rt.startMoving && rt.isScrolling && tt.emit("touchMoveOpposite", ot);
        return
    }
    const dt = lt.pageX
      , ct = lt.pageY;
    if (ot.preventedByNestedSwiper) {
        it.startX = dt,
        it.startY = ct;
        return
    }
    if (!tt.allowTouchMove) {
        ot.target.matches(rt.focusableElements) || (tt.allowClick = !1),
        rt.isTouched && (Object.assign(it, {
            startX: dt,
            startY: ct,
            currentX: dt,
            currentY: ct
        }),
        rt.touchStartTime = now());
        return
    }
    if (nt.touchReleaseOnEdges && !nt.loop) {
        if (tt.isVertical()) {
            if (ct < it.startY && tt.translate <= tt.maxTranslate() || ct > it.startY && tt.translate >= tt.minTranslate()) {
                rt.isTouched = !1,
                rt.isMoved = !1;
                return
            }
        } else if (dt < it.startX && tt.translate <= tt.maxTranslate() || dt > it.startX && tt.translate >= tt.minTranslate())
            return
    }
    if (et.activeElement && ot.target === et.activeElement && ot.target.matches(rt.focusableElements)) {
        rt.isMoved = !0,
        tt.allowClick = !1;
        return
    }
    rt.allowTouchCallbacks && tt.emit("touchMove", ot),
    it.previousX = it.currentX,
    it.previousY = it.currentY,
    it.currentX = dt,
    it.currentY = ct;
    const ut = it.currentX - it.startX
      , ft = it.currentY - it.startY;
    if (tt.params.threshold && Math.sqrt(ut ** 2 + ft ** 2) < tt.params.threshold)
        return;
    if (typeof rt.isScrolling > "u") {
        let _t;
        tt.isHorizontal() && it.currentY === it.startY || tt.isVertical() && it.currentX === it.startX ? rt.isScrolling = !1 : ut * ut + ft * ft >= 25 && (_t = Math.atan2(Math.abs(ft), Math.abs(ut)) * 180 / Math.PI,
        rt.isScrolling = tt.isHorizontal() ? _t > nt.touchAngle : 90 - _t > nt.touchAngle)
    }
    if (rt.isScrolling && tt.emit("touchMoveOpposite", ot),
    typeof rt.startMoving > "u" && (it.currentX !== it.startX || it.currentY !== it.startY) && (rt.startMoving = !0),
    rt.isScrolling) {
        rt.isTouched = !1;
        return
    }
    if (!rt.startMoving)
        return;
    tt.allowClick = !1,
    !nt.cssMode && ot.cancelable && ot.preventDefault(),
    nt.touchMoveStopPropagation && !nt.nested && ot.stopPropagation();
    let ht = tt.isHorizontal() ? ut : ft
      , gt = tt.isHorizontal() ? it.currentX - it.previousX : it.currentY - it.previousY;
    nt.oneWayMovement && (ht = Math.abs(ht) * (st ? 1 : -1),
    gt = Math.abs(gt) * (st ? 1 : -1)),
    it.diff = ht,
    ht *= nt.touchRatio,
    st && (ht = -ht,
    gt = -gt);
    const bt = tt.touchesDirection;
    tt.swipeDirection = ht > 0 ? "prev" : "next",
    tt.touchesDirection = gt > 0 ? "prev" : "next";
    const pt = tt.params.loop && !nt.cssMode
      , mt = tt.touchesDirection === "next" && tt.allowSlideNext || tt.touchesDirection === "prev" && tt.allowSlidePrev;
    if (!rt.isMoved) {
        if (pt && mt && tt.loopFix({
            direction: tt.swipeDirection
        }),
        rt.startTranslate = tt.getTranslate(),
        tt.setTransition(0),
        tt.animating) {
            const _t = new window.CustomEvent("transitionend",{
                bubbles: !0,
                cancelable: !0
            });
            tt.wrapperEl.dispatchEvent(_t)
        }
        rt.allowMomentumBounce = !1,
        nt.grabCursor && (tt.allowSlideNext === !0 || tt.allowSlidePrev === !0) && tt.setGrabCursor(!0),
        tt.emit("sliderFirstMove", ot)
    }
    let yt;
    if (new Date().getTime(),
    rt.isMoved && rt.allowThresholdMove && bt !== tt.touchesDirection && pt && mt && Math.abs(ht) >= 1) {
        Object.assign(it, {
            startX: dt,
            startY: ct,
            currentX: dt,
            currentY: ct,
            startTranslate: rt.currentTranslate
        }),
        rt.loopSwapReset = !0,
        rt.startTranslate = rt.currentTranslate;
        return
    }
    tt.emit("sliderMove", ot),
    rt.isMoved = !0,
    rt.currentTranslate = ht + rt.startTranslate;
    let vt = !0
      , wt = nt.resistanceRatio;
    if (nt.touchReleaseOnEdges && (wt = 0),
    ht > 0 ? (pt && mt && !yt && rt.allowThresholdMove && rt.currentTranslate > (nt.centeredSlides ? tt.minTranslate() - tt.slidesSizesGrid[tt.activeIndex + 1] : tt.minTranslate()) && tt.loopFix({
        direction: "prev",
        setTranslate: !0,
        activeSlideIndex: 0
    }),
    rt.currentTranslate > tt.minTranslate() && (vt = !1,
    nt.resistance && (rt.currentTranslate = tt.minTranslate() - 1 + (-tt.minTranslate() + rt.startTranslate + ht) ** wt))) : ht < 0 && (pt && mt && !yt && rt.allowThresholdMove && rt.currentTranslate < (nt.centeredSlides ? tt.maxTranslate() + tt.slidesSizesGrid[tt.slidesSizesGrid.length - 1] : tt.maxTranslate()) && tt.loopFix({
        direction: "next",
        setTranslate: !0,
        activeSlideIndex: tt.slides.length - (nt.slidesPerView === "auto" ? tt.slidesPerViewDynamic() : Math.ceil(parseFloat(nt.slidesPerView, 10)))
    }),
    rt.currentTranslate < tt.maxTranslate() && (vt = !1,
    nt.resistance && (rt.currentTranslate = tt.maxTranslate() + 1 - (tt.maxTranslate() - rt.startTranslate - ht) ** wt))),
    vt && (ot.preventedByNestedSwiper = !0),
    !tt.allowSlideNext && tt.swipeDirection === "next" && rt.currentTranslate < rt.startTranslate && (rt.currentTranslate = rt.startTranslate),
    !tt.allowSlidePrev && tt.swipeDirection === "prev" && rt.currentTranslate > rt.startTranslate && (rt.currentTranslate = rt.startTranslate),
    !tt.allowSlidePrev && !tt.allowSlideNext && (rt.currentTranslate = rt.startTranslate),
    nt.threshold > 0)
        if (Math.abs(ht) > nt.threshold || rt.allowThresholdMove) {
            if (!rt.allowThresholdMove) {
                rt.allowThresholdMove = !0,
                it.startX = it.currentX,
                it.startY = it.currentY,
                rt.currentTranslate = rt.startTranslate,
                it.diff = tt.isHorizontal() ? it.currentX - it.startX : it.currentY - it.startY;
                return
            }
        } else {
            rt.currentTranslate = rt.startTranslate;
            return
        }
    !nt.followFinger || nt.cssMode || ((nt.freeMode && nt.freeMode.enabled && tt.freeMode || nt.watchSlidesProgress) && (tt.updateActiveIndex(),
    tt.updateSlidesClasses()),
    nt.freeMode && nt.freeMode.enabled && tt.freeMode && tt.freeMode.onTouchMove(),
    tt.updateProgress(rt.currentTranslate),
    tt.setTranslate(rt.currentTranslate))
}
function onTouchEnd(_e) {
    const et = this
      , tt = et.touchEventsData;
    let rt = _e;
    rt.originalEvent && (rt = rt.originalEvent);
    let nt;
    if (rt.type === "touchend" || rt.type === "touchcancel") {
        if (nt = [...rt.changedTouches].filter(wt=>wt.identifier === tt.touchId)[0],
        !nt || nt.identifier !== tt.touchId)
            return
    } else {
        if (tt.touchId !== null || rt.pointerId !== tt.pointerId)
            return;
        nt = rt
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(rt.type) && !(["pointercancel", "contextmenu"].includes(rt.type) && (et.browser.isSafari || et.browser.isWebView)))
        return;
    tt.pointerId = null,
    tt.touchId = null;
    const {params: st, touches: at, rtlTranslate: ot, slidesGrid: lt, enabled: dt} = et;
    if (!dt || !st.simulateTouch && rt.pointerType === "mouse")
        return;
    if (tt.allowTouchCallbacks && et.emit("touchEnd", rt),
    tt.allowTouchCallbacks = !1,
    !tt.isTouched) {
        tt.isMoved && st.grabCursor && et.setGrabCursor(!1),
        tt.isMoved = !1,
        tt.startMoving = !1;
        return
    }
    st.grabCursor && tt.isMoved && tt.isTouched && (et.allowSlideNext === !0 || et.allowSlidePrev === !0) && et.setGrabCursor(!1);
    const ct = now()
      , ut = ct - tt.touchStartTime;
    if (et.allowClick) {
        const wt = rt.path || rt.composedPath && rt.composedPath();
        et.updateClickedSlide(wt && wt[0] || rt.target, wt),
        et.emit("tap click", rt),
        ut < 300 && ct - tt.lastClickTime < 300 && et.emit("doubleTap doubleClick", rt)
    }
    if (tt.lastClickTime = now(),
    nextTick(()=>{
        et.destroyed || (et.allowClick = !0)
    }
    ),
    !tt.isTouched || !tt.isMoved || !et.swipeDirection || at.diff === 0 && !tt.loopSwapReset || tt.currentTranslate === tt.startTranslate && !tt.loopSwapReset) {
        tt.isTouched = !1,
        tt.isMoved = !1,
        tt.startMoving = !1;
        return
    }
    tt.isTouched = !1,
    tt.isMoved = !1,
    tt.startMoving = !1;
    let ft;
    if (st.followFinger ? ft = ot ? et.translate : -et.translate : ft = -tt.currentTranslate,
    st.cssMode)
        return;
    if (st.freeMode && st.freeMode.enabled) {
        et.freeMode.onTouchEnd({
            currentPos: ft
        });
        return
    }
    const ht = ft >= -et.maxTranslate() && !et.params.loop;
    let gt = 0
      , bt = et.slidesSizesGrid[0];
    for (let wt = 0; wt < lt.length; wt += wt < st.slidesPerGroupSkip ? 1 : st.slidesPerGroup) {
        const _t = wt < st.slidesPerGroupSkip - 1 ? 1 : st.slidesPerGroup;
        typeof lt[wt + _t] < "u" ? (ht || ft >= lt[wt] && ft < lt[wt + _t]) && (gt = wt,
        bt = lt[wt + _t] - lt[wt]) : (ht || ft >= lt[wt]) && (gt = wt,
        bt = lt[lt.length - 1] - lt[lt.length - 2])
    }
    let pt = null
      , mt = null;
    st.rewind && (et.isBeginning ? mt = st.virtual && st.virtual.enabled && et.virtual ? et.virtual.slides.length - 1 : et.slides.length - 1 : et.isEnd && (pt = 0));
    const yt = (ft - lt[gt]) / bt
      , vt = gt < st.slidesPerGroupSkip - 1 ? 1 : st.slidesPerGroup;
    if (ut > st.longSwipesMs) {
        if (!st.longSwipes) {
            et.slideTo(et.activeIndex);
            return
        }
        et.swipeDirection === "next" && (yt >= st.longSwipesRatio ? et.slideTo(st.rewind && et.isEnd ? pt : gt + vt) : et.slideTo(gt)),
        et.swipeDirection === "prev" && (yt > 1 - st.longSwipesRatio ? et.slideTo(gt + vt) : mt !== null && yt < 0 && Math.abs(yt) > st.longSwipesRatio ? et.slideTo(mt) : et.slideTo(gt))
    } else {
        if (!st.shortSwipes) {
            et.slideTo(et.activeIndex);
            return
        }
        et.navigation && (rt.target === et.navigation.nextEl || rt.target === et.navigation.prevEl) ? rt.target === et.navigation.nextEl ? et.slideTo(gt + vt) : et.slideTo(gt) : (et.swipeDirection === "next" && et.slideTo(pt !== null ? pt : gt + vt),
        et.swipeDirection === "prev" && et.slideTo(mt !== null ? mt : gt))
    }
}
function onResize() {
    const _e = this
      , {params: et, el: tt} = _e;
    if (tt && tt.offsetWidth === 0)
        return;
    et.breakpoints && _e.setBreakpoint();
    const {allowSlideNext: rt, allowSlidePrev: nt, snapGrid: it} = _e
      , st = _e.virtual && _e.params.virtual.enabled;
    _e.allowSlideNext = !0,
    _e.allowSlidePrev = !0,
    _e.updateSize(),
    _e.updateSlides(),
    _e.updateSlidesClasses();
    const at = st && et.loop;
    (et.slidesPerView === "auto" || et.slidesPerView > 1) && _e.isEnd && !_e.isBeginning && !_e.params.centeredSlides && !at ? _e.slideTo(_e.slides.length - 1, 0, !1, !0) : _e.params.loop && !st ? _e.slideToLoop(_e.realIndex, 0, !1, !0) : _e.slideTo(_e.activeIndex, 0, !1, !0),
    _e.autoplay && _e.autoplay.running && _e.autoplay.paused && (clearTimeout(_e.autoplay.resizeTimeout),
    _e.autoplay.resizeTimeout = setTimeout(()=>{
        _e.autoplay && _e.autoplay.running && _e.autoplay.paused && _e.autoplay.resume()
    }
    , 500)),
    _e.allowSlidePrev = nt,
    _e.allowSlideNext = rt,
    _e.params.watchOverflow && it !== _e.snapGrid && _e.checkOverflow()
}
function onClick(_e) {
    const et = this;
    et.enabled && (et.allowClick || (et.params.preventClicks && _e.preventDefault(),
    et.params.preventClicksPropagation && et.animating && (_e.stopPropagation(),
    _e.stopImmediatePropagation())))
}
function onScroll() {
    const _e = this
      , {wrapperEl: et, rtlTranslate: tt, enabled: rt} = _e;
    if (!rt)
        return;
    _e.previousTranslate = _e.translate,
    _e.isHorizontal() ? _e.translate = -et.scrollLeft : _e.translate = -et.scrollTop,
    _e.translate === 0 && (_e.translate = 0),
    _e.updateActiveIndex(),
    _e.updateSlidesClasses();
    let nt;
    const it = _e.maxTranslate() - _e.minTranslate();
    it === 0 ? nt = 0 : nt = (_e.translate - _e.minTranslate()) / it,
    nt !== _e.progress && _e.updateProgress(tt ? -_e.translate : _e.translate),
    _e.emit("setTranslate", _e.translate, !1)
}
function onLoad(_e) {
    const et = this;
    processLazyPreloader(et, _e.target),
    !(et.params.cssMode || et.params.slidesPerView !== "auto" && !et.params.autoHeight) && et.update()
}
function onDocumentTouchStart() {
    const _e = this;
    _e.documentTouchHandlerProceeded || (_e.documentTouchHandlerProceeded = !0,
    _e.params.touchReleaseOnEdges && (_e.el.style.touchAction = "auto"))
}
const events = (_e,et)=>{
    const tt = getDocument()
      , {params: rt, el: nt, wrapperEl: it, device: st} = _e
      , at = !!rt.nested
      , ot = et === "on" ? "addEventListener" : "removeEventListener"
      , lt = et;
    tt[ot]("touchstart", _e.onDocumentTouchStart, {
        passive: !1,
        capture: at
    }),
    nt[ot]("touchstart", _e.onTouchStart, {
        passive: !1
    }),
    nt[ot]("pointerdown", _e.onTouchStart, {
        passive: !1
    }),
    tt[ot]("touchmove", _e.onTouchMove, {
        passive: !1,
        capture: at
    }),
    tt[ot]("pointermove", _e.onTouchMove, {
        passive: !1,
        capture: at
    }),
    tt[ot]("touchend", _e.onTouchEnd, {
        passive: !0
    }),
    tt[ot]("pointerup", _e.onTouchEnd, {
        passive: !0
    }),
    tt[ot]("pointercancel", _e.onTouchEnd, {
        passive: !0
    }),
    tt[ot]("touchcancel", _e.onTouchEnd, {
        passive: !0
    }),
    tt[ot]("pointerout", _e.onTouchEnd, {
        passive: !0
    }),
    tt[ot]("pointerleave", _e.onTouchEnd, {
        passive: !0
    }),
    tt[ot]("contextmenu", _e.onTouchEnd, {
        passive: !0
    }),
    (rt.preventClicks || rt.preventClicksPropagation) && nt[ot]("click", _e.onClick, !0),
    rt.cssMode && it[ot]("scroll", _e.onScroll),
    rt.updateOnWindowResize ? _e[lt](st.ios || st.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : _e[lt]("observerUpdate", onResize, !0),
    nt[ot]("load", _e.onLoad, {
        capture: !0
    })
}
;
function attachEvents() {
    const _e = this
      , {params: et} = _e;
    _e.onTouchStart = onTouchStart.bind(_e),
    _e.onTouchMove = onTouchMove.bind(_e),
    _e.onTouchEnd = onTouchEnd.bind(_e),
    _e.onDocumentTouchStart = onDocumentTouchStart.bind(_e),
    et.cssMode && (_e.onScroll = onScroll.bind(_e)),
    _e.onClick = onClick.bind(_e),
    _e.onLoad = onLoad.bind(_e),
    events(_e, "on")
}
function detachEvents() {
    events(this, "off")
}
var events$1 = {
    attachEvents,
    detachEvents
};
const isGridEnabled = (_e,et)=>_e.grid && et.grid && et.grid.rows > 1;
function setBreakpoint() {
    const _e = this
      , {realIndex: et, initialized: tt, params: rt, el: nt} = _e
      , it = rt.breakpoints;
    if (!it || it && Object.keys(it).length === 0)
        return;
    const st = _e.getBreakpoint(it, _e.params.breakpointsBase, _e.el);
    if (!st || _e.currentBreakpoint === st)
        return;
    const ot = (st in it ? it[st] : void 0) || _e.originalParams
      , lt = isGridEnabled(_e, rt)
      , dt = isGridEnabled(_e, ot)
      , ct = rt.enabled;
    lt && !dt ? (nt.classList.remove(`${rt.containerModifierClass}grid`, `${rt.containerModifierClass}grid-column`),
    _e.emitContainerClasses()) : !lt && dt && (nt.classList.add(`${rt.containerModifierClass}grid`),
    (ot.grid.fill && ot.grid.fill === "column" || !ot.grid.fill && rt.grid.fill === "column") && nt.classList.add(`${rt.containerModifierClass}grid-column`),
    _e.emitContainerClasses()),
    ["navigation", "pagination", "scrollbar"].forEach(pt=>{
        if (typeof ot[pt] > "u")
            return;
        const mt = rt[pt] && rt[pt].enabled
          , yt = ot[pt] && ot[pt].enabled;
        mt && !yt && _e[pt].disable(),
        !mt && yt && _e[pt].enable()
    }
    );
    const ut = ot.direction && ot.direction !== rt.direction
      , ft = rt.loop && (ot.slidesPerView !== rt.slidesPerView || ut)
      , ht = rt.loop;
    ut && tt && _e.changeDirection(),
    extend$1(_e.params, ot);
    const gt = _e.params.enabled
      , bt = _e.params.loop;
    Object.assign(_e, {
        allowTouchMove: _e.params.allowTouchMove,
        allowSlideNext: _e.params.allowSlideNext,
        allowSlidePrev: _e.params.allowSlidePrev
    }),
    ct && !gt ? _e.disable() : !ct && gt && _e.enable(),
    _e.currentBreakpoint = st,
    _e.emit("_beforeBreakpoint", ot),
    tt && (ft ? (_e.loopDestroy(),
    _e.loopCreate(et),
    _e.updateSlides()) : !ht && bt ? (_e.loopCreate(et),
    _e.updateSlides()) : ht && !bt && _e.loopDestroy()),
    _e.emit("breakpoint", ot)
}
function getBreakpoint(_e, et, tt) {
    if (et === void 0 && (et = "window"),
    !_e || et === "container" && !tt)
        return;
    let rt = !1;
    const nt = getWindow()
      , it = et === "window" ? nt.innerHeight : tt.clientHeight
      , st = Object.keys(_e).map(at=>{
        if (typeof at == "string" && at.indexOf("@") === 0) {
            const ot = parseFloat(at.substr(1));
            return {
                value: it * ot,
                point: at
            }
        }
        return {
            value: at,
            point: at
        }
    }
    );
    st.sort((at,ot)=>parseInt(at.value, 10) - parseInt(ot.value, 10));
    for (let at = 0; at < st.length; at += 1) {
        const {point: ot, value: lt} = st[at];
        et === "window" ? nt.matchMedia(`(min-width: ${lt}px)`).matches && (rt = ot) : lt <= tt.clientWidth && (rt = ot)
    }
    return rt || "max"
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};
function prepareClasses(_e, et) {
    const tt = [];
    return _e.forEach(rt=>{
        typeof rt == "object" ? Object.keys(rt).forEach(nt=>{
            rt[nt] && tt.push(et + nt)
        }
        ) : typeof rt == "string" && tt.push(et + rt)
    }
    ),
    tt
}
function addClasses() {
    const _e = this
      , {classNames: et, params: tt, rtl: rt, el: nt, device: it} = _e
      , st = prepareClasses(["initialized", tt.direction, {
        "free-mode": _e.params.freeMode && tt.freeMode.enabled
    }, {
        autoheight: tt.autoHeight
    }, {
        rtl: rt
    }, {
        grid: tt.grid && tt.grid.rows > 1
    }, {
        "grid-column": tt.grid && tt.grid.rows > 1 && tt.grid.fill === "column"
    }, {
        android: it.android
    }, {
        ios: it.ios
    }, {
        "css-mode": tt.cssMode
    }, {
        centered: tt.cssMode && tt.centeredSlides
    }, {
        "watch-progress": tt.watchSlidesProgress
    }], tt.containerModifierClass);
    et.push(...st),
    nt.classList.add(...et),
    _e.emitContainerClasses()
}
function removeClasses() {
    const _e = this
      , {el: et, classNames: tt} = _e;
    et.classList.remove(...tt),
    _e.emitContainerClasses()
}
var classes = {
    addClasses,
    removeClasses
};
function checkOverflow() {
    const _e = this
      , {isLocked: et, params: tt} = _e
      , {slidesOffsetBefore: rt} = tt;
    if (rt) {
        const nt = _e.slides.length - 1
          , it = _e.slidesGrid[nt] + _e.slidesSizesGrid[nt] + rt * 2;
        _e.isLocked = _e.size > it
    } else
        _e.isLocked = _e.snapGrid.length === 1;
    tt.allowSlideNext === !0 && (_e.allowSlideNext = !_e.isLocked),
    tt.allowSlidePrev === !0 && (_e.allowSlidePrev = !_e.isLocked),
    et && et !== _e.isLocked && (_e.isEnd = !1),
    et !== _e.isLocked && _e.emit(_e.isLocked ? "lock" : "unlock")
}
var checkOverflow$1 = {
    checkOverflow
}
  , defaults = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function moduleExtendParams(_e, et) {
    return function(rt) {
        rt === void 0 && (rt = {});
        const nt = Object.keys(rt)[0]
          , it = rt[nt];
        if (typeof it != "object" || it === null) {
            extend$1(et, rt);
            return
        }
        if (_e[nt] === !0 && (_e[nt] = {
            enabled: !0
        }),
        nt === "navigation" && _e[nt] && _e[nt].enabled && !_e[nt].prevEl && !_e[nt].nextEl && (_e[nt].auto = !0),
        ["pagination", "scrollbar"].indexOf(nt) >= 0 && _e[nt] && _e[nt].enabled && !_e[nt].el && (_e[nt].auto = !0),
        !(nt in _e && "enabled"in it)) {
            extend$1(et, rt);
            return
        }
        typeof _e[nt] == "object" && !("enabled"in _e[nt]) && (_e[nt].enabled = !0),
        _e[nt] || (_e[nt] = {
            enabled: !1
        }),
        extend$1(et, rt)
    }
}
const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
}
  , extendedDefaults = {};
let Swiper$1 = class $n {
    constructor() {
        let et, tt;
        for (var rt = arguments.length, nt = new Array(rt), it = 0; it < rt; it++)
            nt[it] = arguments[it];
        nt.length === 1 && nt[0].constructor && Object.prototype.toString.call(nt[0]).slice(8, -1) === "Object" ? tt = nt[0] : [et,tt] = nt,
        tt || (tt = {}),
        tt = extend$1({}, tt),
        et && !tt.el && (tt.el = et);
        const st = getDocument();
        if (tt.el && typeof tt.el == "string" && st.querySelectorAll(tt.el).length > 1) {
            const dt = [];
            return st.querySelectorAll(tt.el).forEach(ct=>{
                const ut = extend$1({}, tt, {
                    el: ct
                });
                dt.push(new $n(ut))
            }
            ),
            dt
        }
        const at = this;
        at.__swiper__ = !0,
        at.support = getSupport(),
        at.device = getDevice({
            userAgent: tt.userAgent
        }),
        at.browser = getBrowser(),
        at.eventsListeners = {},
        at.eventsAnyListeners = [],
        at.modules = [...at.__modules__],
        tt.modules && Array.isArray(tt.modules) && at.modules.push(...tt.modules);
        const ot = {};
        at.modules.forEach(dt=>{
            dt({
                params: tt,
                swiper: at,
                extendParams: moduleExtendParams(tt, ot),
                on: at.on.bind(at),
                once: at.once.bind(at),
                off: at.off.bind(at),
                emit: at.emit.bind(at)
            })
        }
        );
        const lt = extend$1({}, defaults, ot);
        return at.params = extend$1({}, lt, extendedDefaults, tt),
        at.originalParams = extend$1({}, at.params),
        at.passedParams = extend$1({}, tt),
        at.params && at.params.on && Object.keys(at.params.on).forEach(dt=>{
            at.on(dt, at.params.on[dt])
        }
        ),
        at.params && at.params.onAny && at.onAny(at.params.onAny),
        Object.assign(at, {
            enabled: at.params.enabled,
            el: et,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return at.params.direction === "horizontal"
            },
            isVertical() {
                return at.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
            },
            allowSlideNext: at.params.allowSlideNext,
            allowSlidePrev: at.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: at.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: at.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }),
        at.emit("_swiper"),
        at.params.init && at.init(),
        at
    }
    getDirectionLabel(et) {
        return this.isHorizontal() ? et : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[et]
    }
    getSlideIndex(et) {
        const {slidesEl: tt, params: rt} = this
          , nt = elementChildren(tt, `.${rt.slideClass}, swiper-slide`)
          , it = elementIndex(nt[0]);
        return elementIndex(et) - it
    }
    getSlideIndexByData(et) {
        return this.getSlideIndex(this.slides.filter(tt=>tt.getAttribute("data-swiper-slide-index") * 1 === et)[0])
    }
    recalcSlides() {
        const et = this
          , {slidesEl: tt, params: rt} = et;
        et.slides = elementChildren(tt, `.${rt.slideClass}, swiper-slide`)
    }
    enable() {
        const et = this;
        et.enabled || (et.enabled = !0,
        et.params.grabCursor && et.setGrabCursor(),
        et.emit("enable"))
    }
    disable() {
        const et = this;
        et.enabled && (et.enabled = !1,
        et.params.grabCursor && et.unsetGrabCursor(),
        et.emit("disable"))
    }
    setProgress(et, tt) {
        const rt = this;
        et = Math.min(Math.max(et, 0), 1);
        const nt = rt.minTranslate()
          , st = (rt.maxTranslate() - nt) * et + nt;
        rt.translateTo(st, typeof tt > "u" ? 0 : tt),
        rt.updateActiveIndex(),
        rt.updateSlidesClasses()
    }
    emitContainerClasses() {
        const et = this;
        if (!et.params._emitClasses || !et.el)
            return;
        const tt = et.el.className.split(" ").filter(rt=>rt.indexOf("swiper") === 0 || rt.indexOf(et.params.containerModifierClass) === 0);
        et.emit("_containerClasses", tt.join(" "))
    }
    getSlideClasses(et) {
        const tt = this;
        return tt.destroyed ? "" : et.className.split(" ").filter(rt=>rt.indexOf("swiper-slide") === 0 || rt.indexOf(tt.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const et = this;
        if (!et.params._emitClasses || !et.el)
            return;
        const tt = [];
        et.slides.forEach(rt=>{
            const nt = et.getSlideClasses(rt);
            tt.push({
                slideEl: rt,
                classNames: nt
            }),
            et.emit("_slideClass", rt, nt)
        }
        ),
        et.emit("_slideClasses", tt)
    }
    slidesPerViewDynamic(et, tt) {
        et === void 0 && (et = "current"),
        tt === void 0 && (tt = !1);
        const rt = this
          , {params: nt, slides: it, slidesGrid: st, slidesSizesGrid: at, size: ot, activeIndex: lt} = rt;
        let dt = 1;
        if (typeof nt.slidesPerView == "number")
            return nt.slidesPerView;
        if (nt.centeredSlides) {
            let ct = it[lt] ? Math.ceil(it[lt].swiperSlideSize) : 0, ut;
            for (let ft = lt + 1; ft < it.length; ft += 1)
                it[ft] && !ut && (ct += Math.ceil(it[ft].swiperSlideSize),
                dt += 1,
                ct > ot && (ut = !0));
            for (let ft = lt - 1; ft >= 0; ft -= 1)
                it[ft] && !ut && (ct += it[ft].swiperSlideSize,
                dt += 1,
                ct > ot && (ut = !0))
        } else if (et === "current")
            for (let ct = lt + 1; ct < it.length; ct += 1)
                (tt ? st[ct] + at[ct] - st[lt] < ot : st[ct] - st[lt] < ot) && (dt += 1);
        else
            for (let ct = lt - 1; ct >= 0; ct -= 1)
                st[lt] - st[ct] < ot && (dt += 1);
        return dt
    }
    update() {
        const et = this;
        if (!et || et.destroyed)
            return;
        const {snapGrid: tt, params: rt} = et;
        rt.breakpoints && et.setBreakpoint(),
        [...et.el.querySelectorAll('[loading="lazy"]')].forEach(st=>{
            st.complete && processLazyPreloader(et, st)
        }
        ),
        et.updateSize(),
        et.updateSlides(),
        et.updateProgress(),
        et.updateSlidesClasses();
        function nt() {
            const st = et.rtlTranslate ? et.translate * -1 : et.translate
              , at = Math.min(Math.max(st, et.maxTranslate()), et.minTranslate());
            et.setTranslate(at),
            et.updateActiveIndex(),
            et.updateSlidesClasses()
        }
        let it;
        if (rt.freeMode && rt.freeMode.enabled && !rt.cssMode)
            nt(),
            rt.autoHeight && et.updateAutoHeight();
        else {
            if ((rt.slidesPerView === "auto" || rt.slidesPerView > 1) && et.isEnd && !rt.centeredSlides) {
                const st = et.virtual && rt.virtual.enabled ? et.virtual.slides : et.slides;
                it = et.slideTo(st.length - 1, 0, !1, !0)
            } else
                it = et.slideTo(et.activeIndex, 0, !1, !0);
            it || nt()
        }
        rt.watchOverflow && tt !== et.snapGrid && et.checkOverflow(),
        et.emit("update")
    }
    changeDirection(et, tt) {
        tt === void 0 && (tt = !0);
        const rt = this
          , nt = rt.params.direction;
        return et || (et = nt === "horizontal" ? "vertical" : "horizontal"),
        et === nt || et !== "horizontal" && et !== "vertical" || (rt.el.classList.remove(`${rt.params.containerModifierClass}${nt}`),
        rt.el.classList.add(`${rt.params.containerModifierClass}${et}`),
        rt.emitContainerClasses(),
        rt.params.direction = et,
        rt.slides.forEach(it=>{
            et === "vertical" ? it.style.width = "" : it.style.height = ""
        }
        ),
        rt.emit("changeDirection"),
        tt && rt.update()),
        rt
    }
    changeLanguageDirection(et) {
        const tt = this;
        tt.rtl && et === "rtl" || !tt.rtl && et === "ltr" || (tt.rtl = et === "rtl",
        tt.rtlTranslate = tt.params.direction === "horizontal" && tt.rtl,
        tt.rtl ? (tt.el.classList.add(`${tt.params.containerModifierClass}rtl`),
        tt.el.dir = "rtl") : (tt.el.classList.remove(`${tt.params.containerModifierClass}rtl`),
        tt.el.dir = "ltr"),
        tt.update())
    }
    mount(et) {
        const tt = this;
        if (tt.mounted)
            return !0;
        let rt = et || tt.params.el;
        if (typeof rt == "string" && (rt = document.querySelector(rt)),
        !rt)
            return !1;
        rt.swiper = tt,
        rt.parentNode && rt.parentNode.host && rt.parentNode.host.nodeName === tt.params.swiperElementNodeName.toUpperCase() && (tt.isElement = !0);
        const nt = ()=>`.${(tt.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let st = rt && rt.shadowRoot && rt.shadowRoot.querySelector ? rt.shadowRoot.querySelector(nt()) : elementChildren(rt, nt())[0];
        return !st && tt.params.createElements && (st = createElement("div", tt.params.wrapperClass),
        rt.append(st),
        elementChildren(rt, `.${tt.params.slideClass}`).forEach(at=>{
            st.append(at)
        }
        )),
        Object.assign(tt, {
            el: rt,
            wrapperEl: st,
            slidesEl: tt.isElement && !rt.parentNode.host.slideSlots ? rt.parentNode.host : st,
            hostEl: tt.isElement ? rt.parentNode.host : rt,
            mounted: !0,
            rtl: rt.dir.toLowerCase() === "rtl" || elementStyle(rt, "direction") === "rtl",
            rtlTranslate: tt.params.direction === "horizontal" && (rt.dir.toLowerCase() === "rtl" || elementStyle(rt, "direction") === "rtl"),
            wrongRTL: elementStyle(st, "display") === "-webkit-box"
        }),
        !0
    }
    init(et) {
        const tt = this;
        if (tt.initialized || tt.mount(et) === !1)
            return tt;
        tt.emit("beforeInit"),
        tt.params.breakpoints && tt.setBreakpoint(),
        tt.addClasses(),
        tt.updateSize(),
        tt.updateSlides(),
        tt.params.watchOverflow && tt.checkOverflow(),
        tt.params.grabCursor && tt.enabled && tt.setGrabCursor(),
        tt.params.loop && tt.virtual && tt.params.virtual.enabled ? tt.slideTo(tt.params.initialSlide + tt.virtual.slidesBefore, 0, tt.params.runCallbacksOnInit, !1, !0) : tt.slideTo(tt.params.initialSlide, 0, tt.params.runCallbacksOnInit, !1, !0),
        tt.params.loop && tt.loopCreate(),
        tt.attachEvents();
        const nt = [...tt.el.querySelectorAll('[loading="lazy"]')];
        return tt.isElement && nt.push(...tt.hostEl.querySelectorAll('[loading="lazy"]')),
        nt.forEach(it=>{
            it.complete ? processLazyPreloader(tt, it) : it.addEventListener("load", st=>{
                processLazyPreloader(tt, st.target)
            }
            )
        }
        ),
        preload(tt),
        tt.initialized = !0,
        preload(tt),
        tt.emit("init"),
        tt.emit("afterInit"),
        tt
    }
    destroy(et, tt) {
        et === void 0 && (et = !0),
        tt === void 0 && (tt = !0);
        const rt = this
          , {params: nt, el: it, wrapperEl: st, slides: at} = rt;
        return typeof rt.params > "u" || rt.destroyed || (rt.emit("beforeDestroy"),
        rt.initialized = !1,
        rt.detachEvents(),
        nt.loop && rt.loopDestroy(),
        tt && (rt.removeClasses(),
        it.removeAttribute("style"),
        st.removeAttribute("style"),
        at && at.length && at.forEach(ot=>{
            ot.classList.remove(nt.slideVisibleClass, nt.slideFullyVisibleClass, nt.slideActiveClass, nt.slideNextClass, nt.slidePrevClass),
            ot.removeAttribute("style"),
            ot.removeAttribute("data-swiper-slide-index")
        }
        )),
        rt.emit("destroy"),
        Object.keys(rt.eventsListeners).forEach(ot=>{
            rt.off(ot)
        }
        ),
        et !== !1 && (rt.el.swiper = null,
        deleteProps(rt)),
        rt.destroyed = !0),
        null
    }
    static extendDefaults(et) {
        extend$1(extendedDefaults, et)
    }
    static get extendedDefaults() {
        return extendedDefaults
    }
    static get defaults() {
        return defaults
    }
    static installModule(et) {
        $n.prototype.__modules__ || ($n.prototype.__modules__ = []);
        const tt = $n.prototype.__modules__;
        typeof et == "function" && tt.indexOf(et) < 0 && tt.push(et)
    }
    static use(et) {
        return Array.isArray(et) ? (et.forEach(tt=>$n.installModule(tt)),
        $n) : ($n.installModule(et),
        $n)
    }
}
;
Object.keys(prototypes).forEach(_e=>{
    Object.keys(prototypes[_e]).forEach(et=>{
        Swiper$1.prototype[et] = prototypes[_e][et]
    }
    )
}
);
Swiper$1.use([Resize, Observer]);
const paramsList = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"];
function isObject(_e) {
    return typeof _e == "object" && _e !== null && _e.constructor && Object.prototype.toString.call(_e).slice(8, -1) === "Object" && !_e.__swiper__
}
function extend(_e, et) {
    const tt = ["__proto__", "constructor", "prototype"];
    Object.keys(et).filter(rt=>tt.indexOf(rt) < 0).forEach(rt=>{
        typeof _e[rt] > "u" ? _e[rt] = et[rt] : isObject(et[rt]) && isObject(_e[rt]) && Object.keys(et[rt]).length > 0 ? et[rt].__swiper__ ? _e[rt] = et[rt] : extend(_e[rt], et[rt]) : _e[rt] = et[rt]
    }
    )
}
function needsNavigation(_e) {
    return _e === void 0 && (_e = {}),
    _e.navigation && typeof _e.navigation.nextEl > "u" && typeof _e.navigation.prevEl > "u"
}
function needsPagination(_e) {
    return _e === void 0 && (_e = {}),
    _e.pagination && typeof _e.pagination.el > "u"
}
function needsScrollbar(_e) {
    return _e === void 0 && (_e = {}),
    _e.scrollbar && typeof _e.scrollbar.el > "u"
}
function uniqueClasses(_e) {
    _e === void 0 && (_e = "");
    const et = _e.split(" ").map(rt=>rt.trim()).filter(rt=>!!rt)
      , tt = [];
    return et.forEach(rt=>{
        tt.indexOf(rt) < 0 && tt.push(rt)
    }
    ),
    tt.join(" ")
}
function wrapperClass(_e) {
    return _e === void 0 && (_e = ""),
    _e ? _e.includes("swiper-wrapper") ? _e : `swiper-wrapper ${_e}` : "swiper-wrapper"
}
function updateSwiper(_e) {
    let {swiper: et, slides: tt, passedParams: rt, changedParams: nt, nextEl: it, prevEl: st, scrollbarEl: at, paginationEl: ot} = _e;
    const lt = nt.filter(Ct=>Ct !== "children" && Ct !== "direction" && Ct !== "wrapperClass")
      , {params: dt, pagination: ct, navigation: ut, scrollbar: ft, virtual: ht, thumbs: gt} = et;
    let bt, pt, mt, yt, vt, wt, _t, Et;
    nt.includes("thumbs") && rt.thumbs && rt.thumbs.swiper && dt.thumbs && !dt.thumbs.swiper && (bt = !0),
    nt.includes("controller") && rt.controller && rt.controller.control && dt.controller && !dt.controller.control && (pt = !0),
    nt.includes("pagination") && rt.pagination && (rt.pagination.el || ot) && (dt.pagination || dt.pagination === !1) && ct && !ct.el && (mt = !0),
    nt.includes("scrollbar") && rt.scrollbar && (rt.scrollbar.el || at) && (dt.scrollbar || dt.scrollbar === !1) && ft && !ft.el && (yt = !0),
    nt.includes("navigation") && rt.navigation && (rt.navigation.prevEl || st) && (rt.navigation.nextEl || it) && (dt.navigation || dt.navigation === !1) && ut && !ut.prevEl && !ut.nextEl && (vt = !0);
    const xt = Ct=>{
        et[Ct] && (et[Ct].destroy(),
        Ct === "navigation" ? (et.isElement && (et[Ct].prevEl.remove(),
        et[Ct].nextEl.remove()),
        dt[Ct].prevEl = void 0,
        dt[Ct].nextEl = void 0,
        et[Ct].prevEl = void 0,
        et[Ct].nextEl = void 0) : (et.isElement && et[Ct].el.remove(),
        dt[Ct].el = void 0,
        et[Ct].el = void 0))
    }
    ;
    nt.includes("loop") && et.isElement && (dt.loop && !rt.loop ? wt = !0 : !dt.loop && rt.loop ? _t = !0 : Et = !0),
    lt.forEach(Ct=>{
        if (isObject(dt[Ct]) && isObject(rt[Ct]))
            Object.assign(dt[Ct], rt[Ct]),
            (Ct === "navigation" || Ct === "pagination" || Ct === "scrollbar") && "enabled"in rt[Ct] && !rt[Ct].enabled && xt(Ct);
        else {
            const Tt = rt[Ct];
            (Tt === !0 || Tt === !1) && (Ct === "navigation" || Ct === "pagination" || Ct === "scrollbar") ? Tt === !1 && xt(Ct) : dt[Ct] = rt[Ct]
        }
    }
    ),
    lt.includes("controller") && !pt && et.controller && et.controller.control && dt.controller && dt.controller.control && (et.controller.control = dt.controller.control),
    nt.includes("children") && tt && ht && dt.virtual.enabled ? (ht.slides = tt,
    ht.update(!0)) : nt.includes("virtual") && ht && dt.virtual.enabled && (tt && (ht.slides = tt),
    ht.update(!0)),
    nt.includes("children") && tt && dt.loop && (Et = !0),
    bt && gt.init() && gt.update(!0),
    pt && (et.controller.control = dt.controller.control),
    mt && (et.isElement && (!ot || typeof ot == "string") && (ot = document.createElement("div"),
    ot.classList.add("swiper-pagination"),
    ot.part.add("pagination"),
    et.el.appendChild(ot)),
    ot && (dt.pagination.el = ot),
    ct.init(),
    ct.render(),
    ct.update()),
    yt && (et.isElement && (!at || typeof at == "string") && (at = document.createElement("div"),
    at.classList.add("swiper-scrollbar"),
    at.part.add("scrollbar"),
    et.el.appendChild(at)),
    at && (dt.scrollbar.el = at),
    ft.init(),
    ft.updateSize(),
    ft.setTranslate()),
    vt && (et.isElement && ((!it || typeof it == "string") && (it = document.createElement("div"),
    it.classList.add("swiper-button-next"),
    it.innerHTML = et.hostEl.constructor.nextButtonSvg,
    it.part.add("button-next"),
    et.el.appendChild(it)),
    (!st || typeof st == "string") && (st = document.createElement("div"),
    st.classList.add("swiper-button-prev"),
    st.innerHTML = et.hostEl.constructor.prevButtonSvg,
    st.part.add("button-prev"),
    et.el.appendChild(st))),
    it && (dt.navigation.nextEl = it),
    st && (dt.navigation.prevEl = st),
    ut.init(),
    ut.update()),
    nt.includes("allowSlideNext") && (et.allowSlideNext = rt.allowSlideNext),
    nt.includes("allowSlidePrev") && (et.allowSlidePrev = rt.allowSlidePrev),
    nt.includes("direction") && et.changeDirection(rt.direction, !1),
    (wt || Et) && et.loopDestroy(),
    (_t || Et) && et.loopCreate(),
    et.update()
}
function getParams(_e, et) {
    _e === void 0 && (_e = {}),
    et === void 0 && (et = !0);
    const tt = {
        on: {}
    }
      , rt = {}
      , nt = {};
    extend(tt, defaults),
    tt._emitClasses = !0,
    tt.init = !1;
    const it = {}
      , st = paramsList.map(ot=>ot.replace(/_/, ""))
      , at = Object.assign({}, _e);
    return Object.keys(at).forEach(ot=>{
        typeof _e[ot] > "u" || (st.indexOf(ot) >= 0 ? isObject(_e[ot]) ? (tt[ot] = {},
        nt[ot] = {},
        extend(tt[ot], _e[ot]),
        extend(nt[ot], _e[ot])) : (tt[ot] = _e[ot],
        nt[ot] = _e[ot]) : ot.search(/on[A-Z]/) === 0 && typeof _e[ot] == "function" ? et ? rt[`${ot[2].toLowerCase()}${ot.substr(3)}`] = _e[ot] : tt.on[`${ot[2].toLowerCase()}${ot.substr(3)}`] = _e[ot] : it[ot] = _e[ot])
    }
    ),
    ["navigation", "pagination", "scrollbar"].forEach(ot=>{
        tt[ot] === !0 && (tt[ot] = {}),
        tt[ot] === !1 && delete tt[ot]
    }
    ),
    {
        params: tt,
        passedParams: nt,
        rest: it,
        events: rt
    }
}
function mountSwiper(_e, et) {
    let {el: tt, nextEl: rt, prevEl: nt, paginationEl: it, scrollbarEl: st, swiper: at} = _e;
    needsNavigation(et) && rt && nt && (at.params.navigation.nextEl = rt,
    at.originalParams.navigation.nextEl = rt,
    at.params.navigation.prevEl = nt,
    at.originalParams.navigation.prevEl = nt),
    needsPagination(et) && it && (at.params.pagination.el = it,
    at.originalParams.pagination.el = it),
    needsScrollbar(et) && st && (at.params.scrollbar.el = st,
    at.originalParams.scrollbar.el = st),
    at.init(tt)
}
function getChangedParams(_e, et, tt, rt, nt) {
    const it = [];
    if (!et)
        return it;
    const st = ot=>{
        it.indexOf(ot) < 0 && it.push(ot)
    }
    ;
    if (tt && rt) {
        const ot = rt.map(nt)
          , lt = tt.map(nt);
        ot.join("") !== lt.join("") && st("children"),
        rt.length !== tt.length && st("children")
    }
    return paramsList.filter(ot=>ot[0] === "_").map(ot=>ot.replace(/_/, "")).forEach(ot=>{
        if (ot in _e && ot in et)
            if (isObject(_e[ot]) && isObject(et[ot])) {
                const lt = Object.keys(_e[ot])
                  , dt = Object.keys(et[ot]);
                lt.length !== dt.length ? st(ot) : (lt.forEach(ct=>{
                    _e[ot][ct] !== et[ot][ct] && st(ot)
                }
                ),
                dt.forEach(ct=>{
                    _e[ot][ct] !== et[ot][ct] && st(ot)
                }
                ))
            } else
                _e[ot] !== et[ot] && st(ot)
    }
    ),
    it
}
const updateOnVirtualData = _e=>{
    !_e || _e.destroyed || !_e.params.virtual || _e.params.virtual && !_e.params.virtual.enabled || (_e.updateSlides(),
    _e.updateProgress(),
    _e.updateSlidesClasses(),
    _e.parallax && _e.params.parallax && _e.params.parallax.enabled && _e.parallax.setTranslate())
}
;
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(_e) {
        for (var et = 1; et < arguments.length; et++) {
            var tt = arguments[et];
            for (var rt in tt)
                Object.prototype.hasOwnProperty.call(tt, rt) && (_e[rt] = tt[rt])
        }
        return _e
    }
    ,
    _extends.apply(this, arguments)
}
function isChildSwiperSlide(_e) {
    return _e.type && _e.type.displayName && _e.type.displayName.includes("SwiperSlide")
}
function processChildren(_e) {
    const et = [];
    return React$1.Children.toArray(_e).forEach(tt=>{
        isChildSwiperSlide(tt) ? et.push(tt) : tt.props && tt.props.children && processChildren(tt.props.children).forEach(rt=>et.push(rt))
    }
    ),
    et
}
function getChildren(_e) {
    const et = []
      , tt = {
        "container-start": [],
        "container-end": [],
        "wrapper-start": [],
        "wrapper-end": []
    };
    return React$1.Children.toArray(_e).forEach(rt=>{
        if (isChildSwiperSlide(rt))
            et.push(rt);
        else if (rt.props && rt.props.slot && tt[rt.props.slot])
            tt[rt.props.slot].push(rt);
        else if (rt.props && rt.props.children) {
            const nt = processChildren(rt.props.children);
            nt.length > 0 ? nt.forEach(it=>et.push(it)) : tt["container-end"].push(rt)
        } else
            tt["container-end"].push(rt)
    }
    ),
    {
        slides: et,
        slots: tt
    }
}
function renderVirtual(_e, et, tt) {
    if (!tt)
        return null;
    const rt = dt=>{
        let ct = dt;
        return dt < 0 ? ct = et.length + dt : ct >= et.length && (ct = ct - et.length),
        ct
    }
      , nt = _e.isHorizontal() ? {
        [_e.rtlTranslate ? "right" : "left"]: `${tt.offset}px`
    } : {
        top: `${tt.offset}px`
    }
      , {from: it, to: st} = tt
      , at = _e.params.loop ? -et.length : 0
      , ot = _e.params.loop ? et.length * 2 : et.length
      , lt = [];
    for (let dt = at; dt < ot; dt += 1)
        dt >= it && dt <= st && lt.push(et[rt(dt)]);
    return lt.map((dt,ct)=>React$1.cloneElement(dt, {
        swiper: _e,
        style: nt,
        key: `slide-${ct}`
    }))
}
function useIsomorphicLayoutEffect(_e, et) {
    return typeof window > "u" ? reactExports.useEffect(_e, et) : reactExports.useLayoutEffect(_e, et)
}
const SwiperSlideContext = reactExports.createContext(null)
  , SwiperContext = reactExports.createContext(null)
  , Swiper = reactExports.forwardRef(function(_e, et) {
    let {className: tt, tag: rt="div", wrapperTag: nt="div", children: it, onSwiper: st, ...at} = _e === void 0 ? {} : _e
      , ot = !1;
    const [lt,dt] = reactExports.useState("swiper")
      , [ct,ut] = reactExports.useState(null)
      , [ft,ht] = reactExports.useState(!1)
      , gt = reactExports.useRef(!1)
      , bt = reactExports.useRef(null)
      , pt = reactExports.useRef(null)
      , mt = reactExports.useRef(null)
      , yt = reactExports.useRef(null)
      , vt = reactExports.useRef(null)
      , wt = reactExports.useRef(null)
      , _t = reactExports.useRef(null)
      , Et = reactExports.useRef(null)
      , {params: xt, passedParams: Ct, rest: Tt, events: It} = getParams(at)
      , {slides: Nt, slots: Ft} = getChildren(it)
      , Lt = ()=>{
        ht(!ft)
    }
    ;
    Object.assign(xt.on, {
        _containerClasses(Pt, Dt) {
            dt(Dt)
        }
    });
    const Mt = ()=>{
        Object.assign(xt.on, It),
        ot = !0;
        const Pt = {
            ...xt
        };
        if (delete Pt.wrapperClass,
        pt.current = new Swiper$1(Pt),
        pt.current.virtual && pt.current.params.virtual.enabled) {
            pt.current.virtual.slides = Nt;
            const Dt = {
                cache: !1,
                slides: Nt,
                renderExternal: ut,
                renderExternalUpdate: !1
            };
            extend(pt.current.params.virtual, Dt),
            extend(pt.current.originalParams.virtual, Dt)
        }
    }
    ;
    bt.current || Mt(),
    pt.current && pt.current.on("_beforeBreakpoint", Lt);
    const $t = ()=>{
        ot || !It || !pt.current || Object.keys(It).forEach(Pt=>{
            pt.current.on(Pt, It[Pt])
        }
        )
    }
      , kt = ()=>{
        !It || !pt.current || Object.keys(It).forEach(Pt=>{
            pt.current.off(Pt, It[Pt])
        }
        )
    }
    ;
    reactExports.useEffect(()=>()=>{
        pt.current && pt.current.off("_beforeBreakpoint", Lt)
    }
    ),
    reactExports.useEffect(()=>{
        !gt.current && pt.current && (pt.current.emitSlidesClasses(),
        gt.current = !0)
    }
    ),
    useIsomorphicLayoutEffect(()=>{
        if (et && (et.current = bt.current),
        !!bt.current)
            return pt.current.destroyed && Mt(),
            mountSwiper({
                el: bt.current,
                nextEl: vt.current,
                prevEl: wt.current,
                paginationEl: _t.current,
                scrollbarEl: Et.current,
                swiper: pt.current
            }, xt),
            st && !pt.current.destroyed && st(pt.current),
            ()=>{
                pt.current && !pt.current.destroyed && pt.current.destroy(!0, !1)
            }
    }
    , []),
    useIsomorphicLayoutEffect(()=>{
        $t();
        const Pt = getChangedParams(Ct, mt.current, Nt, yt.current, Dt=>Dt.key);
        return mt.current = Ct,
        yt.current = Nt,
        Pt.length && pt.current && !pt.current.destroyed && updateSwiper({
            swiper: pt.current,
            slides: Nt,
            passedParams: Ct,
            changedParams: Pt,
            nextEl: vt.current,
            prevEl: wt.current,
            scrollbarEl: Et.current,
            paginationEl: _t.current
        }),
        ()=>{
            kt()
        }
    }
    ),
    useIsomorphicLayoutEffect(()=>{
        updateOnVirtualData(pt.current)
    }
    , [ct]);
    function At() {
        return xt.virtual ? renderVirtual(pt.current, Nt, ct) : Nt.map((Pt,Dt)=>React$1.cloneElement(Pt, {
            swiper: pt.current,
            swiperSlideIndex: Dt
        }))
    }
    return React$1.createElement(rt, _extends({
        ref: bt,
        className: uniqueClasses(`${lt}${tt ? ` ${tt}` : ""}`)
    }, Tt), React$1.createElement(SwiperContext.Provider, {
        value: pt.current
    }, Ft["container-start"], React$1.createElement(nt, {
        className: wrapperClass(xt.wrapperClass)
    }, Ft["wrapper-start"], At(), Ft["wrapper-end"]), needsNavigation(xt) && React$1.createElement(React$1.Fragment, null, React$1.createElement("div", {
        ref: wt,
        className: "swiper-button-prev"
    }), React$1.createElement("div", {
        ref: vt,
        className: "swiper-button-next"
    })), needsScrollbar(xt) && React$1.createElement("div", {
        ref: Et,
        className: "swiper-scrollbar"
    }), needsPagination(xt) && React$1.createElement("div", {
        ref: _t,
        className: "swiper-pagination"
    }), Ft["container-end"]))
});
Swiper.displayName = "Swiper";
const SwiperSlide = reactExports.forwardRef(function(_e, et) {
    let {tag: tt="div", children: rt, className: nt="", swiper: it, zoom: st, lazy: at, virtualIndex: ot, swiperSlideIndex: lt, ...dt} = _e === void 0 ? {} : _e;
    const ct = reactExports.useRef(null)
      , [ut,ft] = reactExports.useState("swiper-slide")
      , [ht,gt] = reactExports.useState(!1);
    function bt(vt, wt, _t) {
        wt === ct.current && ft(_t)
    }
    useIsomorphicLayoutEffect(()=>{
        if (typeof lt < "u" && (ct.current.swiperSlideIndex = lt),
        et && (et.current = ct.current),
        !(!ct.current || !it)) {
            if (it.destroyed) {
                ut !== "swiper-slide" && ft("swiper-slide");
                return
            }
            return it.on("_slideClass", bt),
            ()=>{
                it && it.off("_slideClass", bt)
            }
        }
    }
    ),
    useIsomorphicLayoutEffect(()=>{
        it && ct.current && !it.destroyed && ft(it.getSlideClasses(ct.current))
    }
    , [it]);
    const pt = {
        isActive: ut.indexOf("swiper-slide-active") >= 0,
        isVisible: ut.indexOf("swiper-slide-visible") >= 0,
        isPrev: ut.indexOf("swiper-slide-prev") >= 0,
        isNext: ut.indexOf("swiper-slide-next") >= 0
    }
      , mt = ()=>typeof rt == "function" ? rt(pt) : rt
      , yt = ()=>{
        gt(!0)
    }
    ;
    return React$1.createElement(tt, _extends({
        ref: ct,
        className: uniqueClasses(`${ut}${nt ? ` ${nt}` : ""}`),
        "data-swiper-slide-index": ot,
        onLoad: yt
    }, dt), st && React$1.createElement(SwiperSlideContext.Provider, {
        value: pt
    }, React$1.createElement("div", {
        className: "swiper-zoom-container",
        "data-swiper-zoom": typeof st == "number" ? st : void 0
    }, mt(), at && !ht && React$1.createElement("div", {
        className: "swiper-lazy-preloader"
    }))), !st && React$1.createElement(SwiperSlideContext.Provider, {
        value: pt
    }, mt(), at && !ht && React$1.createElement("div", {
        className: "swiper-lazy-preloader"
    })))
});
SwiperSlide.displayName = "SwiperSlide";
function createElementIfNotDefined(_e, et, tt, rt) {
    return _e.params.createElements && Object.keys(rt).forEach(nt=>{
        if (!tt[nt] && tt.auto === !0) {
            let it = elementChildren(_e.el, `.${rt[nt]}`)[0];
            it || (it = createElement("div", rt[nt]),
            it.className = rt[nt],
            _e.el.append(it)),
            tt[nt] = it,
            et[nt] = it
        }
    }
    ),
    tt
}
function classesToSelector(_e) {
    return _e === void 0 && (_e = ""),
    `.${_e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
}
function Pagination(_e) {
    let {swiper: et, extendParams: tt, on: rt, emit: nt} = _e;
    const it = "swiper-pagination";
    tt({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: pt=>pt,
            formatFractionTotal: pt=>pt,
            bulletClass: `${it}-bullet`,
            bulletActiveClass: `${it}-bullet-active`,
            modifierClass: `${it}-`,
            currentClass: `${it}-current`,
            totalClass: `${it}-total`,
            hiddenClass: `${it}-hidden`,
            progressbarFillClass: `${it}-progressbar-fill`,
            progressbarOppositeClass: `${it}-progressbar-opposite`,
            clickableClass: `${it}-clickable`,
            lockClass: `${it}-lock`,
            horizontalClass: `${it}-horizontal`,
            verticalClass: `${it}-vertical`,
            paginationDisabledClass: `${it}-disabled`
        }
    }),
    et.pagination = {
        el: null,
        bullets: []
    };
    let st, at = 0;
    function ot() {
        return !et.params.pagination.el || !et.pagination.el || Array.isArray(et.pagination.el) && et.pagination.el.length === 0
    }
    function lt(pt, mt) {
        const {bulletActiveClass: yt} = et.params.pagination;
        pt && (pt = pt[`${mt === "prev" ? "previous" : "next"}ElementSibling`],
        pt && (pt.classList.add(`${yt}-${mt}`),
        pt = pt[`${mt === "prev" ? "previous" : "next"}ElementSibling`],
        pt && pt.classList.add(`${yt}-${mt}-${mt}`)))
    }
    function dt(pt) {
        const mt = pt.target.closest(classesToSelector(et.params.pagination.bulletClass));
        if (!mt)
            return;
        pt.preventDefault();
        const yt = elementIndex(mt) * et.params.slidesPerGroup;
        if (et.params.loop) {
            if (et.realIndex === yt)
                return;
            et.slideToLoop(yt)
        } else
            et.slideTo(yt)
    }
    function ct() {
        const pt = et.rtl
          , mt = et.params.pagination;
        if (ot())
            return;
        let yt = et.pagination.el;
        yt = makeElementsArray(yt);
        let vt, wt;
        const _t = et.virtual && et.params.virtual.enabled ? et.virtual.slides.length : et.slides.length
          , Et = et.params.loop ? Math.ceil(_t / et.params.slidesPerGroup) : et.snapGrid.length;
        if (et.params.loop ? (wt = et.previousRealIndex || 0,
        vt = et.params.slidesPerGroup > 1 ? Math.floor(et.realIndex / et.params.slidesPerGroup) : et.realIndex) : typeof et.snapIndex < "u" ? (vt = et.snapIndex,
        wt = et.previousSnapIndex) : (wt = et.previousIndex || 0,
        vt = et.activeIndex || 0),
        mt.type === "bullets" && et.pagination.bullets && et.pagination.bullets.length > 0) {
            const xt = et.pagination.bullets;
            let Ct, Tt, It;
            if (mt.dynamicBullets && (st = elementOuterSize(xt[0], et.isHorizontal() ? "width" : "height", !0),
            yt.forEach(Nt=>{
                Nt.style[et.isHorizontal() ? "width" : "height"] = `${st * (mt.dynamicMainBullets + 4)}px`
            }
            ),
            mt.dynamicMainBullets > 1 && wt !== void 0 && (at += vt - (wt || 0),
            at > mt.dynamicMainBullets - 1 ? at = mt.dynamicMainBullets - 1 : at < 0 && (at = 0)),
            Ct = Math.max(vt - at, 0),
            Tt = Ct + (Math.min(xt.length, mt.dynamicMainBullets) - 1),
            It = (Tt + Ct) / 2),
            xt.forEach(Nt=>{
                const Ft = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(Lt=>`${mt.bulletActiveClass}${Lt}`)].map(Lt=>typeof Lt == "string" && Lt.includes(" ") ? Lt.split(" ") : Lt).flat();
                Nt.classList.remove(...Ft)
            }
            ),
            yt.length > 1)
                xt.forEach(Nt=>{
                    const Ft = elementIndex(Nt);
                    Ft === vt ? Nt.classList.add(...mt.bulletActiveClass.split(" ")) : et.isElement && Nt.setAttribute("part", "bullet"),
                    mt.dynamicBullets && (Ft >= Ct && Ft <= Tt && Nt.classList.add(...`${mt.bulletActiveClass}-main`.split(" ")),
                    Ft === Ct && lt(Nt, "prev"),
                    Ft === Tt && lt(Nt, "next"))
                }
                );
            else {
                const Nt = xt[vt];
                if (Nt && Nt.classList.add(...mt.bulletActiveClass.split(" ")),
                et.isElement && xt.forEach((Ft,Lt)=>{
                    Ft.setAttribute("part", Lt === vt ? "bullet-active" : "bullet")
                }
                ),
                mt.dynamicBullets) {
                    const Ft = xt[Ct]
                      , Lt = xt[Tt];
                    for (let Mt = Ct; Mt <= Tt; Mt += 1)
                        xt[Mt] && xt[Mt].classList.add(...`${mt.bulletActiveClass}-main`.split(" "));
                    lt(Ft, "prev"),
                    lt(Lt, "next")
                }
            }
            if (mt.dynamicBullets) {
                const Nt = Math.min(xt.length, mt.dynamicMainBullets + 4)
                  , Ft = (st * Nt - st) / 2 - It * st
                  , Lt = pt ? "right" : "left";
                xt.forEach(Mt=>{
                    Mt.style[et.isHorizontal() ? Lt : "top"] = `${Ft}px`
                }
                )
            }
        }
        yt.forEach((xt,Ct)=>{
            if (mt.type === "fraction" && (xt.querySelectorAll(classesToSelector(mt.currentClass)).forEach(Tt=>{
                Tt.textContent = mt.formatFractionCurrent(vt + 1)
            }
            ),
            xt.querySelectorAll(classesToSelector(mt.totalClass)).forEach(Tt=>{
                Tt.textContent = mt.formatFractionTotal(Et)
            }
            )),
            mt.type === "progressbar") {
                let Tt;
                mt.progressbarOpposite ? Tt = et.isHorizontal() ? "vertical" : "horizontal" : Tt = et.isHorizontal() ? "horizontal" : "vertical";
                const It = (vt + 1) / Et;
                let Nt = 1
                  , Ft = 1;
                Tt === "horizontal" ? Nt = It : Ft = It,
                xt.querySelectorAll(classesToSelector(mt.progressbarFillClass)).forEach(Lt=>{
                    Lt.style.transform = `translate3d(0,0,0) scaleX(${Nt}) scaleY(${Ft})`,
                    Lt.style.transitionDuration = `${et.params.speed}ms`
                }
                )
            }
            mt.type === "custom" && mt.renderCustom ? (xt.innerHTML = mt.renderCustom(et, vt + 1, Et),
            Ct === 0 && nt("paginationRender", xt)) : (Ct === 0 && nt("paginationRender", xt),
            nt("paginationUpdate", xt)),
            et.params.watchOverflow && et.enabled && xt.classList[et.isLocked ? "add" : "remove"](mt.lockClass)
        }
        )
    }
    function ut() {
        const pt = et.params.pagination;
        if (ot())
            return;
        const mt = et.virtual && et.params.virtual.enabled ? et.virtual.slides.length : et.grid && et.params.grid.rows > 1 ? et.slides.length / Math.ceil(et.params.grid.rows) : et.slides.length;
        let yt = et.pagination.el;
        yt = makeElementsArray(yt);
        let vt = "";
        if (pt.type === "bullets") {
            let wt = et.params.loop ? Math.ceil(mt / et.params.slidesPerGroup) : et.snapGrid.length;
            et.params.freeMode && et.params.freeMode.enabled && wt > mt && (wt = mt);
            for (let _t = 0; _t < wt; _t += 1)
                pt.renderBullet ? vt += pt.renderBullet.call(et, _t, pt.bulletClass) : vt += `<${pt.bulletElement} ${et.isElement ? 'part="bullet"' : ""} class="${pt.bulletClass}"></${pt.bulletElement}>`
        }
        pt.type === "fraction" && (pt.renderFraction ? vt = pt.renderFraction.call(et, pt.currentClass, pt.totalClass) : vt = `<span class="${pt.currentClass}"></span> / <span class="${pt.totalClass}"></span>`),
        pt.type === "progressbar" && (pt.renderProgressbar ? vt = pt.renderProgressbar.call(et, pt.progressbarFillClass) : vt = `<span class="${pt.progressbarFillClass}"></span>`),
        et.pagination.bullets = [],
        yt.forEach(wt=>{
            pt.type !== "custom" && (wt.innerHTML = vt || ""),
            pt.type === "bullets" && et.pagination.bullets.push(...wt.querySelectorAll(classesToSelector(pt.bulletClass)))
        }
        ),
        pt.type !== "custom" && nt("paginationRender", yt[0])
    }
    function ft() {
        et.params.pagination = createElementIfNotDefined(et, et.originalParams.pagination, et.params.pagination, {
            el: "swiper-pagination"
        });
        const pt = et.params.pagination;
        if (!pt.el)
            return;
        let mt;
        typeof pt.el == "string" && et.isElement && (mt = et.el.querySelector(pt.el)),
        !mt && typeof pt.el == "string" && (mt = [...document.querySelectorAll(pt.el)]),
        mt || (mt = pt.el),
        !(!mt || mt.length === 0) && (et.params.uniqueNavElements && typeof pt.el == "string" && Array.isArray(mt) && mt.length > 1 && (mt = [...et.el.querySelectorAll(pt.el)],
        mt.length > 1 && (mt = mt.filter(yt=>elementParents(yt, ".swiper")[0] === et.el)[0])),
        Array.isArray(mt) && mt.length === 1 && (mt = mt[0]),
        Object.assign(et.pagination, {
            el: mt
        }),
        mt = makeElementsArray(mt),
        mt.forEach(yt=>{
            pt.type === "bullets" && pt.clickable && yt.classList.add(...(pt.clickableClass || "").split(" ")),
            yt.classList.add(pt.modifierClass + pt.type),
            yt.classList.add(et.isHorizontal() ? pt.horizontalClass : pt.verticalClass),
            pt.type === "bullets" && pt.dynamicBullets && (yt.classList.add(`${pt.modifierClass}${pt.type}-dynamic`),
            at = 0,
            pt.dynamicMainBullets < 1 && (pt.dynamicMainBullets = 1)),
            pt.type === "progressbar" && pt.progressbarOpposite && yt.classList.add(pt.progressbarOppositeClass),
            pt.clickable && yt.addEventListener("click", dt),
            et.enabled || yt.classList.add(pt.lockClass)
        }
        ))
    }
    function ht() {
        const pt = et.params.pagination;
        if (ot())
            return;
        let mt = et.pagination.el;
        mt && (mt = makeElementsArray(mt),
        mt.forEach(yt=>{
            yt.classList.remove(pt.hiddenClass),
            yt.classList.remove(pt.modifierClass + pt.type),
            yt.classList.remove(et.isHorizontal() ? pt.horizontalClass : pt.verticalClass),
            pt.clickable && (yt.classList.remove(...(pt.clickableClass || "").split(" ")),
            yt.removeEventListener("click", dt))
        }
        )),
        et.pagination.bullets && et.pagination.bullets.forEach(yt=>yt.classList.remove(...pt.bulletActiveClass.split(" ")))
    }
    rt("changeDirection", ()=>{
        if (!et.pagination || !et.pagination.el)
            return;
        const pt = et.params.pagination;
        let {el: mt} = et.pagination;
        mt = makeElementsArray(mt),
        mt.forEach(yt=>{
            yt.classList.remove(pt.horizontalClass, pt.verticalClass),
            yt.classList.add(et.isHorizontal() ? pt.horizontalClass : pt.verticalClass)
        }
        )
    }
    ),
    rt("init", ()=>{
        et.params.pagination.enabled === !1 ? bt() : (ft(),
        ut(),
        ct())
    }
    ),
    rt("activeIndexChange", ()=>{
        typeof et.snapIndex > "u" && ct()
    }
    ),
    rt("snapIndexChange", ()=>{
        ct()
    }
    ),
    rt("snapGridLengthChange", ()=>{
        ut(),
        ct()
    }
    ),
    rt("destroy", ()=>{
        ht()
    }
    ),
    rt("enable disable", ()=>{
        let {el: pt} = et.pagination;
        pt && (pt = makeElementsArray(pt),
        pt.forEach(mt=>mt.classList[et.enabled ? "remove" : "add"](et.params.pagination.lockClass)))
    }
    ),
    rt("lock unlock", ()=>{
        ct()
    }
    ),
    rt("click", (pt,mt)=>{
        const yt = mt.target
          , vt = makeElementsArray(et.pagination.el);
        if (et.params.pagination.el && et.params.pagination.hideOnClick && vt && vt.length > 0 && !yt.classList.contains(et.params.pagination.bulletClass)) {
            if (et.navigation && (et.navigation.nextEl && yt === et.navigation.nextEl || et.navigation.prevEl && yt === et.navigation.prevEl))
                return;
            const wt = vt[0].classList.contains(et.params.pagination.hiddenClass);
            nt(wt === !0 ? "paginationShow" : "paginationHide"),
            vt.forEach(_t=>_t.classList.toggle(et.params.pagination.hiddenClass))
        }
    }
    );
    const gt = ()=>{
        et.el.classList.remove(et.params.pagination.paginationDisabledClass);
        let {el: pt} = et.pagination;
        pt && (pt = makeElementsArray(pt),
        pt.forEach(mt=>mt.classList.remove(et.params.pagination.paginationDisabledClass))),
        ft(),
        ut(),
        ct()
    }
      , bt = ()=>{
        et.el.classList.add(et.params.pagination.paginationDisabledClass);
        let {el: pt} = et.pagination;
        pt && (pt = makeElementsArray(pt),
        pt.forEach(mt=>mt.classList.add(et.params.pagination.paginationDisabledClass))),
        ht()
    }
    ;
    Object.assign(et.pagination, {
        enable: gt,
        disable: bt,
        render: ut,
        update: ct,
        init: ft,
        destroy: ht
    })
}
function Autoplay(_e) {
    let {swiper: et, extendParams: tt, on: rt, emit: nt, params: it} = _e;
    et.autoplay = {
        running: !1,
        paused: !1,
        timeLeft: 0
    },
    tt({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !1,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });
    let st, at, ot = it && it.autoplay ? it.autoplay.delay : 3e3, lt = it && it.autoplay ? it.autoplay.delay : 3e3, dt, ct = new Date().getTime(), ut, ft, ht, gt, bt, pt, mt;
    function yt(At) {
        !et || et.destroyed || !et.wrapperEl || At.target === et.wrapperEl && (et.wrapperEl.removeEventListener("transitionend", yt),
        !mt && Tt())
    }
    const vt = ()=>{
        if (et.destroyed || !et.autoplay.running)
            return;
        et.autoplay.paused ? ut = !0 : ut && (lt = dt,
        ut = !1);
        const At = et.autoplay.paused ? dt : ct + lt - new Date().getTime();
        et.autoplay.timeLeft = At,
        nt("autoplayTimeLeft", At, At / ot),
        at = requestAnimationFrame(()=>{
            vt()
        }
        )
    }
      , wt = ()=>{
        let At;
        return et.virtual && et.params.virtual.enabled ? At = et.slides.filter(Dt=>Dt.classList.contains("swiper-slide-active"))[0] : At = et.slides[et.activeIndex],
        At ? parseInt(At.getAttribute("data-swiper-autoplay"), 10) : void 0
    }
      , _t = At=>{
        if (et.destroyed || !et.autoplay.running)
            return;
        cancelAnimationFrame(at),
        vt();
        let Pt = typeof At > "u" ? et.params.autoplay.delay : At;
        ot = et.params.autoplay.delay,
        lt = et.params.autoplay.delay;
        const Dt = wt();
        !Number.isNaN(Dt) && Dt > 0 && typeof At > "u" && (Pt = Dt,
        ot = Dt,
        lt = Dt),
        dt = Pt;
        const Bt = et.params.speed
          , zt = ()=>{
            !et || et.destroyed || (et.params.autoplay.reverseDirection ? !et.isBeginning || et.params.loop || et.params.rewind ? (et.slidePrev(Bt, !0, !0),
            nt("autoplay")) : et.params.autoplay.stopOnLastSlide || (et.slideTo(et.slides.length - 1, Bt, !0, !0),
            nt("autoplay")) : !et.isEnd || et.params.loop || et.params.rewind ? (et.slideNext(Bt, !0, !0),
            nt("autoplay")) : et.params.autoplay.stopOnLastSlide || (et.slideTo(0, Bt, !0, !0),
            nt("autoplay")),
            et.params.cssMode && (ct = new Date().getTime(),
            requestAnimationFrame(()=>{
                _t()
            }
            )))
        }
        ;
        return Pt > 0 ? (clearTimeout(st),
        st = setTimeout(()=>{
            zt()
        }
        , Pt)) : requestAnimationFrame(()=>{
            zt()
        }
        ),
        Pt
    }
      , Et = ()=>{
        ct = new Date().getTime(),
        et.autoplay.running = !0,
        _t(),
        nt("autoplayStart")
    }
      , xt = ()=>{
        et.autoplay.running = !1,
        clearTimeout(st),
        cancelAnimationFrame(at),
        nt("autoplayStop")
    }
      , Ct = (At,Pt)=>{
        if (et.destroyed || !et.autoplay.running)
            return;
        clearTimeout(st),
        At || (pt = !0);
        const Dt = ()=>{
            nt("autoplayPause"),
            et.params.autoplay.waitForTransition ? et.wrapperEl.addEventListener("transitionend", yt) : Tt()
        }
        ;
        if (et.autoplay.paused = !0,
        Pt) {
            bt && (dt = et.params.autoplay.delay),
            bt = !1,
            Dt();
            return
        }
        dt = (dt || et.params.autoplay.delay) - (new Date().getTime() - ct),
        !(et.isEnd && dt < 0 && !et.params.loop) && (dt < 0 && (dt = 0),
        Dt())
    }
      , Tt = ()=>{
        et.isEnd && dt < 0 && !et.params.loop || et.destroyed || !et.autoplay.running || (ct = new Date().getTime(),
        pt ? (pt = !1,
        _t(dt)) : _t(),
        et.autoplay.paused = !1,
        nt("autoplayResume"))
    }
      , It = ()=>{
        if (et.destroyed || !et.autoplay.running)
            return;
        const At = getDocument();
        At.visibilityState === "hidden" && (pt = !0,
        Ct(!0)),
        At.visibilityState === "visible" && Tt()
    }
      , Nt = At=>{
        At.pointerType === "mouse" && (pt = !0,
        mt = !0,
        !(et.animating || et.autoplay.paused) && Ct(!0))
    }
      , Ft = At=>{
        At.pointerType === "mouse" && (mt = !1,
        et.autoplay.paused && Tt())
    }
      , Lt = ()=>{
        et.params.autoplay.pauseOnMouseEnter && (et.el.addEventListener("pointerenter", Nt),
        et.el.addEventListener("pointerleave", Ft))
    }
      , Mt = ()=>{
        et.el.removeEventListener("pointerenter", Nt),
        et.el.removeEventListener("pointerleave", Ft)
    }
      , $t = ()=>{
        getDocument().addEventListener("visibilitychange", It)
    }
      , kt = ()=>{
        getDocument().removeEventListener("visibilitychange", It)
    }
    ;
    rt("init", ()=>{
        et.params.autoplay.enabled && (Lt(),
        $t(),
        Et())
    }
    ),
    rt("destroy", ()=>{
        Mt(),
        kt(),
        et.autoplay.running && xt()
    }
    ),
    rt("_freeModeStaticRelease", ()=>{
        (ht || pt) && Tt()
    }
    ),
    rt("_freeModeNoMomentumRelease", ()=>{
        et.params.autoplay.disableOnInteraction ? xt() : Ct(!0, !0)
    }
    ),
    rt("beforeTransitionStart", (At,Pt,Dt)=>{
        et.destroyed || !et.autoplay.running || (Dt || !et.params.autoplay.disableOnInteraction ? Ct(!0, !0) : xt())
    }
    ),
    rt("sliderFirstMove", ()=>{
        if (!(et.destroyed || !et.autoplay.running)) {
            if (et.params.autoplay.disableOnInteraction) {
                xt();
                return
            }
            ft = !0,
            ht = !1,
            pt = !1,
            gt = setTimeout(()=>{
                pt = !0,
                ht = !0,
                Ct(!0)
            }
            , 200)
        }
    }
    ),
    rt("touchEnd", ()=>{
        if (!(et.destroyed || !et.autoplay.running || !ft)) {
            if (clearTimeout(gt),
            clearTimeout(st),
            et.params.autoplay.disableOnInteraction) {
                ht = !1,
                ft = !1;
                return
            }
            ht && et.params.cssMode && Tt(),
            ht = !1,
            ft = !1
        }
    }
    ),
    rt("slideChange", ()=>{
        et.destroyed || !et.autoplay.running || (bt = !0)
    }
    ),
    Object.assign(et.autoplay, {
        start: Et,
        stop: xt,
        pause: Ct,
        resume: Tt
    })
}
const u1 = "/assets/u1-CLambCIF.webp"
  , u2 = "/assets/u2-77htlYLZ.webp"
  , u3 = "/assets/u3-DgnWndFy.webp"
  , u4 = "/assets/u4-BBCl-q5U.webp"
  , u5 = "/assets/u5-DJuIv1bF.webp"
  , u6 = "/assets/u6-CyoEKWlH.webp"
  , u7 = "/assets/u7-B7Pz71_1.webp"
  , u8 = "/assets/u8-C4mDXpjS.webp"
  , u9 = "/assets/u9-DRKp_AJM.webp"
  , u10 = "/assets/u10-DAwwDbHt.webp"
  , u11 = "/assets/u11-CqtQt-py.webp"
  , u12 = "/assets/u12-C43xHpVt.webp"
  , u13 = "/assets/u13-bXSiVFqT.webp"
  , u14 = "/assets/u14-CllZWNX3.webp"
  , u15 = "/assets/u15-B6l8u4Jg.webp"
  , u16 = "/assets/u16-BOh4YfXa.webp"
  , u17 = "/assets/u17-ZfDmVMhH.webp"
  , u18 = "/assets/u18-Cox0TnBR.webp"
  , u19 = "/assets/u19-Bw6kdfHZ.webp"
  , u20 = "data:image/webp;base64,UklGRtoIAABXRUJQVlA4WAoAAAAYAAAAKwEAxwAAVlA4TCwHAAAvK8ExEFWH4rZtHHn/tdNz5RsRE6D/BUacnXqLditYZgckdeQ1pFKgOxLs+UWG0s22fb3brH7MzMzsMDMzMzMzM3P0/eh/zvmfcL7SM4Q5aaMZAqXOEpZH0KVevRdQ3GqCcKcuHedMEOyZOebKO6hU+VcMA6TXDmoNVZg7LxA09r40QKhiZuaMoSp1XGYdpgVcqwq1DCuQRggnIzCMgN8A7sLJBDxEVIZWwA2YeQiVIVXpSdPEQ2QeVe4iJAEAWEaSbdu2bdu2vfuybdu2bRtnm2vbu00mAE5tS4IU19d/uFWn53RlXQYQiBwkIA6pJQIpCF35G64oxBEiHv8KcNDf4kEBAIBgM9u2mWzcan/y34xkW0nVtl9tM9u2/U9AH/8f/x//j+E+F2123KZ0YU488vaBqfKf2C797imb1Pax9o7VT67Rt3eaJ/kr5dbZyjbCt+4znfStc55O2vHfoVUSn+b+qW3iawxqnvi27Z+3fwGWc5aRrriDizz85do5beOoxe0mv9e3lrE2vhmfiaChN5Gizf5t6kdjn+tfyzmSNj+hnYlEJGtnJNjMn1iSiBjPuPyMSuuatUIZqkeAaoeG0Th5Gv9CzCa+y6hjkuQOA1vbTx7GE9IXQpK7f6h3JY46X8u7BMc3QcQ0eaR2WGiF0pUq6h9EY+eIITQgYA0CAiXkHJZERE39NJFx9PAoi2ggkK2LKxIKj2eIiKnTFVXQM5nbiDNbn5aozeMYtBogqnvB5mj7hKfDSxOalqjFLU3QojopfZWiIWEoK67WYjzDwQQOmqK0hZroD8QSlZMmW9Fg0AolC83P2dGlDzQAyM/Z8p4/qzxxnyqvs5v8+fPnb++8o6sub3t52oenjIlCYFDYzT1YpmTJv/pDhocsaui1nFq1Obt/9IGGgLU5j7ZC3McODqG2TlCmiar3Z76Bwc/SEjojaMIIPjZ1Vue3LEoRI9DuqQkPNBGFhAT7JrCuY3Qfxl9uUgwHZ1zlraAIB6cJx4mLdOtbjNhKjPxS0haRYI4haYn9IKf+37EafCVQCvlrLQ0ttp0U7kDGMSjqLJ3kZWynZAaozIFQl3eGBjCstyeGq0B+AdwZGh6+pSqODKOLW0PESjp+VxBHdSgIvdb4Zyh8Xi1gPUuMTq7VpIhnJLA0l+9sT8QrqEbgF26JvSE6VRMpkxgRhpJkwdCEsRXMBcVJMgl9AS90fQeVwod6foKuiMmnheTRjLvU1DEKdffwkLk0Ly+p1ABdQXWCPRAbegvRfVrI1suYB1XEluvjGapzGs2m2azn8awUpK/gXKhCKGIChyCo23uHBk5htLov4MkXzziCwL6RmDxm1JB8ZarIqPJXFFl3C9Rh1NiNDavjuYiHL4FORUSjvXOIEnuqy0XMXAI9PuYcZ9Yx6T57awdbEWivjuaUW9lE+hO2hiwdBCcJRER0YXjLceaIJd7oR2I7C0i1f4XWgv/EeqVYgZEH6vre4cT3GmiOGAJS6lt1yVgzzjjjZG7O3j9jK3v9IsQ+z1Dl45nIA62G3qBRtIKErkHQzgg28wuiHINSpF4SVwdV2Zv7b0UeURpX4E3wL1BRxjteGlkLlRFRy3sP6wT1Cyj9BXTXG1BISYiSR2hjRtQEHfinrZC5leC1kVnPIqPRT1pY+mQUm9AP7u35mwHAoCCcRZPObCO4QhWisbKunBSq8LOyPp932g4ltHc2PRwWnTEmV+C2KVPzM+goE5ZNEEdzQqgfpNEP3syTlocoa4+EPpG77rrrrohjOr4ukL+lnSXqGA3wRW5W2yfIb3zIoFTJNsGMpPAdL7E6JgynKJeVXwCxhS1Gq/u2wPQrq6AUcWJro0J5SYMY30SntwE+IKXN/Ba71hz+3wra40YbwFVNhSstQelJIfu2+u/YpdXQIZZgTTs04cP67z6Ce33KJ9jNPaO2wwJMQ/DK0+u+F7q6g8JPRMG8FSAKMINSImd+wTgPdd+ZBEcYIrgFY04zaPcsBA6e/vwrb3z6OzsxF9V/3zE+ROEXGV/kzfdx7pJgz09+Va9YjDj9/HXfsXdCE14s9sY8EB2iPekeqPtcCPZEiZkaGT+vYSHOe0P3Ge2fMz6QcWUFiAIswxHRmVH3bRQEHRomA+dklOGrYSa3NrCBnLppZoLzMYwnCJ4KpabOZNDFiFiDUeeUCrcpZe3T7f3rJyLvERBtK/Iuwbl1w0fF6p4HPRiO7AObw85yvKptDrofgIgP/5LYz2kS/0AVL2Tt2Zy/2LXXTl3lv3RlKZMWCHQg/6U1wVOPFQndoiborhts4dGu/EVpqAVTUbJLAdxhkDuiUviZ2Duf3nHcd7mktFI8jXMLj5sb/qLqDac2cfcm1/vMGETtWiRzNYF+mboYtU/kE64abIT8f1SDtRDbEMd/Y0r1FmKnHCyH2ASqBgUhirsaofW/3N4QTDkc/x//H/+PcT1FWElGMgEAAE1NACoAAAAIAAcBEgADAAAAAQABAAABGgAFAAAAAQAAAGIBGwAFAAAAAQAAAGoBKAADAAAAAQACAAABMQACAAAAHwAAAHIBMgACAAAAFAAAAJGHaQAEAAAAAQAAAKgAAADUAAr8gAAAJxAACvyAAAAnEEFkb2JlIFBob3Rvc2hvcCAyMy41IChXaW5kb3dzKQAyMDI0OjAxOjE5IDIxOjMwOjI2AAAAAAADoAEAAwAAAAH//wAAoAIABAAAAAEAAAEsoAMABAAAAAEAAADIAAAAAAAAAAYBAwADAAAAAQAGAAABGgAFAAAAAQAAASIBGwAFAAAAAQAAASoBKAADAAAAAQACAAACAQAEAAAAAQAAATICAgAEAAAAAQAAAAAAAAAAAAAASAAAAAEAAABIAAAAAVBTQUlOAAAAOEJJTQPtAAAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EKAAAAAAADAAAAAI/8AAAAAAAADhCSU0EQwAAAAAADVBiZVcBEAAFAQIAAAAA"
  , u21 = "/assets/u21-D6KUIlnM.webp"
  , u22 = "/assets/u22-CPGSGVgj.webp"
  , u23 = "data:image/webp;base64,UklGRroPAABXRUJQVlA4WAoAAAAYAAAAKwEAxwAAVlA4TAwOAAAvK8ExEFWH4rZtHGn/sZPr9RkRE8Ar27ODu2ZgnTqbDTbSboYCSGCkt8mHtFvt/zrLTf817Nz5D/MsMzOzmJmZGef7+/2+vxGEuh/VoAIU71G++c3FrBaY+RYiCpm2AB2lnFEP24CqkEIp4pBy5g42FvawmTIpV/ZvQGjmacDsiKED9TDG24Ayh5tt/k+3ADtkLoEhdwELuY5LcOqM2R0o+nagTKHrYfuqA9Wg1JmzDZ1RzBU4Y0/m1JGPQucKXYIbcOizkekICIr8H81A2raht90lQJJk2laETzzbtm3b1rdt27Zt27Zt49q2uTsTQCfbtmlzYvW6/vhXMc/7vd//vTmO7+t4lIwFXFCOETwgAnokIAIh4AEN1BxomJIdKzsKIgJp44BVCC1uMEE3AlIiZDyQKgpiBB9RRY2AR8CUiQdS0k8HQsYBq6FNBGU8xAfjtm0D7b/tNZbsexJk2/g7/J0qBAYACCZ7tm3btm3btm3btm3btm3bdhOAcv+X+7/c/+X+X5Yq4EmMQgvzUZmiQfWq0f9V311aFuQndCBmA3HDEPTCQbWoI/Wn/qerU9FmuEIMm4SBLezEqPqpWdWvmFSuHoKtASNWMeqy9qjuRDKNekuwUEWEeqw9q3cR78HaDISe2q8FqjPDbBswsFRVLfSuINwAdlxQ7dRi1YmQXn2Y8WUt+FTYrDyacy3cE7bqMNdavCd8xVkONaAneLUZGjWkMFlpLMaTMS65eFYZC04t16BqlxfKGlNJNSytaIXRhF8ap0gKq4s/CLVQMx6rrlhNNS5V90XzXH1ME9sQ7NqyzGpG9cZFmLHl24DSc+Ij08rw2lPMemtpfVZrPc+rqXVpW1DDExYCFlf0cp8eU5ciZCVFj/vpUVZqhVVUc1c15f0O/NmVtO5kdiG1Hb804pXMzAptnIljoUUvtxi2Ai2feSVtklf0PK9YU6treCcgYBlFj7EYtQGAz5zStrDoFWtyRYj5RkElFD3P84phq9XgD1ptzyHKMobgf4nUF0Y3RdR1qAteqPvpRNJiDsjZgQIWaKGV3gk9GfR+OlCN9qLwN9FNVWAjG/L0OJTNDSzqWYF6gFX0mYNWTAOErr8ndBLbOwUMQrfjd5/ZAXV2u7B2IRUIKm4uYBGR2T+U1gyT7C0RskKDZVFzYnwNmmnFoj2n0qI7CvPaTwf+pmaCxcJLp4NZsaiD5I6mGu5ZC433KuVflyZzdQZYxHRCqLJapRO/XkU9HdYIXPjUMAk9AVQ+cwNQ+zbzdOI/wLnYWYByZBZY/2mQuQVUE91ScYGKxTnEBBdQxAJWcw0u6Uk0k57/IKixiqLuly9fmghq4exCsmPhNjrsL6HnAH4L8kEmgLKG97CjhGtOTC9jmnjFah4CmYQJ9hSkNFZv8DVmBXJeaH48PJfDwjvZ6ELK5RtUpbgP+SEd+ceOyp5DHJJgGlZDA7LKgyRkEkpAIrrsETVDha9ovg80pC73Eo33koWmvA1g0AIOhHvUU7mCSpoZVqHHwEZX0rWkIU/ZMGDV8RxYQMYY5VmkzklIgbKicQQ02Md71B0X6kgVojv+yIm05vYguzsZZDcyxoVMMT4VTxhB9k/bYiBiza8X9fQw96XwdW33c6f5+/BRKhniwIPpTqEnh95PH5POJDXbu832gWYzPcposd5zkxpnAROrGdUThtewYitWEXnwbzG7y4WCVCM99eZAPiOmgJ548yIOchZyEMv2HM2kjVekNQuaK98vyvEgz3JxUP7I3bg+j0/7mRXSmu946mq/0PM6HLN+MEndeJjqyAyfJYwMPhE+B1SYMQvpq0i9cpEFLPq68k0yUoVdRtpAKU0X0pvZWXOkFd8YXKbIaplOA50TuurDftpAHWJcf8VzE+jguHcOIMUKMMrcPBsyDqV+OnHRgNTgDC9BnA3MpmJRneFHhelEJI8uNQsBj9OFVOKFzkX3Bo/Y0BkvWwHzH6hoqofQXnlsSijpBjpHX4qEHoH8krb4yEXDvDODGMyYBXbcIPEFNBC1VJhdhKl1PbV7xxwmxIRHE70hQP09QkhNLrdVd/cKfTAMoyh6NLV1RAVmjXlJ6J84is03qacDTIr3dAaSRkNJVyzG+AIKMM7DUkERjaWraLzDNNBpIetoH0KXOY/DxNdt9aZAkdZsE7Tcl5Q0wTWjGBrWphYEpDkeebd2XAN5aLrVr7YgyMazjQ8yFFFVuzwl8qCr+y6S3jCfJ2b/0PuB3iMg5gNEWGTHsfAB1JQwDDOKoe651FCtursbKBMxROimvAOO9M7iej0lXw0ilgXzngFyz9iiO4rUAQQdCHC1WSXKIxqYWu16cZTYDVjYAdF9GQC+R8gZdlIcI3R7/oCxnzaTQUd9djudFnz2QEYLhwp9UiXLyS/9l9KBk14H/hpBydUsIrHvPgmrIVIqJnllSBKuKtURpdXWRUsc5eNCFgEELO1bxKiVrdTjfkWDOW6GbkOjnhu5ap2qRQCiHLUxWGYH+uxdyoY8q9eJ/x0LnxZmSlriOceHfSozYxq6uo3UA4QTqYyqUpMNWkIXVjhI4IKHE7MCfREAriaqkjbJyhmKrJYwtNo3lCQ1RkdzyI/Bo1uh15McJDFiXgAltbSRQVV3HZGYG5BDxUZuhiwYdVhVn+9ykIhk1fXEILVvm5BdSUVund1JyGAr1ytSN4XhB4rvszy6Dd+vbGsLvZ7DAerzqGJOh6NqNVO1XaIjYwxcrUfq54eIpl5VdXv3jhAJ8avE2JBQWa0lgoqbA5h4YWiTbLTgc0V6p+aZyH/yDe3nOyVfCCEYmVtooMq7ILkGS7nii4ytADVz65aaPsfQIxrF0VUhbNXPJaqPJdCfkAZzwkZj3VDcwHA+VZXQSCbZwFJzPjLz02l8yCnpviykNMtA5fSIVb7AG9cbJMUGC+RrGuDevXsYILLg7vRgWWM011Mhx4DOagV1f5lsLNThNkVDnmPoTha1c4QlOp3mTx3uqsvdLfiiWnFUBLkc449i4yPpnuQOMkOYuZ+lpKEuRNW+qAM9WlgP5pAxi/k0eg4Ca3RiQGq8hxY+hJ8e034m6sr0Tqdra/POxJkJ9rMQv8E3U51IMtt3ShipK/x007kPwCt/RcmRHMmbCFM9pDR1QQfUcyvW1qNZd6gbXmgNWmbFN3NmUdGD2QyR0QLhbjsfLfjMbyZYqQ19z6MrzgFnUr3Agc5KANBY1xXyZ4br7OBESr62sAM9lnSHSMoYw3omUld8oc5FC+pR8kN0Xybb8ICC+fBaSmruqq62+ip0fR4xGzYR1YrhQaXkGx5FKRs0SvU8SX2SqBtWaMUqIeeGtDtOSZQjBC3zV2xSZ7dZyGq5YjLov2Jw/HwfpuYADm2SGRIc/FxKOpOUd376TDxqFgtKrU0ymjL+W6RfC1UbF2njJ4wVYzmIsUGYDYO7Qx1CMCMcJPxDLThwm+ozUnKTXhDRk41O6HPBgBZ8qqj6Q74hsiXVHCmKJ2ESDb4A2cvCv1+HB0tENmj46mWaaM4F3GFUOSl01IDRU8GoHj2Qeu5b+FCHWxXSkX8cC9eIqGni0Qj9+ntZHLg8SMmGfovMN2S5cGEHHJDFFLHwoNF/s5oiv/Hk59Mg1yUcW6l+d2XOtVVU5haXyalMLuq7g8qoJuTDFvAahfzkxIjKy84BwA6HnP9CUTbmVbAgjYlnUtLPJHXj7WELDoz8cgJkmbOrwZZoaOT1SS9xMS3gp6NHqaccw18DFgqgn5BX+MwD2t2GRk0No58uFp4zAywKkRtHjzOSPhSOC9lvFnYg6t7gvZsJbfhRcXMGUw3GofSSrqTq/pIHT2DgBRDDLXWGIc4myM5aaqD19qRjLpAF6M/jsGORwPsHUB+Bfi2uoySjxRYQuwHVKuNJoA25SHDd8XZKHnLgp2d4J5NjwQ+apcexRYrK2Q33aqtFDLhBc5xkBOTCBuwB/E3oXxuEGHgX1Z0MG3jlhkx9KQ4xCWxI2eybKWmLDxY+wYSINe9uBuGeRCck7PnUzIQb2WQJTzkjkY8wHuTUQN/zMkDnIVGvDynbBkKX3Z/ja6337TBYQCf8Ufw0biMXh3fdbJRQXqSerl1w//scjaPzi7iko+pyr2M4Hr0H4uw5k2rLzzD9OyWNcSUnbfMUWS03AWpp06TQmpx5UlwjoKmqv0d07jmBkklHV8N7ALVvK08n/gdWn80hYnkDrEhtoUFifSkY9pDEt59+HLN/yLFItOY7yV3YwTiUhZhi5CfRgb/mAxBvc+AE4DLFDWao/OjgK85UfOyhtvv5AWirVtJBihP//1NCmusJ8EWeTwDOxb6Z+IeJA5t2+/VbOWdopKoZy2j/dT/hK0veuIRGGydvTPwGOyAQu66S67qlqPWAM2yVhYLrFtyAcwLg96GFguu6bimEcAYAPvN5ZR1u/2HLfdWGH97TSJdq7eoo6+6GYdn5FAqu67qloBK0UBG1joLrum4pZoOBe0ouY+k4YOXBBdd1S+FXawIEL/8vBbcUfJk6JKrLkV6COHJtGzEjQdm5ulkIam8cdcILfX0lS/x0GJJSrnEjeBQoKVf5A9U4xjkvsHWWXEjW7AhqG8LItc7CUSvLE/u8qHK9Y3jHS/uSF3WueRq2mlzWj7woct3/rCqWpFox1Fz9lpf6XsqhCIZAcwNk8ajpZTwKiec2yIKkeX6xvxPIH4LLzfD5127vRz2JNIgiN0VB8vDT8/2FRRmUuTl+S1NSJTfm+EaUQioYfG6TCk7xKLfv3lKXj0VnL6gVUSW8Df7v8yH/l/u/3P/l/i/3/3LjBEVYSUYyAQAATU0AKgAAAAgABwESAAMAAAABAAEAAAEaAAUAAAABAAAAYgEbAAUAAAABAAAAagEoAAMAAAABAAIAAAExAAIAAAAfAAAAcgEyAAIAAAAUAAAAkYdpAAQAAAABAAAAqAAAANQACvyAAAAnEAAK/IAAACcQQWRvYmUgUGhvdG9zaG9wIDIzLjUgKFdpbmRvd3MpADIwMjQ6MDE6MTkgMjE6MzU6MTkAAAAAAAOgAQADAAAAAf//AACgAgAEAAAAAQAAASygAwAEAAAAAQAAAMgAAAAAAAAABgEDAAMAAAABAAYAAAEaAAUAAAABAAABIgEbAAUAAAABAAABKgEoAAMAAAABAAIAAAIBAAQAAAABAAABMgICAAQAAAABAAAAAAAAAAAAAABIAAAAAQAAAEgAAAABUFNBSU4AAAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQABOEJJTQQoAAAAAAAMAAAAAj/wAAAAAAAAOEJJTQRDAAAAAAANUGJlVwEQAAUBAgAAAAA="
  , u24 = "/assets/u24-Fynz8Xkj.webp"
  , u25 = "/assets/u25-BSGnWU1L.webp"
  , u26 = "/assets/u26-COObGzbm.webp"
  , u27 = "/assets/u27-Dq4OpMtV.webp"
  , u28 = "/assets/u28-B_om1MLr.webp"
  , Upcoming = ()=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: jsxRuntimeExports.jsx("div", {
        className: "container-fluid",
        children: jsxRuntimeExports.jsx("div", {
            className: "row",
            children: jsxRuntimeExports.jsxs("div", {
                className: "col-11 mx-auto max-width py-5 ",
                children: [jsxRuntimeExports.jsx("h1", {
                    className: "benefitHead",
                    children: "Upcoming Exchanges"
                }), jsxRuntimeExports.jsxs(Swiper, {
                    slidesPerView: 2,
                    spaceBetween: 30,
                    pagination: {
                        clickable: !0
                    },
                    autoplay: {
                        delay: 2e3,
                        disableOnInteraction: !1
                    },
                    modules: [Pagination, Autoplay],
                    breakpoints: {
                        640: {
                            slidesPerView: 2,
                            spaceBetween: 20
                        },
                        768: {
                            slidesPerView: 4,
                            spaceBetween: 40
                        },
                        1024: {
                            slidesPerView: 5,
                            spaceBetween: 50
                        }
                    },
                    className: "mySwiper",
                    children: [jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u1,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u28,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u2,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u3,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u4,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u5,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u6,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u7,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u8,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u9,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u10,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u11,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u12,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u13,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u14,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u15,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u16,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u17,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u18,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u19,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u20,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u21,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u22,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u23,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u24,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u25,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u26,
                            alt: ""
                        })
                    }), jsxRuntimeExports.jsx(SwiperSlide, {
                        className: "py-5",
                        children: jsxRuntimeExports.jsx("img", {
                            className: "img-fluid",
                            src: u27,
                            alt: ""
                        })
                    })]
                })]
            })
        })
    })
})
  , Home = ()=>jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [jsxRuntimeExports.jsx(Banner, {}), jsxRuntimeExports.jsx(Presale, {}), jsxRuntimeExports.jsx(Upcoming, {}), jsxRuntimeExports.jsx(Targeted, {}), jsxRuntimeExports.jsx(Revolution, {}), jsxRuntimeExports.jsx(Tokenomics, {}), jsxRuntimeExports.jsx(Benefits, {}), jsxRuntimeExports.jsx(Roadmap, {}), jsxRuntimeExports.jsx(Faq, {})]
});
var dist = {}
  , ga4 = {}
  , gtag = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = void 0;
    var et = function() {
        for (var nt = arguments.length, it = new Array(nt), st = 0; st < nt; st++)
            it[st] = arguments[st];
        if (typeof window < "u") {
            var at;
            typeof window.gtag > "u" && (window.dataLayer = window.dataLayer || [],
            window.gtag = function() {
                window.dataLayer.push(arguments)
            }
            ),
            (at = window).gtag.apply(at, it)
        }
    }
      , tt = et;
    _e.default = tt
}
)(gtag);
var format$1 = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = st;
    var et = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i;
    function tt(at) {
        return at.toString().trim().replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function(ot, lt, dt) {
            return lt > 0 && lt + ot.length !== dt.length && ot.search(et) > -1 && dt.charAt(lt - 2) !== ":" && (dt.charAt(lt + ot.length) !== "-" || dt.charAt(lt - 1) === "-") && dt.charAt(lt - 1).search(/[^\s-]/) < 0 ? ot.toLowerCase() : ot.substr(1).search(/[A-Z]|\../) > -1 ? ot : ot.charAt(0).toUpperCase() + ot.substr(1)
        })
    }
    function rt(at) {
        return typeof at == "string" && at.indexOf("@") !== -1
    }
    var nt = "REDACTED (Potential Email Address)";
    function it(at) {
        return rt(at) ? (console.warn("This arg looks like an email address, redacting."),
        nt) : at
    }
    function st() {
        var at = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""
          , ot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
          , lt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
          , dt = at || "";
        return ot && (dt = tt(at)),
        lt && (dt = it(dt)),
        dt
    }
}
)(format$1);
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = _e.GA4 = void 0;
    var et = st(gtag)
      , tt = st(format$1)
      , rt = ["eventCategory", "eventAction", "eventLabel", "eventValue", "hitType"]
      , nt = ["title", "location"]
      , it = ["page", "hitType"];
    function st(Lt) {
        return Lt && Lt.__esModule ? Lt : {
            default: Lt
        }
    }
    function at(Lt, Mt) {
        if (Lt == null)
            return {};
        var $t = ot(Lt, Mt), kt, At;
        if (Object.getOwnPropertySymbols) {
            var Pt = Object.getOwnPropertySymbols(Lt);
            for (At = 0; At < Pt.length; At++)
                kt = Pt[At],
                !(Mt.indexOf(kt) >= 0) && Object.prototype.propertyIsEnumerable.call(Lt, kt) && ($t[kt] = Lt[kt])
        }
        return $t
    }
    function ot(Lt, Mt) {
        if (Lt == null)
            return {};
        var $t = {}, kt = Object.keys(Lt), At, Pt;
        for (Pt = 0; Pt < kt.length; Pt++)
            At = kt[Pt],
            !(Mt.indexOf(At) >= 0) && ($t[At] = Lt[At]);
        return $t
    }
    function lt(Lt) {
        "@babel/helpers - typeof";
        return lt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Mt) {
            return typeof Mt
        }
        : function(Mt) {
            return Mt && typeof Symbol == "function" && Mt.constructor === Symbol && Mt !== Symbol.prototype ? "symbol" : typeof Mt
        }
        ,
        lt(Lt)
    }
    function dt(Lt) {
        return ft(Lt) || ut(Lt) || mt(Lt) || ct()
    }
    function ct() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function ut(Lt) {
        if (typeof Symbol < "u" && Lt[Symbol.iterator] != null || Lt["@@iterator"] != null)
            return Array.from(Lt)
    }
    function ft(Lt) {
        if (Array.isArray(Lt))
            return yt(Lt)
    }
    function ht(Lt, Mt) {
        var $t = Object.keys(Lt);
        if (Object.getOwnPropertySymbols) {
            var kt = Object.getOwnPropertySymbols(Lt);
            Mt && (kt = kt.filter(function(At) {
                return Object.getOwnPropertyDescriptor(Lt, At).enumerable
            })),
            $t.push.apply($t, kt)
        }
        return $t
    }
    function gt(Lt) {
        for (var Mt = 1; Mt < arguments.length; Mt++) {
            var $t = arguments[Mt] != null ? arguments[Mt] : {};
            Mt % 2 ? ht(Object($t), !0).forEach(function(kt) {
                Ct(Lt, kt, $t[kt])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Lt, Object.getOwnPropertyDescriptors($t)) : ht(Object($t)).forEach(function(kt) {
                Object.defineProperty(Lt, kt, Object.getOwnPropertyDescriptor($t, kt))
            })
        }
        return Lt
    }
    function bt(Lt, Mt) {
        return wt(Lt) || vt(Lt, Mt) || mt(Lt, Mt) || pt()
    }
    function pt() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function mt(Lt, Mt) {
        if (Lt) {
            if (typeof Lt == "string")
                return yt(Lt, Mt);
            var $t = Object.prototype.toString.call(Lt).slice(8, -1);
            if ($t === "Object" && Lt.constructor && ($t = Lt.constructor.name),
            $t === "Map" || $t === "Set")
                return Array.from(Lt);
            if ($t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test($t))
                return yt(Lt, Mt)
        }
    }
    function yt(Lt, Mt) {
        (Mt == null || Mt > Lt.length) && (Mt = Lt.length);
        for (var $t = 0, kt = new Array(Mt); $t < Mt; $t++)
            kt[$t] = Lt[$t];
        return kt
    }
    function vt(Lt, Mt) {
        var $t = Lt == null ? null : typeof Symbol < "u" && Lt[Symbol.iterator] || Lt["@@iterator"];
        if ($t != null) {
            var kt, At, Pt, Dt, Bt = [], zt = !0, Yt = !1;
            try {
                if (Pt = ($t = $t.call(Lt)).next,
                Mt === 0) {
                    if (Object($t) !== $t)
                        return;
                    zt = !1
                } else
                    for (; !(zt = (kt = Pt.call($t)).done) && (Bt.push(kt.value),
                    Bt.length !== Mt); zt = !0)
                        ;
            } catch (rr) {
                Yt = !0,
                At = rr
            } finally {
                try {
                    if (!zt && $t.return != null && (Dt = $t.return(),
                    Object(Dt) !== Dt))
                        return
                } finally {
                    if (Yt)
                        throw At
                }
            }
            return Bt
        }
    }
    function wt(Lt) {
        if (Array.isArray(Lt))
            return Lt
    }
    function _t(Lt, Mt) {
        if (!(Lt instanceof Mt))
            throw new TypeError("Cannot call a class as a function")
    }
    function Et(Lt, Mt) {
        for (var $t = 0; $t < Mt.length; $t++) {
            var kt = Mt[$t];
            kt.enumerable = kt.enumerable || !1,
            kt.configurable = !0,
            "value"in kt && (kt.writable = !0),
            Object.defineProperty(Lt, Tt(kt.key), kt)
        }
    }
    function xt(Lt, Mt, $t) {
        return Mt && Et(Lt.prototype, Mt),
        $t && Et(Lt, $t),
        Object.defineProperty(Lt, "prototype", {
            writable: !1
        }),
        Lt
    }
    function Ct(Lt, Mt, $t) {
        return Mt = Tt(Mt),
        Mt in Lt ? Object.defineProperty(Lt, Mt, {
            value: $t,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : Lt[Mt] = $t,
        Lt
    }
    function Tt(Lt) {
        var Mt = It(Lt, "string");
        return lt(Mt) === "symbol" ? Mt : String(Mt)
    }
    function It(Lt, Mt) {
        if (lt(Lt) !== "object" || Lt === null)
            return Lt;
        var $t = Lt[Symbol.toPrimitive];
        if ($t !== void 0) {
            var kt = $t.call(Lt, Mt || "default");
            if (lt(kt) !== "object")
                return kt;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (Mt === "string" ? String : Number)(Lt)
    }
    var Nt = function() {
        function Lt() {
            var Mt = this;
            _t(this, Lt),
            Ct(this, "reset", function() {
                Mt.isInitialized = !1,
                Mt._testMode = !1,
                Mt._currentMeasurementId,
                Mt._hasLoadedGA = !1,
                Mt._isQueuing = !1,
                Mt._queueGtag = []
            }),
            Ct(this, "_gtag", function() {
                for (var $t = arguments.length, kt = new Array($t), At = 0; At < $t; At++)
                    kt[At] = arguments[At];
                Mt._testMode || Mt._isQueuing ? Mt._queueGtag.push(kt) : et.default.apply(void 0, kt)
            }),
            Ct(this, "_loadGA", function($t, kt) {
                var At = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "https://www.googletagmanager.com/gtag/js";
                if (!(typeof window > "u" || typeof document > "u") && !Mt._hasLoadedGA) {
                    var Pt = document.createElement("script");
                    Pt.async = !0,
                    Pt.src = "".concat(At, "?id=").concat($t),
                    kt && Pt.setAttribute("nonce", kt),
                    document.body.appendChild(Pt),
                    window.dataLayer = window.dataLayer || [],
                    window.gtag = function() {
                        window.dataLayer.push(arguments)
                    }
                    ,
                    Mt._hasLoadedGA = !0
                }
            }),
            Ct(this, "_toGtagOptions", function($t) {
                if ($t) {
                    var kt = {
                        cookieUpdate: "cookie_update",
                        cookieExpires: "cookie_expires",
                        cookieDomain: "cookie_domain",
                        cookieFlags: "cookie_flags",
                        userId: "user_id",
                        clientId: "client_id",
                        anonymizeIp: "anonymize_ip",
                        contentGroup1: "content_group1",
                        contentGroup2: "content_group2",
                        contentGroup3: "content_group3",
                        contentGroup4: "content_group4",
                        contentGroup5: "content_group5",
                        allowAdFeatures: "allow_google_signals",
                        allowAdPersonalizationSignals: "allow_ad_personalization_signals",
                        nonInteraction: "non_interaction",
                        page: "page_path",
                        hitCallback: "event_callback"
                    }
                      , At = Object.entries($t).reduce(function(Pt, Dt) {
                        var Bt = bt(Dt, 2)
                          , zt = Bt[0]
                          , Yt = Bt[1];
                        return kt[zt] ? Pt[kt[zt]] = Yt : Pt[zt] = Yt,
                        Pt
                    }, {});
                    return At
                }
            }),
            Ct(this, "initialize", function($t) {
                var kt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (!$t)
                    throw new Error("Require GA_MEASUREMENT_ID");
                var At = typeof $t == "string" ? [{
                    trackingId: $t
                }] : $t;
                Mt._currentMeasurementId = At[0].trackingId;
                var Pt = kt.gaOptions
                  , Dt = kt.gtagOptions
                  , Bt = kt.nonce
                  , zt = kt.testMode
                  , Yt = zt === void 0 ? !1 : zt
                  , rr = kt.gtagUrl;
                if (Mt._testMode = Yt,
                Yt || Mt._loadGA(Mt._currentMeasurementId, Bt, rr),
                Mt.isInitialized || (Mt._gtag("js", new Date),
                At.forEach(function(pr) {
                    var gr = gt(gt(gt({}, Mt._toGtagOptions(gt(gt({}, Pt), pr.gaOptions))), Dt), pr.gtagOptions);
                    Object.keys(gr).length ? Mt._gtag("config", pr.trackingId, gr) : Mt._gtag("config", pr.trackingId)
                })),
                Mt.isInitialized = !0,
                !Yt) {
                    var ar = dt(Mt._queueGtag);
                    for (Mt._queueGtag = [],
                    Mt._isQueuing = !1; ar.length; ) {
                        var or = ar.shift();
                        Mt._gtag.apply(Mt, dt(or)),
                        or[0] === "get" && (Mt._isQueuing = !0)
                    }
                }
            }),
            Ct(this, "set", function($t) {
                if (!$t) {
                    console.warn("`fieldsObject` is required in .set()");
                    return
                }
                if (lt($t) !== "object") {
                    console.warn("Expected `fieldsObject` arg to be an Object");
                    return
                }
                Object.keys($t).length === 0 && console.warn("empty `fieldsObject` given to .set()"),
                Mt._gaCommand("set", $t)
            }),
            Ct(this, "_gaCommandSendEvent", function($t, kt, At, Pt, Dt) {
                Mt._gtag("event", kt, gt(gt({
                    event_category: $t,
                    event_label: At,
                    value: Pt
                }, Dt && {
                    non_interaction: Dt.nonInteraction
                }), Mt._toGtagOptions(Dt)))
            }),
            Ct(this, "_gaCommandSendEventParameters", function() {
                for (var $t = arguments.length, kt = new Array($t), At = 0; At < $t; At++)
                    kt[At] = arguments[At];
                if (typeof kt[0] == "string")
                    Mt._gaCommandSendEvent.apply(Mt, dt(kt.slice(1)));
                else {
                    var Pt = kt[0]
                      , Dt = Pt.eventCategory
                      , Bt = Pt.eventAction
                      , zt = Pt.eventLabel
                      , Yt = Pt.eventValue;
                    Pt.hitType;
                    var rr = at(Pt, rt);
                    Mt._gaCommandSendEvent(Dt, Bt, zt, Yt, rr)
                }
            }),
            Ct(this, "_gaCommandSendTiming", function($t, kt, At, Pt) {
                Mt._gtag("event", "timing_complete", {
                    name: kt,
                    value: At,
                    event_category: $t,
                    event_label: Pt
                })
            }),
            Ct(this, "_gaCommandSendPageview", function($t, kt) {
                if (kt && Object.keys(kt).length) {
                    var At = Mt._toGtagOptions(kt)
                      , Pt = At.title
                      , Dt = At.location
                      , Bt = at(At, nt);
                    Mt._gtag("event", "page_view", gt(gt(gt(gt({}, $t && {
                        page_path: $t
                    }), Pt && {
                        page_title: Pt
                    }), Dt && {
                        page_location: Dt
                    }), Bt))
                } else
                    $t ? Mt._gtag("event", "page_view", {
                        page_path: $t
                    }) : Mt._gtag("event", "page_view")
            }),
            Ct(this, "_gaCommandSendPageviewParameters", function() {
                for (var $t = arguments.length, kt = new Array($t), At = 0; At < $t; At++)
                    kt[At] = arguments[At];
                if (typeof kt[0] == "string")
                    Mt._gaCommandSendPageview.apply(Mt, dt(kt.slice(1)));
                else {
                    var Pt = kt[0]
                      , Dt = Pt.page;
                    Pt.hitType;
                    var Bt = at(Pt, it);
                    Mt._gaCommandSendPageview(Dt, Bt)
                }
            }),
            Ct(this, "_gaCommandSend", function() {
                for (var $t = arguments.length, kt = new Array($t), At = 0; At < $t; At++)
                    kt[At] = arguments[At];
                var Pt = typeof kt[0] == "string" ? kt[0] : kt[0].hitType;
                switch (Pt) {
                case "event":
                    Mt._gaCommandSendEventParameters.apply(Mt, kt);
                    break;
                case "pageview":
                    Mt._gaCommandSendPageviewParameters.apply(Mt, kt);
                    break;
                case "timing":
                    Mt._gaCommandSendTiming.apply(Mt, dt(kt.slice(1)));
                    break;
                case "screenview":
                case "transaction":
                case "item":
                case "social":
                case "exception":
                    console.warn("Unsupported send command: ".concat(Pt));
                    break;
                default:
                    console.warn("Send command doesn't exist: ".concat(Pt))
                }
            }),
            Ct(this, "_gaCommandSet", function() {
                for (var $t = arguments.length, kt = new Array($t), At = 0; At < $t; At++)
                    kt[At] = arguments[At];
                typeof kt[0] == "string" && (kt[0] = Ct({}, kt[0], kt[1])),
                Mt._gtag("set", Mt._toGtagOptions(kt[0]))
            }),
            Ct(this, "_gaCommand", function($t) {
                for (var kt = arguments.length, At = new Array(kt > 1 ? kt - 1 : 0), Pt = 1; Pt < kt; Pt++)
                    At[Pt - 1] = arguments[Pt];
                switch ($t) {
                case "send":
                    Mt._gaCommandSend.apply(Mt, At);
                    break;
                case "set":
                    Mt._gaCommandSet.apply(Mt, At);
                    break;
                default:
                    console.warn("Command doesn't exist: ".concat($t))
                }
            }),
            Ct(this, "ga", function() {
                for (var $t = arguments.length, kt = new Array($t), At = 0; At < $t; At++)
                    kt[At] = arguments[At];
                if (typeof kt[0] == "string")
                    Mt._gaCommand.apply(Mt, kt);
                else {
                    var Pt = kt[0];
                    Mt._gtag("get", Mt._currentMeasurementId, "client_id", function(Dt) {
                        Mt._isQueuing = !1;
                        var Bt = Mt._queueGtag;
                        for (Pt({
                            get: function(rr) {
                                return rr === "clientId" ? Dt : rr === "trackingId" ? Mt._currentMeasurementId : rr === "apiVersion" ? "1" : void 0
                            }
                        }); Bt.length; ) {
                            var zt = Bt.shift();
                            Mt._gtag.apply(Mt, dt(zt))
                        }
                    }),
                    Mt._isQueuing = !0
                }
                return Mt.ga
            }),
            Ct(this, "event", function($t, kt) {
                if (typeof $t == "string")
                    Mt._gtag("event", $t, Mt._toGtagOptions(kt));
                else {
                    var At = $t.action
                      , Pt = $t.category
                      , Dt = $t.label
                      , Bt = $t.value
                      , zt = $t.nonInteraction
                      , Yt = $t.transport;
                    if (!Pt || !At) {
                        console.warn("args.category AND args.action are required in event()");
                        return
                    }
                    var rr = {
                        hitType: "event",
                        eventCategory: (0,
                        tt.default)(Pt),
                        eventAction: (0,
                        tt.default)(At)
                    };
                    Dt && (rr.eventLabel = (0,
                    tt.default)(Dt)),
                    typeof Bt < "u" && (typeof Bt != "number" ? console.warn("Expected `args.value` arg to be a Number.") : rr.eventValue = Bt),
                    typeof zt < "u" && (typeof zt != "boolean" ? console.warn("`args.nonInteraction` must be a boolean.") : rr.nonInteraction = zt),
                    typeof Yt < "u" && (typeof Yt != "string" ? console.warn("`args.transport` must be a string.") : (["beacon", "xhr", "image"].indexOf(Yt) === -1 && console.warn("`args.transport` must be either one of these values: `beacon`, `xhr` or `image`"),
                    rr.transport = Yt)),
                    Mt._gaCommand("send", rr)
                }
            }),
            Ct(this, "send", function($t) {
                Mt._gaCommand("send", $t)
            }),
            this.reset()
        }
        return xt(Lt, [{
            key: "gtag",
            value: function() {
                this._gtag.apply(this, arguments)
            }
        }]),
        Lt
    }();
    _e.GA4 = Nt;
    var Ft = new Nt;
    _e.default = Ft
}
)(ga4);
(function(_e) {
    function et(at) {
        "@babel/helpers - typeof";
        return et = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ot) {
            return typeof ot
        }
        : function(ot) {
            return ot && typeof Symbol == "function" && ot.constructor === Symbol && ot !== Symbol.prototype ? "symbol" : typeof ot
        }
        ,
        et(at)
    }
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.default = _e.ReactGAImplementation = void 0;
    var tt = nt(ga4);
    function rt(at) {
        if (typeof WeakMap != "function")
            return null;
        var ot = new WeakMap
          , lt = new WeakMap;
        return (rt = function(ct) {
            return ct ? lt : ot
        }
        )(at)
    }
    function nt(at, ot) {
        if (!ot && at && at.__esModule)
            return at;
        if (at === null || et(at) !== "object" && typeof at != "function")
            return {
                default: at
            };
        var lt = rt(ot);
        if (lt && lt.has(at))
            return lt.get(at);
        var dt = {}
          , ct = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var ut in at)
            if (ut !== "default" && Object.prototype.hasOwnProperty.call(at, ut)) {
                var ft = ct ? Object.getOwnPropertyDescriptor(at, ut) : null;
                ft && (ft.get || ft.set) ? Object.defineProperty(dt, ut, ft) : dt[ut] = at[ut]
            }
        return dt.default = at,
        lt && lt.set(at, dt),
        dt
    }
    var it = tt.GA4;
    _e.ReactGAImplementation = it;
    var st = tt.default;
    _e.default = st
}
)(dist);
const ReactGA = getDefaultExportFromCjs(dist);
function toDate(_e) {
    const et = Object.prototype.toString.call(_e);
    return _e instanceof Date || typeof _e == "object" && et === "[object Date]" ? new _e.constructor(+_e) : typeof _e == "number" || et === "[object Number]" || typeof _e == "string" || et === "[object String]" ? new Date(_e) : new Date(NaN)
}
function constructFrom(_e, et) {
    return _e instanceof Date ? new _e.constructor(et) : new Date(et)
}
function addDays(_e, et) {
    const tt = toDate(_e);
    return isNaN(et) ? constructFrom(_e, NaN) : (et && tt.setDate(tt.getDate() + et),
    tt)
}
const millisecondsInWeek = 6048e5
  , millisecondsInDay = 864e5;
let defaultOptions = {};
function getDefaultOptions() {
    return defaultOptions
}
function startOfWeek(_e, et) {
    var at, ot, lt, dt;
    const tt = getDefaultOptions()
      , rt = (et == null ? void 0 : et.weekStartsOn) ?? ((ot = (at = et == null ? void 0 : et.locale) == null ? void 0 : at.options) == null ? void 0 : ot.weekStartsOn) ?? tt.weekStartsOn ?? ((dt = (lt = tt.locale) == null ? void 0 : lt.options) == null ? void 0 : dt.weekStartsOn) ?? 0
      , nt = toDate(_e)
      , it = nt.getDay()
      , st = (it < rt ? 7 : 0) + it - rt;
    return nt.setDate(nt.getDate() - st),
    nt.setHours(0, 0, 0, 0),
    nt
}
function startOfISOWeek(_e) {
    return startOfWeek(_e, {
        weekStartsOn: 1
    })
}
function getISOWeekYear(_e) {
    const et = toDate(_e)
      , tt = et.getFullYear()
      , rt = constructFrom(_e, 0);
    rt.setFullYear(tt + 1, 0, 4),
    rt.setHours(0, 0, 0, 0);
    const nt = startOfISOWeek(rt)
      , it = constructFrom(_e, 0);
    it.setFullYear(tt, 0, 4),
    it.setHours(0, 0, 0, 0);
    const st = startOfISOWeek(it);
    return et.getTime() >= nt.getTime() ? tt + 1 : et.getTime() >= st.getTime() ? tt : tt - 1
}
function startOfDay(_e) {
    const et = toDate(_e);
    return et.setHours(0, 0, 0, 0),
    et
}
function getTimezoneOffsetInMilliseconds(_e) {
    const et = toDate(_e)
      , tt = new Date(Date.UTC(et.getFullYear(), et.getMonth(), et.getDate(), et.getHours(), et.getMinutes(), et.getSeconds(), et.getMilliseconds()));
    return tt.setUTCFullYear(et.getFullYear()),
    +_e - +tt
}
function differenceInCalendarDays(_e, et) {
    const tt = startOfDay(_e)
      , rt = startOfDay(et)
      , nt = +tt - getTimezoneOffsetInMilliseconds(tt)
      , it = +rt - getTimezoneOffsetInMilliseconds(rt);
    return Math.round((nt - it) / millisecondsInDay)
}
function startOfISOWeekYear(_e) {
    const et = getISOWeekYear(_e)
      , tt = constructFrom(_e, 0);
    return tt.setFullYear(et, 0, 4),
    tt.setHours(0, 0, 0, 0),
    startOfISOWeek(tt)
}
function isDate(_e) {
    return _e instanceof Date || typeof _e == "object" && Object.prototype.toString.call(_e) === "[object Date]"
}
function isValid(_e) {
    if (!isDate(_e) && typeof _e != "number")
        return !1;
    const et = toDate(_e);
    return !isNaN(Number(et))
}
function differenceInMilliseconds(_e, et) {
    return +toDate(_e) - +toDate(et)
}
function startOfYear(_e) {
    const et = toDate(_e)
      , tt = constructFrom(_e, 0);
    return tt.setFullYear(et.getFullYear(), 0, 1),
    tt.setHours(0, 0, 0, 0),
    tt
}
const formatDistanceLocale = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , formatDistance = (_e,et,tt)=>{
    let rt;
    const nt = formatDistanceLocale[_e];
    return typeof nt == "string" ? rt = nt : et === 1 ? rt = nt.one : rt = nt.other.replace("{{count}}", et.toString()),
    tt != null && tt.addSuffix ? tt.comparison && tt.comparison > 0 ? "in " + rt : rt + " ago" : rt
}
;
function buildFormatLongFn(_e) {
    return (et={})=>{
        const tt = et.width ? String(et.width) : _e.defaultWidth;
        return _e.formats[tt] || _e.formats[_e.defaultWidth]
    }
}
const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , formatLong = {
    date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
    })
}
  , formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , formatRelative = (_e,et,tt,rt)=>formatRelativeLocale[_e];
function buildLocalizeFn(_e) {
    return (et,tt)=>{
        const rt = tt != null && tt.context ? String(tt.context) : "standalone";
        let nt;
        if (rt === "formatting" && _e.formattingValues) {
            const st = _e.defaultFormattingWidth || _e.defaultWidth
              , at = tt != null && tt.width ? String(tt.width) : st;
            nt = _e.formattingValues[at] || _e.formattingValues[st]
        } else {
            const st = _e.defaultWidth
              , at = tt != null && tt.width ? String(tt.width) : _e.defaultWidth;
            nt = _e.values[at] || _e.values[st]
        }
        const it = _e.argumentCallback ? _e.argumentCallback(et) : et;
        return nt[it]
    }
}
const eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , dayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , formattingDayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , ordinalNumber = (_e,et)=>{
    const tt = Number(_e)
      , rt = tt % 100;
    if (rt > 20 || rt < 10)
        switch (rt % 10) {
        case 1:
            return tt + "st";
        case 2:
            return tt + "nd";
        case 3:
            return tt + "rd"
        }
    return tt + "th"
}
  , localize = {
    ordinalNumber,
    era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: _e=>_e - 1
    }),
    month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
    })
};
function buildMatchFn(_e) {
    return (et,tt={})=>{
        const rt = tt.width
          , nt = rt && _e.matchPatterns[rt] || _e.matchPatterns[_e.defaultMatchWidth]
          , it = et.match(nt);
        if (!it)
            return null;
        const st = it[0]
          , at = rt && _e.parsePatterns[rt] || _e.parsePatterns[_e.defaultParseWidth]
          , ot = Array.isArray(at) ? findIndex(at, ct=>ct.test(st)) : findKey(at, ct=>ct.test(st));
        let lt;
        lt = _e.valueCallback ? _e.valueCallback(ot) : ot,
        lt = tt.valueCallback ? tt.valueCallback(lt) : lt;
        const dt = et.slice(st.length);
        return {
            value: lt,
            rest: dt
        }
    }
}
function findKey(_e, et) {
    for (const tt in _e)
        if (Object.prototype.hasOwnProperty.call(_e, tt) && et(_e[tt]))
            return tt
}
function findIndex(_e, et) {
    for (let tt = 0; tt < _e.length; tt++)
        if (et(_e[tt]))
            return tt
}
function buildMatchPatternFn(_e) {
    return (et,tt={})=>{
        const rt = et.match(_e.matchPattern);
        if (!rt)
            return null;
        const nt = rt[0]
          , it = et.match(_e.parsePattern);
        if (!it)
            return null;
        let st = _e.valueCallback ? _e.valueCallback(it[0]) : it[0];
        st = tt.valueCallback ? tt.valueCallback(st) : st;
        const at = et.slice(nt.length);
        return {
            value: st,
            rest: at
        }
    }
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i
  , parseOrdinalNumberPattern = /\d+/i
  , matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
}
  , matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , parseDayPeriodPatterns = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , match = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: _e=>parseInt(_e, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: _e=>_e + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
    })
}
  , enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function getDayOfYear(_e) {
    const et = toDate(_e);
    return differenceInCalendarDays(et, startOfYear(et)) + 1
}
function getISOWeek(_e) {
    const et = toDate(_e)
      , tt = +startOfISOWeek(et) - +startOfISOWeekYear(et);
    return Math.round(tt / millisecondsInWeek) + 1
}
function getWeekYear(_e, et) {
    var dt, ct, ut, ft;
    const tt = toDate(_e)
      , rt = tt.getFullYear()
      , nt = getDefaultOptions()
      , it = (et == null ? void 0 : et.firstWeekContainsDate) ?? ((ct = (dt = et == null ? void 0 : et.locale) == null ? void 0 : dt.options) == null ? void 0 : ct.firstWeekContainsDate) ?? nt.firstWeekContainsDate ?? ((ft = (ut = nt.locale) == null ? void 0 : ut.options) == null ? void 0 : ft.firstWeekContainsDate) ?? 1
      , st = constructFrom(_e, 0);
    st.setFullYear(rt + 1, 0, it),
    st.setHours(0, 0, 0, 0);
    const at = startOfWeek(st, et)
      , ot = constructFrom(_e, 0);
    ot.setFullYear(rt, 0, it),
    ot.setHours(0, 0, 0, 0);
    const lt = startOfWeek(ot, et);
    return tt.getTime() >= at.getTime() ? rt + 1 : tt.getTime() >= lt.getTime() ? rt : rt - 1
}
function startOfWeekYear(_e, et) {
    var at, ot, lt, dt;
    const tt = getDefaultOptions()
      , rt = (et == null ? void 0 : et.firstWeekContainsDate) ?? ((ot = (at = et == null ? void 0 : et.locale) == null ? void 0 : at.options) == null ? void 0 : ot.firstWeekContainsDate) ?? tt.firstWeekContainsDate ?? ((dt = (lt = tt.locale) == null ? void 0 : lt.options) == null ? void 0 : dt.firstWeekContainsDate) ?? 1
      , nt = getWeekYear(_e, et)
      , it = constructFrom(_e, 0);
    return it.setFullYear(nt, 0, rt),
    it.setHours(0, 0, 0, 0),
    startOfWeek(it, et)
}
function getWeek(_e, et) {
    const tt = toDate(_e)
      , rt = +startOfWeek(tt, et) - +startOfWeekYear(tt, et);
    return Math.round(rt / millisecondsInWeek) + 1
}
function addLeadingZeros(_e, et) {
    const tt = _e < 0 ? "-" : ""
      , rt = Math.abs(_e).toString().padStart(et, "0");
    return tt + rt
}
const lightFormatters = {
    y(_e, et) {
        const tt = _e.getFullYear()
          , rt = tt > 0 ? tt : 1 - tt;
        return addLeadingZeros(et === "yy" ? rt % 100 : rt, et.length)
    },
    M(_e, et) {
        const tt = _e.getMonth();
        return et === "M" ? String(tt + 1) : addLeadingZeros(tt + 1, 2)
    },
    d(_e, et) {
        return addLeadingZeros(_e.getDate(), et.length)
    },
    a(_e, et) {
        const tt = _e.getHours() / 12 >= 1 ? "pm" : "am";
        switch (et) {
        case "a":
        case "aa":
            return tt.toUpperCase();
        case "aaa":
            return tt;
        case "aaaaa":
            return tt[0];
        case "aaaa":
        default:
            return tt === "am" ? "a.m." : "p.m."
        }
    },
    h(_e, et) {
        return addLeadingZeros(_e.getHours() % 12 || 12, et.length)
    },
    H(_e, et) {
        return addLeadingZeros(_e.getHours(), et.length)
    },
    m(_e, et) {
        return addLeadingZeros(_e.getMinutes(), et.length)
    },
    s(_e, et) {
        return addLeadingZeros(_e.getSeconds(), et.length)
    },
    S(_e, et) {
        const tt = et.length
          , rt = _e.getMilliseconds()
          , nt = Math.trunc(rt * Math.pow(10, tt - 3));
        return addLeadingZeros(nt, et.length)
    }
}
  , dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , formatters = {
    G: function(_e, et, tt) {
        const rt = _e.getFullYear() > 0 ? 1 : 0;
        switch (et) {
        case "G":
        case "GG":
        case "GGG":
            return tt.era(rt, {
                width: "abbreviated"
            });
        case "GGGGG":
            return tt.era(rt, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return tt.era(rt, {
                width: "wide"
            })
        }
    },
    y: function(_e, et, tt) {
        if (et === "yo") {
            const rt = _e.getFullYear()
              , nt = rt > 0 ? rt : 1 - rt;
            return tt.ordinalNumber(nt, {
                unit: "year"
            })
        }
        return lightFormatters.y(_e, et)
    },
    Y: function(_e, et, tt, rt) {
        const nt = getWeekYear(_e, rt)
          , it = nt > 0 ? nt : 1 - nt;
        if (et === "YY") {
            const st = it % 100;
            return addLeadingZeros(st, 2)
        }
        return et === "Yo" ? tt.ordinalNumber(it, {
            unit: "year"
        }) : addLeadingZeros(it, et.length)
    },
    R: function(_e, et) {
        const tt = getISOWeekYear(_e);
        return addLeadingZeros(tt, et.length)
    },
    u: function(_e, et) {
        const tt = _e.getFullYear();
        return addLeadingZeros(tt, et.length)
    },
    Q: function(_e, et, tt) {
        const rt = Math.ceil((_e.getMonth() + 1) / 3);
        switch (et) {
        case "Q":
            return String(rt);
        case "QQ":
            return addLeadingZeros(rt, 2);
        case "Qo":
            return tt.ordinalNumber(rt, {
                unit: "quarter"
            });
        case "QQQ":
            return tt.quarter(rt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return tt.quarter(rt, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return tt.quarter(rt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(_e, et, tt) {
        const rt = Math.ceil((_e.getMonth() + 1) / 3);
        switch (et) {
        case "q":
            return String(rt);
        case "qq":
            return addLeadingZeros(rt, 2);
        case "qo":
            return tt.ordinalNumber(rt, {
                unit: "quarter"
            });
        case "qqq":
            return tt.quarter(rt, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return tt.quarter(rt, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return tt.quarter(rt, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(_e, et, tt) {
        const rt = _e.getMonth();
        switch (et) {
        case "M":
        case "MM":
            return lightFormatters.M(_e, et);
        case "Mo":
            return tt.ordinalNumber(rt + 1, {
                unit: "month"
            });
        case "MMM":
            return tt.month(rt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return tt.month(rt, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return tt.month(rt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(_e, et, tt) {
        const rt = _e.getMonth();
        switch (et) {
        case "L":
            return String(rt + 1);
        case "LL":
            return addLeadingZeros(rt + 1, 2);
        case "Lo":
            return tt.ordinalNumber(rt + 1, {
                unit: "month"
            });
        case "LLL":
            return tt.month(rt, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return tt.month(rt, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return tt.month(rt, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(_e, et, tt, rt) {
        const nt = getWeek(_e, rt);
        return et === "wo" ? tt.ordinalNumber(nt, {
            unit: "week"
        }) : addLeadingZeros(nt, et.length)
    },
    I: function(_e, et, tt) {
        const rt = getISOWeek(_e);
        return et === "Io" ? tt.ordinalNumber(rt, {
            unit: "week"
        }) : addLeadingZeros(rt, et.length)
    },
    d: function(_e, et, tt) {
        return et === "do" ? tt.ordinalNumber(_e.getDate(), {
            unit: "date"
        }) : lightFormatters.d(_e, et)
    },
    D: function(_e, et, tt) {
        const rt = getDayOfYear(_e);
        return et === "Do" ? tt.ordinalNumber(rt, {
            unit: "dayOfYear"
        }) : addLeadingZeros(rt, et.length)
    },
    E: function(_e, et, tt) {
        const rt = _e.getDay();
        switch (et) {
        case "E":
        case "EE":
        case "EEE":
            return tt.day(rt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return tt.day(rt, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return tt.day(rt, {
                width: "short",
                context: "formatting"
            });
        case "EEEE":
        default:
            return tt.day(rt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(_e, et, tt, rt) {
        const nt = _e.getDay()
          , it = (nt - rt.weekStartsOn + 8) % 7 || 7;
        switch (et) {
        case "e":
            return String(it);
        case "ee":
            return addLeadingZeros(it, 2);
        case "eo":
            return tt.ordinalNumber(it, {
                unit: "day"
            });
        case "eee":
            return tt.day(nt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return tt.day(nt, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return tt.day(nt, {
                width: "short",
                context: "formatting"
            });
        case "eeee":
        default:
            return tt.day(nt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(_e, et, tt, rt) {
        const nt = _e.getDay()
          , it = (nt - rt.weekStartsOn + 8) % 7 || 7;
        switch (et) {
        case "c":
            return String(it);
        case "cc":
            return addLeadingZeros(it, et.length);
        case "co":
            return tt.ordinalNumber(it, {
                unit: "day"
            });
        case "ccc":
            return tt.day(nt, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return tt.day(nt, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return tt.day(nt, {
                width: "short",
                context: "standalone"
            });
        case "cccc":
        default:
            return tt.day(nt, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(_e, et, tt) {
        const rt = _e.getDay()
          , nt = rt === 0 ? 7 : rt;
        switch (et) {
        case "i":
            return String(nt);
        case "ii":
            return addLeadingZeros(nt, et.length);
        case "io":
            return tt.ordinalNumber(nt, {
                unit: "day"
            });
        case "iii":
            return tt.day(rt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return tt.day(rt, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return tt.day(rt, {
                width: "short",
                context: "formatting"
            });
        case "iiii":
        default:
            return tt.day(rt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(_e, et, tt) {
        const nt = _e.getHours() / 12 >= 1 ? "pm" : "am";
        switch (et) {
        case "a":
        case "aa":
            return tt.dayPeriod(nt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return tt.dayPeriod(nt, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return tt.dayPeriod(nt, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return tt.dayPeriod(nt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(_e, et, tt) {
        const rt = _e.getHours();
        let nt;
        switch (rt === 12 ? nt = dayPeriodEnum.noon : rt === 0 ? nt = dayPeriodEnum.midnight : nt = rt / 12 >= 1 ? "pm" : "am",
        et) {
        case "b":
        case "bb":
            return tt.dayPeriod(nt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return tt.dayPeriod(nt, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return tt.dayPeriod(nt, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return tt.dayPeriod(nt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(_e, et, tt) {
        const rt = _e.getHours();
        let nt;
        switch (rt >= 17 ? nt = dayPeriodEnum.evening : rt >= 12 ? nt = dayPeriodEnum.afternoon : rt >= 4 ? nt = dayPeriodEnum.morning : nt = dayPeriodEnum.night,
        et) {
        case "B":
        case "BB":
        case "BBB":
            return tt.dayPeriod(nt, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return tt.dayPeriod(nt, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return tt.dayPeriod(nt, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(_e, et, tt) {
        if (et === "ho") {
            let rt = _e.getHours() % 12;
            return rt === 0 && (rt = 12),
            tt.ordinalNumber(rt, {
                unit: "hour"
            })
        }
        return lightFormatters.h(_e, et)
    },
    H: function(_e, et, tt) {
        return et === "Ho" ? tt.ordinalNumber(_e.getHours(), {
            unit: "hour"
        }) : lightFormatters.H(_e, et)
    },
    K: function(_e, et, tt) {
        const rt = _e.getHours() % 12;
        return et === "Ko" ? tt.ordinalNumber(rt, {
            unit: "hour"
        }) : addLeadingZeros(rt, et.length)
    },
    k: function(_e, et, tt) {
        let rt = _e.getHours();
        return rt === 0 && (rt = 24),
        et === "ko" ? tt.ordinalNumber(rt, {
            unit: "hour"
        }) : addLeadingZeros(rt, et.length)
    },
    m: function(_e, et, tt) {
        return et === "mo" ? tt.ordinalNumber(_e.getMinutes(), {
            unit: "minute"
        }) : lightFormatters.m(_e, et)
    },
    s: function(_e, et, tt) {
        return et === "so" ? tt.ordinalNumber(_e.getSeconds(), {
            unit: "second"
        }) : lightFormatters.s(_e, et)
    },
    S: function(_e, et) {
        return lightFormatters.S(_e, et)
    },
    X: function(_e, et, tt) {
        const rt = _e.getTimezoneOffset();
        if (rt === 0)
            return "Z";
        switch (et) {
        case "X":
            return formatTimezoneWithOptionalMinutes(rt);
        case "XXXX":
        case "XX":
            return formatTimezone(rt);
        case "XXXXX":
        case "XXX":
        default:
            return formatTimezone(rt, ":")
        }
    },
    x: function(_e, et, tt) {
        const rt = _e.getTimezoneOffset();
        switch (et) {
        case "x":
            return formatTimezoneWithOptionalMinutes(rt);
        case "xxxx":
        case "xx":
            return formatTimezone(rt);
        case "xxxxx":
        case "xxx":
        default:
            return formatTimezone(rt, ":")
        }
    },
    O: function(_e, et, tt) {
        const rt = _e.getTimezoneOffset();
        switch (et) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + formatTimezoneShort(rt, ":");
        case "OOOO":
        default:
            return "GMT" + formatTimezone(rt, ":")
        }
    },
    z: function(_e, et, tt) {
        const rt = _e.getTimezoneOffset();
        switch (et) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + formatTimezoneShort(rt, ":");
        case "zzzz":
        default:
            return "GMT" + formatTimezone(rt, ":")
        }
    },
    t: function(_e, et, tt) {
        const rt = Math.trunc(_e.getTime() / 1e3);
        return addLeadingZeros(rt, et.length)
    },
    T: function(_e, et, tt) {
        const rt = _e.getTime();
        return addLeadingZeros(rt, et.length)
    }
};
function formatTimezoneShort(_e, et="") {
    const tt = _e > 0 ? "-" : "+"
      , rt = Math.abs(_e)
      , nt = Math.trunc(rt / 60)
      , it = rt % 60;
    return it === 0 ? tt + String(nt) : tt + String(nt) + et + addLeadingZeros(it, 2)
}
function formatTimezoneWithOptionalMinutes(_e, et) {
    return _e % 60 === 0 ? (_e > 0 ? "-" : "+") + addLeadingZeros(Math.abs(_e) / 60, 2) : formatTimezone(_e, et)
}
function formatTimezone(_e, et="") {
    const tt = _e > 0 ? "-" : "+"
      , rt = Math.abs(_e)
      , nt = addLeadingZeros(Math.trunc(rt / 60), 2)
      , it = addLeadingZeros(rt % 60, 2);
    return tt + nt + et + it
}
const dateLongFormatter = (_e,et)=>{
    switch (_e) {
    case "P":
        return et.date({
            width: "short"
        });
    case "PP":
        return et.date({
            width: "medium"
        });
    case "PPP":
        return et.date({
            width: "long"
        });
    case "PPPP":
    default:
        return et.date({
            width: "full"
        })
    }
}
  , timeLongFormatter = (_e,et)=>{
    switch (_e) {
    case "p":
        return et.time({
            width: "short"
        });
    case "pp":
        return et.time({
            width: "medium"
        });
    case "ppp":
        return et.time({
            width: "long"
        });
    case "pppp":
    default:
        return et.time({
            width: "full"
        })
    }
}
  , dateTimeLongFormatter = (_e,et)=>{
    const tt = _e.match(/(P+)(p+)?/) || []
      , rt = tt[1]
      , nt = tt[2];
    if (!nt)
        return dateLongFormatter(_e, et);
    let it;
    switch (rt) {
    case "P":
        it = et.dateTime({
            width: "short"
        });
        break;
    case "PP":
        it = et.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        it = et.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        it = et.dateTime({
            width: "full"
        });
        break
    }
    return it.replace("{{date}}", dateLongFormatter(rt, et)).replace("{{time}}", timeLongFormatter(nt, et))
}
  , longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
}
  , dayOfYearTokenRE = /^D+$/
  , weekYearTokenRE = /^Y+$/
  , throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(_e) {
    return dayOfYearTokenRE.test(_e)
}
function isProtectedWeekYearToken(_e) {
    return weekYearTokenRE.test(_e)
}
function warnOrThrowProtectedError(_e, et, tt) {
    const rt = message(_e, et, tt);
    if (console.warn(rt),
    throwTokens.includes(_e))
        throw new RangeError(rt)
}
function message(_e, et, tt) {
    const rt = _e[0] === "Y" ? "years" : "days of the month";
    return `Use \`${_e.toLowerCase()}\` instead of \`${_e}\` (in \`${et}\`) for formatting ${rt} to the input \`${tt}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , escapedStringRegExp = /^'([^]*?)'?$/
  , doubleQuoteRegExp = /''/g
  , unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(_e, et, tt) {
    var dt, ct, ut, ft, ht, gt, bt, pt;
    const rt = getDefaultOptions()
      , nt = (tt == null ? void 0 : tt.locale) ?? rt.locale ?? enUS
      , it = (tt == null ? void 0 : tt.firstWeekContainsDate) ?? ((ct = (dt = tt == null ? void 0 : tt.locale) == null ? void 0 : dt.options) == null ? void 0 : ct.firstWeekContainsDate) ?? rt.firstWeekContainsDate ?? ((ft = (ut = rt.locale) == null ? void 0 : ut.options) == null ? void 0 : ft.firstWeekContainsDate) ?? 1
      , st = (tt == null ? void 0 : tt.weekStartsOn) ?? ((gt = (ht = tt == null ? void 0 : tt.locale) == null ? void 0 : ht.options) == null ? void 0 : gt.weekStartsOn) ?? rt.weekStartsOn ?? ((pt = (bt = rt.locale) == null ? void 0 : bt.options) == null ? void 0 : pt.weekStartsOn) ?? 0
      , at = toDate(_e);
    if (!isValid(at))
        throw new RangeError("Invalid time value");
    let ot = et.match(longFormattingTokensRegExp).map(mt=>{
        const yt = mt[0];
        if (yt === "p" || yt === "P") {
            const vt = longFormatters[yt];
            return vt(mt, nt.formatLong)
        }
        return mt
    }
    ).join("").match(formattingTokensRegExp).map(mt=>{
        if (mt === "''")
            return {
                isToken: !1,
                value: "'"
            };
        const yt = mt[0];
        if (yt === "'")
            return {
                isToken: !1,
                value: cleanEscapedString(mt)
            };
        if (formatters[yt])
            return {
                isToken: !0,
                value: mt
            };
        if (yt.match(unescapedLatinCharacterRegExp))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + yt + "`");
        return {
            isToken: !1,
            value: mt
        }
    }
    );
    nt.localize.preprocessor && (ot = nt.localize.preprocessor(at, ot));
    const lt = {
        firstWeekContainsDate: it,
        weekStartsOn: st,
        locale: nt
    };
    return ot.map(mt=>{
        if (!mt.isToken)
            return mt.value;
        const yt = mt.value;
        (!(tt != null && tt.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(yt) || !(tt != null && tt.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(yt)) && warnOrThrowProtectedError(yt, et, String(_e));
        const vt = formatters[yt[0]];
        return vt(at, yt, nt.localize, lt)
    }
    ).join("")
}
function cleanEscapedString(_e) {
    const et = _e.match(escapedStringRegExp);
    return et ? et[1].replace(doubleQuoteRegExp, "'") : _e
}
const endTimeCal = (_e,et)=>{
    var ct;
    if (!_e || !et)
        return {
            remainingHours: 0,
            remainingMinutes: 0
        };
    const tt = (ct = _e[1]) == null ? void 0 : ct.toString()
      , rt = tt.endsWith("n") ? tt.slice(0, -1) : tt
      , nt = parseInt(rt)
      , it = new Date(nt * 1e3)
      , st = new Date
      , at = addDays(it, et)
      , ot = differenceInMilliseconds(at, st)
      , lt = Math.floor(ot / (1e3 * 60 * 60))
      , dt = Math.floor(ot % (1e3 * 60 * 60) / (1e3 * 60));
    return lt && lt < 0 ? {
        remainingHours: 0,
        remainingMinutes: 0
    } : lt || dt ? {
        remainingHours: lt,
        remainingMinutes: dt
    } : {
        remainingHours: 0,
        remainingMinutes: 0
    }
}
  , startTimeCal = _e=>{
    var st;
    if (!_e)
        return {
            date: "",
            formattedDate: ""
        };
    const et = (st = _e[1]) == null ? void 0 : st.toString()
      , tt = et.endsWith("n") ? et.slice(0, -1) : et
      , rt = parseInt(tt)
      , nt = new Date(rt * 1e3)
      , it = format(nt, "dd-MM-yyyy HH:mm:ss");
    return nt && it ? {
        date: nt,
        formattedDate: it
    } : {
        date: "",
        formattedDate: ""
    }
}
  , claimRewardCal = (_e,et)=>{
    var tt;
    if (!_e || !et)
        return !1;
    try {
        const rt = (tt = _e[1]) == null ? void 0 : tt.toString()
          , nt = rt.endsWith("n") ? rt.slice(0, -1) : rt
          , it = parseInt(nt)
          , st = new Date(it * 1e3)
          , at = new Date
          , ot = addDays(st, et);
        return differenceInMilliseconds(ot, at) <= 0
    } catch {
        return !1
    }
}
  , stakeApiSlice = apiSlice.injectEndpoints({
    endpoints: _e=>({
        createStake: _e.mutation({
            query: et=>({
                url: "/transaction/stake-create",
                method: "POST",
                body: et
            })
        }),
        createErrorStake: _e.mutation({
            query: et=>({
                url: "/transaction/stake-error-create",
                method: "POST",
                body: et
            })
        })
    })
})
  , {useCreateStakeMutation, useCreateErrorStakeMutation} = stakeApiSlice
  , useDBStake = ()=>{
    const [_e] = useCreateStakeMutation()
      , [et] = useCreateErrorStakeMutation();
    return [async(nt,it,st,at,ot,lt,dt)=>{
        try {
            const ct = await _e({
                userAddress: nt ?? "couldn't got userAddress",
                message: st,
                success: at,
                amount: it,
                cbtcBalance: ot,
                userBalance: lt,
                duration: dt
            }).unwrap();
            console.log(ct, "response")
        } catch (ct) {
            console.log(ct, "error")
        }
        return ""
    }
    , async(nt,it,st,at,ot,lt,dt)=>{
        try {
            const ct = await et({
                userAddress: nt ?? "couldn't got userAddress",
                message: st,
                success: at,
                amount: it,
                cbtcBalance: ot,
                userBalance: lt,
                duration: dt
            }).unwrap();
            console.log(ct, "response")
        } catch (ct) {
            console.log(ct, "error")
        }
        return ""
    }
    ]
}
  , abi$3 = [{
    inputs: [{
        internalType: "address",
        name: "_stakingToken",
        type: "address"
    }],
    stateMutability: "nonpayable",
    type: "constructor"
}, {
    inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
    }],
    name: "OwnableInvalidOwner",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
    }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "OwnershipTransferred",
    type: "event"
}, {
    inputs: [],
    name: "pauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bool",
        name: "val",
        type: "bool"
    }],
    name: "setAutoUpdateReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[3]",
        name: "val",
        type: "uint256[3]"
    }],
    name: "setRewardPercentages",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[4]",
        name: "val",
        type: "uint256[4]"
    }],
    name: "setStakeRewardPerYear",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Staked",
    type: "event"
}, {
    inputs: [{
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transferRewardTokensToOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "unpauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "unstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "reward",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Unstaked",
    type: "event"
}, {
    inputs: [{
        internalType: "uint256[4][3]",
        name: "newRewardPools",
        type: "uint256[4][3]"
    }],
    name: "updateRewardPools",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "newYear",
        type: "uint256"
    }],
    name: "updateYearlyReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "autoUpdateReward",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "calReward",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "currentYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getCurrentPeriod",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getDurationNum",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }],
    name: "getRewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "getTotal",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUnlockTime",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUserStake",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "owner",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "periodTotalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPercentages",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPools",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    name: "rewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "stakeRewardPerYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingStartTimestamp",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingToken",
    outputs: [{
        internalType: "contract IERC20",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalRewardPaid",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }],
    name: "userStakes",
    outputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }, {
        internalType: "bool",
        name: "exists",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "yearInSeconds",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}]
  , CurrentStakes = ()=>{
    var Pt, Dt, Bt, zt;
    const {address: _e} = useAccount()
      , [et,tt] = reactExports.useState({
        remainingHours: 0,
        remainingMinutes: 0
    })
      , [rt,nt] = reactExports.useState({
        remainingHours: 0,
        remainingMinutes: 0
    })
      , [it,st] = reactExports.useState({
        remainingHours: 0,
        remainingMinutes: 0
    })
      , [at] = useDBStake()
      , {data: ot} = useBalance({
        address: _e,
        chainId: 1
    })
      , {data: lt, isError: dt, isLoading: ct} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$3,
        functionName: "getUserStake",
        args: [_e, 0]
    })
      , {data: ut, isError: ft, isLoading: ht} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$3,
        functionName: "getUserStake",
        args: [_e, 1]
    })
      , {data: gt, isError: bt, isLoading: pt} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$3,
        functionName: "getUserStake",
        args: [_e, 2]
    })
      , {data: mt, isError: yt, isLoading: vt} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$3,
        functionName: "calReward",
        args: [_e, 0]
    })
      , {data: wt, isError: _t, isLoading: Et} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$3,
        functionName: "calReward",
        args: [_e, 1]
    })
      , {data: xt, isError: Ct, isLoading: Tt} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$3,
        functionName: "calReward",
        args: [_e, 2]
    })
      , {data: It, isPending: Nt, error: Ft, writeContractAsync: Lt, reset: Mt} = useWriteContract()
      , {isLoading: $t, isSuccess: kt} = useWaitForTransactionReceipt({
        hash: It
    });
    reactExports.useEffect(()=>{
        Ft && (toastFun("error", (Ft == null ? void 0 : Ft.shortMessage) ?? "Error! Please try again!"),
        at(_e, "unStaking", (Ft == null ? void 0 : Ft.shortMessage) ?? Ft, !1, "unStaking", formatEther((ot == null ? void 0 : ot.value) ?? "0n"), "unStaking"),
        Mt())
    }
    , [Ft]),
    reactExports.useEffect(()=>{
        kt && at(_e, "unStaking", "UnStaked Successful", !0, "unStaking", formatEther((ot == null ? void 0 : ot.value) ?? "0n"), "unStaking")
    }
    , [kt]);
    const At = async Yt=>{
        let rr = null;
        if (Yt === 1) {
            if (rr = 0,
            !claimRewardCal(lt ?? 0, Yt)) {
                alert("Can't Unstake Now");
                return
            }
        } else if (Yt === 30) {
            if (rr = 1,
            !claimRewardCal(ut ?? 0, Yt)) {
                alert("Can't Unstake Now");
                return
            }
        } else if (Yt === 90 && (rr = 2,
        !claimRewardCal(gt ?? 0, Yt))) {
            alert("Can't Unstake Now");
            return
        }
        try {
            await Lt({
                address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
                abi: abi$3,
                functionName: "unstake",
                args: [rr]
            })
        } catch (ar) {
            console.log(ar, "error")
        }
    }
    ;
    return reactExports.useEffect(()=>{
        !ct && !dt && tt(endTimeCal(lt, 1)),
        !ht && !ft && nt(endTimeCal(ut, 30)),
        !pt && !bt && st(endTimeCal(gt, 90));
        const Yt = setInterval(()=>{
            !ct && !dt && tt(endTimeCal(lt, 1)),
            !ht && !ft && nt(endTimeCal(ut, 30)),
            !pt && !bt && st(endTimeCal(gt, 90))
        }
        , 1e3);
        return ()=>clearInterval(Yt)
    }
    , [lt, ut, gt]),
    jsxRuntimeExports.jsx("div", {
        className: "container-fluid",
        children: jsxRuntimeExports.jsx("div", {
            className: "row",
            children: jsxRuntimeExports.jsxs("div", {
                className: "col-11 mx-auto max-width py-5",
                children: [Nt && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Initiating"
                    }), jsxRuntimeExports.jsx(MoonLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                }), It && jsxRuntimeExports.jsxs("div", {
                    className: "referralWrapper my-4",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "referralHead ",
                        children: "Transaction Hash:"
                    }), jsxRuntimeExports.jsx("span", {
                        className: "referralText ",
                        children: It
                    }), jsxRuntimeExports.jsx(CopyToClipboard$1, {
                        text: It ?? "",
                        onCopy: ()=>{
                            toastFun("", "Copied!")
                        }
                        ,
                        children: jsxRuntimeExports.jsx("button", {
                            className: "referralBtn",
                            children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                        })
                    })]
                }), $t && jsxRuntimeExports.jsxs("div", {
                    className: "initiatingTextWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "",
                        children: "Confirming"
                    }), jsxRuntimeExports.jsx(BounceLoader, {
                        color: "#FBBD18",
                        size: 20
                    })]
                }), kt && jsxRuntimeExports.jsxs("div", {
                    className: "confirmedWrapper",
                    children: [jsxRuntimeExports.jsx("h6", {
                        className: "text-center",
                        children: "Confirmed"
                    }), jsxRuntimeExports.jsx(UseAnimations, {
                        animation: checkmark,
                        size: 46,
                        fillColor: "#FBBD18",
                        strokeColor: "#FBBD18",
                        loop: !1
                    })]
                }), jsxRuntimeExports.jsx("div", {
                    className: "currentStakesTableWrapper",
                    children: jsxRuntimeExports.jsxs("table", {
                        className: "currentStakesTable",
                        style: {
                            minWidth: "1270px"
                        },
                        children: [jsxRuntimeExports.jsx("thead", {
                            children: jsxRuntimeExports.jsxs("tr", {
                                children: [jsxRuntimeExports.jsx("th", {
                                    children: "Duration"
                                }), jsxRuntimeExports.jsx("th", {
                                    children: "Amount Staked"
                                }), jsxRuntimeExports.jsx("th", {
                                    children: "Start Time"
                                }), jsxRuntimeExports.jsx("th", {
                                    children: "Time Remaining"
                                }), jsxRuntimeExports.jsx("th", {
                                    children: "Reward"
                                }), jsxRuntimeExports.jsx("th", {
                                    children: "Claim Reward"
                                })]
                            })
                        }), jsxRuntimeExports.jsxs("tbody", {
                            children: [!ct && !dt ? jsxRuntimeExports.jsxs("tr", {
                                children: [jsxRuntimeExports.jsx("td", {
                                    children: "1 Day "
                                }), jsxRuntimeExports.jsx("td", {
                                    children: Number(formatEther((lt == null ? void 0 : lt[0]) ?? "0n")).toFixed(2)
                                }), jsxRuntimeExports.jsx("td", {
                                    children: ((Pt = startTimeCal(lt)) == null ? void 0 : Pt.formattedDate) ?? "0n"
                                }), jsxRuntimeExports.jsx("td", {
                                    children: `${(et == null ? void 0 : et.remainingHours) ?? "0n"} Hours and ${(et == null ? void 0 : et.remainingMinutes) ?? "0n"} Mints Left`
                                }), jsxRuntimeExports.jsx("td", {
                                    children: !vt && !yt ? Number(formatEther(mt ?? "0n")).toFixed(2) : 0
                                }), jsxRuntimeExports.jsx("td", {
                                    children: jsxRuntimeExports.jsx("div", {
                                        className: `claimRewardBtn ${claimRewardCal(lt ?? 0, 1),
                                        ""}`,
                                        onClick: ()=>{
                                            At(1)
                                        }
                                        ,
                                        children: "Claim Reward"
                                    })
                                })]
                            }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                children: jsxRuntimeExports.jsxs("tr", {
                                    children: [jsxRuntimeExports.jsx("td", {
                                        children: "1 Day"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: jsxRuntimeExports.jsx("div", {
                                            className: "claimRewardBtn disable",
                                            children: "Claim Reward"
                                        })
                                    })]
                                })
                            }), !ht && !ft ? jsxRuntimeExports.jsxs("tr", {
                                children: [jsxRuntimeExports.jsx("td", {
                                    children: "30 Days"
                                }), jsxRuntimeExports.jsx("td", {
                                    children: Number(formatEther(((Dt = ut ?? ["0n", "0n"]) == null ? void 0 : Dt[0]) ?? "0n")).toFixed(2)
                                }), jsxRuntimeExports.jsx("td", {
                                    children: ((Bt = startTimeCal(ut)) == null ? void 0 : Bt.formattedDate) ?? "0n"
                                }), jsxRuntimeExports.jsx("td", {
                                    children: `${(rt == null ? void 0 : rt.remainingHours) ?? "0n"} Hours and ${(rt == null ? void 0 : rt.remainingMinutes) ?? "0n"} Mints Left`
                                }), jsxRuntimeExports.jsx("td", {
                                    children: !Et && !_t ? Number(formatEther(wt ?? "0n")).toFixed(2) : 0
                                }), jsxRuntimeExports.jsx("td", {
                                    children: jsxRuntimeExports.jsx("div", {
                                        className: `claimRewardBtn ${claimRewardCal(ut ?? "0n", 30),
                                        ""}`,
                                        onClick: ()=>{
                                            At(30)
                                        }
                                        ,
                                        children: "Claim Reward"
                                    })
                                })]
                            }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                children: jsxRuntimeExports.jsxs("tr", {
                                    children: [jsxRuntimeExports.jsx("td", {
                                        children: "30 Days"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: jsxRuntimeExports.jsx("div", {
                                            className: "claimRewardBtn disable",
                                            children: "Claim Reward"
                                        })
                                    })]
                                })
                            }), !pt && !bt ? jsxRuntimeExports.jsxs("tr", {
                                children: [jsxRuntimeExports.jsx("td", {
                                    children: "90 Days"
                                }), jsxRuntimeExports.jsx("td", {
                                    children: Number(formatEther((gt == null ? void 0 : gt[0]) ?? "0n")).toFixed(2)
                                }), jsxRuntimeExports.jsx("td", {
                                    children: ((zt = startTimeCal(gt)) == null ? void 0 : zt.formattedDate) ?? "0n"
                                }), jsxRuntimeExports.jsx("td", {
                                    children: `${(it == null ? void 0 : it.remainingHours) ?? "0n"} Hours and ${(it == null ? void 0 : it.remainingMinutes) ?? "0n"} Mints Left`
                                }), jsxRuntimeExports.jsx("td", {
                                    children: !Tt && !Ct ? Number(formatEther(xt ?? "0n")).toFixed(2) : 0
                                }), jsxRuntimeExports.jsx("td", {
                                    children: jsxRuntimeExports.jsx("div", {
                                        className: `claimRewardBtn ${claimRewardCal(gt ?? "0n", 90),
                                        ""}`,
                                        onClick: ()=>{
                                            At(90)
                                        }
                                        ,
                                        children: "Claim Reward"
                                    })
                                })]
                            }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                children: jsxRuntimeExports.jsxs("tr", {
                                    children: [jsxRuntimeExports.jsx("td", {
                                        children: "90 Day"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: "0"
                                    }), jsxRuntimeExports.jsx("td", {
                                        children: jsxRuntimeExports.jsx("div", {
                                            className: "claimRewardBtn disable",
                                            children: "Claim Reward"
                                        })
                                    })]
                                })
                            })]
                        })]
                    })
                })]
            })
        })
    })
}
  , abi$2 = [{
    inputs: [{
        internalType: "address",
        name: "_stakingToken",
        type: "address"
    }],
    stateMutability: "nonpayable",
    type: "constructor"
}, {
    inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
    }],
    name: "OwnableInvalidOwner",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
    }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "OwnershipTransferred",
    type: "event"
}, {
    inputs: [],
    name: "pauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bool",
        name: "val",
        type: "bool"
    }],
    name: "setAutoUpdateReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[3]",
        name: "val",
        type: "uint256[3]"
    }],
    name: "setRewardPercentages",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[4]",
        name: "val",
        type: "uint256[4]"
    }],
    name: "setStakeRewardPerYear",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Staked",
    type: "event"
}, {
    inputs: [{
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transferRewardTokensToOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "unpauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "unstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "reward",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Unstaked",
    type: "event"
}, {
    inputs: [{
        internalType: "uint256[4][3]",
        name: "newRewardPools",
        type: "uint256[4][3]"
    }],
    name: "updateRewardPools",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "newYear",
        type: "uint256"
    }],
    name: "updateYearlyReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "autoUpdateReward",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "calReward",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "currentYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getCurrentPeriod",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getDurationNum",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }],
    name: "getRewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "getTotal",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUnlockTime",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUserStake",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "owner",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "periodTotalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPercentages",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPools",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    name: "rewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "stakeRewardPerYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingStartTimestamp",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingToken",
    outputs: [{
        internalType: "contract IERC20",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalRewardPaid",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }],
    name: "userStakes",
    outputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }, {
        internalType: "bool",
        name: "exists",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "yearInSeconds",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}]
  , Info = ()=>{
    const {data: _e, isError: et, isLoading: tt, isFetching: rt} = useReadContract({
        abi: abi$2,
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        functionName: "getTotal"
    });
    return jsxRuntimeExports.jsx("div", {
        className: "container-fluid",
        children: jsxRuntimeExports.jsx("div", {
            className: "row",
            children: jsxRuntimeExports.jsx("div", {
                className: "col-11 mx-auto max-width py-5",
                children: jsxRuntimeExports.jsxs("div", {
                    className: "row",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "col-md-4 offset-md-1 mb-4",
                        children: jsxRuntimeExports.jsxs("div", {
                            className: "infoBox",
                            children: [jsxRuntimeExports.jsx("h2", {
                                children: !et && !tt && !rt && Number(formatEther((_e == null ? void 0 : _e[0]) ?? "0n")).toFixed(2)
                            }), jsxRuntimeExports.jsx("h4", {
                                children: "CBTC reward paid"
                            })]
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-md-4 offset-md-2 mb-4",
                        children: jsxRuntimeExports.jsxs("div", {
                            className: "infoBox",
                            children: [jsxRuntimeExports.jsx("h2", {
                                children: !et && !tt && !rt && Number(formatEther((_e == null ? void 0 : _e[1]) ?? "0n")).toFixed(2)
                            }), jsxRuntimeExports.jsx("h4", {
                                children: "Total CBTC staked"
                            })]
                        })
                    })]
                })
            })
        })
    })
}
;
let totalStaked = 0;
const abi$1 = [{
    inputs: [{
        internalType: "address",
        name: "_stakingToken",
        type: "address"
    }],
    stateMutability: "nonpayable",
    type: "constructor"
}, {
    inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
    }],
    name: "OwnableInvalidOwner",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
    }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "OwnershipTransferred",
    type: "event"
}, {
    inputs: [],
    name: "pauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bool",
        name: "val",
        type: "bool"
    }],
    name: "setAutoUpdateReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[3]",
        name: "val",
        type: "uint256[3]"
    }],
    name: "setRewardPercentages",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[4]",
        name: "val",
        type: "uint256[4]"
    }],
    name: "setStakeRewardPerYear",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Staked",
    type: "event"
}, {
    inputs: [{
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transferRewardTokensToOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "unpauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "unstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "reward",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Unstaked",
    type: "event"
}, {
    inputs: [{
        internalType: "uint256[4][3]",
        name: "newRewardPools",
        type: "uint256[4][3]"
    }],
    name: "updateRewardPools",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "newYear",
        type: "uint256"
    }],
    name: "updateYearlyReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "autoUpdateReward",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "calReward",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "currentYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getCurrentPeriod",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getDurationNum",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }],
    name: "getRewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "getTotal",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUnlockTime",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUserStake",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "owner",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "periodTotalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPercentages",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPools",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    name: "rewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "stakeRewardPerYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingStartTimestamp",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingToken",
    outputs: [{
        internalType: "contract IERC20",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalRewardPaid",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }],
    name: "userStakes",
    outputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }, {
        internalType: "bool",
        name: "exists",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "yearInSeconds",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}]
  , approveAbi = [{
    inputs: [{
        internalType: "string",
        name: "name",
        type: "string"
    }, {
        internalType: "string",
        name: "symbol",
        type: "string"
    }, {
        internalType: "uint256",
        name: "totalSupply",
        type: "uint256"
    }, {
        internalType: "address[]",
        name: "wallets",
        type: "address[]"
    }],
    stateMutability: "nonpayable",
    type: "constructor"
}, {
    inputs: [{
        internalType: "address",
        name: "spender",
        type: "address"
    }, {
        internalType: "uint256",
        name: "allowance",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
    }],
    name: "ERC20InsufficientAllowance",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "sender",
        type: "address"
    }, {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
    }],
    name: "ERC20InsufficientBalance",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "approver",
        type: "address"
    }],
    name: "ERC20InvalidApprover",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "receiver",
        type: "address"
    }],
    name: "ERC20InvalidReceiver",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "sender",
        type: "address"
    }],
    name: "ERC20InvalidSender",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "spender",
        type: "address"
    }],
    name: "ERC20InvalidSpender",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
    }],
    name: "OwnableInvalidOwner",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
    }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
    }],
    name: "Approval",
    type: "event"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "OwnershipTransferred",
    type: "event"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
    }],
    name: "Transfer",
    type: "event"
}, {
    inputs: [{
        internalType: "address",
        name: "addr",
        type: "address"
    }],
    name: "addToWhitelist",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
    }, {
        internalType: "address",
        name: "spender",
        type: "address"
    }],
    name: "allowance",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "spender",
        type: "address"
    }, {
        internalType: "uint256",
        name: "value",
        type: "uint256"
    }],
    name: "approve",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
    }],
    name: "balanceOf",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "decimals",
    outputs: [{
        internalType: "uint8",
        name: "",
        type: "uint8"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "isPresaleActive",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "name",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "owner",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "addr",
        type: "address"
    }],
    name: "removeFromWhitelist",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bool",
        name: "active",
        type: "bool"
    }],
    name: "setIsPresaleActive",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "symbol",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalSupply",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "to",
        type: "address"
    }, {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transfer",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "from",
        type: "address"
    }, {
        internalType: "address",
        name: "to",
        type: "address"
    }, {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transferFrom",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    name: "whitelist",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}]
  , WalletConnect = ()=>{
    const {open: _e} = useWeb3Modal()
      , {address: et, isConnected: tt} = useAccount()
      , rt = reactExports.useRef(null)
      , nt = reactExports.useRef(null)
      , [it,st] = useDBStake()
      , {data: at, writeContract: ot, error: lt, isPending: dt, reset: ct} = useWriteContract()
      , {data: ut, writeContract: ft, error: ht, isPending: gt} = useWriteContract()
      , {data: bt, isLoading: pt, isError: mt} = useReadContract({
        abi: approveAbi,
        address: "0xcAE6EBAceF456e5A942afb40Fc99F2F38639eF01",
        functionName: "balanceOf",
        args: [et]
    })
      , {data: yt, isLoading: vt, isError: wt} = useReadContract({
        abi: abi$1,
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        functionName: "getRewardsEarned",
        args: [et]
    })
      , {data: _t, isLoading: Et, isError: xt} = useReadContract({
        abi: approveAbi,
        address: "0xcAE6EBAceF456e5A942afb40Fc99F2F38639eF01",
        functionName: "allowance",
        args: [et, "0xb9b213d92253a405977ffe38fe8e2bd9c14457a1"]
    })
      , {data: Ct, isError: Tt, isLoading: It} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$1,
        functionName: "getUserStake",
        args: [et, 0]
    })
      , {data: Nt, isError: Ft, isLoading: Lt} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$1,
        functionName: "getUserStake",
        args: [et, 1]
    })
      , {data: Mt, isError: $t, isLoading: kt} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi: abi$1,
        functionName: "getUserStake",
        args: [et, 2]
    })
      , {data: At} = useBalance({
        address: et,
        chainId: 1
    })
      , {isLoading: Pt, isSuccess: Dt} = useWaitForTransactionReceipt({
        hash: at
    })
      , {isLoading: Bt, isSuccess: zt} = useWaitForTransactionReceipt({
        hash: ut
    });
    reactExports.useEffect(()=>{
        (!Tt && !It || !Ft && !Lt || !$t && !kt) && (Ct && (totalStaked += Number(formatEther(Ct == null ? void 0 : Ct[0]))),
        Nt && (totalStaked += Number(formatEther(Nt == null ? void 0 : Nt[0]))),
        Mt && (totalStaked += Number(formatEther(Mt == null ? void 0 : Mt[0]))))
    }
    , [Ct, Nt, Mt]),
    reactExports.useEffect(()=>{
        var or, pr;
        if (lt) {
            toastFun("error", (lt == null ? void 0 : lt.shortMessage) ?? "Error! Please try again!");
            let gr = "not defined"
              , Sr = "not defined";
            rt.current && nt.current && (gr = (or = rt.current) == null ? void 0 : or.value,
            Sr = (pr = nt.current) == null ? void 0 : pr.value),
            st(et, gr, (lt == null ? void 0 : lt.shortMessage) ?? lt, !1, formatEther(bt ?? "0n"), formatEther((At == null ? void 0 : At.value) ?? "0n"), Sr),
            ct(),
            rt.current && nt.current && (rt.current.value = "",
            nt.current.value = "")
        }
    }
    , [lt]),
    reactExports.useEffect(()=>{
        var or, pr;
        if (ht) {
            toastFun("error", (ht == null ? void 0 : ht.shortMessage) ?? "Error! Please try again!");
            let gr = "not defined"
              , Sr = "not defined";
            rt.current && nt.current && (gr = (or = rt.current) == null ? void 0 : or.value,
            Sr = (pr = nt.current) == null ? void 0 : pr.value),
            st(et, gr, (ht == null ? void 0 : ht.shortMessage) ?? ht, !1, formatEther(bt ?? "0n"), formatEther((At == null ? void 0 : At.value) ?? "0n"), Sr),
            ct(),
            rt.current && nt.current && (rt.current.value = "",
            nt.current.value = "")
        }
    }
    , [ht]),
    reactExports.useEffect(()=>{
        var or, pr;
        if (Dt && rt.current && nt.current) {
            const gr = parseEther(rt.current.value)
              , Sr = Number(nt.current.value)
              , br = (or = rt.current) == null ? void 0 : or.value
              , Pr = (pr = nt.current) == null ? void 0 : pr.value;
            it(et, br, "approved", !0, formatEther(bt ?? "0n"), formatEther((At == null ? void 0 : At.value) ?? "0n"), Pr),
            ct(),
            ft({
                address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
                abi: abi$1,
                functionName: "stake",
                args: [gr, Sr]
            })
        }
    }
    , [Dt]),
    reactExports.useEffect(()=>{
        var or, pr;
        if (zt && rt.current && nt.current) {
            const gr = (or = rt.current) == null ? void 0 : or.value
              , Sr = (pr = nt.current) == null ? void 0 : pr.value;
            it(et, gr, "Staking Confirmed.", !0, formatEther(bt ?? "0n"), formatEther((At == null ? void 0 : At.value) ?? "0n"), Sr)
        }
    }
    , [zt]);
    const Yt = async or=>{
        or.preventDefault(),
        _e()
    }
      , rr = async or=>{
        var pr, gr, Sr, br;
        if (or.preventDefault(),
        rt.current && nt.current) {
            if (!((pr = rt.current) != null && pr.value)) {
                toastFun("error", "CBTC Required.");
                return
            }
            if (!((gr = nt.current) != null && gr.value)) {
                toastFun("error", "Duration is required!");
                return
            }
            if ((Sr = rt.current) != null && Sr.value) {
                const Pr = Number(formatEther(bt ?? parseEther("0"))).toFixed(2);
                if (Number((br = rt.current) == null ? void 0 : br.value) > Math.floor(+Pr)) {
                    toastFun("error", "Amount Exceeded Your CBTC Balance.");
                    return
                }
            }
            if (!Et && !xt) {
                const Pr = formatEther(_t || 0n)
                  , Wr = +rt.current.value - +Pr
                  , _r = parseEther(rt.current.value)
                  , hr = Number(nt.current.value);
                Wr > 0 ? ot({
                    abi: approveAbi,
                    address: "0xcAE6EBAceF456e5A942afb40Fc99F2F38639eF01",
                    functionName: "approve",
                    args: ["0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1", _r]
                }) : ft({
                    address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
                    abi: abi$1,
                    functionName: "stake",
                    args: [_r, hr]
                })
            }
        }
    }
      , ar = ()=>{
        if (rt.current && bt) {
            const or = Number(formatEther(bt ?? "0n")).toFixed(1);
            rt.current.value = Math.floor(+or || 0).toString() ?? "0"
        }
    }
    ;
    return jsxRuntimeExports.jsx("div", {
        className: "container-fluid",
        children: jsxRuntimeExports.jsx("div", {
            className: "row",
            children: jsxRuntimeExports.jsx("div", {
                className: "col-11 max-width mx-auto py-5",
                children: jsxRuntimeExports.jsxs("div", {
                    className: "row",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6",
                        children: jsxRuntimeExports.jsxs("div", {
                            className: "connectWalletWrapper",
                            children: [jsxRuntimeExports.jsx("h4", {
                                className: "connectWalletHead",
                                children: "connect wallet"
                            }), jsxRuntimeExports.jsx("hr", {}), jsxRuntimeExports.jsxs("div", {
                                className: "connectWalletRow",
                                children: [jsxRuntimeExports.jsx("p", {
                                    children: "Available"
                                }), jsxRuntimeExports.jsxs("span", {
                                    children: [!pt && !mt && Number(formatEther(bt ?? "0n")).toFixed(0), " ", "CBTC"]
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                className: "connectWalletRow",
                                children: [jsxRuntimeExports.jsx("p", {
                                    children: "Staked"
                                }), jsxRuntimeExports.jsxs("span", {
                                    children: [(totalStaked == null ? void 0 : totalStaked.toFixed(2)) ?? 0, " CBTC"]
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                className: "connectWalletRow",
                                children: [jsxRuntimeExports.jsx("p", {
                                    children: "CBTC earned"
                                }), jsxRuntimeExports.jsx("span", {
                                    children: !wt && !vt && Number(formatEther(yt ?? "0n")).toFixed(2)
                                })]
                            }), jsxRuntimeExports.jsx("a", {
                                href: "",
                                onClick: or=>{
                                    Yt(or)
                                }
                                ,
                                className: "connectWalletBtn",
                                style: {
                                    marginTop: "7rem"
                                },
                                children: tt ? "Disconnect Wallet" : "Connect Wallet"
                            })]
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6",
                        children: jsxRuntimeExports.jsxs("div", {
                            className: `stakeWrapper ${tt ? "" : "disabled"}`,
                            children: [jsxRuntimeExports.jsx("h3", {
                                className: "stakeHead",
                                children: "Stake CBTC"
                            }), jsxRuntimeExports.jsx("hr", {}), jsxRuntimeExports.jsxs("div", {
                                className: "stakeRowWrapper",
                                children: [jsxRuntimeExports.jsx("p", {
                                    children: "Staked"
                                }), jsxRuntimeExports.jsxs("span", {
                                    children: [(totalStaked == null ? void 0 : totalStaked.toFixed(2)) ?? 0, " CBTC"]
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                className: "stakeRowWrapper",
                                children: [jsxRuntimeExports.jsx("p", {
                                    children: "Available"
                                }), jsxRuntimeExports.jsxs("span", {
                                    children: [!pt && !mt && Number(formatEther(bt ?? "0n")).toFixed(0), " ", "CBTC"]
                                })]
                            }), jsxRuntimeExports.jsxs("form", {
                                onSubmit: or=>{
                                    rr(or)
                                }
                                ,
                                children: [jsxRuntimeExports.jsxs("div", {
                                    className: "stakeInputMainWrap",
                                    children: [jsxRuntimeExports.jsxs("div", {
                                        className: "stakeLabelWrap",
                                        children: [jsxRuntimeExports.jsx("label", {
                                            htmlFor: "",
                                            children: "Amount to Stake"
                                        }), jsxRuntimeExports.jsx("span", {
                                            onClick: ar,
                                            style: {
                                                cursor: "pointer"
                                            },
                                            children: "MAX"
                                        })]
                                    }), jsxRuntimeExports.jsxs("div", {
                                        className: "stakeInputWrap",
                                        children: [jsxRuntimeExports.jsx("input", {
                                            className: "stakeInput",
                                            type: "text",
                                            placeholder: "0",
                                            ref: rt,
                                            disabled: !tt
                                        }), jsxRuntimeExports.jsx("img", {
                                            className: "img-fluid",
                                            src: favicon,
                                            alt: "CBTC",
                                            title: "CBTC"
                                        })]
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "duration",
                                        className: "durationLabel",
                                        children: "Duration"
                                    }), jsxRuntimeExports.jsx("div", {
                                        className: "pe-1 durationSelectWrapper",
                                        children: jsxRuntimeExports.jsxs("select", {
                                            name: "",
                                            id: "",
                                            className: "durationSelect",
                                            ref: nt,
                                            disabled: !tt,
                                            children: [jsxRuntimeExports.jsx("option", {
                                                value: "",
                                                children: "Select Please"
                                            }), jsxRuntimeExports.jsx("option", {
                                                value: "1",
                                                children: "30 Days"
                                            }), jsxRuntimeExports.jsx("option", {
                                                value: "2",
                                                children: "90 Days"
                                            })]
                                        })
                                    })]
                                }), dt && jsxRuntimeExports.jsxs("div", {
                                    className: "initiatingTextWrapper",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "",
                                        children: "Initiating"
                                    }), jsxRuntimeExports.jsx(MoonLoader, {
                                        color: "#FBBD18",
                                        size: 20
                                    })]
                                }), at && jsxRuntimeExports.jsxs("div", {
                                    className: "referralWrapper my-4",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "referralHead ",
                                        children: "Approval Hash:"
                                    }), jsxRuntimeExports.jsx("span", {
                                        className: "referralText ",
                                        children: at
                                    }), jsxRuntimeExports.jsx(CopyToClipboard$1, {
                                        text: at ?? "",
                                        onCopy: ()=>{
                                            toastFun("", "Copied!")
                                        }
                                        ,
                                        children: jsxRuntimeExports.jsx("button", {
                                            className: "referralBtn",
                                            children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                                        })
                                    })]
                                }), Pt && jsxRuntimeExports.jsxs("div", {
                                    className: "initiatingTextWrapper",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "",
                                        children: "Approving"
                                    }), jsxRuntimeExports.jsx(BounceLoader, {
                                        color: "#FBBD18",
                                        size: 20
                                    })]
                                }), Dt && jsxRuntimeExports.jsxs("div", {
                                    className: "confirmedWrapper",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "text-center",
                                        children: "Request Approved"
                                    }), jsxRuntimeExports.jsx(UseAnimations, {
                                        animation: checkmark,
                                        size: 46,
                                        fillColor: "#FBBD18",
                                        strokeColor: "#FBBD18",
                                        loop: !1
                                    })]
                                }), gt && jsxRuntimeExports.jsxs("div", {
                                    className: "initiatingTextWrapper",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "",
                                        children: "Initiating"
                                    }), jsxRuntimeExports.jsx(MoonLoader, {
                                        color: "#FBBD18",
                                        size: 20
                                    })]
                                }), ut && jsxRuntimeExports.jsxs("div", {
                                    className: "referralWrapper my-4",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "referralHead ",
                                        children: "Transaction Hash:"
                                    }), jsxRuntimeExports.jsx("span", {
                                        className: "referralText ",
                                        children: ut
                                    }), jsxRuntimeExports.jsx(CopyToClipboard$1, {
                                        text: ut ?? "",
                                        onCopy: ()=>{
                                            toastFun("", "Copied!")
                                        }
                                        ,
                                        children: jsxRuntimeExports.jsx("button", {
                                            className: "referralBtn",
                                            children: jsxRuntimeExports.jsx(LuClipboardCopy, {})
                                        })
                                    })]
                                }), Bt && jsxRuntimeExports.jsxs("div", {
                                    className: "initiatingTextWrapper",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "",
                                        children: "Confirming"
                                    }), jsxRuntimeExports.jsx(BounceLoader, {
                                        color: "#FBBD18",
                                        size: 20
                                    })]
                                }), zt && jsxRuntimeExports.jsxs("div", {
                                    className: "confirmedWrapper",
                                    children: [jsxRuntimeExports.jsx("h6", {
                                        className: "text-center",
                                        children: "Confirmed"
                                    }), jsxRuntimeExports.jsx(UseAnimations, {
                                        animation: checkmark,
                                        size: 46,
                                        fillColor: "#FBBD18",
                                        strokeColor: "#FBBD18",
                                        loop: !1
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "d-flex",
                                    children: [jsxRuntimeExports.jsx("button", {
                                        disabled: !tt,
                                        type: "submit",
                                        className: "connectWalletBtn mt-1",
                                        children: "stake"
                                    }), jsxRuntimeExports.jsx(Link, {
                                        to: "/how-stake",
                                        className: "connectWalletBtn ms-1",
                                        children: "How to Stake"
                                    })]
                                })]
                            })]
                        })
                    })]
                })
            })
        })
    })
}
  , Staking = ()=>{
    const _e = useChainId()
      , et = useNavigate();
    return reactExports.useEffect(()=>{
        _e !== 1 && (toastFun("", "Switch Network to ETH ERC20"),
        et("/"))
    }
    , []),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(Info, {}), jsxRuntimeExports.jsx(WalletConnect, {}), jsxRuntimeExports.jsx(CurrentStakes, {})]
    })
}
;
var loadScript = function _e(et, tt, rt) {
    var nt = document.head || document.getElementsByTagName("head")[0]
      , it = document.createElement("script");
    typeof tt == "function" && (rt = tt,
    tt = {}),
    tt = tt || {},
    rt = rt || function() {}
    ,
    it.type = tt.type || "text/javascript",
    it.charset = tt.charset || "utf8",
    it.async = "async"in tt ? !!tt.async : !0,
    it.src = et,
    tt.attrs && setAttributes(it, tt.attrs),
    tt.text && (it.text = "" + tt.text);
    var st = "onload"in it ? stdOnEnd : ieOnEnd;
    st(it, rt),
    it.onload || stdOnEnd(it, rt),
    nt.appendChild(it)
};
function setAttributes(_e, et) {
    for (var tt in et)
        _e.setAttribute(tt, et[tt])
}
function stdOnEnd(_e, et) {
    _e.onload = function() {
        this.onerror = this.onload = null,
        et(null, _e)
    }
    ,
    _e.onerror = function() {
        this.onerror = this.onload = null,
        et(new Error("Failed to load " + this.src), _e)
    }
}
function ieOnEnd(_e, et) {
    _e.onreadystatechange = function() {
        this.readyState != "complete" && this.readyState != "loaded" || (this.onreadystatechange = null,
        et(null, _e))
    }
}
var isMergeableObject = function _e(et) {
    return isNonNullObject(et) && !isSpecial(et)
};
function isNonNullObject(_e) {
    return !!_e && typeof _e == "object"
}
function isSpecial(_e) {
    var et = Object.prototype.toString.call(_e);
    return et === "[object RegExp]" || et === "[object Date]" || isReactElement(_e)
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for
  , REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(_e) {
    return _e.$$typeof === REACT_ELEMENT_TYPE
}
function emptyTarget(_e) {
    return Array.isArray(_e) ? [] : {}
}
function cloneUnlessOtherwiseSpecified(_e, et) {
    return et.clone !== !1 && et.isMergeableObject(_e) ? deepmerge(emptyTarget(_e), _e, et) : _e
}
function defaultArrayMerge(_e, et, tt) {
    return _e.concat(et).map(function(rt) {
        return cloneUnlessOtherwiseSpecified(rt, tt)
    })
}
function getMergeFunction(_e, et) {
    if (!et.customMerge)
        return deepmerge;
    var tt = et.customMerge(_e);
    return typeof tt == "function" ? tt : deepmerge
}
function getEnumerableOwnPropertySymbols(_e) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(_e).filter(function(et) {
        return Object.propertyIsEnumerable.call(_e, et)
    }) : []
}
function getKeys(_e) {
    return Object.keys(_e).concat(getEnumerableOwnPropertySymbols(_e))
}
function propertyIsOnObject(_e, et) {
    try {
        return et in _e
    } catch {
        return !1
    }
}
function propertyIsUnsafe(_e, et) {
    return propertyIsOnObject(_e, et) && !(Object.hasOwnProperty.call(_e, et) && Object.propertyIsEnumerable.call(_e, et))
}
function mergeObject(_e, et, tt) {
    var rt = {};
    return tt.isMergeableObject(_e) && getKeys(_e).forEach(function(nt) {
        rt[nt] = cloneUnlessOtherwiseSpecified(_e[nt], tt)
    }),
    getKeys(et).forEach(function(nt) {
        propertyIsUnsafe(_e, nt) || (propertyIsOnObject(_e, nt) && tt.isMergeableObject(et[nt]) ? rt[nt] = getMergeFunction(nt, tt)(_e[nt], et[nt], tt) : rt[nt] = cloneUnlessOtherwiseSpecified(et[nt], tt))
    }),
    rt
}
function deepmerge(_e, et, tt) {
    tt = tt || {},
    tt.arrayMerge = tt.arrayMerge || defaultArrayMerge,
    tt.isMergeableObject = tt.isMergeableObject || isMergeableObject,
    tt.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var rt = Array.isArray(et)
      , nt = Array.isArray(_e)
      , it = rt === nt;
    return it ? rt ? tt.arrayMerge(_e, et, tt) : mergeObject(_e, et, tt) : cloneUnlessOtherwiseSpecified(et, tt)
}
deepmerge.all = function _e(et, tt) {
    if (!Array.isArray(et))
        throw new Error("first argument should be an array");
    return et.reduce(function(rt, nt) {
        return deepmerge(rt, nt, tt)
    }, {})
}
;
var deepmerge_1 = deepmerge
  , cjs = deepmerge_1
  , __create$4 = Object.create
  , __defProp$6 = Object.defineProperty
  , __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor
  , __getOwnPropNames$6 = Object.getOwnPropertyNames
  , __getProtoOf$4 = Object.getPrototypeOf
  , __hasOwnProp$6 = Object.prototype.hasOwnProperty
  , __export$6 = (_e,et)=>{
    for (var tt in et)
        __defProp$6(_e, tt, {
            get: et[tt],
            enumerable: !0
        })
}
  , __copyProps$6 = (_e,et,tt,rt)=>{
    if (et && typeof et == "object" || typeof et == "function")
        for (let nt of __getOwnPropNames$6(et))
            !__hasOwnProp$6.call(_e, nt) && nt !== tt && __defProp$6(_e, nt, {
                get: ()=>et[nt],
                enumerable: !(rt = __getOwnPropDesc$6(et, nt)) || rt.enumerable
            });
    return _e
}
  , __toESM$4 = (_e,et,tt)=>(tt = _e != null ? __create$4(__getProtoOf$4(_e)) : {},
__copyProps$6(et || !_e || !_e.__esModule ? __defProp$6(tt, "default", {
    value: _e,
    enumerable: !0
}) : tt, _e))
  , __toCommonJS$6 = _e=>__copyProps$6(__defProp$6({}, "__esModule", {
    value: !0
}), _e)
  , utils_exports = {};
__export$6(utils_exports, {
    callPlayer: ()=>callPlayer,
    getConfig: ()=>getConfig,
    getSDK: ()=>getSDK,
    isBlobUrl: ()=>isBlobUrl,
    isMediaStream: ()=>isMediaStream,
    lazy: ()=>lazy$1,
    omit: ()=>omit,
    parseEndTime: ()=>parseEndTime,
    parseStartTime: ()=>parseStartTime,
    queryString: ()=>queryString,
    randomString: ()=>randomString,
    supportsWebKitPresentationMode: ()=>supportsWebKitPresentationMode
});
var utils = __toCommonJS$6(utils_exports)
  , import_react$2 = __toESM$4(reactExports)
  , import_load_script = __toESM$4(loadScript)
  , import_deepmerge$1 = __toESM$4(cjs);
const lazy$1 = _e=>import_react$2.default.lazy(async()=>{
    const et = await _e();
    return typeof et.default == "function" ? et : et.default
}
)
  , MATCH_START_QUERY = /[?&#](?:start|t)=([0-9hms]+)/
  , MATCH_END_QUERY = /[?&#]end=([0-9hms]+)/
  , MATCH_START_STAMP = /(\d+)(h|m|s)/g
  , MATCH_NUMERIC = /^\d+$/;
function parseTimeParam(_e, et) {
    if (_e instanceof Array)
        return;
    const tt = _e.match(et);
    if (tt) {
        const rt = tt[1];
        if (rt.match(MATCH_START_STAMP))
            return parseTimeString(rt);
        if (MATCH_NUMERIC.test(rt))
            return parseInt(rt)
    }
}
function parseTimeString(_e) {
    let et = 0
      , tt = MATCH_START_STAMP.exec(_e);
    for (; tt !== null; ) {
        const [,rt,nt] = tt;
        nt === "h" && (et += parseInt(rt, 10) * 60 * 60),
        nt === "m" && (et += parseInt(rt, 10) * 60),
        nt === "s" && (et += parseInt(rt, 10)),
        tt = MATCH_START_STAMP.exec(_e)
    }
    return et
}
function parseStartTime(_e) {
    return parseTimeParam(_e, MATCH_START_QUERY)
}
function parseEndTime(_e) {
    return parseTimeParam(_e, MATCH_END_QUERY)
}
function randomString() {
    return Math.random().toString(36).substr(2, 5)
}
function queryString(_e) {
    return Object.keys(_e).map(et=>`${et}=${_e[et]}`).join("&")
}
function getGlobal(_e) {
    return window[_e] ? window[_e] : window.exports && window.exports[_e] ? window.exports[_e] : window.module && window.module.exports && window.module.exports[_e] ? window.module.exports[_e] : null
}
const requests = {}
  , getSDK = function _e(et, tt, rt=null, nt=()=>!0, it=import_load_script.default) {
    const st = getGlobal(tt);
    return st && nt(st) ? Promise.resolve(st) : new Promise((at,ot)=>{
        if (requests[et]) {
            requests[et].push({
                resolve: at,
                reject: ot
            });
            return
        }
        requests[et] = [{
            resolve: at,
            reject: ot
        }];
        const lt = dt=>{
            requests[et].forEach(ct=>ct.resolve(dt))
        }
        ;
        if (rt) {
            const dt = window[rt];
            window[rt] = function() {
                dt && dt(),
                lt(getGlobal(tt))
            }
        }
        it(et, dt=>{
            dt ? (requests[et].forEach(ct=>ct.reject(dt)),
            requests[et] = null) : rt || lt(getGlobal(tt))
        }
        )
    }
    )
};
function getConfig(_e, et) {
    return (0,
    import_deepmerge$1.default)(et.config, _e.config)
}
function omit(_e, ...et) {
    const tt = [].concat(...et)
      , rt = {}
      , nt = Object.keys(_e);
    for (const it of nt)
        tt.indexOf(it) === -1 && (rt[it] = _e[it]);
    return rt
}
function callPlayer(_e, ...et) {
    if (!this.player || !this.player[_e]) {
        let tt = `ReactPlayer: ${this.constructor.displayName} player could not call %c${_e}%c – `;
        return this.player ? this.player[_e] || (tt += "The method was not available") : tt += "The player was not available",
        console.warn(tt, "font-weight: bold", ""),
        null
    }
    return this.player[_e](...et)
}
function isMediaStream(_e) {
    return typeof window < "u" && typeof window.MediaStream < "u" && _e instanceof window.MediaStream
}
function isBlobUrl(_e) {
    return /^blob:/.test(_e)
}
function supportsWebKitPresentationMode(_e=document.createElement("video")) {
    const et = /iPhone|iPod/.test(navigator.userAgent) === !1;
    return _e.webkitSupportsPresentationMode && typeof _e.webkitSetPresentationMode == "function" && et
}
function enableStubOn(_e) {
    return _e
}
var __defProp$5 = Object.defineProperty
  , __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor
  , __getOwnPropNames$5 = Object.getOwnPropertyNames
  , __hasOwnProp$5 = Object.prototype.hasOwnProperty
  , __export$5 = (_e,et)=>{
    for (var tt in et)
        __defProp$5(_e, tt, {
            get: et[tt],
            enumerable: !0
        })
}
  , __copyProps$5 = (_e,et,tt,rt)=>{
    if (et && typeof et == "object" || typeof et == "function")
        for (let nt of __getOwnPropNames$5(et))
            !__hasOwnProp$5.call(_e, nt) && nt !== tt && __defProp$5(_e, nt, {
                get: ()=>et[nt],
                enumerable: !(rt = __getOwnPropDesc$5(et, nt)) || rt.enumerable
            });
    return _e
}
  , __toCommonJS$5 = _e=>__copyProps$5(__defProp$5({}, "__esModule", {
    value: !0
}), _e)
  , patterns_exports = {};
__export$5(patterns_exports, {
    AUDIO_EXTENSIONS: ()=>AUDIO_EXTENSIONS,
    DASH_EXTENSIONS: ()=>DASH_EXTENSIONS,
    FLV_EXTENSIONS: ()=>FLV_EXTENSIONS,
    HLS_EXTENSIONS: ()=>HLS_EXTENSIONS,
    MATCH_URL_DAILYMOTION: ()=>MATCH_URL_DAILYMOTION,
    MATCH_URL_FACEBOOK: ()=>MATCH_URL_FACEBOOK,
    MATCH_URL_FACEBOOK_WATCH: ()=>MATCH_URL_FACEBOOK_WATCH,
    MATCH_URL_KALTURA: ()=>MATCH_URL_KALTURA,
    MATCH_URL_MIXCLOUD: ()=>MATCH_URL_MIXCLOUD,
    MATCH_URL_SOUNDCLOUD: ()=>MATCH_URL_SOUNDCLOUD,
    MATCH_URL_STREAMABLE: ()=>MATCH_URL_STREAMABLE,
    MATCH_URL_TWITCH_CHANNEL: ()=>MATCH_URL_TWITCH_CHANNEL,
    MATCH_URL_TWITCH_VIDEO: ()=>MATCH_URL_TWITCH_VIDEO,
    MATCH_URL_VIDYARD: ()=>MATCH_URL_VIDYARD,
    MATCH_URL_VIMEO: ()=>MATCH_URL_VIMEO,
    MATCH_URL_WISTIA: ()=>MATCH_URL_WISTIA,
    MATCH_URL_YOUTUBE: ()=>MATCH_URL_YOUTUBE,
    VIDEO_EXTENSIONS: ()=>VIDEO_EXTENSIONS,
    canPlay: ()=>canPlay
});
var patterns = __toCommonJS$5(patterns_exports)
  , import_utils$3 = utils;
const MATCH_URL_YOUTUBE = /(?:youtu\.be\/|youtube(?:-nocookie|education)?\.com\/(?:embed\/|v\/|watch\/|watch\?v=|watch\?.+&v=|shorts\/|live\/))((\w|-){11})|youtube\.com\/playlist\?list=|youtube\.com\/user\//
  , MATCH_URL_SOUNDCLOUD = /(?:soundcloud\.com|snd\.sc)\/[^.]+$/
  , MATCH_URL_VIMEO = /vimeo\.com\/(?!progressive_redirect).+/
  , MATCH_URL_FACEBOOK = /^https?:\/\/(www\.)?facebook\.com.*\/(video(s)?|watch|story)(\.php?|\/).+$/
  , MATCH_URL_FACEBOOK_WATCH = /^https?:\/\/fb\.watch\/.+$/
  , MATCH_URL_STREAMABLE = /streamable\.com\/([a-z0-9]+)$/
  , MATCH_URL_WISTIA = /(?:wistia\.(?:com|net)|wi\.st)\/(?:medias|embed)\/(?:iframe\/)?([^?]+)/
  , MATCH_URL_TWITCH_VIDEO = /(?:www\.|go\.)?twitch\.tv\/videos\/(\d+)($|\?)/
  , MATCH_URL_TWITCH_CHANNEL = /(?:www\.|go\.)?twitch\.tv\/([a-zA-Z0-9_]+)($|\?)/
  , MATCH_URL_DAILYMOTION = /^(?:(?:https?):)?(?:\/\/)?(?:www\.)?(?:(?:dailymotion\.com(?:\/embed)?\/video)|dai\.ly)\/([a-zA-Z0-9]+)(?:_[\w_-]+)?(?:[\w.#_-]+)?/
  , MATCH_URL_MIXCLOUD = /mixcloud\.com\/([^/]+\/[^/]+)/
  , MATCH_URL_VIDYARD = /vidyard.com\/(?:watch\/)?([a-zA-Z0-9-_]+)/
  , MATCH_URL_KALTURA = /^https?:\/\/[a-zA-Z]+\.kaltura.(com|org)\/p\/([0-9]+)\/sp\/([0-9]+)00\/embedIframeJs\/uiconf_id\/([0-9]+)\/partner_id\/([0-9]+)(.*)entry_id.([a-zA-Z0-9-_].*)$/
  , AUDIO_EXTENSIONS = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i
  , VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i
  , HLS_EXTENSIONS = /\.(m3u8)($|\?)/i
  , DASH_EXTENSIONS = /\.(mpd)($|\?)/i
  , FLV_EXTENSIONS = /\.(flv)($|\?)/i
  , canPlayFile = _e=>{
    if (_e instanceof Array) {
        for (const et of _e)
            if (typeof et == "string" && canPlayFile(et) || canPlayFile(et.src))
                return !0;
        return !1
    }
    return (0,
    import_utils$3.isMediaStream)(_e) || (0,
    import_utils$3.isBlobUrl)(_e) ? !0 : AUDIO_EXTENSIONS.test(_e) || VIDEO_EXTENSIONS.test(_e) || HLS_EXTENSIONS.test(_e) || DASH_EXTENSIONS.test(_e) || FLV_EXTENSIONS.test(_e)
}
  , canPlay = {
    youtube: _e=>_e instanceof Array ? _e.every(et=>MATCH_URL_YOUTUBE.test(et)) : MATCH_URL_YOUTUBE.test(_e),
    soundcloud: _e=>MATCH_URL_SOUNDCLOUD.test(_e) && !AUDIO_EXTENSIONS.test(_e),
    vimeo: _e=>MATCH_URL_VIMEO.test(_e) && !VIDEO_EXTENSIONS.test(_e) && !HLS_EXTENSIONS.test(_e),
    facebook: _e=>MATCH_URL_FACEBOOK.test(_e) || MATCH_URL_FACEBOOK_WATCH.test(_e),
    streamable: _e=>MATCH_URL_STREAMABLE.test(_e),
    wistia: _e=>MATCH_URL_WISTIA.test(_e),
    twitch: _e=>MATCH_URL_TWITCH_VIDEO.test(_e) || MATCH_URL_TWITCH_CHANNEL.test(_e),
    dailymotion: _e=>MATCH_URL_DAILYMOTION.test(_e),
    mixcloud: _e=>MATCH_URL_MIXCLOUD.test(_e),
    vidyard: _e=>MATCH_URL_VIDYARD.test(_e),
    kaltura: _e=>MATCH_URL_KALTURA.test(_e),
    file: canPlayFile
};
var __defProp$4 = Object.defineProperty
  , __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor
  , __getOwnPropNames$4 = Object.getOwnPropertyNames
  , __hasOwnProp$4 = Object.prototype.hasOwnProperty
  , __export$4 = (_e,et)=>{
    for (var tt in et)
        __defProp$4(_e, tt, {
            get: et[tt],
            enumerable: !0
        })
}
  , __copyProps$4 = (_e,et,tt,rt)=>{
    if (et && typeof et == "object" || typeof et == "function")
        for (let nt of __getOwnPropNames$4(et))
            !__hasOwnProp$4.call(_e, nt) && nt !== tt && __defProp$4(_e, nt, {
                get: ()=>et[nt],
                enumerable: !(rt = __getOwnPropDesc$4(et, nt)) || rt.enumerable
            });
    return _e
}
  , __toCommonJS$4 = _e=>__copyProps$4(__defProp$4({}, "__esModule", {
    value: !0
}), _e)
  , players_exports = {};
__export$4(players_exports, {
    default: ()=>players_default
});
var players = __toCommonJS$4(players_exports)
  , import_utils$2 = utils
  , import_patterns = patterns
  , players_default = [{
    key: "youtube",
    name: "YouTube",
    canPlay: import_patterns.canPlay.youtube,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./YouTube-v4zDiZrS.js").then(_e=>_e.Y), __vite__mapDeps([])))
}, {
    key: "soundcloud",
    name: "SoundCloud",
    canPlay: import_patterns.canPlay.soundcloud,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./SoundCloud-CWl58u5T.js").then(_e=>_e.S), __vite__mapDeps([])))
}, {
    key: "vimeo",
    name: "Vimeo",
    canPlay: import_patterns.canPlay.vimeo,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Vimeo-Bdem6NOD.js").then(_e=>_e.V), __vite__mapDeps([])))
}, {
    key: "facebook",
    name: "Facebook",
    canPlay: import_patterns.canPlay.facebook,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Facebook-BwA4wfum.js").then(_e=>_e.F), __vite__mapDeps([])))
}, {
    key: "streamable",
    name: "Streamable",
    canPlay: import_patterns.canPlay.streamable,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Streamable-BoPp39yf.js").then(_e=>_e.S), __vite__mapDeps([])))
}, {
    key: "wistia",
    name: "Wistia",
    canPlay: import_patterns.canPlay.wistia,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Wistia-D2oBxsTe.js").then(_e=>_e.W), __vite__mapDeps([])))
}, {
    key: "twitch",
    name: "Twitch",
    canPlay: import_patterns.canPlay.twitch,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Twitch-ChzfolZ3.js").then(_e=>_e.T), __vite__mapDeps([])))
}, {
    key: "dailymotion",
    name: "DailyMotion",
    canPlay: import_patterns.canPlay.dailymotion,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./DailyMotion-nVGyhskx.js").then(_e=>_e.D), __vite__mapDeps([])))
}, {
    key: "mixcloud",
    name: "Mixcloud",
    canPlay: import_patterns.canPlay.mixcloud,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Mixcloud-B7oIDI2k.js").then(_e=>_e.M), __vite__mapDeps([])))
}, {
    key: "vidyard",
    name: "Vidyard",
    canPlay: import_patterns.canPlay.vidyard,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Vidyard-DCRR9seh.js").then(_e=>_e.V), __vite__mapDeps([])))
}, {
    key: "kaltura",
    name: "Kaltura",
    canPlay: import_patterns.canPlay.kaltura,
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./Kaltura-BJAzekx0.js").then(_e=>_e.K), __vite__mapDeps([])))
}, {
    key: "file",
    name: "FilePlayer",
    canPlay: import_patterns.canPlay.file,
    canEnablePIP: _e=>import_patterns.canPlay.file(_e) && (document.pictureInPictureEnabled || (0,
    import_utils$2.supportsWebKitPresentationMode)()) && !import_patterns.AUDIO_EXTENSIONS.test(_e),
    lazyPlayer: (0,
    import_utils$2.lazy)(()=>__vitePreload(()=>import("./FilePlayer-BdG3Eh4k.js").then(_e=>_e.F), __vite__mapDeps([])))
}]
  , safeIsNaN = Number.isNaN || function _e(et) {
    return typeof et == "number" && et !== et
}
;
function isEqual(_e, et) {
    return !!(_e === et || safeIsNaN(_e) && safeIsNaN(et))
}
function areInputsEqual(_e, et) {
    if (_e.length !== et.length)
        return !1;
    for (var tt = 0; tt < _e.length; tt++)
        if (!isEqual(_e[tt], et[tt]))
            return !1;
    return !0
}
function memoizeOne(_e, et) {
    et === void 0 && (et = areInputsEqual);
    var tt, rt = [], nt, it = !1;
    function st() {
        for (var at = [], ot = 0; ot < arguments.length; ot++)
            at[ot] = arguments[ot];
        return it && tt === this && et(at, rt) || (nt = _e.apply(this, at),
        it = !0,
        tt = this,
        rt = at),
        nt
    }
    return st
}
const memoizeOne_esm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: memoizeOne
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$2 = getAugmentedNamespace(memoizeOne_esm);
var hasElementType = typeof Element < "u"
  , hasMap = typeof Map == "function"
  , hasSet = typeof Set == "function"
  , hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function equal(_e, et) {
    if (_e === et)
        return !0;
    if (_e && et && typeof _e == "object" && typeof et == "object") {
        if (_e.constructor !== et.constructor)
            return !1;
        var tt, rt, nt;
        if (Array.isArray(_e)) {
            if (tt = _e.length,
            tt != et.length)
                return !1;
            for (rt = tt; rt-- !== 0; )
                if (!equal(_e[rt], et[rt]))
                    return !1;
            return !0
        }
        var it;
        if (hasMap && _e instanceof Map && et instanceof Map) {
            if (_e.size !== et.size)
                return !1;
            for (it = _e.entries(); !(rt = it.next()).done; )
                if (!et.has(rt.value[0]))
                    return !1;
            for (it = _e.entries(); !(rt = it.next()).done; )
                if (!equal(rt.value[1], et.get(rt.value[0])))
                    return !1;
            return !0
        }
        if (hasSet && _e instanceof Set && et instanceof Set) {
            if (_e.size !== et.size)
                return !1;
            for (it = _e.entries(); !(rt = it.next()).done; )
                if (!et.has(rt.value[0]))
                    return !1;
            return !0
        }
        if (hasArrayBuffer && ArrayBuffer.isView(_e) && ArrayBuffer.isView(et)) {
            if (tt = _e.length,
            tt != et.length)
                return !1;
            for (rt = tt; rt-- !== 0; )
                if (_e[rt] !== et[rt])
                    return !1;
            return !0
        }
        if (_e.constructor === RegExp)
            return _e.source === et.source && _e.flags === et.flags;
        if (_e.valueOf !== Object.prototype.valueOf && typeof _e.valueOf == "function" && typeof et.valueOf == "function")
            return _e.valueOf() === et.valueOf();
        if (_e.toString !== Object.prototype.toString && typeof _e.toString == "function" && typeof et.toString == "function")
            return _e.toString() === et.toString();
        if (nt = Object.keys(_e),
        tt = nt.length,
        tt !== Object.keys(et).length)
            return !1;
        for (rt = tt; rt-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(et, nt[rt]))
                return !1;
        if (hasElementType && _e instanceof Element)
            return !1;
        for (rt = tt; rt-- !== 0; )
            if (!((nt[rt] === "_owner" || nt[rt] === "__v" || nt[rt] === "__o") && _e.$$typeof) && !equal(_e[nt[rt]], et[nt[rt]]))
                return !1;
        return !0
    }
    return _e !== _e && et !== et
}
var reactFastCompare = function _e(et, tt) {
    try {
        return equal(et, tt)
    } catch (rt) {
        if ((rt.message || "").match(/stack|recursion/i))
            return console.warn("react-fast-compare cannot handle circular refs"),
            !1;
        throw rt
    }
}
  , __create$3 = Object.create
  , __defProp$3 = Object.defineProperty
  , __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor
  , __getOwnPropNames$3 = Object.getOwnPropertyNames
  , __getProtoOf$3 = Object.getPrototypeOf
  , __hasOwnProp$3 = Object.prototype.hasOwnProperty
  , __export$3 = (_e,et)=>{
    for (var tt in et)
        __defProp$3(_e, tt, {
            get: et[tt],
            enumerable: !0
        })
}
  , __copyProps$3 = (_e,et,tt,rt)=>{
    if (et && typeof et == "object" || typeof et == "function")
        for (let nt of __getOwnPropNames$3(et))
            !__hasOwnProp$3.call(_e, nt) && nt !== tt && __defProp$3(_e, nt, {
                get: ()=>et[nt],
                enumerable: !(rt = __getOwnPropDesc$3(et, nt)) || rt.enumerable
            });
    return _e
}
  , __toESM$3 = (_e,et,tt)=>(tt = _e != null ? __create$3(__getProtoOf$3(_e)) : {},
__copyProps$3(et || !_e || !_e.__esModule ? __defProp$3(tt, "default", {
    value: _e,
    enumerable: !0
}) : tt, _e))
  , __toCommonJS$3 = _e=>__copyProps$3(__defProp$3({}, "__esModule", {
    value: !0
}), _e)
  , props_exports = {};
__export$3(props_exports, {
    defaultProps: ()=>defaultProps,
    propTypes: ()=>propTypes
});
var props = __toCommonJS$3(props_exports)
  , import_prop_types = __toESM$3(propTypesExports);
const {string, bool, number, array, oneOfType, shape, object, func, node} = import_prop_types.default
  , propTypes = {
    url: oneOfType([string, array, object]),
    playing: bool,
    loop: bool,
    controls: bool,
    volume: number,
    muted: bool,
    playbackRate: number,
    width: oneOfType([string, number]),
    height: oneOfType([string, number]),
    style: object,
    progressInterval: number,
    playsinline: bool,
    pip: bool,
    stopOnUnmount: bool,
    light: oneOfType([bool, string, object]),
    playIcon: node,
    previewTabIndex: number,
    fallback: node,
    oEmbedUrl: string,
    wrapper: oneOfType([string, func, shape({
        render: func.isRequired
    })]),
    config: shape({
        soundcloud: shape({
            options: object
        }),
        youtube: shape({
            playerVars: object,
            embedOptions: object,
            onUnstarted: func
        }),
        facebook: shape({
            appId: string,
            version: string,
            playerId: string,
            attributes: object
        }),
        dailymotion: shape({
            params: object
        }),
        vimeo: shape({
            playerOptions: object,
            title: string
        }),
        file: shape({
            attributes: object,
            tracks: array,
            forceVideo: bool,
            forceAudio: bool,
            forceHLS: bool,
            forceSafariHLS: bool,
            forceDisableHls: bool,
            forceDASH: bool,
            forceFLV: bool,
            hlsOptions: object,
            hlsVersion: string,
            dashVersion: string,
            flvVersion: string
        }),
        wistia: shape({
            options: object,
            playerId: string,
            customControls: array
        }),
        mixcloud: shape({
            options: object
        }),
        twitch: shape({
            options: object,
            playerId: string
        }),
        vidyard: shape({
            options: object
        })
    }),
    onReady: func,
    onStart: func,
    onPlay: func,
    onPause: func,
    onBuffer: func,
    onBufferEnd: func,
    onEnded: func,
    onError: func,
    onDuration: func,
    onSeek: func,
    onPlaybackRateChange: func,
    onPlaybackQualityChange: func,
    onProgress: func,
    onClickPreview: func,
    onEnablePIP: func,
    onDisablePIP: func
}
  , noop = ()=>{}
  , defaultProps = {
    playing: !1,
    loop: !1,
    controls: !1,
    volume: null,
    muted: !1,
    playbackRate: 1,
    width: "640px",
    height: "360px",
    style: {},
    progressInterval: 1e3,
    playsinline: !1,
    pip: !1,
    stopOnUnmount: !0,
    light: !1,
    fallback: null,
    wrapper: "div",
    previewTabIndex: 0,
    oEmbedUrl: "https://noembed.com/embed?url={url}",
    config: {
        soundcloud: {
            options: {
                visual: !0,
                buying: !1,
                liking: !1,
                download: !1,
                sharing: !1,
                show_comments: !1,
                show_playcount: !1
            }
        },
        youtube: {
            playerVars: {
                playsinline: 1,
                showinfo: 0,
                rel: 0,
                iv_load_policy: 3,
                modestbranding: 1
            },
            embedOptions: {},
            onUnstarted: noop
        },
        facebook: {
            appId: "1309697205772819",
            version: "v3.3",
            playerId: null,
            attributes: {}
        },
        dailymotion: {
            params: {
                api: 1,
                "endscreen-enable": !1
            }
        },
        vimeo: {
            playerOptions: {
                autopause: !1,
                byline: !1,
                portrait: !1,
                title: !1
            },
            title: null
        },
        file: {
            attributes: {},
            tracks: [],
            forceVideo: !1,
            forceAudio: !1,
            forceHLS: !1,
            forceDASH: !1,
            forceFLV: !1,
            hlsOptions: {},
            hlsVersion: "1.1.4",
            dashVersion: "3.1.3",
            flvVersion: "1.5.0",
            forceDisableHls: !1
        },
        wistia: {
            options: {},
            playerId: null,
            customControls: null
        },
        mixcloud: {
            options: {
                hide_cover: 1
            }
        },
        twitch: {
            options: {},
            playerId: null
        },
        vidyard: {
            options: {}
        }
    },
    onReady: noop,
    onStart: noop,
    onPlay: noop,
    onPause: noop,
    onBuffer: noop,
    onBufferEnd: noop,
    onEnded: noop,
    onError: noop,
    onDuration: noop,
    onSeek: noop,
    onPlaybackRateChange: noop,
    onPlaybackQualityChange: noop,
    onProgress: noop,
    onClickPreview: noop,
    onEnablePIP: noop,
    onDisablePIP: noop
};
var __create$2 = Object.create
  , __defProp$2 = Object.defineProperty
  , __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor
  , __getOwnPropNames$2 = Object.getOwnPropertyNames
  , __getProtoOf$2 = Object.getPrototypeOf
  , __hasOwnProp$2 = Object.prototype.hasOwnProperty
  , __defNormalProp$1 = (_e,et,tt)=>et in _e ? __defProp$2(_e, et, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: tt
}) : _e[et] = tt
  , __export$2 = (_e,et)=>{
    for (var tt in et)
        __defProp$2(_e, tt, {
            get: et[tt],
            enumerable: !0
        })
}
  , __copyProps$2 = (_e,et,tt,rt)=>{
    if (et && typeof et == "object" || typeof et == "function")
        for (let nt of __getOwnPropNames$2(et))
            !__hasOwnProp$2.call(_e, nt) && nt !== tt && __defProp$2(_e, nt, {
                get: ()=>et[nt],
                enumerable: !(rt = __getOwnPropDesc$2(et, nt)) || rt.enumerable
            });
    return _e
}
  , __toESM$2 = (_e,et,tt)=>(tt = _e != null ? __create$2(__getProtoOf$2(_e)) : {},
__copyProps$2(et || !_e || !_e.__esModule ? __defProp$2(tt, "default", {
    value: _e,
    enumerable: !0
}) : tt, _e))
  , __toCommonJS$2 = _e=>__copyProps$2(__defProp$2({}, "__esModule", {
    value: !0
}), _e)
  , __publicField$1 = (_e,et,tt)=>(__defNormalProp$1(_e, typeof et != "symbol" ? et + "" : et, tt),
tt)
  , Player_exports = {};
__export$2(Player_exports, {
    default: ()=>Player
});
var Player_1 = __toCommonJS$2(Player_exports)
  , import_react$1 = __toESM$2(reactExports)
  , import_react_fast_compare$1 = __toESM$2(reactFastCompare)
  , import_props$1 = props
  , import_utils$1 = utils;
const SEEK_ON_PLAY_EXPIRY = 5e3;
class Player extends import_react$1.Component {
    constructor() {
        super(...arguments),
        __publicField$1(this, "mounted", !1),
        __publicField$1(this, "isReady", !1),
        __publicField$1(this, "isPlaying", !1),
        __publicField$1(this, "isLoading", !0),
        __publicField$1(this, "loadOnReady", null),
        __publicField$1(this, "startOnPlay", !0),
        __publicField$1(this, "seekOnPlay", null),
        __publicField$1(this, "onDurationCalled", !1),
        __publicField$1(this, "handlePlayerMount", et=>{
            if (this.player) {
                this.progress();
                return
            }
            this.player = et,
            this.player.load(this.props.url),
            this.progress()
        }
        ),
        __publicField$1(this, "getInternalPlayer", et=>this.player ? this.player[et] : null),
        __publicField$1(this, "progress", ()=>{
            if (this.props.url && this.player && this.isReady) {
                const et = this.getCurrentTime() || 0
                  , tt = this.getSecondsLoaded()
                  , rt = this.getDuration();
                if (rt) {
                    const nt = {
                        playedSeconds: et,
                        played: et / rt
                    };
                    tt !== null && (nt.loadedSeconds = tt,
                    nt.loaded = tt / rt),
                    (nt.playedSeconds !== this.prevPlayed || nt.loadedSeconds !== this.prevLoaded) && this.props.onProgress(nt),
                    this.prevPlayed = nt.playedSeconds,
                    this.prevLoaded = nt.loadedSeconds
                }
            }
            this.progressTimeout = setTimeout(this.progress, this.props.progressFrequency || this.props.progressInterval)
        }
        ),
        __publicField$1(this, "handleReady", ()=>{
            if (!this.mounted)
                return;
            this.isReady = !0,
            this.isLoading = !1;
            const {onReady: et, playing: tt, volume: rt, muted: nt} = this.props;
            et(),
            !nt && rt !== null && this.player.setVolume(rt),
            this.loadOnReady ? (this.player.load(this.loadOnReady, !0),
            this.loadOnReady = null) : tt && this.player.play(),
            this.handleDurationCheck()
        }
        ),
        __publicField$1(this, "handlePlay", ()=>{
            this.isPlaying = !0,
            this.isLoading = !1;
            const {onStart: et, onPlay: tt, playbackRate: rt} = this.props;
            this.startOnPlay && (this.player.setPlaybackRate && rt !== 1 && this.player.setPlaybackRate(rt),
            et(),
            this.startOnPlay = !1),
            tt(),
            this.seekOnPlay && (this.seekTo(this.seekOnPlay),
            this.seekOnPlay = null),
            this.handleDurationCheck()
        }
        ),
        __publicField$1(this, "handlePause", et=>{
            this.isPlaying = !1,
            this.isLoading || this.props.onPause(et)
        }
        ),
        __publicField$1(this, "handleEnded", ()=>{
            const {activePlayer: et, loop: tt, onEnded: rt} = this.props;
            et.loopOnEnded && tt && this.seekTo(0),
            tt || (this.isPlaying = !1,
            rt())
        }
        ),
        __publicField$1(this, "handleError", (...et)=>{
            this.isLoading = !1,
            this.props.onError(...et)
        }
        ),
        __publicField$1(this, "handleDurationCheck", ()=>{
            clearTimeout(this.durationCheckTimeout);
            const et = this.getDuration();
            et ? this.onDurationCalled || (this.props.onDuration(et),
            this.onDurationCalled = !0) : this.durationCheckTimeout = setTimeout(this.handleDurationCheck, 100)
        }
        ),
        __publicField$1(this, "handleLoaded", ()=>{
            this.isLoading = !1
        }
        )
    }
    componentDidMount() {
        this.mounted = !0
    }
    componentWillUnmount() {
        clearTimeout(this.progressTimeout),
        clearTimeout(this.durationCheckTimeout),
        this.isReady && this.props.stopOnUnmount && (this.player.stop(),
        this.player.disablePIP && this.player.disablePIP()),
        this.mounted = !1
    }
    componentDidUpdate(et) {
        if (!this.player)
            return;
        const {url: tt, playing: rt, volume: nt, muted: it, playbackRate: st, pip: at, loop: ot, activePlayer: lt, disableDeferredLoading: dt} = this.props;
        if (!(0,
        import_react_fast_compare$1.default)(et.url, tt)) {
            if (this.isLoading && !lt.forceLoad && !dt && !(0,
            import_utils$1.isMediaStream)(tt)) {
                console.warn(`ReactPlayer: the attempt to load ${tt} is being deferred until the player has loaded`),
                this.loadOnReady = tt;
                return
            }
            this.isLoading = !0,
            this.startOnPlay = !0,
            this.onDurationCalled = !1,
            this.player.load(tt, this.isReady)
        }
        !et.playing && rt && !this.isPlaying && this.player.play(),
        et.playing && !rt && this.isPlaying && this.player.pause(),
        !et.pip && at && this.player.enablePIP && this.player.enablePIP(),
        et.pip && !at && this.player.disablePIP && this.player.disablePIP(),
        et.volume !== nt && nt !== null && this.player.setVolume(nt),
        et.muted !== it && (it ? this.player.mute() : (this.player.unmute(),
        nt !== null && setTimeout(()=>this.player.setVolume(nt)))),
        et.playbackRate !== st && this.player.setPlaybackRate && this.player.setPlaybackRate(st),
        et.loop !== ot && this.player.setLoop && this.player.setLoop(ot)
    }
    getDuration() {
        return this.isReady ? this.player.getDuration() : null
    }
    getCurrentTime() {
        return this.isReady ? this.player.getCurrentTime() : null
    }
    getSecondsLoaded() {
        return this.isReady ? this.player.getSecondsLoaded() : null
    }
    seekTo(et, tt, rt) {
        if (!this.isReady) {
            et !== 0 && (this.seekOnPlay = et,
            setTimeout(()=>{
                this.seekOnPlay = null
            }
            , SEEK_ON_PLAY_EXPIRY));
            return
        }
        if (tt ? tt === "fraction" : et > 0 && et < 1) {
            const it = this.player.getDuration();
            if (!it) {
                console.warn("ReactPlayer: could not seek using fraction – duration not yet available");
                return
            }
            this.player.seekTo(it * et, rt);
            return
        }
        this.player.seekTo(et, rt)
    }
    render() {
        const et = this.props.activePlayer;
        return et ? import_react$1.default.createElement(et, {
            ...this.props,
            onMount: this.handlePlayerMount,
            onReady: this.handleReady,
            onPlay: this.handlePlay,
            onPause: this.handlePause,
            onEnded: this.handleEnded,
            onLoaded: this.handleLoaded,
            onError: this.handleError
        }) : null
    }
}
__publicField$1(Player, "displayName", "Player");
__publicField$1(Player, "propTypes", import_props$1.propTypes);
__publicField$1(Player, "defaultProps", import_props$1.defaultProps);
var __create$1 = Object.create
  , __defProp$1 = Object.defineProperty
  , __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor
  , __getOwnPropNames$1 = Object.getOwnPropertyNames
  , __getProtoOf$1 = Object.getPrototypeOf
  , __hasOwnProp$1 = Object.prototype.hasOwnProperty
  , __defNormalProp = (_e,et,tt)=>et in _e ? __defProp$1(_e, et, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: tt
}) : _e[et] = tt
  , __export$1 = (_e,et)=>{
    for (var tt in et)
        __defProp$1(_e, tt, {
            get: et[tt],
            enumerable: !0
        })
}
  , __copyProps$1 = (_e,et,tt,rt)=>{
    if (et && typeof et == "object" || typeof et == "function")
        for (let nt of __getOwnPropNames$1(et))
            !__hasOwnProp$1.call(_e, nt) && nt !== tt && __defProp$1(_e, nt, {
                get: ()=>et[nt],
                enumerable: !(rt = __getOwnPropDesc$1(et, nt)) || rt.enumerable
            });
    return _e
}
  , __toESM$1 = (_e,et,tt)=>(tt = _e != null ? __create$1(__getProtoOf$1(_e)) : {},
__copyProps$1(et || !_e || !_e.__esModule ? __defProp$1(tt, "default", {
    value: _e,
    enumerable: !0
}) : tt, _e))
  , __toCommonJS$1 = _e=>__copyProps$1(__defProp$1({}, "__esModule", {
    value: !0
}), _e)
  , __publicField = (_e,et,tt)=>(__defNormalProp(_e, typeof et != "symbol" ? et + "" : et, tt),
tt)
  , ReactPlayer_exports = {};
__export$1(ReactPlayer_exports, {
    createReactPlayer: ()=>createReactPlayer
});
var ReactPlayer$1 = __toCommonJS$1(ReactPlayer_exports)
  , import_react = __toESM$1(reactExports)
  , import_deepmerge = __toESM$1(cjs)
  , import_memoize_one = __toESM$1(require$$2)
  , import_react_fast_compare = __toESM$1(reactFastCompare)
  , import_props = props
  , import_utils = utils
  , import_Player = __toESM$1(Player_1);
const Preview = (0,
import_utils.lazy)(()=>__vitePreload(()=>import("./Preview-BdCOisuC.js").then(_e=>_e.P), __vite__mapDeps([])))
  , IS_BROWSER = typeof window < "u" && window.document
  , IS_GLOBAL = typeof commonjsGlobal < "u" && commonjsGlobal.window && commonjsGlobal.window.document
  , SUPPORTED_PROPS = Object.keys(import_props.propTypes)
  , UniversalSuspense = IS_BROWSER || IS_GLOBAL ? import_react.Suspense : ()=>null
  , customPlayers = []
  , createReactPlayer = (_e,et)=>{
    var tt;
    return tt = class extends import_react.Component {
        constructor() {
            super(...arguments),
            __publicField(this, "state", {
                showPreview: !!this.props.light
            }),
            __publicField(this, "references", {
                wrapper: rt=>{
                    this.wrapper = rt
                }
                ,
                player: rt=>{
                    this.player = rt
                }
            }),
            __publicField(this, "handleClickPreview", rt=>{
                this.setState({
                    showPreview: !1
                }),
                this.props.onClickPreview(rt)
            }
            ),
            __publicField(this, "showPreview", ()=>{
                this.setState({
                    showPreview: !0
                })
            }
            ),
            __publicField(this, "getDuration", ()=>this.player ? this.player.getDuration() : null),
            __publicField(this, "getCurrentTime", ()=>this.player ? this.player.getCurrentTime() : null),
            __publicField(this, "getSecondsLoaded", ()=>this.player ? this.player.getSecondsLoaded() : null),
            __publicField(this, "getInternalPlayer", (rt="player")=>this.player ? this.player.getInternalPlayer(rt) : null),
            __publicField(this, "seekTo", (rt,nt,it)=>{
                if (!this.player)
                    return null;
                this.player.seekTo(rt, nt, it)
            }
            ),
            __publicField(this, "handleReady", ()=>{
                this.props.onReady(this)
            }
            ),
            __publicField(this, "getActivePlayer", (0,
            import_memoize_one.default)(rt=>{
                for (const nt of [...customPlayers, ..._e])
                    if (nt.canPlay(rt))
                        return nt;
                return et || null
            }
            )),
            __publicField(this, "getConfig", (0,
            import_memoize_one.default)((rt,nt)=>{
                const {config: it} = this.props;
                return import_deepmerge.default.all([import_props.defaultProps.config, import_props.defaultProps.config[nt] || {}, it, it[nt] || {}])
            }
            )),
            __publicField(this, "getAttributes", (0,
            import_memoize_one.default)(rt=>(0,
            import_utils.omit)(this.props, SUPPORTED_PROPS))),
            __publicField(this, "renderActivePlayer", rt=>{
                if (!rt)
                    return null;
                const nt = this.getActivePlayer(rt);
                if (!nt)
                    return null;
                const it = this.getConfig(rt, nt.key);
                return import_react.default.createElement(import_Player.default, {
                    ...this.props,
                    key: nt.key,
                    ref: this.references.player,
                    config: it,
                    activePlayer: nt.lazyPlayer || nt,
                    onReady: this.handleReady
                })
            }
            )
        }
        shouldComponentUpdate(rt, nt) {
            return !(0,
            import_react_fast_compare.default)(this.props, rt) || !(0,
            import_react_fast_compare.default)(this.state, nt)
        }
        componentDidUpdate(rt) {
            const {light: nt} = this.props;
            !rt.light && nt && this.setState({
                showPreview: !0
            }),
            rt.light && !nt && this.setState({
                showPreview: !1
            })
        }
        renderPreview(rt) {
            if (!rt)
                return null;
            const {light: nt, playIcon: it, previewTabIndex: st, oEmbedUrl: at} = this.props;
            return import_react.default.createElement(Preview, {
                url: rt,
                light: nt,
                playIcon: it,
                previewTabIndex: st,
                oEmbedUrl: at,
                onClick: this.handleClickPreview
            })
        }
        render() {
            const {url: rt, style: nt, width: it, height: st, fallback: at, wrapper: ot} = this.props
              , {showPreview: lt} = this.state
              , dt = this.getAttributes(rt)
              , ct = typeof ot == "string" ? this.references.wrapper : void 0;
            return import_react.default.createElement(ot, {
                ref: ct,
                style: {
                    ...nt,
                    width: it,
                    height: st
                },
                ...dt
            }, import_react.default.createElement(UniversalSuspense, {
                fallback: at
            }, lt ? this.renderPreview(rt) : this.renderActivePlayer(rt)))
        }
    }
    ,
    __publicField(tt, "displayName", "ReactPlayer"),
    __publicField(tt, "propTypes", import_props.propTypes),
    __publicField(tt, "defaultProps", import_props.defaultProps),
    __publicField(tt, "addCustomPlayer", rt=>{
        customPlayers.push(rt)
    }
    ),
    __publicField(tt, "removeCustomPlayers", ()=>{
        customPlayers.length = 0
    }
    ),
    __publicField(tt, "canPlay", rt=>{
        for (const nt of [...customPlayers, ..._e])
            if (nt.canPlay(rt))
                return !0;
        return !1
    }
    ),
    __publicField(tt, "canEnablePIP", rt=>{
        for (const nt of [...customPlayers, ..._e])
            if (nt.canEnablePIP && nt.canEnablePIP(rt))
                return !0;
        return !1
    }
    ),
    tt
}
;
var __create = Object.create
  , __defProp = Object.defineProperty
  , __getOwnPropDesc = Object.getOwnPropertyDescriptor
  , __getOwnPropNames = Object.getOwnPropertyNames
  , __getProtoOf = Object.getPrototypeOf
  , __hasOwnProp = Object.prototype.hasOwnProperty
  , __export = (_e,et)=>{
    for (var tt in et)
        __defProp(_e, tt, {
            get: et[tt],
            enumerable: !0
        })
}
  , __copyProps = (_e,et,tt,rt)=>{
    if (et && typeof et == "object" || typeof et == "function")
        for (let nt of __getOwnPropNames(et))
            !__hasOwnProp.call(_e, nt) && nt !== tt && __defProp(_e, nt, {
                get: ()=>et[nt],
                enumerable: !(rt = __getOwnPropDesc(et, nt)) || rt.enumerable
            });
    return _e
}
  , __toESM = (_e,et,tt)=>(tt = _e != null ? __create(__getProtoOf(_e)) : {},
__copyProps(et || !_e || !_e.__esModule ? __defProp(tt, "default", {
    value: _e,
    enumerable: !0
}) : tt, _e))
  , __toCommonJS = _e=>__copyProps(__defProp({}, "__esModule", {
    value: !0
}), _e)
  , src_exports = {};
__export(src_exports, {
    default: ()=>src_default
});
var lazy = __toCommonJS(src_exports)
  , import_players = __toESM(players)
  , import_ReactPlayer = ReactPlayer$1;
const fallback = import_players.default[import_players.default.length - 1];
var src_default = (0,
import_ReactPlayer.createReactPlayer)(import_players.default, fallback);
const ReactPlayer = getDefaultExportFromCjs(lazy)
  , video$1 = "/assets/bnbUsdt-Bq5-juNk.mp4"
  , video2 = "/assets/eth-rtAWEnO_.mp4"
  , video = "/assets/cbtc_how_to_stake-DExAyQzQ.mp4"
  , Video = ()=>jsxRuntimeExports.jsx("div", {
    className: "container-fluid",
    children: jsxRuntimeExports.jsx("div", {
        className: "row",
        children: jsxRuntimeExports.jsxs("div", {
            className: "col-11 mx-auto max-width py-5",
            children: [jsxRuntimeExports.jsx("h2", {
                className: "videoHeading",
                children: "How To Buy"
            }), jsxRuntimeExports.jsx("h4", {
                className: "text-center mb-5",
                children: "BNB & USDT (BEP20)"
            }), jsxRuntimeExports.jsx("div", {
                className: "d-flex justify-content-center mb-5 pb-5",
                children: jsxRuntimeExports.jsx("span", {
                    className: "videoShadow mb-5",
                    children: jsxRuntimeExports.jsx(ReactPlayer, {
                        url: video$1,
                        controls: !0,
                        volume: 1,
                        width: "100%",
                        muted: !1,
                        style: {
                            maxWidth: "640px",
                            border: "4px solid #fbbd18",
                            borderRadius: "10px"
                        }
                    })
                })
            }), jsxRuntimeExports.jsx("h4", {
                className: "text-center my-5",
                children: "ETH (ERC20)"
            }), jsxRuntimeExports.jsx("div", {
                className: "d-flex justify-content-center",
                children: jsxRuntimeExports.jsx("span", {
                    className: "videoShadow mb-5",
                    children: jsxRuntimeExports.jsx(ReactPlayer, {
                        url: video2,
                        controls: !0,
                        volume: 1,
                        width: "100%",
                        muted: !1,
                        style: {
                            maxWidth: "640px",
                            border: "4px solid #fbbd18",
                            borderRadius: "10px"
                        }
                    })
                })
            }), jsxRuntimeExports.jsx("h2", {
                className: "videoHeading mt-5 pt-5 mb-2",
                children: "How To Stake"
            }), jsxRuntimeExports.jsx("h4", {
                className: "text-center mb-5",
                children: "Stake ETH (ERC20)"
            }), jsxRuntimeExports.jsx("div", {
                className: "d-flex justify-content-center mb-5 pb-5",
                children: jsxRuntimeExports.jsx("span", {
                    className: "videoShadow mb-5",
                    children: jsxRuntimeExports.jsx(ReactPlayer, {
                        url: video,
                        controls: !0,
                        volume: 1,
                        width: "100%",
                        muted: !1,
                        style: {
                            maxWidth: "640px",
                            border: "4px solid #fbbd18",
                            borderRadius: "10px"
                        }
                    })
                })
            })]
        })
    })
})
  , StakingVideo = ()=>jsxRuntimeExports.jsx("div", {
    className: "container-fluid",
    children: jsxRuntimeExports.jsx("div", {
        className: "row",
        children: jsxRuntimeExports.jsxs("div", {
            className: "col-11 mx-auto max-width py-5",
            children: [jsxRuntimeExports.jsx("h2", {
                className: "videoHeading",
                children: "How To Stake"
            }), jsxRuntimeExports.jsx("h4", {
                className: "text-center mb-5",
                children: "Stake ETH (ERC20)"
            }), jsxRuntimeExports.jsx("div", {
                className: "d-flex justify-content-center mb-5 pb-5",
                children: jsxRuntimeExports.jsx("span", {
                    className: "videoShadow mb-5",
                    children: jsxRuntimeExports.jsx(ReactPlayer, {
                        url: video,
                        controls: !0,
                        volume: 1,
                        width: "100%",
                        muted: !1,
                        style: {
                            maxWidth: "640px",
                            border: "4px solid #fbbd18",
                            borderRadius: "10px"
                        }
                    })
                })
            })]
        })
    })
})
  , abi = [{
    inputs: [{
        internalType: "address",
        name: "_stakingToken",
        type: "address"
    }],
    stateMutability: "nonpayable",
    type: "constructor"
}, {
    inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
    }],
    name: "OwnableInvalidOwner",
    type: "error"
}, {
    inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
    }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "OwnershipTransferred",
    type: "event"
}, {
    inputs: [],
    name: "pauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bool",
        name: "val",
        type: "bool"
    }],
    name: "setAutoUpdateReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[3]",
        name: "val",
        type: "uint256[3]"
    }],
    name: "setRewardPercentages",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256[4]",
        name: "val",
        type: "uint256[4]"
    }],
    name: "setStakeRewardPerYear",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Staked",
    type: "event"
}, {
    inputs: [{
        internalType: "address",
        name: "newOwner",
        type: "address"
    }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }],
    name: "transferRewardTokensToOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "unpauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "unstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "reward",
        type: "uint256"
    }, {
        indexed: !1,
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }],
    name: "Unstaked",
    type: "event"
}, {
    inputs: [{
        internalType: "uint256[4][3]",
        name: "newRewardPools",
        type: "uint256[4][3]"
    }],
    name: "updateRewardPools",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "newYear",
        type: "uint256"
    }],
    name: "updateYearlyReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "autoUpdateReward",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "calReward",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "currentYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getCurrentPeriod",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getDurationNum",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }],
    name: "getRewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "getTotal",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUnlockTime",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "pure",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "user",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "duration",
        type: "uint8"
    }],
    name: "getUserStake",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "owner",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "periodTotalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPercentages",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "rewardPools",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    name: "rewardsEarned",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    name: "stakeRewardPerYear",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingStartTimestamp",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "stakingToken",
    outputs: [{
        internalType: "contract IERC20",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalRewardPaid",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "totalStaked",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }, {
        internalType: "enum StakingContract.LockDuration",
        name: "",
        type: "uint8"
    }],
    name: "userStakes",
    outputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
    }, {
        internalType: "uint256",
        name: "period",
        type: "uint256"
    }, {
        internalType: "bool",
        name: "exists",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "yearInSeconds",
    outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
}]
  , Admin = ()=>{
    var Cr, Wt, Rt, jt;
    const {address: _e, isConnected: et} = useAccount()
      , tt = useNavigate()
      , rt = reactExports.useRef(null)
      , nt = reactExports.useRef(null)
      , it = reactExports.useRef(null)
      , st = reactExports.useRef(null)
      , at = reactExports.useRef(null)
      , ot = reactExports.useRef(null)
      , lt = reactExports.useRef(null)
      , dt = reactExports.useRef(null)
      , ct = reactExports.useRef(null)
      , ut = reactExports.useRef(null)
      , ft = reactExports.useRef(null)
      , ht = reactExports.useRef(null)
      , {data: gt, error: bt, isError: pt, isLoading: mt, refetch: yt} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi,
        functionName: "calReward",
        args: [(Cr = rt == null ? void 0 : rt.current) == null ? void 0 : Cr.value, Number((Wt = nt == null ? void 0 : nt.current) == null ? void 0 : Wt.value)]
    })
      , {data: vt, error: wt, isError: _t, isLoading: Et, refetch: xt} = useReadContract({
        address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
        abi,
        functionName: "getUserStake",
        args: [(Rt = it == null ? void 0 : it.current) == null ? void 0 : Rt.value, Number((jt = st == null ? void 0 : st.current) == null ? void 0 : jt.value)]
    })
      , {data: Ct, isError: Tt, error: It, isPending: Nt, failureReason: Ft, writeContract: Lt} = useWriteContract()
      , {data: Mt, isError: $t, error: kt, isPending: At, failureReason: Pt, writeContract: Dt} = useWriteContract()
      , {data: Bt, isError: zt, error: Yt, isPending: rr, failureReason: ar, writeContract: or} = useWriteContract()
      , {data: pr, isError: gr, error: Sr, isPending: br, failureReason: Pr, writeContract: Wr} = useWriteContract()
      , {data: _r, isError: hr, error: Vr, isPending: Xr, failureReason: Yr, writeContract: Hr} = useWriteContract();
    reactExports.useEffect(()=>{
        et && _e !== "0xe84C28E595Fa741c5b846e39AE25B257E05c4868" && (tt("/"),
        toastFun("error", "Not Authorized.")),
        et || (tt("/"),
        toastFun("", "Connect to metamask first."))
    }
    , [et]);
    const Gt = async Ht=>{
        var qt, Xt, nr, Er;
        Ht.preventDefault(),
        rt.current && nt.current && ((((qt = rt.current) == null ? void 0 : qt.value) === "" || ((Xt = nt.current) == null ? void 0 : Xt.value) === "") && toastFun("error", "Please fill all fields."),
        console.log((nr = rt.current) == null ? void 0 : nr.value),
        console.log((Er = nt.current) == null ? void 0 : Er.value),
        await yt())
    }
      , Jt = async Ht=>{
        var qt, Xt, nr, Er;
        Ht.preventDefault(),
        it.current && st.current && ((((qt = it.current) == null ? void 0 : qt.value) === "" || ((Xt = st.current) == null ? void 0 : Xt.value) === "") && toastFun("error", "Please fill all fields."),
        console.log((nr = it.current) == null ? void 0 : nr.value),
        console.log((Er = st.current) == null ? void 0 : Er.value),
        await xt())
    }
      , tr = async Ht=>{
        var qt, Xt, nr;
        if (Ht.preventDefault(),
        at.current) {
            ((qt = at.current) == null ? void 0 : qt.value) === "" && toastFun("error", "Please select an option.");
            let Er;
            ((Xt = at.current) == null ? void 0 : Xt.value) === "true" ? Er = !0 : Er = !1,
            console.log((nr = at.current) == null ? void 0 : nr.value),
            Lt({
                address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
                abi,
                functionName: "setAutoUpdateReward",
                args: [Er]
            })
        }
    }
      , lr = async Ht=>{
        var qt, Xt, nr, Er, Dr, kr;
        if (Ht.preventDefault(),
        ot.current && lt.current && dt.current) {
            (((qt = ot.current) == null ? void 0 : qt.value) === "" || ((Xt = lt.current) == null ? void 0 : Xt.value) === "" || ((nr = dt.current) == null ? void 0 : nr.value) === "") && toastFun("error", "Please fill all fields.");
            const Fr = parseEther((Er = ot.current) == null ? void 0 : Er.value)
              , Mr = parseEther((Dr = lt.current) == null ? void 0 : Dr.value)
              , Xn = parseEther((kr = dt.current) == null ? void 0 : kr.value);
            Dt({
                address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
                abi,
                functionName: "setAutoUpdateReward",
                args: [Fr, Mr, Xn]
            })
        }
    }
      , sr = async Ht=>{
        var qt, Xt, nr, Er, Dr, kr, Fr, Mr;
        if (Ht.preventDefault(),
        ct.current && ut.current && ft.current && ht.current) {
            (((qt = ct.current) == null ? void 0 : qt.value) === "" || ((Xt = ut.current) == null ? void 0 : Xt.value) === "" || ((nr = ft.current) == null ? void 0 : nr.value) === "" || ((Er = ht.current) == null ? void 0 : Er.value) === "") && toastFun("error", "Please fill all fields.");
            const Xn = parseEther((Dr = ct.current) == null ? void 0 : Dr.value)
              , yn = parseEther((kr = ut.current) == null ? void 0 : kr.value)
              , ga = parseEther((Fr = ft.current) == null ? void 0 : Fr.value)
              , wn = parseEther((Mr = ht.current) == null ? void 0 : Mr.value);
            or({
                address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
                abi,
                functionName: "setStakeRewardPerYear",
                args: [Xn, yn, ga, wn]
            })
        }
    }
      , ir = async Ht=>{
        Ht.preventDefault(),
        Wr({
            address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
            abi,
            functionName: "pauseStaking"
        })
    }
      , ur = async Ht=>{
        Ht.preventDefault(),
        Hr({
            address: "0xb9b213D92253A405977FFE38Fe8E2bd9c14457a1",
            abi,
            functionName: "unpauseStaking"
        })
    }
    ;
    return jsxRuntimeExports.jsx("div", {
        className: "container-fluid",
        children: jsxRuntimeExports.jsx("div", {
            className: "row",
            children: jsxRuntimeExports.jsxs("div", {
                className: "col-11 mx-auto max-width py-5",
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "row",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6",
                        children: jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsxs("form", {
                                onSubmit: Ht=>{
                                    Gt(Ht)
                                }
                                ,
                                children: [jsxRuntimeExports.jsx("h3", {
                                    className: "text-center",
                                    children: "Calculate Reward"
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-3",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "userAddress",
                                        children: "User Address"
                                    }), jsxRuntimeExports.jsx("input", {
                                        type: "text",
                                        placeholder: "User Address",
                                        className: "form-control",
                                        ref: rt
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-3",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "duration",
                                        children: "Duration"
                                    }), jsxRuntimeExports.jsx("input", {
                                        type: "number",
                                        placeholder: "0 | 1 | 2",
                                        className: "form-control",
                                        ref: nt
                                    })]
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("button", {
                                        type: "submit",
                                        className: "btn btn-success",
                                        children: "Submit"
                                    })
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                className: "mt-5",
                                children: [jsxRuntimeExports.jsx("h4", {
                                    children: "OutPuts of Cal Reward"
                                }), jsxRuntimeExports.jsxs("div", {
                                    children: [!pt && !mt && formatEther(gt ?? 0n), pt && !mt && bt.message.toString(), mt && "Loading..."]
                                })]
                            })]
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6",
                        children: jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsxs("form", {
                                onSubmit: Ht=>{
                                    Jt(Ht)
                                }
                                ,
                                children: [jsxRuntimeExports.jsx("h3", {
                                    className: "text-center",
                                    children: "User Stake"
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-3",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "userAddress",
                                        children: "User Address"
                                    }), jsxRuntimeExports.jsx("input", {
                                        type: "text",
                                        placeholder: "User Address",
                                        className: "form-control",
                                        ref: it
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-3",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "duration",
                                        children: "Duration"
                                    }), jsxRuntimeExports.jsx("input", {
                                        type: "number",
                                        placeholder: "0 | 1 | 2",
                                        className: "form-control",
                                        ref: st
                                    })]
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("button", {
                                        type: "submit",
                                        className: "btn btn-success",
                                        children: "Submit"
                                    })
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                className: "mt-5",
                                children: [jsxRuntimeExports.jsx("h4", {
                                    children: "OutPuts of User Stake"
                                }), jsxRuntimeExports.jsxs("div", {
                                    children: [!_t && !Et && formatEther(vt ?? 0n), _t && !Et && wt.message.toString(), Et && "Loading..."]
                                })]
                            })]
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "row mt-5 pt-5",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 mt-5",
                        children: jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsxs("form", {
                                onSubmit: Ht=>{
                                    tr(Ht)
                                }
                                ,
                                children: [jsxRuntimeExports.jsx("h3", {
                                    className: "text-center mb-4",
                                    children: "Set auto update reward"
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "bool",
                                        children: "Boolean parameter"
                                    }), jsxRuntimeExports.jsxs("select", {
                                        ref: at,
                                        className: "form-control mb-4",
                                        name: "",
                                        id: "bool",
                                        children: [jsxRuntimeExports.jsx("option", {
                                            value: "",
                                            children: "Select Option"
                                        }), jsxRuntimeExports.jsx("option", {
                                            value: "false",
                                            children: "False"
                                        }), jsxRuntimeExports.jsx("option", {
                                            value: "true",
                                            children: "True"
                                        })]
                                    })]
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("button", {
                                        type: "submit",
                                        className: "btn btn-success",
                                        children: "Submit"
                                    })
                                })]
                            }), jsxRuntimeExports.jsx("h3", {
                                className: "mt-5",
                                children: "Response of set auto update reward"
                            }), Nt && "Pending", Tt && (It == null ? void 0 : It.message.toString()), Ft && Ft.message.toString(), Ct && Ct]
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 mt-5",
                        children: jsxRuntimeExports.jsx("div", {
                            children: jsxRuntimeExports.jsxs("form", {
                                onSubmit: lr,
                                children: [jsxRuntimeExports.jsx("h3", {
                                    className: "text-center mb-4",
                                    children: "setRewardPercentages"
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-4",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "arg2",
                                        children: "Argument 1"
                                    }), jsxRuntimeExports.jsx("input", {
                                        className: "form-control",
                                        type: "number",
                                        placeholder: "numbers only",
                                        id: "arg1",
                                        ref: ot
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-4",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "arg2",
                                        children: "Argument 2"
                                    }), jsxRuntimeExports.jsx("input", {
                                        className: "form-control",
                                        type: "number",
                                        placeholder: "numbers only",
                                        id: "arg2",
                                        ref: lt
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-4",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "arg3",
                                        children: "Argument 3"
                                    }), jsxRuntimeExports.jsx("input", {
                                        className: "form-control",
                                        type: "number",
                                        placeholder: "numbers only",
                                        id: "arg3",
                                        ref: dt
                                    })]
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("button", {
                                        type: "submit",
                                        className: "btn btn-success",
                                        children: "Submit"
                                    })
                                }), jsxRuntimeExports.jsx("h3", {
                                    className: "mt-5",
                                    children: "Response of Reward Percentages"
                                }), At && "Pending", $t && (kt == null ? void 0 : kt.message.toString()), Pt && Pt.message.toString(), Mt && Mt]
                            })
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "row mt-5 pt-5",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 mt-5",
                        children: jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsxs("form", {
                                onSubmit: Ht=>{
                                    sr(Ht)
                                }
                                ,
                                children: [jsxRuntimeExports.jsx("h3", {
                                    className: "text-center mb-4",
                                    children: "setStakeRewardPerYear"
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-4",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "arg1",
                                        children: "Argument 1"
                                    }), jsxRuntimeExports.jsx("input", {
                                        className: "form-control",
                                        type: "number",
                                        placeholder: "numbers only",
                                        id: "arg1",
                                        ref: ct
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-4",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "arg2",
                                        children: "Argument 2"
                                    }), jsxRuntimeExports.jsx("input", {
                                        className: "form-control",
                                        type: "number",
                                        placeholder: "numbers only",
                                        id: "arg2",
                                        ref: ut
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-4",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "arg3",
                                        children: "Argument 3"
                                    }), jsxRuntimeExports.jsx("input", {
                                        className: "form-control",
                                        type: "number",
                                        placeholder: "numbers only",
                                        id: "arg3",
                                        ref: ft
                                    })]
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: "form-group mb-4",
                                    children: [jsxRuntimeExports.jsx("label", {
                                        htmlFor: "arg4",
                                        children: "Argument 4"
                                    }), jsxRuntimeExports.jsx("input", {
                                        className: "form-control",
                                        type: "number",
                                        placeholder: "numbers only",
                                        id: "arg4",
                                        ref: ht
                                    })]
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("button", {
                                        type: "submit",
                                        className: "btn btn-success",
                                        children: "Submit"
                                    })
                                })]
                            }), jsxRuntimeExports.jsx("h3", {
                                className: "mt-5",
                                children: "Response of Reward Per Year"
                            }), rr && "Pending", zt && (Yt == null ? void 0 : Yt.message.toString()), ar && ar.message.toString(), Bt && Bt]
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 mt-5",
                        children: jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsxs("form", {
                                children: [jsxRuntimeExports.jsx("h3", {
                                    className: "text-center mb-4",
                                    children: "Pause Staking"
                                }), jsxRuntimeExports.jsx("div", {
                                    className: "form-group",
                                    children: jsxRuntimeExports.jsx("label", {
                                        htmlFor: "no",
                                        children: "No Inputs required."
                                    })
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("button", {
                                        onClick: Ht=>{
                                            ir(Ht)
                                        }
                                        ,
                                        className: "btn btn-success",
                                        children: "Pause"
                                    })
                                })]
                            }), jsxRuntimeExports.jsx("h3", {
                                className: "mt-5",
                                children: "Response of Pause"
                            }), br && "Pending", gr && (Sr == null ? void 0 : Sr.message.toString()), Pr && Pr.message.toString(), pr && pr]
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: "row mt-5 pt-5",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 mt-5",
                        children: jsxRuntimeExports.jsxs("div", {
                            className: "mt-5",
                            children: [jsxRuntimeExports.jsxs("form", {
                                children: [jsxRuntimeExports.jsx("h3", {
                                    className: "text-center mb-4",
                                    children: "Unpause Staking"
                                }), jsxRuntimeExports.jsx("div", {
                                    className: "form-group",
                                    children: jsxRuntimeExports.jsx("label", {
                                        htmlFor: "no",
                                        children: "no inputs required."
                                    })
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("button", {
                                        onClick: Ht=>{
                                            ur(Ht)
                                        }
                                        ,
                                        className: "btn btn-success",
                                        children: "UnPause"
                                    })
                                })]
                            }), jsxRuntimeExports.jsx("h3", {
                                className: "mt-5",
                                children: "Response of UnPause"
                            }), Xr && "Pending", hr && (Vr == null ? void 0 : Vr.message.toString()), Yr && Yr.message.toString(), _r && _r]
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: "col-lg-6 mt-5",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "mt-5"
                        })
                    })]
                })]
            })
        })
    })
}
;
ReactGA.initialize("G-DS43BVZWV1");
ReactGA.send({
    hitType: "pageview",
    page: window.location.pathname
});
function App() {
    return jsxRuntimeExports.jsxs(BrowserRouter, {
        children: [jsxRuntimeExports.jsx(Q, {}), jsxRuntimeExports.jsx(Routes, {
            children: jsxRuntimeExports.jsxs(Route, {
                path: "/",
                element: jsxRuntimeExports.jsx(Layout, {}),
                children: [jsxRuntimeExports.jsx(Route, {
                    index: !0,
                    element: jsxRuntimeExports.jsx(Home, {})
                }), jsxRuntimeExports.jsx(Route, {
                    path: "staking",
                    element: jsxRuntimeExports.jsx(Staking, {})
                }), jsxRuntimeExports.jsx(Route, {
                    path: "how",
                    element: jsxRuntimeExports.jsx(Video, {})
                }), jsxRuntimeExports.jsx(Route, {
                    path: "how-stake",
                    element: jsxRuntimeExports.jsx(StakingVideo, {})
                }), jsxRuntimeExports.jsx(Route, {
                    path: "admin",
                    element: jsxRuntimeExports.jsx(Admin, {})
                })]
            })
        })]
    })
}
var bootstrap_bundle_min = {
    exports: {}
};
/*!
  * Bootstrap v5.0.2 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function(_e, et) {
    (function(tt, rt) {
        _e.exports = rt()
    }
    )(commonjsGlobal, function() {
        const tt = {
            find: (Ut,St=document.documentElement)=>[].concat(...Element.prototype.querySelectorAll.call(St, Ut)),
            findOne: (Ut,St=document.documentElement)=>Element.prototype.querySelector.call(St, Ut),
            children: (Ut,St)=>[].concat(...Ut.children).filter(Ot=>Ot.matches(St)),
            parents(Ut, St) {
                const Ot = [];
                let Vt = Ut.parentNode;
                for (; Vt && Vt.nodeType === Node.ELEMENT_NODE && Vt.nodeType !== 3; )
                    Vt.matches(St) && Ot.push(Vt),
                    Vt = Vt.parentNode;
                return Ot
            },
            prev(Ut, St) {
                let Ot = Ut.previousElementSibling;
                for (; Ot; ) {
                    if (Ot.matches(St))
                        return [Ot];
                    Ot = Ot.previousElementSibling
                }
                return []
            },
            next(Ut, St) {
                let Ot = Ut.nextElementSibling;
                for (; Ot; ) {
                    if (Ot.matches(St))
                        return [Ot];
                    Ot = Ot.nextElementSibling
                }
                return []
            }
        }
          , rt = Ut=>{
            do
                Ut += Math.floor(1e6 * Math.random());
            while (document.getElementById(Ut));
            return Ut
        }
          , nt = Ut=>{
            let St = Ut.getAttribute("data-bs-target");
            if (!St || St === "#") {
                let Ot = Ut.getAttribute("href");
                if (!Ot || !Ot.includes("#") && !Ot.startsWith("."))
                    return null;
                Ot.includes("#") && !Ot.startsWith("#") && (Ot = "#" + Ot.split("#")[1]),
                St = Ot && Ot !== "#" ? Ot.trim() : null
            }
            return St
        }
          , it = Ut=>{
            const St = nt(Ut);
            return St && document.querySelector(St) ? St : null
        }
          , st = Ut=>{
            const St = nt(Ut);
            return St ? document.querySelector(St) : null
        }
          , at = Ut=>{
            Ut.dispatchEvent(new Event("transitionend"))
        }
          , ot = Ut=>!(!Ut || typeof Ut != "object") && (Ut.jquery !== void 0 && (Ut = Ut[0]),
        Ut.nodeType !== void 0)
          , lt = Ut=>ot(Ut) ? Ut.jquery ? Ut[0] : Ut : typeof Ut == "string" && Ut.length > 0 ? tt.findOne(Ut) : null
          , dt = (Ut,St,Ot)=>{
            Object.keys(Ot).forEach(Vt=>{
                const Zt = Ot[Vt]
                  , Qt = St[Vt]
                  , er = Qt && ot(Qt) ? "element" : (cr = Qt) == null ? "" + cr : {}.toString.call(cr).match(/\s([a-z]+)/i)[1].toLowerCase();
                var cr;
                if (!new RegExp(Zt).test(er))
                    throw new TypeError(`${Ut.toUpperCase()}: Option "${Vt}" provided type "${er}" but expected type "${Zt}".`)
            }
            )
        }
          , ct = Ut=>!(!ot(Ut) || Ut.getClientRects().length === 0) && getComputedStyle(Ut).getPropertyValue("visibility") === "visible"
          , ut = Ut=>!Ut || Ut.nodeType !== Node.ELEMENT_NODE || !!Ut.classList.contains("disabled") || (Ut.disabled !== void 0 ? Ut.disabled : Ut.hasAttribute("disabled") && Ut.getAttribute("disabled") !== "false")
          , ft = Ut=>{
            if (!document.documentElement.attachShadow)
                return null;
            if (typeof Ut.getRootNode == "function") {
                const St = Ut.getRootNode();
                return St instanceof ShadowRoot ? St : null
            }
            return Ut instanceof ShadowRoot ? Ut : Ut.parentNode ? ft(Ut.parentNode) : null
        }
          , ht = ()=>{}
          , gt = Ut=>Ut.offsetHeight
          , bt = ()=>{
            const {jQuery: Ut} = window;
            return Ut && !document.body.hasAttribute("data-bs-no-jquery") ? Ut : null
        }
          , pt = []
          , mt = ()=>document.documentElement.dir === "rtl"
          , yt = Ut=>{
            var St;
            St = ()=>{
                const Ot = bt();
                if (Ot) {
                    const Vt = Ut.NAME
                      , Zt = Ot.fn[Vt];
                    Ot.fn[Vt] = Ut.jQueryInterface,
                    Ot.fn[Vt].Constructor = Ut,
                    Ot.fn[Vt].noConflict = ()=>(Ot.fn[Vt] = Zt,
                    Ut.jQueryInterface)
                }
            }
            ,
            document.readyState === "loading" ? (pt.length || document.addEventListener("DOMContentLoaded", ()=>{
                pt.forEach(Ot=>Ot())
            }
            ),
            pt.push(St)) : St()
        }
          , vt = Ut=>{
            typeof Ut == "function" && Ut()
        }
          , wt = (Ut,St,Ot=!0)=>{
            if (!Ot)
                return void vt(Ut);
            const Vt = (er=>{
                if (!er)
                    return 0;
                let {transitionDuration: cr, transitionDelay: dr} = window.getComputedStyle(er);
                const mr = Number.parseFloat(cr)
                  , xr = Number.parseFloat(dr);
                return mr || xr ? (cr = cr.split(",")[0],
                dr = dr.split(",")[0],
                1e3 * (Number.parseFloat(cr) + Number.parseFloat(dr))) : 0
            }
            )(St) + 5;
            let Zt = !1;
            const Qt = ({target: er})=>{
                er === St && (Zt = !0,
                St.removeEventListener("transitionend", Qt),
                vt(Ut))
            }
            ;
            St.addEventListener("transitionend", Qt),
            setTimeout(()=>{
                Zt || at(St)
            }
            , Vt)
        }
          , _t = (Ut,St,Ot,Vt)=>{
            let Zt = Ut.indexOf(St);
            if (Zt === -1)
                return Ut[!Ot && Vt ? Ut.length - 1 : 0];
            const Qt = Ut.length;
            return Zt += Ot ? 1 : -1,
            Vt && (Zt = (Zt + Qt) % Qt),
            Ut[Math.max(0, Math.min(Zt, Qt - 1))]
        }
          , Et = /[^.]*(?=\..*)\.|.*/
          , xt = /\..*/
          , Ct = /::\d+$/
          , Tt = {};
        let It = 1;
        const Nt = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        }
          , Ft = /^(mouseenter|mouseleave)/i
          , Lt = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
        function Mt(Ut, St) {
            return St && `${St}::${It++}` || Ut.uidEvent || It++
        }
        function $t(Ut) {
            const St = Mt(Ut);
            return Ut.uidEvent = St,
            Tt[St] = Tt[St] || {},
            Tt[St]
        }
        function kt(Ut, St, Ot=null) {
            const Vt = Object.keys(Ut);
            for (let Zt = 0, Qt = Vt.length; Zt < Qt; Zt++) {
                const er = Ut[Vt[Zt]];
                if (er.originalHandler === St && er.delegationSelector === Ot)
                    return er
            }
            return null
        }
        function At(Ut, St, Ot) {
            const Vt = typeof St == "string"
              , Zt = Vt ? Ot : St;
            let Qt = Bt(Ut);
            return Lt.has(Qt) || (Qt = Ut),
            [Vt, Zt, Qt]
        }
        function Pt(Ut, St, Ot, Vt, Zt) {
            if (typeof St != "string" || !Ut)
                return;
            if (Ot || (Ot = Vt,
            Vt = null),
            Ft.test(St)) {
                const $r = Ar=>function(jr) {
                    if (!jr.relatedTarget || jr.relatedTarget !== jr.delegateTarget && !jr.delegateTarget.contains(jr.relatedTarget))
                        return Ar.call(this, jr)
                }
                ;
                Vt ? Vt = $r(Vt) : Ot = $r(Ot)
            }
            const [Qt,er,cr] = At(St, Ot, Vt)
              , dr = $t(Ut)
              , mr = dr[cr] || (dr[cr] = {})
              , xr = kt(mr, er, Qt ? Ot : null);
            if (xr)
                return void (xr.oneOff = xr.oneOff && Zt);
            const yr = Mt(er, St.replace(Et, ""))
              , Rr = Qt ? function($r, Ar, jr) {
                return function Ir(zr) {
                    const Ur = $r.querySelectorAll(Ar);
                    for (let {target: Lr} = zr; Lr && Lr !== this; Lr = Lr.parentNode)
                        for (let Tr = Ur.length; Tr--; )
                            if (Ur[Tr] === Lr)
                                return zr.delegateTarget = Lr,
                                Ir.oneOff && zt.off($r, zr.type, Ar, jr),
                                jr.apply(Lr, [zr]);
                    return null
                }
            }(Ut, Ot, Vt) : function($r, Ar) {
                return function jr(Ir) {
                    return Ir.delegateTarget = $r,
                    jr.oneOff && zt.off($r, Ir.type, Ar),
                    Ar.apply($r, [Ir])
                }
            }(Ut, Ot);
            Rr.delegationSelector = Qt ? Ot : null,
            Rr.originalHandler = er,
            Rr.oneOff = Zt,
            Rr.uidEvent = yr,
            mr[yr] = Rr,
            Ut.addEventListener(cr, Rr, Qt)
        }
        function Dt(Ut, St, Ot, Vt, Zt) {
            const Qt = kt(St[Ot], Vt, Zt);
            Qt && (Ut.removeEventListener(Ot, Qt, !!Zt),
            delete St[Ot][Qt.uidEvent])
        }
        function Bt(Ut) {
            return Ut = Ut.replace(xt, ""),
            Nt[Ut] || Ut
        }
        const zt = {
            on(Ut, St, Ot, Vt) {
                Pt(Ut, St, Ot, Vt, !1)
            },
            one(Ut, St, Ot, Vt) {
                Pt(Ut, St, Ot, Vt, !0)
            },
            off(Ut, St, Ot, Vt) {
                if (typeof St != "string" || !Ut)
                    return;
                const [Zt,Qt,er] = At(St, Ot, Vt)
                  , cr = er !== St
                  , dr = $t(Ut)
                  , mr = St.startsWith(".");
                if (Qt !== void 0)
                    return !dr || !dr[er] ? void 0 : void Dt(Ut, dr, er, Qt, Zt ? Ot : null);
                mr && Object.keys(dr).forEach(yr=>{
                    (function(Rr, $r, Ar, jr) {
                        const Ir = $r[Ar] || {};
                        Object.keys(Ir).forEach(zr=>{
                            if (zr.includes(jr)) {
                                const Ur = Ir[zr];
                                Dt(Rr, $r, Ar, Ur.originalHandler, Ur.delegationSelector)
                            }
                        }
                        )
                    }
                    )(Ut, dr, yr, St.slice(1))
                }
                );
                const xr = dr[er] || {};
                Object.keys(xr).forEach(yr=>{
                    const Rr = yr.replace(Ct, "");
                    if (!cr || St.includes(Rr)) {
                        const $r = xr[yr];
                        Dt(Ut, dr, er, $r.originalHandler, $r.delegationSelector)
                    }
                }
                )
            },
            trigger(Ut, St, Ot) {
                if (typeof St != "string" || !Ut)
                    return null;
                const Vt = bt()
                  , Zt = Bt(St)
                  , Qt = St !== Zt
                  , er = Lt.has(Zt);
                let cr, dr = !0, mr = !0, xr = !1, yr = null;
                return Qt && Vt && (cr = Vt.Event(St, Ot),
                Vt(Ut).trigger(cr),
                dr = !cr.isPropagationStopped(),
                mr = !cr.isImmediatePropagationStopped(),
                xr = cr.isDefaultPrevented()),
                er ? (yr = document.createEvent("HTMLEvents"),
                yr.initEvent(Zt, dr, !0)) : yr = new CustomEvent(St,{
                    bubbles: dr,
                    cancelable: !0
                }),
                Ot !== void 0 && Object.keys(Ot).forEach(Rr=>{
                    Object.defineProperty(yr, Rr, {
                        get: ()=>Ot[Rr]
                    })
                }
                ),
                xr && yr.preventDefault(),
                mr && Ut.dispatchEvent(yr),
                yr.defaultPrevented && cr !== void 0 && cr.preventDefault(),
                yr
            }
        }
          , Yt = new Map;
        var rr = {
            set(Ut, St, Ot) {
                Yt.has(Ut) || Yt.set(Ut, new Map);
                const Vt = Yt.get(Ut);
                Vt.has(St) || Vt.size === 0 ? Vt.set(St, Ot) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(Vt.keys())[0]}.`)
            },
            get: (Ut,St)=>Yt.has(Ut) && Yt.get(Ut).get(St) || null,
            remove(Ut, St) {
                if (!Yt.has(Ut))
                    return;
                const Ot = Yt.get(Ut);
                Ot.delete(St),
                Ot.size === 0 && Yt.delete(Ut)
            }
        };
        class ar {
            constructor(St) {
                (St = lt(St)) && (this._element = St,
                rr.set(this._element, this.constructor.DATA_KEY, this))
            }
            dispose() {
                rr.remove(this._element, this.constructor.DATA_KEY),
                zt.off(this._element, this.constructor.EVENT_KEY),
                Object.getOwnPropertyNames(this).forEach(St=>{
                    this[St] = null
                }
                )
            }
            _queueCallback(St, Ot, Vt=!0) {
                wt(St, Ot, Vt)
            }
            static getInstance(St) {
                return rr.get(St, this.DATA_KEY)
            }
            static getOrCreateInstance(St, Ot={}) {
                return this.getInstance(St) || new this(St,typeof Ot == "object" ? Ot : null)
            }
            static get VERSION() {
                return "5.0.2"
            }
            static get NAME() {
                throw new Error('You have to implement the static method "NAME", for each component!')
            }
            static get DATA_KEY() {
                return "bs." + this.NAME
            }
            static get EVENT_KEY() {
                return "." + this.DATA_KEY
            }
        }
        class or extends ar {
            static get NAME() {
                return "alert"
            }
            close(St) {
                const Ot = St ? this._getRootElement(St) : this._element
                  , Vt = this._triggerCloseEvent(Ot);
                Vt === null || Vt.defaultPrevented || this._removeElement(Ot)
            }
            _getRootElement(St) {
                return st(St) || St.closest(".alert")
            }
            _triggerCloseEvent(St) {
                return zt.trigger(St, "close.bs.alert")
            }
            _removeElement(St) {
                St.classList.remove("show");
                const Ot = St.classList.contains("fade");
                this._queueCallback(()=>this._destroyElement(St), St, Ot)
            }
            _destroyElement(St) {
                St.remove(),
                zt.trigger(St, "closed.bs.alert")
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = or.getOrCreateInstance(this);
                    St === "close" && Ot[St](this)
                })
            }
            static handleDismiss(St) {
                return function(Ot) {
                    Ot && Ot.preventDefault(),
                    St.close(this)
                }
            }
        }
        zt.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', or.handleDismiss(new or)),
        yt(or);
        class pr extends ar {
            static get NAME() {
                return "button"
            }
            toggle() {
                this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = pr.getOrCreateInstance(this);
                    St === "toggle" && Ot[St]()
                })
            }
        }
        function gr(Ut) {
            return Ut === "true" || Ut !== "false" && (Ut === Number(Ut).toString() ? Number(Ut) : Ut === "" || Ut === "null" ? null : Ut)
        }
        function Sr(Ut) {
            return Ut.replace(/[A-Z]/g, St=>"-" + St.toLowerCase())
        }
        zt.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', Ut=>{
            Ut.preventDefault();
            const St = Ut.target.closest('[data-bs-toggle="button"]');
            pr.getOrCreateInstance(St).toggle()
        }
        ),
        yt(pr);
        const br = {
            setDataAttribute(Ut, St, Ot) {
                Ut.setAttribute("data-bs-" + Sr(St), Ot)
            },
            removeDataAttribute(Ut, St) {
                Ut.removeAttribute("data-bs-" + Sr(St))
            },
            getDataAttributes(Ut) {
                if (!Ut)
                    return {};
                const St = {};
                return Object.keys(Ut.dataset).filter(Ot=>Ot.startsWith("bs")).forEach(Ot=>{
                    let Vt = Ot.replace(/^bs/, "");
                    Vt = Vt.charAt(0).toLowerCase() + Vt.slice(1, Vt.length),
                    St[Vt] = gr(Ut.dataset[Ot])
                }
                ),
                St
            },
            getDataAttribute: (Ut,St)=>gr(Ut.getAttribute("data-bs-" + Sr(St))),
            offset(Ut) {
                const St = Ut.getBoundingClientRect();
                return {
                    top: St.top + document.body.scrollTop,
                    left: St.left + document.body.scrollLeft
                }
            },
            position: Ut=>({
                top: Ut.offsetTop,
                left: Ut.offsetLeft
            })
        }
          , Pr = {
            interval: 5e3,
            keyboard: !0,
            slide: !1,
            pause: "hover",
            wrap: !0,
            touch: !0
        }
          , Wr = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            slide: "(boolean|string)",
            pause: "(string|boolean)",
            wrap: "boolean",
            touch: "boolean"
        }
          , _r = "next"
          , hr = "prev"
          , Vr = "left"
          , Xr = "right"
          , Yr = {
            ArrowLeft: Xr,
            ArrowRight: Vr
        };
        class Hr extends ar {
            constructor(St, Ot) {
                super(St),
                this._items = null,
                this._interval = null,
                this._activeElement = null,
                this._isPaused = !1,
                this._isSliding = !1,
                this.touchTimeout = null,
                this.touchStartX = 0,
                this.touchDeltaX = 0,
                this._config = this._getConfig(Ot),
                this._indicatorsElement = tt.findOne(".carousel-indicators", this._element),
                this._touchSupported = "ontouchstart"in document.documentElement || navigator.maxTouchPoints > 0,
                this._pointerEvent = !!window.PointerEvent,
                this._addEventListeners()
            }
            static get Default() {
                return Pr
            }
            static get NAME() {
                return "carousel"
            }
            next() {
                this._slide(_r)
            }
            nextWhenVisible() {
                !document.hidden && ct(this._element) && this.next()
            }
            prev() {
                this._slide(hr)
            }
            pause(St) {
                St || (this._isPaused = !0),
                tt.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (at(this._element),
                this.cycle(!0)),
                clearInterval(this._interval),
                this._interval = null
            }
            cycle(St) {
                St || (this._isPaused = !1),
                this._interval && (clearInterval(this._interval),
                this._interval = null),
                this._config && this._config.interval && !this._isPaused && (this._updateInterval(),
                this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
            }
            to(St) {
                this._activeElement = tt.findOne(".active.carousel-item", this._element);
                const Ot = this._getItemIndex(this._activeElement);
                if (St > this._items.length - 1 || St < 0)
                    return;
                if (this._isSliding)
                    return void zt.one(this._element, "slid.bs.carousel", ()=>this.to(St));
                if (Ot === St)
                    return this.pause(),
                    void this.cycle();
                const Vt = St > Ot ? _r : hr;
                this._slide(Vt, this._items[St])
            }
            _getConfig(St) {
                return St = {
                    ...Pr,
                    ...br.getDataAttributes(this._element),
                    ...typeof St == "object" ? St : {}
                },
                dt("carousel", St, Wr),
                St
            }
            _handleSwipe() {
                const St = Math.abs(this.touchDeltaX);
                if (St <= 40)
                    return;
                const Ot = St / this.touchDeltaX;
                this.touchDeltaX = 0,
                Ot && this._slide(Ot > 0 ? Xr : Vr)
            }
            _addEventListeners() {
                this._config.keyboard && zt.on(this._element, "keydown.bs.carousel", St=>this._keydown(St)),
                this._config.pause === "hover" && (zt.on(this._element, "mouseenter.bs.carousel", St=>this.pause(St)),
                zt.on(this._element, "mouseleave.bs.carousel", St=>this.cycle(St))),
                this._config.touch && this._touchSupported && this._addTouchEventListeners()
            }
            _addTouchEventListeners() {
                const St = Zt=>{
                    !this._pointerEvent || Zt.pointerType !== "pen" && Zt.pointerType !== "touch" ? this._pointerEvent || (this.touchStartX = Zt.touches[0].clientX) : this.touchStartX = Zt.clientX
                }
                  , Ot = Zt=>{
                    this.touchDeltaX = Zt.touches && Zt.touches.length > 1 ? 0 : Zt.touches[0].clientX - this.touchStartX
                }
                  , Vt = Zt=>{
                    !this._pointerEvent || Zt.pointerType !== "pen" && Zt.pointerType !== "touch" || (this.touchDeltaX = Zt.clientX - this.touchStartX),
                    this._handleSwipe(),
                    this._config.pause === "hover" && (this.pause(),
                    this.touchTimeout && clearTimeout(this.touchTimeout),
                    this.touchTimeout = setTimeout(Qt=>this.cycle(Qt), 500 + this._config.interval))
                }
                ;
                tt.find(".carousel-item img", this._element).forEach(Zt=>{
                    zt.on(Zt, "dragstart.bs.carousel", Qt=>Qt.preventDefault())
                }
                ),
                this._pointerEvent ? (zt.on(this._element, "pointerdown.bs.carousel", Zt=>St(Zt)),
                zt.on(this._element, "pointerup.bs.carousel", Zt=>Vt(Zt)),
                this._element.classList.add("pointer-event")) : (zt.on(this._element, "touchstart.bs.carousel", Zt=>St(Zt)),
                zt.on(this._element, "touchmove.bs.carousel", Zt=>Ot(Zt)),
                zt.on(this._element, "touchend.bs.carousel", Zt=>Vt(Zt)))
            }
            _keydown(St) {
                if (/input|textarea/i.test(St.target.tagName))
                    return;
                const Ot = Yr[St.key];
                Ot && (St.preventDefault(),
                this._slide(Ot))
            }
            _getItemIndex(St) {
                return this._items = St && St.parentNode ? tt.find(".carousel-item", St.parentNode) : [],
                this._items.indexOf(St)
            }
            _getItemByOrder(St, Ot) {
                const Vt = St === _r;
                return _t(this._items, Ot, Vt, this._config.wrap)
            }
            _triggerSlideEvent(St, Ot) {
                const Vt = this._getItemIndex(St)
                  , Zt = this._getItemIndex(tt.findOne(".active.carousel-item", this._element));
                return zt.trigger(this._element, "slide.bs.carousel", {
                    relatedTarget: St,
                    direction: Ot,
                    from: Zt,
                    to: Vt
                })
            }
            _setActiveIndicatorElement(St) {
                if (this._indicatorsElement) {
                    const Ot = tt.findOne(".active", this._indicatorsElement);
                    Ot.classList.remove("active"),
                    Ot.removeAttribute("aria-current");
                    const Vt = tt.find("[data-bs-target]", this._indicatorsElement);
                    for (let Zt = 0; Zt < Vt.length; Zt++)
                        if (Number.parseInt(Vt[Zt].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(St)) {
                            Vt[Zt].classList.add("active"),
                            Vt[Zt].setAttribute("aria-current", "true");
                            break
                        }
                }
            }
            _updateInterval() {
                const St = this._activeElement || tt.findOne(".active.carousel-item", this._element);
                if (!St)
                    return;
                const Ot = Number.parseInt(St.getAttribute("data-bs-interval"), 10);
                Ot ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval,
                this._config.interval = Ot) : this._config.interval = this._config.defaultInterval || this._config.interval
            }
            _slide(St, Ot) {
                const Vt = this._directionToOrder(St)
                  , Zt = tt.findOne(".active.carousel-item", this._element)
                  , Qt = this._getItemIndex(Zt)
                  , er = Ot || this._getItemByOrder(Vt, Zt)
                  , cr = this._getItemIndex(er)
                  , dr = !!this._interval
                  , mr = Vt === _r
                  , xr = mr ? "carousel-item-start" : "carousel-item-end"
                  , yr = mr ? "carousel-item-next" : "carousel-item-prev"
                  , Rr = this._orderToDirection(Vt);
                if (er && er.classList.contains("active"))
                    return void (this._isSliding = !1);
                if (this._isSliding || this._triggerSlideEvent(er, Rr).defaultPrevented || !Zt || !er)
                    return;
                this._isSliding = !0,
                dr && this.pause(),
                this._setActiveIndicatorElement(er),
                this._activeElement = er;
                const $r = ()=>{
                    zt.trigger(this._element, "slid.bs.carousel", {
                        relatedTarget: er,
                        direction: Rr,
                        from: Qt,
                        to: cr
                    })
                }
                ;
                if (this._element.classList.contains("slide")) {
                    er.classList.add(yr),
                    gt(er),
                    Zt.classList.add(xr),
                    er.classList.add(xr);
                    const Ar = ()=>{
                        er.classList.remove(xr, yr),
                        er.classList.add("active"),
                        Zt.classList.remove("active", yr, xr),
                        this._isSliding = !1,
                        setTimeout($r, 0)
                    }
                    ;
                    this._queueCallback(Ar, Zt, !0)
                } else
                    Zt.classList.remove("active"),
                    er.classList.add("active"),
                    this._isSliding = !1,
                    $r();
                dr && this.cycle()
            }
            _directionToOrder(St) {
                return [Xr, Vr].includes(St) ? mt() ? St === Vr ? hr : _r : St === Vr ? _r : hr : St
            }
            _orderToDirection(St) {
                return [_r, hr].includes(St) ? mt() ? St === hr ? Vr : Xr : St === hr ? Xr : Vr : St
            }
            static carouselInterface(St, Ot) {
                const Vt = Hr.getOrCreateInstance(St, Ot);
                let {_config: Zt} = Vt;
                typeof Ot == "object" && (Zt = {
                    ...Zt,
                    ...Ot
                });
                const Qt = typeof Ot == "string" ? Ot : Zt.slide;
                if (typeof Ot == "number")
                    Vt.to(Ot);
                else if (typeof Qt == "string") {
                    if (Vt[Qt] === void 0)
                        throw new TypeError(`No method named "${Qt}"`);
                    Vt[Qt]()
                } else
                    Zt.interval && Zt.ride && (Vt.pause(),
                    Vt.cycle())
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    Hr.carouselInterface(this, St)
                })
            }
            static dataApiClickHandler(St) {
                const Ot = st(this);
                if (!Ot || !Ot.classList.contains("carousel"))
                    return;
                const Vt = {
                    ...br.getDataAttributes(Ot),
                    ...br.getDataAttributes(this)
                }
                  , Zt = this.getAttribute("data-bs-slide-to");
                Zt && (Vt.interval = !1),
                Hr.carouselInterface(Ot, Vt),
                Zt && Hr.getInstance(Ot).to(Zt),
                St.preventDefault()
            }
        }
        zt.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Hr.dataApiClickHandler),
        zt.on(window, "load.bs.carousel.data-api", ()=>{
            const Ut = tt.find('[data-bs-ride="carousel"]');
            for (let St = 0, Ot = Ut.length; St < Ot; St++)
                Hr.carouselInterface(Ut[St], Hr.getInstance(Ut[St]))
        }
        ),
        yt(Hr);
        const Gt = {
            toggle: !0,
            parent: ""
        }
          , Jt = {
            toggle: "boolean",
            parent: "(string|element)"
        };
        class tr extends ar {
            constructor(St, Ot) {
                super(St),
                this._isTransitioning = !1,
                this._config = this._getConfig(Ot),
                this._triggerArray = tt.find(`[data-bs-toggle="collapse"][href="#${this._element.id}"],[data-bs-toggle="collapse"][data-bs-target="#${this._element.id}"]`);
                const Vt = tt.find('[data-bs-toggle="collapse"]');
                for (let Zt = 0, Qt = Vt.length; Zt < Qt; Zt++) {
                    const er = Vt[Zt]
                      , cr = it(er)
                      , dr = tt.find(cr).filter(mr=>mr === this._element);
                    cr !== null && dr.length && (this._selector = cr,
                    this._triggerArray.push(er))
                }
                this._parent = this._config.parent ? this._getParent() : null,
                this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray),
                this._config.toggle && this.toggle()
            }
            static get Default() {
                return Gt
            }
            static get NAME() {
                return "collapse"
            }
            toggle() {
                this._element.classList.contains("show") ? this.hide() : this.show()
            }
            show() {
                if (this._isTransitioning || this._element.classList.contains("show"))
                    return;
                let St, Ot;
                this._parent && (St = tt.find(".show, .collapsing", this._parent).filter(er=>typeof this._config.parent == "string" ? er.getAttribute("data-bs-parent") === this._config.parent : er.classList.contains("collapse")),
                St.length === 0 && (St = null));
                const Vt = tt.findOne(this._selector);
                if (St) {
                    const er = St.find(cr=>Vt !== cr);
                    if (Ot = er ? tr.getInstance(er) : null,
                    Ot && Ot._isTransitioning)
                        return
                }
                if (zt.trigger(this._element, "show.bs.collapse").defaultPrevented)
                    return;
                St && St.forEach(er=>{
                    Vt !== er && tr.collapseInterface(er, "hide"),
                    Ot || rr.set(er, "bs.collapse", null)
                }
                );
                const Zt = this._getDimension();
                this._element.classList.remove("collapse"),
                this._element.classList.add("collapsing"),
                this._element.style[Zt] = 0,
                this._triggerArray.length && this._triggerArray.forEach(er=>{
                    er.classList.remove("collapsed"),
                    er.setAttribute("aria-expanded", !0)
                }
                ),
                this.setTransitioning(!0);
                const Qt = "scroll" + (Zt[0].toUpperCase() + Zt.slice(1));
                this._queueCallback(()=>{
                    this._element.classList.remove("collapsing"),
                    this._element.classList.add("collapse", "show"),
                    this._element.style[Zt] = "",
                    this.setTransitioning(!1),
                    zt.trigger(this._element, "shown.bs.collapse")
                }
                , this._element, !0),
                this._element.style[Zt] = this._element[Qt] + "px"
            }
            hide() {
                if (this._isTransitioning || !this._element.classList.contains("show") || zt.trigger(this._element, "hide.bs.collapse").defaultPrevented)
                    return;
                const St = this._getDimension();
                this._element.style[St] = this._element.getBoundingClientRect()[St] + "px",
                gt(this._element),
                this._element.classList.add("collapsing"),
                this._element.classList.remove("collapse", "show");
                const Ot = this._triggerArray.length;
                if (Ot > 0)
                    for (let Vt = 0; Vt < Ot; Vt++) {
                        const Zt = this._triggerArray[Vt]
                          , Qt = st(Zt);
                        Qt && !Qt.classList.contains("show") && (Zt.classList.add("collapsed"),
                        Zt.setAttribute("aria-expanded", !1))
                    }
                this.setTransitioning(!0),
                this._element.style[St] = "",
                this._queueCallback(()=>{
                    this.setTransitioning(!1),
                    this._element.classList.remove("collapsing"),
                    this._element.classList.add("collapse"),
                    zt.trigger(this._element, "hidden.bs.collapse")
                }
                , this._element, !0)
            }
            setTransitioning(St) {
                this._isTransitioning = St
            }
            _getConfig(St) {
                return (St = {
                    ...Gt,
                    ...St
                }).toggle = !!St.toggle,
                dt("collapse", St, Jt),
                St
            }
            _getDimension() {
                return this._element.classList.contains("width") ? "width" : "height"
            }
            _getParent() {
                let {parent: St} = this._config;
                St = lt(St);
                const Ot = `[data-bs-toggle="collapse"][data-bs-parent="${St}"]`;
                return tt.find(Ot, St).forEach(Vt=>{
                    const Zt = st(Vt);
                    this._addAriaAndCollapsedClass(Zt, [Vt])
                }
                ),
                St
            }
            _addAriaAndCollapsedClass(St, Ot) {
                if (!St || !Ot.length)
                    return;
                const Vt = St.classList.contains("show");
                Ot.forEach(Zt=>{
                    Vt ? Zt.classList.remove("collapsed") : Zt.classList.add("collapsed"),
                    Zt.setAttribute("aria-expanded", Vt)
                }
                )
            }
            static collapseInterface(St, Ot) {
                let Vt = tr.getInstance(St);
                const Zt = {
                    ...Gt,
                    ...br.getDataAttributes(St),
                    ...typeof Ot == "object" && Ot ? Ot : {}
                };
                if (!Vt && Zt.toggle && typeof Ot == "string" && /show|hide/.test(Ot) && (Zt.toggle = !1),
                Vt || (Vt = new tr(St,Zt)),
                typeof Ot == "string") {
                    if (Vt[Ot] === void 0)
                        throw new TypeError(`No method named "${Ot}"`);
                    Vt[Ot]()
                }
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    tr.collapseInterface(this, St)
                })
            }
        }
        zt.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', function(Ut) {
            (Ut.target.tagName === "A" || Ut.delegateTarget && Ut.delegateTarget.tagName === "A") && Ut.preventDefault();
            const St = br.getDataAttributes(this)
              , Ot = it(this);
            tt.find(Ot).forEach(Vt=>{
                const Zt = tr.getInstance(Vt);
                let Qt;
                Zt ? (Zt._parent === null && typeof St.parent == "string" && (Zt._config.parent = St.parent,
                Zt._parent = Zt._getParent()),
                Qt = "toggle") : Qt = St,
                tr.collapseInterface(Vt, Qt)
            }
            )
        }),
        yt(tr);
        var lr = "top"
          , sr = "bottom"
          , ir = "right"
          , ur = "left"
          , Cr = [lr, sr, ir, ur]
          , Wt = Cr.reduce(function(Ut, St) {
            return Ut.concat([St + "-start", St + "-end"])
        }, [])
          , Rt = [].concat(Cr, ["auto"]).reduce(function(Ut, St) {
            return Ut.concat([St, St + "-start", St + "-end"])
        }, [])
          , jt = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
        function Ht(Ut) {
            return Ut ? (Ut.nodeName || "").toLowerCase() : null
        }
        function qt(Ut) {
            if (Ut == null)
                return window;
            if (Ut.toString() !== "[object Window]") {
                var St = Ut.ownerDocument;
                return St && St.defaultView || window
            }
            return Ut
        }
        function Xt(Ut) {
            return Ut instanceof qt(Ut).Element || Ut instanceof Element
        }
        function nr(Ut) {
            return Ut instanceof qt(Ut).HTMLElement || Ut instanceof HTMLElement
        }
        function Er(Ut) {
            return typeof ShadowRoot < "u" && (Ut instanceof qt(Ut).ShadowRoot || Ut instanceof ShadowRoot)
        }
        var Dr = {
            name: "applyStyles",
            enabled: !0,
            phase: "write",
            fn: function(Ut) {
                var St = Ut.state;
                Object.keys(St.elements).forEach(function(Ot) {
                    var Vt = St.styles[Ot] || {}
                      , Zt = St.attributes[Ot] || {}
                      , Qt = St.elements[Ot];
                    nr(Qt) && Ht(Qt) && (Object.assign(Qt.style, Vt),
                    Object.keys(Zt).forEach(function(er) {
                        var cr = Zt[er];
                        cr === !1 ? Qt.removeAttribute(er) : Qt.setAttribute(er, cr === !0 ? "" : cr)
                    }))
                })
            },
            effect: function(Ut) {
                var St = Ut.state
                  , Ot = {
                    popper: {
                        position: St.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
                return Object.assign(St.elements.popper.style, Ot.popper),
                St.styles = Ot,
                St.elements.arrow && Object.assign(St.elements.arrow.style, Ot.arrow),
                function() {
                    Object.keys(St.elements).forEach(function(Vt) {
                        var Zt = St.elements[Vt]
                          , Qt = St.attributes[Vt] || {}
                          , er = Object.keys(St.styles.hasOwnProperty(Vt) ? St.styles[Vt] : Ot[Vt]).reduce(function(cr, dr) {
                            return cr[dr] = "",
                            cr
                        }, {});
                        nr(Zt) && Ht(Zt) && (Object.assign(Zt.style, er),
                        Object.keys(Qt).forEach(function(cr) {
                            Zt.removeAttribute(cr)
                        }))
                    })
                }
            },
            requires: ["computeStyles"]
        };
        function kr(Ut) {
            return Ut.split("-")[0]
        }
        function Fr(Ut) {
            var St = Ut.getBoundingClientRect();
            return {
                width: St.width,
                height: St.height,
                top: St.top,
                right: St.right,
                bottom: St.bottom,
                left: St.left,
                x: St.left,
                y: St.top
            }
        }
        function Mr(Ut) {
            var St = Fr(Ut)
              , Ot = Ut.offsetWidth
              , Vt = Ut.offsetHeight;
            return Math.abs(St.width - Ot) <= 1 && (Ot = St.width),
            Math.abs(St.height - Vt) <= 1 && (Vt = St.height),
            {
                x: Ut.offsetLeft,
                y: Ut.offsetTop,
                width: Ot,
                height: Vt
            }
        }
        function Xn(Ut, St) {
            var Ot = St.getRootNode && St.getRootNode();
            if (Ut.contains(St))
                return !0;
            if (Ot && Er(Ot)) {
                var Vt = St;
                do {
                    if (Vt && Ut.isSameNode(Vt))
                        return !0;
                    Vt = Vt.parentNode || Vt.host
                } while (Vt)
            }
            return !1
        }
        function yn(Ut) {
            return qt(Ut).getComputedStyle(Ut)
        }
        function ga(Ut) {
            return ["table", "td", "th"].indexOf(Ht(Ut)) >= 0
        }
        function wn(Ut) {
            return ((Xt(Ut) ? Ut.ownerDocument : Ut.document) || window.document).documentElement
        }
        function Ws(Ut) {
            return Ht(Ut) === "html" ? Ut : Ut.assignedSlot || Ut.parentNode || (Er(Ut) ? Ut.host : null) || wn(Ut)
        }
        function wo(Ut) {
            return nr(Ut) && yn(Ut).position !== "fixed" ? Ut.offsetParent : null
        }
        function vs(Ut) {
            for (var St = qt(Ut), Ot = wo(Ut); Ot && ga(Ot) && yn(Ot).position === "static"; )
                Ot = wo(Ot);
            return Ot && (Ht(Ot) === "html" || Ht(Ot) === "body" && yn(Ot).position === "static") ? St : Ot || function(Vt) {
                var Zt = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
                if (navigator.userAgent.indexOf("Trident") !== -1 && nr(Vt) && yn(Vt).position === "fixed")
                    return null;
                for (var Qt = Ws(Vt); nr(Qt) && ["html", "body"].indexOf(Ht(Qt)) < 0; ) {
                    var er = yn(Qt);
                    if (er.transform !== "none" || er.perspective !== "none" || er.contain === "paint" || ["transform", "perspective"].indexOf(er.willChange) !== -1 || Zt && er.willChange === "filter" || Zt && er.filter && er.filter !== "none")
                        return Qt;
                    Qt = Qt.parentNode
                }
                return null
            }(Ut) || St
        }
        function ba(Ut) {
            return ["top", "bottom"].indexOf(Ut) >= 0 ? "x" : "y"
        }
        var Rn = Math.max
          , bs = Math.min
          , Us = Math.round;
        function zs(Ut, St, Ot) {
            return Rn(Ut, bs(St, Ot))
        }
        function xo(Ut) {
            return Object.assign({}, {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }, Ut)
        }
        function Eo(Ut, St) {
            return St.reduce(function(Ot, Vt) {
                return Ot[Vt] = Ut,
                Ot
            }, {})
        }
        var _o = {
            name: "arrow",
            enabled: !0,
            phase: "main",
            fn: function(Ut) {
                var St, Ot = Ut.state, Vt = Ut.name, Zt = Ut.options, Qt = Ot.elements.arrow, er = Ot.modifiersData.popperOffsets, cr = kr(Ot.placement), dr = ba(cr), mr = [ur, ir].indexOf(cr) >= 0 ? "height" : "width";
                if (Qt && er) {
                    var xr = function(Br, qr) {
                        return xo(typeof (Br = typeof Br == "function" ? Br(Object.assign({}, qr.rects, {
                            placement: qr.placement
                        })) : Br) != "number" ? Br : Eo(Br, Cr))
                    }(Zt.padding, Ot)
                      , yr = Mr(Qt)
                      , Rr = dr === "y" ? lr : ur
                      , $r = dr === "y" ? sr : ir
                      , Ar = Ot.rects.reference[mr] + Ot.rects.reference[dr] - er[dr] - Ot.rects.popper[mr]
                      , jr = er[dr] - Ot.rects.reference[dr]
                      , Ir = vs(Qt)
                      , zr = Ir ? dr === "y" ? Ir.clientHeight || 0 : Ir.clientWidth || 0 : 0
                      , Ur = Ar / 2 - jr / 2
                      , Lr = xr[Rr]
                      , Tr = zr - yr[mr] - xr[$r]
                      , Zr = zr / 2 - yr[mr] / 2 + Ur
                      , Nr = zs(Lr, Zr, Tr)
                      , Gr = dr;
                    Ot.modifiersData[Vt] = ((St = {})[Gr] = Nr,
                    St.centerOffset = Nr - Zr,
                    St)
                }
            },
            effect: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.options.element
                  , Vt = Ot === void 0 ? "[data-popper-arrow]" : Ot;
                Vt != null && (typeof Vt != "string" || (Vt = St.elements.popper.querySelector(Vt))) && Xn(St.elements.popper, Vt) && (St.elements.arrow = Vt)
            },
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
        }
          , Ol = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };
        function Co(Ut) {
            var St, Ot = Ut.popper, Vt = Ut.popperRect, Zt = Ut.placement, Qt = Ut.offsets, er = Ut.position, cr = Ut.gpuAcceleration, dr = Ut.adaptive, mr = Ut.roundOffsets, xr = mr === !0 ? function(qr) {
                var Jr = qr.x
                  , vn = qr.y
                  , Qr = window.devicePixelRatio || 1;
                return {
                    x: Us(Us(Jr * Qr) / Qr) || 0,
                    y: Us(Us(vn * Qr) / Qr) || 0
                }
            }(Qt) : typeof mr == "function" ? mr(Qt) : Qt, yr = xr.x, Rr = yr === void 0 ? 0 : yr, $r = xr.y, Ar = $r === void 0 ? 0 : $r, jr = Qt.hasOwnProperty("x"), Ir = Qt.hasOwnProperty("y"), zr = ur, Ur = lr, Lr = window;
            if (dr) {
                var Tr = vs(Ot)
                  , Zr = "clientHeight"
                  , Nr = "clientWidth";
                Tr === qt(Ot) && yn(Tr = wn(Ot)).position !== "static" && (Zr = "scrollHeight",
                Nr = "scrollWidth"),
                Tr = Tr,
                Zt === lr && (Ur = sr,
                Ar -= Tr[Zr] - Vt.height,
                Ar *= cr ? 1 : -1),
                Zt === ur && (zr = ir,
                Rr -= Tr[Nr] - Vt.width,
                Rr *= cr ? 1 : -1)
            }
            var Gr, Br = Object.assign({
                position: er
            }, dr && Ol);
            return cr ? Object.assign({}, Br, ((Gr = {})[Ur] = Ir ? "0" : "",
            Gr[zr] = jr ? "0" : "",
            Gr.transform = (Lr.devicePixelRatio || 1) < 2 ? "translate(" + Rr + "px, " + Ar + "px)" : "translate3d(" + Rr + "px, " + Ar + "px, 0)",
            Gr)) : Object.assign({}, Br, ((St = {})[Ur] = Ir ? Ar + "px" : "",
            St[zr] = jr ? Rr + "px" : "",
            St.transform = "",
            St))
        }
        var xa = {
            name: "computeStyles",
            enabled: !0,
            phase: "beforeWrite",
            fn: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.options
                  , Vt = Ot.gpuAcceleration
                  , Zt = Vt === void 0 || Vt
                  , Qt = Ot.adaptive
                  , er = Qt === void 0 || Qt
                  , cr = Ot.roundOffsets
                  , dr = cr === void 0 || cr
                  , mr = {
                    placement: kr(St.placement),
                    popper: St.elements.popper,
                    popperRect: St.rects.popper,
                    gpuAcceleration: Zt
                };
                St.modifiersData.popperOffsets != null && (St.styles.popper = Object.assign({}, St.styles.popper, Co(Object.assign({}, mr, {
                    offsets: St.modifiersData.popperOffsets,
                    position: St.options.strategy,
                    adaptive: er,
                    roundOffsets: dr
                })))),
                St.modifiersData.arrow != null && (St.styles.arrow = Object.assign({}, St.styles.arrow, Co(Object.assign({}, mr, {
                    offsets: St.modifiersData.arrow,
                    position: "absolute",
                    adaptive: !1,
                    roundOffsets: dr
                })))),
                St.attributes.popper = Object.assign({}, St.attributes.popper, {
                    "data-popper-placement": St.placement
                })
            },
            data: {}
        }
          , Vs = {
            passive: !0
        }
          , _a = {
            name: "eventListeners",
            enabled: !0,
            phase: "write",
            fn: function() {},
            effect: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.instance
                  , Vt = Ut.options
                  , Zt = Vt.scroll
                  , Qt = Zt === void 0 || Zt
                  , er = Vt.resize
                  , cr = er === void 0 || er
                  , dr = qt(St.elements.popper)
                  , mr = [].concat(St.scrollParents.reference, St.scrollParents.popper);
                return Qt && mr.forEach(function(xr) {
                    xr.addEventListener("scroll", Ot.update, Vs)
                }),
                cr && dr.addEventListener("resize", Ot.update, Vs),
                function() {
                    Qt && mr.forEach(function(xr) {
                        xr.removeEventListener("scroll", Ot.update, Vs)
                    }),
                    cr && dr.removeEventListener("resize", Ot.update, Vs)
                }
            },
            data: {}
        }
          , Ml = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        function Hs(Ut) {
            return Ut.replace(/left|right|bottom|top/g, function(St) {
                return Ml[St]
            })
        }
        var Nl = {
            start: "end",
            end: "start"
        };
        function So(Ut) {
            return Ut.replace(/start|end/g, function(St) {
                return Nl[St]
            })
        }
        function $a(Ut) {
            var St = qt(Ut);
            return {
                scrollLeft: St.pageXOffset,
                scrollTop: St.pageYOffset
            }
        }
        function eo(Ut) {
            return Fr(wn(Ut)).left + $a(Ut).scrollLeft
        }
        function to(Ut) {
            var St = yn(Ut)
              , Ot = St.overflow
              , Vt = St.overflowX
              , Zt = St.overflowY;
            return /auto|scroll|overlay|hidden/.test(Ot + Zt + Vt)
        }
        function ws(Ut, St) {
            var Ot;
            St === void 0 && (St = []);
            var Vt = function dr(mr) {
                return ["html", "body", "#document"].indexOf(Ht(mr)) >= 0 ? mr.ownerDocument.body : nr(mr) && to(mr) ? mr : dr(Ws(mr))
            }(Ut)
              , Zt = Vt === ((Ot = Ut.ownerDocument) == null ? void 0 : Ot.body)
              , Qt = qt(Vt)
              , er = Zt ? [Qt].concat(Qt.visualViewport || [], to(Vt) ? Vt : []) : Vt
              , cr = St.concat(er);
            return Zt ? cr : cr.concat(ws(Ws(er)))
        }
        function ro(Ut) {
            return Object.assign({}, Ut, {
                left: Ut.x,
                top: Ut.y,
                right: Ut.x + Ut.width,
                bottom: Ut.y + Ut.height
            })
        }
        function Ao(Ut, St) {
            return St === "viewport" ? ro(function(Ot) {
                var Vt = qt(Ot)
                  , Zt = wn(Ot)
                  , Qt = Vt.visualViewport
                  , er = Zt.clientWidth
                  , cr = Zt.clientHeight
                  , dr = 0
                  , mr = 0;
                return Qt && (er = Qt.width,
                cr = Qt.height,
                /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (dr = Qt.offsetLeft,
                mr = Qt.offsetTop)),
                {
                    width: er,
                    height: cr,
                    x: dr + eo(Ot),
                    y: mr
                }
            }(Ut)) : nr(St) ? function(Ot) {
                var Vt = Fr(Ot);
                return Vt.top = Vt.top + Ot.clientTop,
                Vt.left = Vt.left + Ot.clientLeft,
                Vt.bottom = Vt.top + Ot.clientHeight,
                Vt.right = Vt.left + Ot.clientWidth,
                Vt.width = Ot.clientWidth,
                Vt.height = Ot.clientHeight,
                Vt.x = Vt.left,
                Vt.y = Vt.top,
                Vt
            }(St) : ro(function(Ot) {
                var Vt, Zt = wn(Ot), Qt = $a(Ot), er = (Vt = Ot.ownerDocument) == null ? void 0 : Vt.body, cr = Rn(Zt.scrollWidth, Zt.clientWidth, er ? er.scrollWidth : 0, er ? er.clientWidth : 0), dr = Rn(Zt.scrollHeight, Zt.clientHeight, er ? er.scrollHeight : 0, er ? er.clientHeight : 0), mr = -Qt.scrollLeft + eo(Ot), xr = -Qt.scrollTop;
                return yn(er || Zt).direction === "rtl" && (mr += Rn(Zt.clientWidth, er ? er.clientWidth : 0) - cr),
                {
                    width: cr,
                    height: dr,
                    x: mr,
                    y: xr
                }
            }(wn(Ut)))
        }
        function xs(Ut) {
            return Ut.split("-")[1]
        }
        function To(Ut) {
            var St, Ot = Ut.reference, Vt = Ut.element, Zt = Ut.placement, Qt = Zt ? kr(Zt) : null, er = Zt ? xs(Zt) : null, cr = Ot.x + Ot.width / 2 - Vt.width / 2, dr = Ot.y + Ot.height / 2 - Vt.height / 2;
            switch (Qt) {
            case lr:
                St = {
                    x: cr,
                    y: Ot.y - Vt.height
                };
                break;
            case sr:
                St = {
                    x: cr,
                    y: Ot.y + Ot.height
                };
                break;
            case ir:
                St = {
                    x: Ot.x + Ot.width,
                    y: dr
                };
                break;
            case ur:
                St = {
                    x: Ot.x - Vt.width,
                    y: dr
                };
                break;
            default:
                St = {
                    x: Ot.x,
                    y: Ot.y
                }
            }
            var mr = Qt ? ba(Qt) : null;
            if (mr != null) {
                var xr = mr === "y" ? "height" : "width";
                switch (er) {
                case "start":
                    St[mr] = St[mr] - (Ot[xr] / 2 - Vt[xr] / 2);
                    break;
                case "end":
                    St[mr] = St[mr] + (Ot[xr] / 2 - Vt[xr] / 2)
                }
            }
            return St
        }
        function Jn(Ut, St) {
            St === void 0 && (St = {});
            var Ot = St
              , Vt = Ot.placement
              , Zt = Vt === void 0 ? Ut.placement : Vt
              , Qt = Ot.boundary
              , er = Qt === void 0 ? "clippingParents" : Qt
              , cr = Ot.rootBoundary
              , dr = cr === void 0 ? "viewport" : cr
              , mr = Ot.elementContext
              , xr = mr === void 0 ? "popper" : mr
              , yr = Ot.altBoundary
              , Rr = yr !== void 0 && yr
              , $r = Ot.padding
              , Ar = $r === void 0 ? 0 : $r
              , jr = xo(typeof Ar != "number" ? Ar : Eo(Ar, Cr))
              , Ir = xr === "popper" ? "reference" : "popper"
              , zr = Ut.elements.reference
              , Ur = Ut.rects.popper
              , Lr = Ut.elements[Rr ? Ir : xr]
              , Tr = function(Qr, en, fn) {
                var kn = en === "clippingParents" ? function(tn) {
                    var En = ws(Ws(tn))
                      , rn = ["absolute", "fixed"].indexOf(yn(tn).position) >= 0 && nr(tn) ? vs(tn) : tn;
                    return Xt(rn) ? En.filter(function(on) {
                        return Xt(on) && Xn(on, rn) && Ht(on) !== "body"
                    }) : []
                }(Qr) : [].concat(en)
                  , xn = [].concat(kn, [fn])
                  , _i = xn[0]
                  , sn = xn.reduce(function(tn, En) {
                    var rn = Ao(Qr, En);
                    return tn.top = Rn(rn.top, tn.top),
                    tn.right = bs(rn.right, tn.right),
                    tn.bottom = bs(rn.bottom, tn.bottom),
                    tn.left = Rn(rn.left, tn.left),
                    tn
                }, Ao(Qr, _i));
                return sn.width = sn.right - sn.left,
                sn.height = sn.bottom - sn.top,
                sn.x = sn.left,
                sn.y = sn.top,
                sn
            }(Xt(Lr) ? Lr : Lr.contextElement || wn(Ut.elements.popper), er, dr)
              , Zr = Fr(zr)
              , Nr = To({
                reference: Zr,
                element: Ur,
                strategy: "absolute",
                placement: Zt
            })
              , Gr = ro(Object.assign({}, Ur, Nr))
              , Br = xr === "popper" ? Gr : Zr
              , qr = {
                top: Tr.top - Br.top + jr.top,
                bottom: Br.bottom - Tr.bottom + jr.bottom,
                left: Tr.left - Br.left + jr.left,
                right: Br.right - Tr.right + jr.right
            }
              , Jr = Ut.modifiersData.offset;
            if (xr === "popper" && Jr) {
                var vn = Jr[Zt];
                Object.keys(qr).forEach(function(Qr) {
                    var en = [ir, sr].indexOf(Qr) >= 0 ? 1 : -1
                      , fn = [lr, sr].indexOf(Qr) >= 0 ? "y" : "x";
                    qr[Qr] += vn[fn] * en
                })
            }
            return qr
        }
        function Ll(Ut, St) {
            St === void 0 && (St = {});
            var Ot = St
              , Vt = Ot.placement
              , Zt = Ot.boundary
              , Qt = Ot.rootBoundary
              , er = Ot.padding
              , cr = Ot.flipVariations
              , dr = Ot.allowedAutoPlacements
              , mr = dr === void 0 ? Rt : dr
              , xr = xs(Vt)
              , yr = xr ? cr ? Wt : Wt.filter(function(Ar) {
                return xs(Ar) === xr
            }) : Cr
              , Rr = yr.filter(function(Ar) {
                return mr.indexOf(Ar) >= 0
            });
            Rr.length === 0 && (Rr = yr);
            var $r = Rr.reduce(function(Ar, jr) {
                return Ar[jr] = Jn(Ut, {
                    placement: jr,
                    boundary: Zt,
                    rootBoundary: Qt,
                    padding: er
                })[kr(jr)],
                Ar
            }, {});
            return Object.keys($r).sort(function(Ar, jr) {
                return $r[Ar] - $r[jr]
            })
        }
        var $o = {
            name: "flip",
            enabled: !0,
            phase: "main",
            fn: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.options
                  , Vt = Ut.name;
                if (!St.modifiersData[Vt]._skip) {
                    for (var Zt = Ot.mainAxis, Qt = Zt === void 0 || Zt, er = Ot.altAxis, cr = er === void 0 || er, dr = Ot.fallbackPlacements, mr = Ot.padding, xr = Ot.boundary, yr = Ot.rootBoundary, Rr = Ot.altBoundary, $r = Ot.flipVariations, Ar = $r === void 0 || $r, jr = Ot.allowedAutoPlacements, Ir = St.options.placement, zr = kr(Ir), Ur = dr || (zr !== Ir && Ar ? function(rn) {
                        if (kr(rn) === "auto")
                            return [];
                        var on = Hs(rn);
                        return [So(rn), on, So(on)]
                    }(Ir) : [Hs(Ir)]), Lr = [Ir].concat(Ur).reduce(function(rn, on) {
                        return rn.concat(kr(on) === "auto" ? Ll(St, {
                            placement: on,
                            boundary: xr,
                            rootBoundary: yr,
                            padding: mr,
                            flipVariations: Ar,
                            allowedAutoPlacements: jr
                        }) : on)
                    }, []), Tr = St.rects.reference, Zr = St.rects.popper, Nr = new Map, Gr = !0, Br = Lr[0], qr = 0; qr < Lr.length; qr++) {
                        var Jr = Lr[qr]
                          , vn = kr(Jr)
                          , Qr = xs(Jr) === "start"
                          , en = [lr, sr].indexOf(vn) >= 0
                          , fn = en ? "width" : "height"
                          , kn = Jn(St, {
                            placement: Jr,
                            boundary: xr,
                            rootBoundary: yr,
                            altBoundary: Rr,
                            padding: mr
                        })
                          , xn = en ? Qr ? ir : ur : Qr ? sr : lr;
                        Tr[fn] > Zr[fn] && (xn = Hs(xn));
                        var _i = Hs(xn)
                          , sn = [];
                        if (Qt && sn.push(kn[vn] <= 0),
                        cr && sn.push(kn[xn] <= 0, kn[_i] <= 0),
                        sn.every(function(rn) {
                            return rn
                        })) {
                            Br = Jr,
                            Gr = !1;
                            break
                        }
                        Nr.set(Jr, sn)
                    }
                    if (Gr)
                        for (var tn = function(rn) {
                            var on = Lr.find(function(Ks) {
                                var Ss = Nr.get(Ks);
                                if (Ss)
                                    return Ss.slice(0, rn).every(function(es) {
                                        return es
                                    })
                            });
                            if (on)
                                return Br = on,
                                "break"
                        }, En = Ar ? 3 : 1; En > 0 && tn(En) !== "break"; En--)
                            ;
                    St.placement !== Br && (St.modifiersData[Vt]._skip = !0,
                    St.placement = Br,
                    St.reset = !0)
                }
            },
            requiresIfExists: ["offset"],
            data: {
                _skip: !1
            }
        };
        function Po(Ut, St, Ot) {
            return Ot === void 0 && (Ot = {
                x: 0,
                y: 0
            }),
            {
                top: Ut.top - St.height - Ot.y,
                right: Ut.right - St.width + Ot.x,
                bottom: Ut.bottom - St.height + Ot.y,
                left: Ut.left - St.width - Ot.x
            }
        }
        function Ro(Ut) {
            return [lr, ir, sr, ur].some(function(St) {
                return Ut[St] >= 0
            })
        }
        var ko = {
            name: "hide",
            enabled: !0,
            phase: "main",
            requiresIfExists: ["preventOverflow"],
            fn: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.name
                  , Vt = St.rects.reference
                  , Zt = St.rects.popper
                  , Qt = St.modifiersData.preventOverflow
                  , er = Jn(St, {
                    elementContext: "reference"
                })
                  , cr = Jn(St, {
                    altBoundary: !0
                })
                  , dr = Po(er, Vt)
                  , mr = Po(cr, Zt, Qt)
                  , xr = Ro(dr)
                  , yr = Ro(mr);
                St.modifiersData[Ot] = {
                    referenceClippingOffsets: dr,
                    popperEscapeOffsets: mr,
                    isReferenceHidden: xr,
                    hasPopperEscaped: yr
                },
                St.attributes.popper = Object.assign({}, St.attributes.popper, {
                    "data-popper-reference-hidden": xr,
                    "data-popper-escaped": yr
                })
            }
        }
          , Io = {
            name: "offset",
            enabled: !0,
            phase: "main",
            requires: ["popperOffsets"],
            fn: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.options
                  , Vt = Ut.name
                  , Zt = Ot.offset
                  , Qt = Zt === void 0 ? [0, 0] : Zt
                  , er = Rt.reduce(function(xr, yr) {
                    return xr[yr] = function(Rr, $r, Ar) {
                        var jr = kr(Rr)
                          , Ir = [ur, lr].indexOf(jr) >= 0 ? -1 : 1
                          , zr = typeof Ar == "function" ? Ar(Object.assign({}, $r, {
                            placement: Rr
                        })) : Ar
                          , Ur = zr[0]
                          , Lr = zr[1];
                        return Ur = Ur || 0,
                        Lr = (Lr || 0) * Ir,
                        [ur, ir].indexOf(jr) >= 0 ? {
                            x: Lr,
                            y: Ur
                        } : {
                            x: Ur,
                            y: Lr
                        }
                    }(yr, St.rects, Qt),
                    xr
                }, {})
                  , cr = er[St.placement]
                  , dr = cr.x
                  , mr = cr.y;
                St.modifiersData.popperOffsets != null && (St.modifiersData.popperOffsets.x += dr,
                St.modifiersData.popperOffsets.y += mr),
                St.modifiersData[Vt] = er
            }
        }
          , no = {
            name: "popperOffsets",
            enabled: !0,
            phase: "read",
            fn: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.name;
                St.modifiersData[Ot] = To({
                    reference: St.rects.reference,
                    element: St.rects.popper,
                    strategy: "absolute",
                    placement: St.placement
                })
            },
            data: {}
        }
          , Oo = {
            name: "preventOverflow",
            enabled: !0,
            phase: "main",
            fn: function(Ut) {
                var St = Ut.state
                  , Ot = Ut.options
                  , Vt = Ut.name
                  , Zt = Ot.mainAxis
                  , Qt = Zt === void 0 || Zt
                  , er = Ot.altAxis
                  , cr = er !== void 0 && er
                  , dr = Ot.boundary
                  , mr = Ot.rootBoundary
                  , xr = Ot.altBoundary
                  , yr = Ot.padding
                  , Rr = Ot.tether
                  , $r = Rr === void 0 || Rr
                  , Ar = Ot.tetherOffset
                  , jr = Ar === void 0 ? 0 : Ar
                  , Ir = Jn(St, {
                    boundary: dr,
                    rootBoundary: mr,
                    padding: yr,
                    altBoundary: xr
                })
                  , zr = kr(St.placement)
                  , Ur = xs(St.placement)
                  , Lr = !Ur
                  , Tr = ba(zr)
                  , Zr = Tr === "x" ? "y" : "x"
                  , Nr = St.modifiersData.popperOffsets
                  , Gr = St.rects.reference
                  , Br = St.rects.popper
                  , qr = typeof jr == "function" ? jr(Object.assign({}, St.rects, {
                    placement: St.placement
                })) : jr
                  , Jr = {
                    x: 0,
                    y: 0
                };
                if (Nr) {
                    if (Qt || cr) {
                        var vn = Tr === "y" ? lr : ur
                          , Qr = Tr === "y" ? sr : ir
                          , en = Tr === "y" ? "height" : "width"
                          , fn = Nr[Tr]
                          , kn = Nr[Tr] + Ir[vn]
                          , xn = Nr[Tr] - Ir[Qr]
                          , _i = $r ? -Br[en] / 2 : 0
                          , sn = Ur === "start" ? Gr[en] : Br[en]
                          , tn = Ur === "start" ? -Br[en] : -Gr[en]
                          , En = St.elements.arrow
                          , rn = $r && En ? Mr(En) : {
                            width: 0,
                            height: 0
                        }
                          , on = St.modifiersData["arrow#persistent"] ? St.modifiersData["arrow#persistent"].padding : {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }
                          , Ks = on[vn]
                          , Ss = on[Qr]
                          , es = zs(0, Gr[en], rn[en])
                          , gu = Lr ? Gr[en] / 2 - _i - es - Ks - qr : sn - es - Ks - qr
                          , yu = Lr ? -Gr[en] / 2 + _i + es + Ss + qr : tn + es + Ss + qr
                          , ao = St.elements.arrow && vs(St.elements.arrow)
                          , vu = ao ? Tr === "y" ? ao.clientTop || 0 : ao.clientLeft || 0 : 0
                          , zo = St.modifiersData.offset ? St.modifiersData.offset[St.placement][Tr] : 0
                          , Vo = Nr[Tr] + gu - zo - vu
                          , Ho = Nr[Tr] + yu - zo;
                        if (Qt) {
                            var Zo = zs($r ? bs(kn, Vo) : kn, fn, $r ? Rn(xn, Ho) : xn);
                            Nr[Tr] = Zo,
                            Jr[Tr] = Zo - fn
                        }
                        if (cr) {
                            var bu = Tr === "x" ? lr : ur
                              , wu = Tr === "x" ? sr : ir
                              , Ys = Nr[Zr]
                              , Go = Ys + Ir[bu]
                              , qo = Ys - Ir[wu]
                              , Ko = zs($r ? bs(Go, Vo) : Go, Ys, $r ? Rn(qo, Ho) : qo);
                            Nr[Zr] = Ko,
                            Jr[Zr] = Ko - Ys
                        }
                    }
                    St.modifiersData[Vt] = Jr
                }
            },
            requiresIfExists: ["offset"]
        };
        function Dl(Ut, St, Ot) {
            Ot === void 0 && (Ot = !1);
            var Vt, Zt, Qt = wn(St), er = Fr(Ut), cr = nr(St), dr = {
                scrollLeft: 0,
                scrollTop: 0
            }, mr = {
                x: 0,
                y: 0
            };
            return (cr || !cr && !Ot) && ((Ht(St) !== "body" || to(Qt)) && (dr = (Vt = St) !== qt(Vt) && nr(Vt) ? {
                scrollLeft: (Zt = Vt).scrollLeft,
                scrollTop: Zt.scrollTop
            } : $a(Vt)),
            nr(St) ? ((mr = Fr(St)).x += St.clientLeft,
            mr.y += St.clientTop) : Qt && (mr.x = eo(Qt))),
            {
                x: er.left + dr.scrollLeft - mr.x,
                y: er.top + dr.scrollTop - mr.y,
                width: er.width,
                height: er.height
            }
        }
        var jo = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };
        function Mo() {
            for (var Ut = arguments.length, St = new Array(Ut), Ot = 0; Ot < Ut; Ot++)
                St[Ot] = arguments[Ot];
            return !St.some(function(Vt) {
                return !(Vt && typeof Vt.getBoundingClientRect == "function")
            })
        }
        function Zs(Ut) {
            Ut === void 0 && (Ut = {});
            var St = Ut
              , Ot = St.defaultModifiers
              , Vt = Ot === void 0 ? [] : Ot
              , Zt = St.defaultOptions
              , Qt = Zt === void 0 ? jo : Zt;
            return function(er, cr, dr) {
                dr === void 0 && (dr = Qt);
                var mr, xr, yr = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, jo, Qt),
                    modifiersData: {},
                    elements: {
                        reference: er,
                        popper: cr
                    },
                    attributes: {},
                    styles: {}
                }, Rr = [], $r = !1, Ar = {
                    state: yr,
                    setOptions: function(Ir) {
                        jr(),
                        yr.options = Object.assign({}, Qt, yr.options, Ir),
                        yr.scrollParents = {
                            reference: Xt(er) ? ws(er) : er.contextElement ? ws(er.contextElement) : [],
                            popper: ws(cr)
                        };
                        var zr, Ur, Lr = function(Tr) {
                            var Zr = function(Nr) {
                                var Gr = new Map
                                  , Br = new Set
                                  , qr = [];
                                return Nr.forEach(function(Jr) {
                                    Gr.set(Jr.name, Jr)
                                }),
                                Nr.forEach(function(Jr) {
                                    Br.has(Jr.name) || function vn(Qr) {
                                        Br.add(Qr.name),
                                        [].concat(Qr.requires || [], Qr.requiresIfExists || []).forEach(function(en) {
                                            if (!Br.has(en)) {
                                                var fn = Gr.get(en);
                                                fn && vn(fn)
                                            }
                                        }),
                                        qr.push(Qr)
                                    }(Jr)
                                }),
                                qr
                            }(Tr);
                            return jt.reduce(function(Nr, Gr) {
                                return Nr.concat(Zr.filter(function(Br) {
                                    return Br.phase === Gr
                                }))
                            }, [])
                        }((zr = [].concat(Vt, yr.options.modifiers),
                        Ur = zr.reduce(function(Tr, Zr) {
                            var Nr = Tr[Zr.name];
                            return Tr[Zr.name] = Nr ? Object.assign({}, Nr, Zr, {
                                options: Object.assign({}, Nr.options, Zr.options),
                                data: Object.assign({}, Nr.data, Zr.data)
                            }) : Zr,
                            Tr
                        }, {}),
                        Object.keys(Ur).map(function(Tr) {
                            return Ur[Tr]
                        })));
                        return yr.orderedModifiers = Lr.filter(function(Tr) {
                            return Tr.enabled
                        }),
                        yr.orderedModifiers.forEach(function(Tr) {
                            var Zr = Tr.name
                              , Nr = Tr.options
                              , Gr = Nr === void 0 ? {} : Nr
                              , Br = Tr.effect;
                            if (typeof Br == "function") {
                                var qr = Br({
                                    state: yr,
                                    name: Zr,
                                    instance: Ar,
                                    options: Gr
                                });
                                Rr.push(qr || function() {}
                                )
                            }
                        }),
                        Ar.update()
                    },
                    forceUpdate: function() {
                        if (!$r) {
                            var Ir = yr.elements
                              , zr = Ir.reference
                              , Ur = Ir.popper;
                            if (Mo(zr, Ur)) {
                                yr.rects = {
                                    reference: Dl(zr, vs(Ur), yr.options.strategy === "fixed"),
                                    popper: Mr(Ur)
                                },
                                yr.reset = !1,
                                yr.placement = yr.options.placement,
                                yr.orderedModifiers.forEach(function(qr) {
                                    return yr.modifiersData[qr.name] = Object.assign({}, qr.data)
                                });
                                for (var Lr = 0; Lr < yr.orderedModifiers.length; Lr++)
                                    if (yr.reset !== !0) {
                                        var Tr = yr.orderedModifiers[Lr]
                                          , Zr = Tr.fn
                                          , Nr = Tr.options
                                          , Gr = Nr === void 0 ? {} : Nr
                                          , Br = Tr.name;
                                        typeof Zr == "function" && (yr = Zr({
                                            state: yr,
                                            options: Gr,
                                            name: Br,
                                            instance: Ar
                                        }) || yr)
                                    } else
                                        yr.reset = !1,
                                        Lr = -1
                            }
                        }
                    },
                    update: (mr = function() {
                        return new Promise(function(Ir) {
                            Ar.forceUpdate(),
                            Ir(yr)
                        }
                        )
                    }
                    ,
                    function() {
                        return xr || (xr = new Promise(function(Ir) {
                            Promise.resolve().then(function() {
                                xr = void 0,
                                Ir(mr())
                            })
                        }
                        )),
                        xr
                    }
                    ),
                    destroy: function() {
                        jr(),
                        $r = !0
                    }
                };
                if (!Mo(er, cr))
                    return Ar;
                function jr() {
                    Rr.forEach(function(Ir) {
                        return Ir()
                    }),
                    Rr = []
                }
                return Ar.setOptions(dr).then(function(Ir) {
                    !$r && dr.onFirstUpdate && dr.onFirstUpdate(Ir)
                }),
                Ar
            }
        }
        var Fl = Zs()
          , Bl = Zs({
            defaultModifiers: [_a, no, xa, Dr]
        })
          , io = Zs({
            defaultModifiers: [_a, no, xa, Dr, Io, $o, Oo, _o, ko]
        })
          , No = Object.freeze({
            __proto__: null,
            popperGenerator: Zs,
            detectOverflow: Jn,
            createPopperBase: Fl,
            createPopper: io,
            createPopperLite: Bl,
            top: lr,
            bottom: sr,
            right: ir,
            left: ur,
            auto: "auto",
            basePlacements: Cr,
            start: "start",
            end: "end",
            clippingParents: "clippingParents",
            viewport: "viewport",
            popper: "popper",
            reference: "reference",
            variationPlacements: Wt,
            placements: Rt,
            beforeRead: "beforeRead",
            read: "read",
            afterRead: "afterRead",
            beforeMain: "beforeMain",
            main: "main",
            afterMain: "afterMain",
            beforeWrite: "beforeWrite",
            write: "write",
            afterWrite: "afterWrite",
            modifierPhases: jt,
            applyStyles: Dr,
            arrow: _o,
            computeStyles: xa,
            eventListeners: _a,
            flip: $o,
            hide: ko,
            offset: Io,
            popperOffsets: no,
            preventOverflow: Oo
        });
        const Wl = new RegExp("ArrowUp|ArrowDown|Escape")
          , Ul = mt() ? "top-end" : "top-start"
          , zl = mt() ? "top-start" : "top-end"
          , Vl = mt() ? "bottom-end" : "bottom-start"
          , Hl = mt() ? "bottom-start" : "bottom-end"
          , Zl = mt() ? "left-start" : "right-start"
          , Gl = mt() ? "right-start" : "left-start"
          , Kl = {
            offset: [0, 2],
            boundary: "clippingParents",
            reference: "toggle",
            display: "dynamic",
            popperConfig: null,
            autoClose: !0
        }
          , Yl = {
            offset: "(array|string|function)",
            boundary: "(string|element)",
            reference: "(string|element|object)",
            display: "string",
            popperConfig: "(null|object|function)",
            autoClose: "(boolean|string)"
        };
        class ln extends ar {
            constructor(St, Ot) {
                super(St),
                this._popper = null,
                this._config = this._getConfig(Ot),
                this._menu = this._getMenuElement(),
                this._inNavbar = this._detectNavbar(),
                this._addEventListeners()
            }
            static get Default() {
                return Kl
            }
            static get DefaultType() {
                return Yl
            }
            static get NAME() {
                return "dropdown"
            }
            toggle() {
                ut(this._element) || (this._element.classList.contains("show") ? this.hide() : this.show())
            }
            show() {
                if (ut(this._element) || this._menu.classList.contains("show"))
                    return;
                const St = ln.getParentFromElement(this._element)
                  , Ot = {
                    relatedTarget: this._element
                };
                if (!zt.trigger(this._element, "show.bs.dropdown", Ot).defaultPrevented) {
                    if (this._inNavbar)
                        br.setDataAttribute(this._menu, "popper", "none");
                    else {
                        if (No === void 0)
                            throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                        let Vt = this._element;
                        this._config.reference === "parent" ? Vt = St : ot(this._config.reference) ? Vt = lt(this._config.reference) : typeof this._config.reference == "object" && (Vt = this._config.reference);
                        const Zt = this._getPopperConfig()
                          , Qt = Zt.modifiers.find(er=>er.name === "applyStyles" && er.enabled === !1);
                        this._popper = io(Vt, this._menu, Zt),
                        Qt && br.setDataAttribute(this._menu, "popper", "static")
                    }
                    "ontouchstart"in document.documentElement && !St.closest(".navbar-nav") && [].concat(...document.body.children).forEach(Vt=>zt.on(Vt, "mouseover", ht)),
                    this._element.focus(),
                    this._element.setAttribute("aria-expanded", !0),
                    this._menu.classList.toggle("show"),
                    this._element.classList.toggle("show"),
                    zt.trigger(this._element, "shown.bs.dropdown", Ot)
                }
            }
            hide() {
                if (ut(this._element) || !this._menu.classList.contains("show"))
                    return;
                const St = {
                    relatedTarget: this._element
                };
                this._completeHide(St)
            }
            dispose() {
                this._popper && this._popper.destroy(),
                super.dispose()
            }
            update() {
                this._inNavbar = this._detectNavbar(),
                this._popper && this._popper.update()
            }
            _addEventListeners() {
                zt.on(this._element, "click.bs.dropdown", St=>{
                    St.preventDefault(),
                    this.toggle()
                }
                )
            }
            _completeHide(St) {
                zt.trigger(this._element, "hide.bs.dropdown", St).defaultPrevented || ("ontouchstart"in document.documentElement && [].concat(...document.body.children).forEach(Ot=>zt.off(Ot, "mouseover", ht)),
                this._popper && this._popper.destroy(),
                this._menu.classList.remove("show"),
                this._element.classList.remove("show"),
                this._element.setAttribute("aria-expanded", "false"),
                br.removeDataAttribute(this._menu, "popper"),
                zt.trigger(this._element, "hidden.bs.dropdown", St))
            }
            _getConfig(St) {
                if (St = {
                    ...this.constructor.Default,
                    ...br.getDataAttributes(this._element),
                    ...St
                },
                dt("dropdown", St, this.constructor.DefaultType),
                typeof St.reference == "object" && !ot(St.reference) && typeof St.reference.getBoundingClientRect != "function")
                    throw new TypeError("dropdown".toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.');
                return St
            }
            _getMenuElement() {
                return tt.next(this._element, ".dropdown-menu")[0]
            }
            _getPlacement() {
                const St = this._element.parentNode;
                if (St.classList.contains("dropend"))
                    return Zl;
                if (St.classList.contains("dropstart"))
                    return Gl;
                const Ot = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
                return St.classList.contains("dropup") ? Ot ? zl : Ul : Ot ? Hl : Vl
            }
            _detectNavbar() {
                return this._element.closest(".navbar") !== null
            }
            _getOffset() {
                const {offset: St} = this._config;
                return typeof St == "string" ? St.split(",").map(Ot=>Number.parseInt(Ot, 10)) : typeof St == "function" ? Ot=>St(Ot, this._element) : St
            }
            _getPopperConfig() {
                const St = {
                    placement: this._getPlacement(),
                    modifiers: [{
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    }, {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }]
                };
                return this._config.display === "static" && (St.modifiers = [{
                    name: "applyStyles",
                    enabled: !1
                }]),
                {
                    ...St,
                    ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(St) : this._config.popperConfig
                }
            }
            _selectMenuItem({key: St, target: Ot}) {
                const Vt = tt.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(ct);
                Vt.length && _t(Vt, Ot, St === "ArrowDown", !Vt.includes(Ot)).focus()
            }
            static dropdownInterface(St, Ot) {
                const Vt = ln.getOrCreateInstance(St, Ot);
                if (typeof Ot == "string") {
                    if (Vt[Ot] === void 0)
                        throw new TypeError(`No method named "${Ot}"`);
                    Vt[Ot]()
                }
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    ln.dropdownInterface(this, St)
                })
            }
            static clearMenus(St) {
                if (St && (St.button === 2 || St.type === "keyup" && St.key !== "Tab"))
                    return;
                const Ot = tt.find('[data-bs-toggle="dropdown"]');
                for (let Vt = 0, Zt = Ot.length; Vt < Zt; Vt++) {
                    const Qt = ln.getInstance(Ot[Vt]);
                    if (!Qt || Qt._config.autoClose === !1 || !Qt._element.classList.contains("show"))
                        continue;
                    const er = {
                        relatedTarget: Qt._element
                    };
                    if (St) {
                        const cr = St.composedPath()
                          , dr = cr.includes(Qt._menu);
                        if (cr.includes(Qt._element) || Qt._config.autoClose === "inside" && !dr || Qt._config.autoClose === "outside" && dr || Qt._menu.contains(St.target) && (St.type === "keyup" && St.key === "Tab" || /input|select|option|textarea|form/i.test(St.target.tagName)))
                            continue;
                        St.type === "click" && (er.clickEvent = St)
                    }
                    Qt._completeHide(er)
                }
            }
            static getParentFromElement(St) {
                return st(St) || St.parentNode
            }
            static dataApiKeydownHandler(St) {
                if (/input|textarea/i.test(St.target.tagName) ? St.key === "Space" || St.key !== "Escape" && (St.key !== "ArrowDown" && St.key !== "ArrowUp" || St.target.closest(".dropdown-menu")) : !Wl.test(St.key))
                    return;
                const Ot = this.classList.contains("show");
                if (!Ot && St.key === "Escape" || (St.preventDefault(),
                St.stopPropagation(),
                ut(this)))
                    return;
                const Vt = ()=>this.matches('[data-bs-toggle="dropdown"]') ? this : tt.prev(this, '[data-bs-toggle="dropdown"]')[0];
                return St.key === "Escape" ? (Vt().focus(),
                void ln.clearMenus()) : St.key === "ArrowUp" || St.key === "ArrowDown" ? (Ot || Vt().click(),
                void ln.getInstance(Vt())._selectMenuItem(St)) : void (Ot && St.key !== "Space" || ln.clearMenus())
            }
        }
        zt.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', ln.dataApiKeydownHandler),
        zt.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", ln.dataApiKeydownHandler),
        zt.on(document, "click.bs.dropdown.data-api", ln.clearMenus),
        zt.on(document, "keyup.bs.dropdown.data-api", ln.clearMenus),
        zt.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', function(Ut) {
            Ut.preventDefault(),
            ln.dropdownInterface(this)
        }),
        yt(ln);
        class so {
            constructor() {
                this._element = document.body
            }
            getWidth() {
                const St = document.documentElement.clientWidth;
                return Math.abs(window.innerWidth - St)
            }
            hide() {
                const St = this.getWidth();
                this._disableOverFlow(),
                this._setElementAttributes(this._element, "paddingRight", Ot=>Ot + St),
                this._setElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight", Ot=>Ot + St),
                this._setElementAttributes(".sticky-top", "marginRight", Ot=>Ot - St)
            }
            _disableOverFlow() {
                this._saveInitialAttribute(this._element, "overflow"),
                this._element.style.overflow = "hidden"
            }
            _setElementAttributes(St, Ot, Vt) {
                const Zt = this.getWidth();
                this._applyManipulationCallback(St, Qt=>{
                    if (Qt !== this._element && window.innerWidth > Qt.clientWidth + Zt)
                        return;
                    this._saveInitialAttribute(Qt, Ot);
                    const er = window.getComputedStyle(Qt)[Ot];
                    Qt.style[Ot] = Vt(Number.parseFloat(er)) + "px"
                }
                )
            }
            reset() {
                this._resetElementAttributes(this._element, "overflow"),
                this._resetElementAttributes(this._element, "paddingRight"),
                this._resetElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"),
                this._resetElementAttributes(".sticky-top", "marginRight")
            }
            _saveInitialAttribute(St, Ot) {
                const Vt = St.style[Ot];
                Vt && br.setDataAttribute(St, Ot, Vt)
            }
            _resetElementAttributes(St, Ot) {
                this._applyManipulationCallback(St, Vt=>{
                    const Zt = br.getDataAttribute(Vt, Ot);
                    Zt === void 0 ? Vt.style.removeProperty(Ot) : (br.removeDataAttribute(Vt, Ot),
                    Vt.style[Ot] = Zt)
                }
                )
            }
            _applyManipulationCallback(St, Ot) {
                ot(St) ? Ot(St) : tt.find(St, this._element).forEach(Ot)
            }
            isOverflowing() {
                return this.getWidth() > 0
            }
        }
        const Ql = {
            isVisible: !0,
            isAnimated: !1,
            rootElement: "body",
            clickCallback: null
        }
          , Xl = {
            isVisible: "boolean",
            isAnimated: "boolean",
            rootElement: "(element|string)",
            clickCallback: "(function|null)"
        };
        class Lo {
            constructor(St) {
                this._config = this._getConfig(St),
                this._isAppended = !1,
                this._element = null
            }
            show(St) {
                this._config.isVisible ? (this._append(),
                this._config.isAnimated && gt(this._getElement()),
                this._getElement().classList.add("show"),
                this._emulateAnimation(()=>{
                    vt(St)
                }
                )) : vt(St)
            }
            hide(St) {
                this._config.isVisible ? (this._getElement().classList.remove("show"),
                this._emulateAnimation(()=>{
                    this.dispose(),
                    vt(St)
                }
                )) : vt(St)
            }
            _getElement() {
                if (!this._element) {
                    const St = document.createElement("div");
                    St.className = "modal-backdrop",
                    this._config.isAnimated && St.classList.add("fade"),
                    this._element = St
                }
                return this._element
            }
            _getConfig(St) {
                return (St = {
                    ...Ql,
                    ...typeof St == "object" ? St : {}
                }).rootElement = lt(St.rootElement),
                dt("backdrop", St, Xl),
                St
            }
            _append() {
                this._isAppended || (this._config.rootElement.appendChild(this._getElement()),
                zt.on(this._getElement(), "mousedown.bs.backdrop", ()=>{
                    vt(this._config.clickCallback)
                }
                ),
                this._isAppended = !0)
            }
            dispose() {
                this._isAppended && (zt.off(this._element, "mousedown.bs.backdrop"),
                this._element.remove(),
                this._isAppended = !1)
            }
            _emulateAnimation(St) {
                wt(St, this._getElement(), this._config.isAnimated)
            }
        }
        const Do = {
            backdrop: !0,
            keyboard: !0,
            focus: !0
        }
          , Jl = {
            backdrop: "(boolean|string)",
            keyboard: "boolean",
            focus: "boolean"
        };
        class Es extends ar {
            constructor(St, Ot) {
                super(St),
                this._config = this._getConfig(Ot),
                this._dialog = tt.findOne(".modal-dialog", this._element),
                this._backdrop = this._initializeBackDrop(),
                this._isShown = !1,
                this._ignoreBackdropClick = !1,
                this._isTransitioning = !1,
                this._scrollBar = new so
            }
            static get Default() {
                return Do
            }
            static get NAME() {
                return "modal"
            }
            toggle(St) {
                return this._isShown ? this.hide() : this.show(St)
            }
            show(St) {
                this._isShown || this._isTransitioning || zt.trigger(this._element, "show.bs.modal", {
                    relatedTarget: St
                }).defaultPrevented || (this._isShown = !0,
                this._isAnimated() && (this._isTransitioning = !0),
                this._scrollBar.hide(),
                document.body.classList.add("modal-open"),
                this._adjustDialog(),
                this._setEscapeEvent(),
                this._setResizeEvent(),
                zt.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', Ot=>this.hide(Ot)),
                zt.on(this._dialog, "mousedown.dismiss.bs.modal", ()=>{
                    zt.one(this._element, "mouseup.dismiss.bs.modal", Ot=>{
                        Ot.target === this._element && (this._ignoreBackdropClick = !0)
                    }
                    )
                }
                ),
                this._showBackdrop(()=>this._showElement(St)))
            }
            hide(St) {
                if (St && ["A", "AREA"].includes(St.target.tagName) && St.preventDefault(),
                !this._isShown || this._isTransitioning || zt.trigger(this._element, "hide.bs.modal").defaultPrevented)
                    return;
                this._isShown = !1;
                const Ot = this._isAnimated();
                Ot && (this._isTransitioning = !0),
                this._setEscapeEvent(),
                this._setResizeEvent(),
                zt.off(document, "focusin.bs.modal"),
                this._element.classList.remove("show"),
                zt.off(this._element, "click.dismiss.bs.modal"),
                zt.off(this._dialog, "mousedown.dismiss.bs.modal"),
                this._queueCallback(()=>this._hideModal(), this._element, Ot)
            }
            dispose() {
                [window, this._dialog].forEach(St=>zt.off(St, ".bs.modal")),
                this._backdrop.dispose(),
                super.dispose(),
                zt.off(document, "focusin.bs.modal")
            }
            handleUpdate() {
                this._adjustDialog()
            }
            _initializeBackDrop() {
                return new Lo({
                    isVisible: !!this._config.backdrop,
                    isAnimated: this._isAnimated()
                })
            }
            _getConfig(St) {
                return St = {
                    ...Do,
                    ...br.getDataAttributes(this._element),
                    ...typeof St == "object" ? St : {}
                },
                dt("modal", St, Jl),
                St
            }
            _showElement(St) {
                const Ot = this._isAnimated()
                  , Vt = tt.findOne(".modal-body", this._dialog);
                this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element),
                this._element.style.display = "block",
                this._element.removeAttribute("aria-hidden"),
                this._element.setAttribute("aria-modal", !0),
                this._element.setAttribute("role", "dialog"),
                this._element.scrollTop = 0,
                Vt && (Vt.scrollTop = 0),
                Ot && gt(this._element),
                this._element.classList.add("show"),
                this._config.focus && this._enforceFocus(),
                this._queueCallback(()=>{
                    this._config.focus && this._element.focus(),
                    this._isTransitioning = !1,
                    zt.trigger(this._element, "shown.bs.modal", {
                        relatedTarget: St
                    })
                }
                , this._dialog, Ot)
            }
            _enforceFocus() {
                zt.off(document, "focusin.bs.modal"),
                zt.on(document, "focusin.bs.modal", St=>{
                    document === St.target || this._element === St.target || this._element.contains(St.target) || this._element.focus()
                }
                )
            }
            _setEscapeEvent() {
                this._isShown ? zt.on(this._element, "keydown.dismiss.bs.modal", St=>{
                    this._config.keyboard && St.key === "Escape" ? (St.preventDefault(),
                    this.hide()) : this._config.keyboard || St.key !== "Escape" || this._triggerBackdropTransition()
                }
                ) : zt.off(this._element, "keydown.dismiss.bs.modal")
            }
            _setResizeEvent() {
                this._isShown ? zt.on(window, "resize.bs.modal", ()=>this._adjustDialog()) : zt.off(window, "resize.bs.modal")
            }
            _hideModal() {
                this._element.style.display = "none",
                this._element.setAttribute("aria-hidden", !0),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._isTransitioning = !1,
                this._backdrop.hide(()=>{
                    document.body.classList.remove("modal-open"),
                    this._resetAdjustments(),
                    this._scrollBar.reset(),
                    zt.trigger(this._element, "hidden.bs.modal")
                }
                )
            }
            _showBackdrop(St) {
                zt.on(this._element, "click.dismiss.bs.modal", Ot=>{
                    this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : Ot.target === Ot.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition())
                }
                ),
                this._backdrop.show(St)
            }
            _isAnimated() {
                return this._element.classList.contains("fade")
            }
            _triggerBackdropTransition() {
                if (zt.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented)
                    return;
                const {classList: St, scrollHeight: Ot, style: Vt} = this._element
                  , Zt = Ot > document.documentElement.clientHeight;
                !Zt && Vt.overflowY === "hidden" || St.contains("modal-static") || (Zt || (Vt.overflowY = "hidden"),
                St.add("modal-static"),
                this._queueCallback(()=>{
                    St.remove("modal-static"),
                    Zt || this._queueCallback(()=>{
                        Vt.overflowY = ""
                    }
                    , this._dialog)
                }
                , this._dialog),
                this._element.focus())
            }
            _adjustDialog() {
                const St = this._element.scrollHeight > document.documentElement.clientHeight
                  , Ot = this._scrollBar.getWidth()
                  , Vt = Ot > 0;
                (!Vt && St && !mt() || Vt && !St && mt()) && (this._element.style.paddingLeft = Ot + "px"),
                (Vt && !St && !mt() || !Vt && St && mt()) && (this._element.style.paddingRight = Ot + "px")
            }
            _resetAdjustments() {
                this._element.style.paddingLeft = "",
                this._element.style.paddingRight = ""
            }
            static jQueryInterface(St, Ot) {
                return this.each(function() {
                    const Vt = Es.getOrCreateInstance(this, St);
                    if (typeof St == "string") {
                        if (Vt[St] === void 0)
                            throw new TypeError(`No method named "${St}"`);
                        Vt[St](Ot)
                    }
                })
            }
        }
        zt.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', function(Ut) {
            const St = st(this);
            ["A", "AREA"].includes(this.tagName) && Ut.preventDefault(),
            zt.one(St, "show.bs.modal", Ot=>{
                Ot.defaultPrevented || zt.one(St, "hidden.bs.modal", ()=>{
                    ct(this) && this.focus()
                }
                )
            }
            ),
            Es.getOrCreateInstance(St).toggle(this)
        }),
        yt(Es);
        const Fo = {
            backdrop: !0,
            keyboard: !0,
            scroll: !1
        }
          , _c = {
            backdrop: "boolean",
            keyboard: "boolean",
            scroll: "boolean"
        };
        class Un extends ar {
            constructor(St, Ot) {
                super(St),
                this._config = this._getConfig(Ot),
                this._isShown = !1,
                this._backdrop = this._initializeBackDrop(),
                this._addEventListeners()
            }
            static get NAME() {
                return "offcanvas"
            }
            static get Default() {
                return Fo
            }
            toggle(St) {
                return this._isShown ? this.hide() : this.show(St)
            }
            show(St) {
                this._isShown || zt.trigger(this._element, "show.bs.offcanvas", {
                    relatedTarget: St
                }).defaultPrevented || (this._isShown = !0,
                this._element.style.visibility = "visible",
                this._backdrop.show(),
                this._config.scroll || (new so().hide(),
                this._enforceFocusOnElement(this._element)),
                this._element.removeAttribute("aria-hidden"),
                this._element.setAttribute("aria-modal", !0),
                this._element.setAttribute("role", "dialog"),
                this._element.classList.add("show"),
                this._queueCallback(()=>{
                    zt.trigger(this._element, "shown.bs.offcanvas", {
                        relatedTarget: St
                    })
                }
                , this._element, !0))
            }
            hide() {
                this._isShown && (zt.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (zt.off(document, "focusin.bs.offcanvas"),
                this._element.blur(),
                this._isShown = !1,
                this._element.classList.remove("show"),
                this._backdrop.hide(),
                this._queueCallback(()=>{
                    this._element.setAttribute("aria-hidden", !0),
                    this._element.removeAttribute("aria-modal"),
                    this._element.removeAttribute("role"),
                    this._element.style.visibility = "hidden",
                    this._config.scroll || new so().reset(),
                    zt.trigger(this._element, "hidden.bs.offcanvas")
                }
                , this._element, !0)))
            }
            dispose() {
                this._backdrop.dispose(),
                super.dispose(),
                zt.off(document, "focusin.bs.offcanvas")
            }
            _getConfig(St) {
                return St = {
                    ...Fo,
                    ...br.getDataAttributes(this._element),
                    ...typeof St == "object" ? St : {}
                },
                dt("offcanvas", St, _c),
                St
            }
            _initializeBackDrop() {
                return new Lo({
                    isVisible: this._config.backdrop,
                    isAnimated: !0,
                    rootElement: this._element.parentNode,
                    clickCallback: ()=>this.hide()
                })
            }
            _enforceFocusOnElement(St) {
                zt.off(document, "focusin.bs.offcanvas"),
                zt.on(document, "focusin.bs.offcanvas", Ot=>{
                    document === Ot.target || St === Ot.target || St.contains(Ot.target) || St.focus()
                }
                ),
                St.focus()
            }
            _addEventListeners() {
                zt.on(this._element, "click.dismiss.bs.offcanvas", '[data-bs-dismiss="offcanvas"]', ()=>this.hide()),
                zt.on(this._element, "keydown.dismiss.bs.offcanvas", St=>{
                    this._config.keyboard && St.key === "Escape" && this.hide()
                }
                )
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = Un.getOrCreateInstance(this, St);
                    if (typeof St == "string") {
                        if (Ot[St] === void 0 || St.startsWith("_") || St === "constructor")
                            throw new TypeError(`No method named "${St}"`);
                        Ot[St](this)
                    }
                })
            }
        }
        zt.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function(Ut) {
            const St = st(this);
            if (["A", "AREA"].includes(this.tagName) && Ut.preventDefault(),
            ut(this))
                return;
            zt.one(St, "hidden.bs.offcanvas", ()=>{
                ct(this) && this.focus()
            }
            );
            const Ot = tt.findOne(".offcanvas.show");
            Ot && Ot !== St && Un.getInstance(Ot).hide(),
            Un.getOrCreateInstance(St).toggle(this)
        }),
        zt.on(window, "load.bs.offcanvas.data-api", ()=>tt.find(".offcanvas.show").forEach(Ut=>Un.getOrCreateInstance(Ut).show())),
        yt(Un);
        const eu = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"])
          , tu = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i
          , ru = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i
          , nu = (Ut,St)=>{
            const Ot = Ut.nodeName.toLowerCase();
            if (St.includes(Ot))
                return !eu.has(Ot) || !!(tu.test(Ut.nodeValue) || ru.test(Ut.nodeValue));
            const Vt = St.filter(Zt=>Zt instanceof RegExp);
            for (let Zt = 0, Qt = Vt.length; Zt < Qt; Zt++)
                if (Vt[Zt].test(Ot))
                    return !0;
            return !1
        }
        ;
        function Bo(Ut, St, Ot) {
            if (!Ut.length)
                return Ut;
            if (Ot && typeof Ot == "function")
                return Ot(Ut);
            const Vt = new window.DOMParser().parseFromString(Ut, "text/html")
              , Zt = Object.keys(St)
              , Qt = [].concat(...Vt.body.querySelectorAll("*"));
            for (let er = 0, cr = Qt.length; er < cr; er++) {
                const dr = Qt[er]
                  , mr = dr.nodeName.toLowerCase();
                if (!Zt.includes(mr)) {
                    dr.remove();
                    continue
                }
                const xr = [].concat(...dr.attributes)
                  , yr = [].concat(St["*"] || [], St[mr] || []);
                xr.forEach(Rr=>{
                    nu(Rr, yr) || dr.removeAttribute(Rr.nodeName)
                }
                )
            }
            return Vt.body.innerHTML
        }
        const iu = new RegExp("(^|\\s)bs-tooltip\\S+","g")
          , su = new Set(["sanitize", "allowList", "sanitizeFn"])
          , au = {
            animation: "boolean",
            template: "string",
            title: "(string|element|function)",
            trigger: "string",
            delay: "(number|object)",
            html: "boolean",
            selector: "(string|boolean)",
            placement: "(string|function)",
            offset: "(array|string|function)",
            container: "(string|element|boolean)",
            fallbackPlacements: "array",
            boundary: "(string|element)",
            customClass: "(string|function)",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            allowList: "object",
            popperConfig: "(null|object|function)"
        }
          , ou = {
            AUTO: "auto",
            TOP: "top",
            RIGHT: mt() ? "left" : "right",
            BOTTOM: "bottom",
            LEFT: mt() ? "right" : "left"
        }
          , lu = {
            animation: !0,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: !1,
            selector: !1,
            placement: "top",
            offset: [0, 0],
            container: !1,
            fallbackPlacements: ["top", "right", "bottom", "left"],
            boundary: "clippingParents",
            customClass: "",
            sanitize: !0,
            sanitizeFn: null,
            allowList: {
                "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
                a: ["target", "href", "title", "rel"],
                area: [],
                b: [],
                br: [],
                col: [],
                code: [],
                div: [],
                em: [],
                hr: [],
                h1: [],
                h2: [],
                h3: [],
                h4: [],
                h5: [],
                h6: [],
                i: [],
                img: ["src", "srcset", "alt", "title", "width", "height"],
                li: [],
                ol: [],
                p: [],
                pre: [],
                s: [],
                small: [],
                span: [],
                sub: [],
                sup: [],
                strong: [],
                u: [],
                ul: []
            },
            popperConfig: null
        }
          , cu = {
            HIDE: "hide.bs.tooltip",
            HIDDEN: "hidden.bs.tooltip",
            SHOW: "show.bs.tooltip",
            SHOWN: "shown.bs.tooltip",
            INSERTED: "inserted.bs.tooltip",
            CLICK: "click.bs.tooltip",
            FOCUSIN: "focusin.bs.tooltip",
            FOCUSOUT: "focusout.bs.tooltip",
            MOUSEENTER: "mouseenter.bs.tooltip",
            MOUSELEAVE: "mouseleave.bs.tooltip"
        };
        class zn extends ar {
            constructor(St, Ot) {
                if (No === void 0)
                    throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                super(St),
                this._isEnabled = !0,
                this._timeout = 0,
                this._hoverState = "",
                this._activeTrigger = {},
                this._popper = null,
                this._config = this._getConfig(Ot),
                this.tip = null,
                this._setListeners()
            }
            static get Default() {
                return lu
            }
            static get NAME() {
                return "tooltip"
            }
            static get Event() {
                return cu
            }
            static get DefaultType() {
                return au
            }
            enable() {
                this._isEnabled = !0
            }
            disable() {
                this._isEnabled = !1
            }
            toggleEnabled() {
                this._isEnabled = !this._isEnabled
            }
            toggle(St) {
                if (this._isEnabled)
                    if (St) {
                        const Ot = this._initializeOnDelegatedTarget(St);
                        Ot._activeTrigger.click = !Ot._activeTrigger.click,
                        Ot._isWithActiveTrigger() ? Ot._enter(null, Ot) : Ot._leave(null, Ot)
                    } else {
                        if (this.getTipElement().classList.contains("show"))
                            return void this._leave(null, this);
                        this._enter(null, this)
                    }
            }
            dispose() {
                clearTimeout(this._timeout),
                zt.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler),
                this.tip && this.tip.remove(),
                this._popper && this._popper.destroy(),
                super.dispose()
            }
            show() {
                if (this._element.style.display === "none")
                    throw new Error("Please use show on visible elements");
                if (!this.isWithContent() || !this._isEnabled)
                    return;
                const St = zt.trigger(this._element, this.constructor.Event.SHOW)
                  , Ot = ft(this._element)
                  , Vt = Ot === null ? this._element.ownerDocument.documentElement.contains(this._element) : Ot.contains(this._element);
                if (St.defaultPrevented || !Vt)
                    return;
                const Zt = this.getTipElement()
                  , Qt = rt(this.constructor.NAME);
                Zt.setAttribute("id", Qt),
                this._element.setAttribute("aria-describedby", Qt),
                this.setContent(),
                this._config.animation && Zt.classList.add("fade");
                const er = typeof this._config.placement == "function" ? this._config.placement.call(this, Zt, this._element) : this._config.placement
                  , cr = this._getAttachment(er);
                this._addAttachmentClass(cr);
                const {container: dr} = this._config;
                rr.set(Zt, this.constructor.DATA_KEY, this),
                this._element.ownerDocument.documentElement.contains(this.tip) || (dr.appendChild(Zt),
                zt.trigger(this._element, this.constructor.Event.INSERTED)),
                this._popper ? this._popper.update() : this._popper = io(this._element, Zt, this._getPopperConfig(cr)),
                Zt.classList.add("show");
                const mr = typeof this._config.customClass == "function" ? this._config.customClass() : this._config.customClass;
                mr && Zt.classList.add(...mr.split(" ")),
                "ontouchstart"in document.documentElement && [].concat(...document.body.children).forEach(yr=>{
                    zt.on(yr, "mouseover", ht)
                }
                );
                const xr = this.tip.classList.contains("fade");
                this._queueCallback(()=>{
                    const yr = this._hoverState;
                    this._hoverState = null,
                    zt.trigger(this._element, this.constructor.Event.SHOWN),
                    yr === "out" && this._leave(null, this)
                }
                , this.tip, xr)
            }
            hide() {
                if (!this._popper)
                    return;
                const St = this.getTipElement();
                if (zt.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented)
                    return;
                St.classList.remove("show"),
                "ontouchstart"in document.documentElement && [].concat(...document.body.children).forEach(Vt=>zt.off(Vt, "mouseover", ht)),
                this._activeTrigger.click = !1,
                this._activeTrigger.focus = !1,
                this._activeTrigger.hover = !1;
                const Ot = this.tip.classList.contains("fade");
                this._queueCallback(()=>{
                    this._isWithActiveTrigger() || (this._hoverState !== "show" && St.remove(),
                    this._cleanTipClass(),
                    this._element.removeAttribute("aria-describedby"),
                    zt.trigger(this._element, this.constructor.Event.HIDDEN),
                    this._popper && (this._popper.destroy(),
                    this._popper = null))
                }
                , this.tip, Ot),
                this._hoverState = ""
            }
            update() {
                this._popper !== null && this._popper.update()
            }
            isWithContent() {
                return !!this.getTitle()
            }
            getTipElement() {
                if (this.tip)
                    return this.tip;
                const St = document.createElement("div");
                return St.innerHTML = this._config.template,
                this.tip = St.children[0],
                this.tip
            }
            setContent() {
                const St = this.getTipElement();
                this.setElementContent(tt.findOne(".tooltip-inner", St), this.getTitle()),
                St.classList.remove("fade", "show")
            }
            setElementContent(St, Ot) {
                if (St !== null)
                    return ot(Ot) ? (Ot = lt(Ot),
                    void (this._config.html ? Ot.parentNode !== St && (St.innerHTML = "",
                    St.appendChild(Ot)) : St.textContent = Ot.textContent)) : void (this._config.html ? (this._config.sanitize && (Ot = Bo(Ot, this._config.allowList, this._config.sanitizeFn)),
                    St.innerHTML = Ot) : St.textContent = Ot)
            }
            getTitle() {
                let St = this._element.getAttribute("data-bs-original-title");
                return St || (St = typeof this._config.title == "function" ? this._config.title.call(this._element) : this._config.title),
                St
            }
            updateAttachment(St) {
                return St === "right" ? "end" : St === "left" ? "start" : St
            }
            _initializeOnDelegatedTarget(St, Ot) {
                const Vt = this.constructor.DATA_KEY;
                return (Ot = Ot || rr.get(St.delegateTarget, Vt)) || (Ot = new this.constructor(St.delegateTarget,this._getDelegateConfig()),
                rr.set(St.delegateTarget, Vt, Ot)),
                Ot
            }
            _getOffset() {
                const {offset: St} = this._config;
                return typeof St == "string" ? St.split(",").map(Ot=>Number.parseInt(Ot, 10)) : typeof St == "function" ? Ot=>St(Ot, this._element) : St
            }
            _getPopperConfig(St) {
                const Ot = {
                    placement: St,
                    modifiers: [{
                        name: "flip",
                        options: {
                            fallbackPlacements: this._config.fallbackPlacements
                        }
                    }, {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }, {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    }, {
                        name: "arrow",
                        options: {
                            element: `.${this.constructor.NAME}-arrow`
                        }
                    }, {
                        name: "onChange",
                        enabled: !0,
                        phase: "afterWrite",
                        fn: Vt=>this._handlePopperPlacementChange(Vt)
                    }],
                    onFirstUpdate: Vt=>{
                        Vt.options.placement !== Vt.placement && this._handlePopperPlacementChange(Vt)
                    }
                };
                return {
                    ...Ot,
                    ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(Ot) : this._config.popperConfig
                }
            }
            _addAttachmentClass(St) {
                this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(St))
            }
            _getAttachment(St) {
                return ou[St.toUpperCase()]
            }
            _setListeners() {
                this._config.trigger.split(" ").forEach(St=>{
                    if (St === "click")
                        zt.on(this._element, this.constructor.Event.CLICK, this._config.selector, Ot=>this.toggle(Ot));
                    else if (St !== "manual") {
                        const Ot = St === "hover" ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN
                          , Vt = St === "hover" ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
                        zt.on(this._element, Ot, this._config.selector, Zt=>this._enter(Zt)),
                        zt.on(this._element, Vt, this._config.selector, Zt=>this._leave(Zt))
                    }
                }
                ),
                this._hideModalHandler = ()=>{
                    this._element && this.hide()
                }
                ,
                zt.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler),
                this._config.selector ? this._config = {
                    ...this._config,
                    trigger: "manual",
                    selector: ""
                } : this._fixTitle()
            }
            _fixTitle() {
                const St = this._element.getAttribute("title")
                  , Ot = typeof this._element.getAttribute("data-bs-original-title");
                (St || Ot !== "string") && (this._element.setAttribute("data-bs-original-title", St || ""),
                !St || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", St),
                this._element.setAttribute("title", ""))
            }
            _enter(St, Ot) {
                Ot = this._initializeOnDelegatedTarget(St, Ot),
                St && (Ot._activeTrigger[St.type === "focusin" ? "focus" : "hover"] = !0),
                Ot.getTipElement().classList.contains("show") || Ot._hoverState === "show" ? Ot._hoverState = "show" : (clearTimeout(Ot._timeout),
                Ot._hoverState = "show",
                Ot._config.delay && Ot._config.delay.show ? Ot._timeout = setTimeout(()=>{
                    Ot._hoverState === "show" && Ot.show()
                }
                , Ot._config.delay.show) : Ot.show())
            }
            _leave(St, Ot) {
                Ot = this._initializeOnDelegatedTarget(St, Ot),
                St && (Ot._activeTrigger[St.type === "focusout" ? "focus" : "hover"] = Ot._element.contains(St.relatedTarget)),
                Ot._isWithActiveTrigger() || (clearTimeout(Ot._timeout),
                Ot._hoverState = "out",
                Ot._config.delay && Ot._config.delay.hide ? Ot._timeout = setTimeout(()=>{
                    Ot._hoverState === "out" && Ot.hide()
                }
                , Ot._config.delay.hide) : Ot.hide())
            }
            _isWithActiveTrigger() {
                for (const St in this._activeTrigger)
                    if (this._activeTrigger[St])
                        return !0;
                return !1
            }
            _getConfig(St) {
                const Ot = br.getDataAttributes(this._element);
                return Object.keys(Ot).forEach(Vt=>{
                    su.has(Vt) && delete Ot[Vt]
                }
                ),
                (St = {
                    ...this.constructor.Default,
                    ...Ot,
                    ...typeof St == "object" && St ? St : {}
                }).container = St.container === !1 ? document.body : lt(St.container),
                typeof St.delay == "number" && (St.delay = {
                    show: St.delay,
                    hide: St.delay
                }),
                typeof St.title == "number" && (St.title = St.title.toString()),
                typeof St.content == "number" && (St.content = St.content.toString()),
                dt("tooltip", St, this.constructor.DefaultType),
                St.sanitize && (St.template = Bo(St.template, St.allowList, St.sanitizeFn)),
                St
            }
            _getDelegateConfig() {
                const St = {};
                if (this._config)
                    for (const Ot in this._config)
                        this.constructor.Default[Ot] !== this._config[Ot] && (St[Ot] = this._config[Ot]);
                return St
            }
            _cleanTipClass() {
                const St = this.getTipElement()
                  , Ot = St.getAttribute("class").match(iu);
                Ot !== null && Ot.length > 0 && Ot.map(Vt=>Vt.trim()).forEach(Vt=>St.classList.remove(Vt))
            }
            _handlePopperPlacementChange(St) {
                const {state: Ot} = St;
                Ot && (this.tip = Ot.elements.popper,
                this._cleanTipClass(),
                this._addAttachmentClass(this._getAttachment(Ot.placement)))
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = zn.getOrCreateInstance(this, St);
                    if (typeof St == "string") {
                        if (Ot[St] === void 0)
                            throw new TypeError(`No method named "${St}"`);
                        Ot[St]()
                    }
                })
            }
        }
        yt(zn);
        const uu = new RegExp("(^|\\s)bs-popover\\S+","g")
          , du = {
            ...zn.Default,
            placement: "right",
            offset: [0, 8],
            trigger: "click",
            content: "",
            template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }
          , pu = {
            ...zn.DefaultType,
            content: "(string|element|function)"
        }
          , fu = {
            HIDE: "hide.bs.popover",
            HIDDEN: "hidden.bs.popover",
            SHOW: "show.bs.popover",
            SHOWN: "shown.bs.popover",
            INSERTED: "inserted.bs.popover",
            CLICK: "click.bs.popover",
            FOCUSIN: "focusin.bs.popover",
            FOCUSOUT: "focusout.bs.popover",
            MOUSEENTER: "mouseenter.bs.popover",
            MOUSELEAVE: "mouseleave.bs.popover"
        };
        class Gs extends zn {
            static get Default() {
                return du
            }
            static get NAME() {
                return "popover"
            }
            static get Event() {
                return fu
            }
            static get DefaultType() {
                return pu
            }
            isWithContent() {
                return this.getTitle() || this._getContent()
            }
            getTipElement() {
                return this.tip || (this.tip = super.getTipElement(),
                this.getTitle() || tt.findOne(".popover-header", this.tip).remove(),
                this._getContent() || tt.findOne(".popover-body", this.tip).remove()),
                this.tip
            }
            setContent() {
                const St = this.getTipElement();
                this.setElementContent(tt.findOne(".popover-header", St), this.getTitle());
                let Ot = this._getContent();
                typeof Ot == "function" && (Ot = Ot.call(this._element)),
                this.setElementContent(tt.findOne(".popover-body", St), Ot),
                St.classList.remove("fade", "show")
            }
            _addAttachmentClass(St) {
                this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(St))
            }
            _getContent() {
                return this._element.getAttribute("data-bs-content") || this._config.content
            }
            _cleanTipClass() {
                const St = this.getTipElement()
                  , Ot = St.getAttribute("class").match(uu);
                Ot !== null && Ot.length > 0 && Ot.map(Vt=>Vt.trim()).forEach(Vt=>St.classList.remove(Vt))
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = Gs.getOrCreateInstance(this, St);
                    if (typeof St == "string") {
                        if (Ot[St] === void 0)
                            throw new TypeError(`No method named "${St}"`);
                        Ot[St]()
                    }
                })
            }
        }
        yt(Gs);
        const Wo = {
            offset: 10,
            method: "auto",
            target: ""
        }
          , hu = {
            offset: "number",
            method: "string",
            target: "(string|element)"
        };
        class _s extends ar {
            constructor(St, Ot) {
                super(St),
                this._scrollElement = this._element.tagName === "BODY" ? window : this._element,
                this._config = this._getConfig(Ot),
                this._selector = `${this._config.target} .nav-link, ${this._config.target} .list-group-item, ${this._config.target} .dropdown-item`,
                this._offsets = [],
                this._targets = [],
                this._activeTarget = null,
                this._scrollHeight = 0,
                zt.on(this._scrollElement, "scroll.bs.scrollspy", ()=>this._process()),
                this.refresh(),
                this._process()
            }
            static get Default() {
                return Wo
            }
            static get NAME() {
                return "scrollspy"
            }
            refresh() {
                const St = this._scrollElement === this._scrollElement.window ? "offset" : "position"
                  , Ot = this._config.method === "auto" ? St : this._config.method
                  , Vt = Ot === "position" ? this._getScrollTop() : 0;
                this._offsets = [],
                this._targets = [],
                this._scrollHeight = this._getScrollHeight(),
                tt.find(this._selector).map(Zt=>{
                    const Qt = it(Zt)
                      , er = Qt ? tt.findOne(Qt) : null;
                    if (er) {
                        const cr = er.getBoundingClientRect();
                        if (cr.width || cr.height)
                            return [br[Ot](er).top + Vt, Qt]
                    }
                    return null
                }
                ).filter(Zt=>Zt).sort((Zt,Qt)=>Zt[0] - Qt[0]).forEach(Zt=>{
                    this._offsets.push(Zt[0]),
                    this._targets.push(Zt[1])
                }
                )
            }
            dispose() {
                zt.off(this._scrollElement, ".bs.scrollspy"),
                super.dispose()
            }
            _getConfig(St) {
                if (typeof (St = {
                    ...Wo,
                    ...br.getDataAttributes(this._element),
                    ...typeof St == "object" && St ? St : {}
                }).target != "string" && ot(St.target)) {
                    let {id: Ot} = St.target;
                    Ot || (Ot = rt("scrollspy"),
                    St.target.id = Ot),
                    St.target = "#" + Ot
                }
                return dt("scrollspy", St, hu),
                St
            }
            _getScrollTop() {
                return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
            }
            _getScrollHeight() {
                return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
            }
            _getOffsetHeight() {
                return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
            }
            _process() {
                const St = this._getScrollTop() + this._config.offset
                  , Ot = this._getScrollHeight()
                  , Vt = this._config.offset + Ot - this._getOffsetHeight();
                if (this._scrollHeight !== Ot && this.refresh(),
                St >= Vt) {
                    const Zt = this._targets[this._targets.length - 1];
                    this._activeTarget !== Zt && this._activate(Zt)
                } else {
                    if (this._activeTarget && St < this._offsets[0] && this._offsets[0] > 0)
                        return this._activeTarget = null,
                        void this._clear();
                    for (let Zt = this._offsets.length; Zt--; )
                        this._activeTarget !== this._targets[Zt] && St >= this._offsets[Zt] && (this._offsets[Zt + 1] === void 0 || St < this._offsets[Zt + 1]) && this._activate(this._targets[Zt])
                }
            }
            _activate(St) {
                this._activeTarget = St,
                this._clear();
                const Ot = this._selector.split(",").map(Zt=>`${Zt}[data-bs-target="${St}"],${Zt}[href="${St}"]`)
                  , Vt = tt.findOne(Ot.join(","));
                Vt.classList.contains("dropdown-item") ? (tt.findOne(".dropdown-toggle", Vt.closest(".dropdown")).classList.add("active"),
                Vt.classList.add("active")) : (Vt.classList.add("active"),
                tt.parents(Vt, ".nav, .list-group").forEach(Zt=>{
                    tt.prev(Zt, ".nav-link, .list-group-item").forEach(Qt=>Qt.classList.add("active")),
                    tt.prev(Zt, ".nav-item").forEach(Qt=>{
                        tt.children(Qt, ".nav-link").forEach(er=>er.classList.add("active"))
                    }
                    )
                }
                )),
                zt.trigger(this._scrollElement, "activate.bs.scrollspy", {
                    relatedTarget: St
                })
            }
            _clear() {
                tt.find(this._selector).filter(St=>St.classList.contains("active")).forEach(St=>St.classList.remove("active"))
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = _s.getOrCreateInstance(this, St);
                    if (typeof St == "string") {
                        if (Ot[St] === void 0)
                            throw new TypeError(`No method named "${St}"`);
                        Ot[St]()
                    }
                })
            }
        }
        zt.on(window, "load.bs.scrollspy.data-api", ()=>{
            tt.find('[data-bs-spy="scroll"]').forEach(Ut=>new _s(Ut))
        }
        ),
        yt(_s);
        class Cs extends ar {
            static get NAME() {
                return "tab"
            }
            show() {
                if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active"))
                    return;
                let St;
                const Ot = st(this._element)
                  , Vt = this._element.closest(".nav, .list-group");
                if (Vt) {
                    const er = Vt.nodeName === "UL" || Vt.nodeName === "OL" ? ":scope > li > .active" : ".active";
                    St = tt.find(er, Vt),
                    St = St[St.length - 1]
                }
                const Zt = St ? zt.trigger(St, "hide.bs.tab", {
                    relatedTarget: this._element
                }) : null;
                if (zt.trigger(this._element, "show.bs.tab", {
                    relatedTarget: St
                }).defaultPrevented || Zt !== null && Zt.defaultPrevented)
                    return;
                this._activate(this._element, Vt);
                const Qt = ()=>{
                    zt.trigger(St, "hidden.bs.tab", {
                        relatedTarget: this._element
                    }),
                    zt.trigger(this._element, "shown.bs.tab", {
                        relatedTarget: St
                    })
                }
                ;
                Ot ? this._activate(Ot, Ot.parentNode, Qt) : Qt()
            }
            _activate(St, Ot, Vt) {
                const Zt = (!Ot || Ot.nodeName !== "UL" && Ot.nodeName !== "OL" ? tt.children(Ot, ".active") : tt.find(":scope > li > .active", Ot))[0]
                  , Qt = Vt && Zt && Zt.classList.contains("fade")
                  , er = ()=>this._transitionComplete(St, Zt, Vt);
                Zt && Qt ? (Zt.classList.remove("show"),
                this._queueCallback(er, St, !0)) : er()
            }
            _transitionComplete(St, Ot, Vt) {
                if (Ot) {
                    Ot.classList.remove("active");
                    const Qt = tt.findOne(":scope > .dropdown-menu .active", Ot.parentNode);
                    Qt && Qt.classList.remove("active"),
                    Ot.getAttribute("role") === "tab" && Ot.setAttribute("aria-selected", !1)
                }
                St.classList.add("active"),
                St.getAttribute("role") === "tab" && St.setAttribute("aria-selected", !0),
                gt(St),
                St.classList.contains("fade") && St.classList.add("show");
                let Zt = St.parentNode;
                if (Zt && Zt.nodeName === "LI" && (Zt = Zt.parentNode),
                Zt && Zt.classList.contains("dropdown-menu")) {
                    const Qt = St.closest(".dropdown");
                    Qt && tt.find(".dropdown-toggle", Qt).forEach(er=>er.classList.add("active")),
                    St.setAttribute("aria-expanded", !0)
                }
                Vt && Vt()
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = Cs.getOrCreateInstance(this);
                    if (typeof St == "string") {
                        if (Ot[St] === void 0)
                            throw new TypeError(`No method named "${St}"`);
                        Ot[St]()
                    }
                })
            }
        }
        zt.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', function(Ut) {
            ["A", "AREA"].includes(this.tagName) && Ut.preventDefault(),
            ut(this) || Cs.getOrCreateInstance(this).show()
        }),
        yt(Cs);
        const mu = {
            animation: "boolean",
            autohide: "boolean",
            delay: "number"
        }
          , Uo = {
            animation: !0,
            autohide: !0,
            delay: 5e3
        };
        class qs extends ar {
            constructor(St, Ot) {
                super(St),
                this._config = this._getConfig(Ot),
                this._timeout = null,
                this._hasMouseInteraction = !1,
                this._hasKeyboardInteraction = !1,
                this._setListeners()
            }
            static get DefaultType() {
                return mu
            }
            static get Default() {
                return Uo
            }
            static get NAME() {
                return "toast"
            }
            show() {
                zt.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(),
                this._config.animation && this._element.classList.add("fade"),
                this._element.classList.remove("hide"),
                gt(this._element),
                this._element.classList.add("showing"),
                this._queueCallback(()=>{
                    this._element.classList.remove("showing"),
                    this._element.classList.add("show"),
                    zt.trigger(this._element, "shown.bs.toast"),
                    this._maybeScheduleHide()
                }
                , this._element, this._config.animation))
            }
            hide() {
                this._element.classList.contains("show") && (zt.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.remove("show"),
                this._queueCallback(()=>{
                    this._element.classList.add("hide"),
                    zt.trigger(this._element, "hidden.bs.toast")
                }
                , this._element, this._config.animation)))
            }
            dispose() {
                this._clearTimeout(),
                this._element.classList.contains("show") && this._element.classList.remove("show"),
                super.dispose()
            }
            _getConfig(St) {
                return St = {
                    ...Uo,
                    ...br.getDataAttributes(this._element),
                    ...typeof St == "object" && St ? St : {}
                },
                dt("toast", St, this.constructor.DefaultType),
                St
            }
            _maybeScheduleHide() {
                this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(()=>{
                    this.hide()
                }
                , this._config.delay)))
            }
            _onInteraction(St, Ot) {
                switch (St.type) {
                case "mouseover":
                case "mouseout":
                    this._hasMouseInteraction = Ot;
                    break;
                case "focusin":
                case "focusout":
                    this._hasKeyboardInteraction = Ot
                }
                if (Ot)
                    return void this._clearTimeout();
                const Vt = St.relatedTarget;
                this._element === Vt || this._element.contains(Vt) || this._maybeScheduleHide()
            }
            _setListeners() {
                zt.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', ()=>this.hide()),
                zt.on(this._element, "mouseover.bs.toast", St=>this._onInteraction(St, !0)),
                zt.on(this._element, "mouseout.bs.toast", St=>this._onInteraction(St, !1)),
                zt.on(this._element, "focusin.bs.toast", St=>this._onInteraction(St, !0)),
                zt.on(this._element, "focusout.bs.toast", St=>this._onInteraction(St, !1))
            }
            _clearTimeout() {
                clearTimeout(this._timeout),
                this._timeout = null
            }
            static jQueryInterface(St) {
                return this.each(function() {
                    const Ot = qs.getOrCreateInstance(this, St);
                    if (typeof St == "string") {
                        if (Ot[St] === void 0)
                            throw new TypeError(`No method named "${St}"`);
                        Ot[St](this)
                    }
                })
            }
        }
        return yt(qs),
        {
            Alert: or,
            Button: pr,
            Carousel: Hr,
            Collapse: tr,
            Dropdown: ln,
            Modal: Es,
            Offcanvas: Un,
            Popover: Gs,
            ScrollSpy: _s,
            Tab: Cs,
            Toast: qs,
            Tooltip: zn
        }
    })
}
)(bootstrap_bundle_min);
var buffer = {}
  , base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = []
  , revLookup = []
  , Arr = typeof Uint8Array < "u" ? Uint8Array : Array
  , code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
    lookup[i] = code[i],
    revLookup[code.charCodeAt(i)] = i;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(_e) {
    var et = _e.length;
    if (et % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var tt = _e.indexOf("=");
    tt === -1 && (tt = et);
    var rt = tt === et ? 0 : 4 - tt % 4;
    return [tt, rt]
}
function byteLength(_e) {
    var et = getLens(_e)
      , tt = et[0]
      , rt = et[1];
    return (tt + rt) * 3 / 4 - rt
}
function _byteLength(_e, et, tt) {
    return (et + tt) * 3 / 4 - tt
}
function toByteArray(_e) {
    var et, tt = getLens(_e), rt = tt[0], nt = tt[1], it = new Arr(_byteLength(_e, rt, nt)), st = 0, at = nt > 0 ? rt - 4 : rt, ot;
    for (ot = 0; ot < at; ot += 4)
        et = revLookup[_e.charCodeAt(ot)] << 18 | revLookup[_e.charCodeAt(ot + 1)] << 12 | revLookup[_e.charCodeAt(ot + 2)] << 6 | revLookup[_e.charCodeAt(ot + 3)],
        it[st++] = et >> 16 & 255,
        it[st++] = et >> 8 & 255,
        it[st++] = et & 255;
    return nt === 2 && (et = revLookup[_e.charCodeAt(ot)] << 2 | revLookup[_e.charCodeAt(ot + 1)] >> 4,
    it[st++] = et & 255),
    nt === 1 && (et = revLookup[_e.charCodeAt(ot)] << 10 | revLookup[_e.charCodeAt(ot + 1)] << 4 | revLookup[_e.charCodeAt(ot + 2)] >> 2,
    it[st++] = et >> 8 & 255,
    it[st++] = et & 255),
    it
}
function tripletToBase64(_e) {
    return lookup[_e >> 18 & 63] + lookup[_e >> 12 & 63] + lookup[_e >> 6 & 63] + lookup[_e & 63]
}
function encodeChunk(_e, et, tt) {
    for (var rt, nt = [], it = et; it < tt; it += 3)
        rt = (_e[it] << 16 & 16711680) + (_e[it + 1] << 8 & 65280) + (_e[it + 2] & 255),
        nt.push(tripletToBase64(rt));
    return nt.join("")
}
function fromByteArray(_e) {
    for (var et, tt = _e.length, rt = tt % 3, nt = [], it = 16383, st = 0, at = tt - rt; st < at; st += it)
        nt.push(encodeChunk(_e, st, st + it > at ? at : st + it));
    return rt === 1 ? (et = _e[tt - 1],
    nt.push(lookup[et >> 2] + lookup[et << 4 & 63] + "==")) : rt === 2 && (et = (_e[tt - 2] << 8) + _e[tt - 1],
    nt.push(lookup[et >> 10] + lookup[et >> 4 & 63] + lookup[et << 2 & 63] + "=")),
    nt.join("")
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(_e, et, tt, rt, nt) {
    var it, st, at = nt * 8 - rt - 1, ot = (1 << at) - 1, lt = ot >> 1, dt = -7, ct = tt ? nt - 1 : 0, ut = tt ? -1 : 1, ft = _e[et + ct];
    for (ct += ut,
    it = ft & (1 << -dt) - 1,
    ft >>= -dt,
    dt += at; dt > 0; it = it * 256 + _e[et + ct],
    ct += ut,
    dt -= 8)
        ;
    for (st = it & (1 << -dt) - 1,
    it >>= -dt,
    dt += rt; dt > 0; st = st * 256 + _e[et + ct],
    ct += ut,
    dt -= 8)
        ;
    if (it === 0)
        it = 1 - lt;
    else {
        if (it === ot)
            return st ? NaN : (ft ? -1 : 1) * (1 / 0);
        st = st + Math.pow(2, rt),
        it = it - lt
    }
    return (ft ? -1 : 1) * st * Math.pow(2, it - rt)
}
;
ieee754.write = function(_e, et, tt, rt, nt, it) {
    var st, at, ot, lt = it * 8 - nt - 1, dt = (1 << lt) - 1, ct = dt >> 1, ut = nt === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ft = rt ? 0 : it - 1, ht = rt ? 1 : -1, gt = et < 0 || et === 0 && 1 / et < 0 ? 1 : 0;
    for (et = Math.abs(et),
    isNaN(et) || et === 1 / 0 ? (at = isNaN(et) ? 1 : 0,
    st = dt) : (st = Math.floor(Math.log(et) / Math.LN2),
    et * (ot = Math.pow(2, -st)) < 1 && (st--,
    ot *= 2),
    st + ct >= 1 ? et += ut / ot : et += ut * Math.pow(2, 1 - ct),
    et * ot >= 2 && (st++,
    ot /= 2),
    st + ct >= dt ? (at = 0,
    st = dt) : st + ct >= 1 ? (at = (et * ot - 1) * Math.pow(2, nt),
    st = st + ct) : (at = et * Math.pow(2, ct - 1) * Math.pow(2, nt),
    st = 0)); nt >= 8; _e[tt + ft] = at & 255,
    ft += ht,
    at /= 256,
    nt -= 8)
        ;
    for (st = st << nt | at,
    lt += nt; lt > 0; _e[tt + ft] = st & 255,
    ft += ht,
    st /= 256,
    lt -= 8)
        ;
    _e[tt + ft - ht] |= gt * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(_e) {
    const et = base64Js
      , tt = ieee754
      , rt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    _e.Buffer = at,
    _e.SlowBuffer = mt,
    _e.INSPECT_MAX_BYTES = 50;
    const nt = 2147483647;
    _e.kMaxLength = nt,
    at.TYPED_ARRAY_SUPPORT = it(),
    !at.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function it() {
        try {
            const Wt = new Uint8Array(1)
              , Rt = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(Rt, Uint8Array.prototype),
            Object.setPrototypeOf(Wt, Rt),
            Wt.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(at.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (at.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(at.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (at.isBuffer(this))
                return this.byteOffset
        }
    });
    function st(Wt) {
        if (Wt > nt)
            throw new RangeError('The value "' + Wt + '" is invalid for option "size"');
        const Rt = new Uint8Array(Wt);
        return Object.setPrototypeOf(Rt, at.prototype),
        Rt
    }
    function at(Wt, Rt, jt) {
        if (typeof Wt == "number") {
            if (typeof Rt == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return ct(Wt)
        }
        return ot(Wt, Rt, jt)
    }
    at.poolSize = 8192;
    function ot(Wt, Rt, jt) {
        if (typeof Wt == "string")
            return ut(Wt, Rt);
        if (ArrayBuffer.isView(Wt))
            return ht(Wt);
        if (Wt == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Wt);
        if (lr(Wt, ArrayBuffer) || Wt && lr(Wt.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (lr(Wt, SharedArrayBuffer) || Wt && lr(Wt.buffer, SharedArrayBuffer)))
            return gt(Wt, Rt, jt);
        if (typeof Wt == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const Ht = Wt.valueOf && Wt.valueOf();
        if (Ht != null && Ht !== Wt)
            return at.from(Ht, Rt, jt);
        const qt = bt(Wt);
        if (qt)
            return qt;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Wt[Symbol.toPrimitive] == "function")
            return at.from(Wt[Symbol.toPrimitive]("string"), Rt, jt);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Wt)
    }
    at.from = function(Wt, Rt, jt) {
        return ot(Wt, Rt, jt)
    }
    ,
    Object.setPrototypeOf(at.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(at, Uint8Array);
    function lt(Wt) {
        if (typeof Wt != "number")
            throw new TypeError('"size" argument must be of type number');
        if (Wt < 0)
            throw new RangeError('The value "' + Wt + '" is invalid for option "size"')
    }
    function dt(Wt, Rt, jt) {
        return lt(Wt),
        Wt <= 0 ? st(Wt) : Rt !== void 0 ? typeof jt == "string" ? st(Wt).fill(Rt, jt) : st(Wt).fill(Rt) : st(Wt)
    }
    at.alloc = function(Wt, Rt, jt) {
        return dt(Wt, Rt, jt)
    }
    ;
    function ct(Wt) {
        return lt(Wt),
        st(Wt < 0 ? 0 : pt(Wt) | 0)
    }
    at.allocUnsafe = function(Wt) {
        return ct(Wt)
    }
    ,
    at.allocUnsafeSlow = function(Wt) {
        return ct(Wt)
    }
    ;
    function ut(Wt, Rt) {
        if ((typeof Rt != "string" || Rt === "") && (Rt = "utf8"),
        !at.isEncoding(Rt))
            throw new TypeError("Unknown encoding: " + Rt);
        const jt = yt(Wt, Rt) | 0;
        let Ht = st(jt);
        const qt = Ht.write(Wt, Rt);
        return qt !== jt && (Ht = Ht.slice(0, qt)),
        Ht
    }
    function ft(Wt) {
        const Rt = Wt.length < 0 ? 0 : pt(Wt.length) | 0
          , jt = st(Rt);
        for (let Ht = 0; Ht < Rt; Ht += 1)
            jt[Ht] = Wt[Ht] & 255;
        return jt
    }
    function ht(Wt) {
        if (lr(Wt, Uint8Array)) {
            const Rt = new Uint8Array(Wt);
            return gt(Rt.buffer, Rt.byteOffset, Rt.byteLength)
        }
        return ft(Wt)
    }
    function gt(Wt, Rt, jt) {
        if (Rt < 0 || Wt.byteLength < Rt)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (Wt.byteLength < Rt + (jt || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let Ht;
        return Rt === void 0 && jt === void 0 ? Ht = new Uint8Array(Wt) : jt === void 0 ? Ht = new Uint8Array(Wt,Rt) : Ht = new Uint8Array(Wt,Rt,jt),
        Object.setPrototypeOf(Ht, at.prototype),
        Ht
    }
    function bt(Wt) {
        if (at.isBuffer(Wt)) {
            const Rt = pt(Wt.length) | 0
              , jt = st(Rt);
            return jt.length === 0 || Wt.copy(jt, 0, 0, Rt),
            jt
        }
        if (Wt.length !== void 0)
            return typeof Wt.length != "number" || sr(Wt.length) ? st(0) : ft(Wt);
        if (Wt.type === "Buffer" && Array.isArray(Wt.data))
            return ft(Wt.data)
    }
    function pt(Wt) {
        if (Wt >= nt)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + nt.toString(16) + " bytes");
        return Wt | 0
    }
    function mt(Wt) {
        return +Wt != Wt && (Wt = 0),
        at.alloc(+Wt)
    }
    at.isBuffer = function(Rt) {
        return Rt != null && Rt._isBuffer === !0 && Rt !== at.prototype
    }
    ,
    at.compare = function(Rt, jt) {
        if (lr(Rt, Uint8Array) && (Rt = at.from(Rt, Rt.offset, Rt.byteLength)),
        lr(jt, Uint8Array) && (jt = at.from(jt, jt.offset, jt.byteLength)),
        !at.isBuffer(Rt) || !at.isBuffer(jt))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (Rt === jt)
            return 0;
        let Ht = Rt.length
          , qt = jt.length;
        for (let Xt = 0, nr = Math.min(Ht, qt); Xt < nr; ++Xt)
            if (Rt[Xt] !== jt[Xt]) {
                Ht = Rt[Xt],
                qt = jt[Xt];
                break
            }
        return Ht < qt ? -1 : qt < Ht ? 1 : 0
    }
    ,
    at.isEncoding = function(Rt) {
        switch (String(Rt).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    at.concat = function(Rt, jt) {
        if (!Array.isArray(Rt))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (Rt.length === 0)
            return at.alloc(0);
        let Ht;
        if (jt === void 0)
            for (jt = 0,
            Ht = 0; Ht < Rt.length; ++Ht)
                jt += Rt[Ht].length;
        const qt = at.allocUnsafe(jt);
        let Xt = 0;
        for (Ht = 0; Ht < Rt.length; ++Ht) {
            let nr = Rt[Ht];
            if (lr(nr, Uint8Array))
                Xt + nr.length > qt.length ? (at.isBuffer(nr) || (nr = at.from(nr)),
                nr.copy(qt, Xt)) : Uint8Array.prototype.set.call(qt, nr, Xt);
            else if (at.isBuffer(nr))
                nr.copy(qt, Xt);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            Xt += nr.length
        }
        return qt
    }
    ;
    function yt(Wt, Rt) {
        if (at.isBuffer(Wt))
            return Wt.length;
        if (ArrayBuffer.isView(Wt) || lr(Wt, ArrayBuffer))
            return Wt.byteLength;
        if (typeof Wt != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Wt);
        const jt = Wt.length
          , Ht = arguments.length > 2 && arguments[2] === !0;
        if (!Ht && jt === 0)
            return 0;
        let qt = !1;
        for (; ; )
            switch (Rt) {
            case "ascii":
            case "latin1":
            case "binary":
                return jt;
            case "utf8":
            case "utf-8":
                return Yr(Wt).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return jt * 2;
            case "hex":
                return jt >>> 1;
            case "base64":
                return Jt(Wt).length;
            default:
                if (qt)
                    return Ht ? -1 : Yr(Wt).length;
                Rt = ("" + Rt).toLowerCase(),
                qt = !0
            }
    }
    at.byteLength = yt;
    function vt(Wt, Rt, jt) {
        let Ht = !1;
        if ((Rt === void 0 || Rt < 0) && (Rt = 0),
        Rt > this.length || ((jt === void 0 || jt > this.length) && (jt = this.length),
        jt <= 0) || (jt >>>= 0,
        Rt >>>= 0,
        jt <= Rt))
            return "";
        for (Wt || (Wt = "utf8"); ; )
            switch (Wt) {
            case "hex":
                return Pt(this, Rt, jt);
            case "utf8":
            case "utf-8":
                return Lt(this, Rt, jt);
            case "ascii":
                return kt(this, Rt, jt);
            case "latin1":
            case "binary":
                return At(this, Rt, jt);
            case "base64":
                return Ft(this, Rt, jt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Dt(this, Rt, jt);
            default:
                if (Ht)
                    throw new TypeError("Unknown encoding: " + Wt);
                Wt = (Wt + "").toLowerCase(),
                Ht = !0
            }
    }
    at.prototype._isBuffer = !0;
    function wt(Wt, Rt, jt) {
        const Ht = Wt[Rt];
        Wt[Rt] = Wt[jt],
        Wt[jt] = Ht
    }
    at.prototype.swap16 = function() {
        const Rt = this.length;
        if (Rt % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let jt = 0; jt < Rt; jt += 2)
            wt(this, jt, jt + 1);
        return this
    }
    ,
    at.prototype.swap32 = function() {
        const Rt = this.length;
        if (Rt % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let jt = 0; jt < Rt; jt += 4)
            wt(this, jt, jt + 3),
            wt(this, jt + 1, jt + 2);
        return this
    }
    ,
    at.prototype.swap64 = function() {
        const Rt = this.length;
        if (Rt % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let jt = 0; jt < Rt; jt += 8)
            wt(this, jt, jt + 7),
            wt(this, jt + 1, jt + 6),
            wt(this, jt + 2, jt + 5),
            wt(this, jt + 3, jt + 4);
        return this
    }
    ,
    at.prototype.toString = function() {
        const Rt = this.length;
        return Rt === 0 ? "" : arguments.length === 0 ? Lt(this, 0, Rt) : vt.apply(this, arguments)
    }
    ,
    at.prototype.toLocaleString = at.prototype.toString,
    at.prototype.equals = function(Rt) {
        if (!at.isBuffer(Rt))
            throw new TypeError("Argument must be a Buffer");
        return this === Rt ? !0 : at.compare(this, Rt) === 0
    }
    ,
    at.prototype.inspect = function() {
        let Rt = "";
        const jt = _e.INSPECT_MAX_BYTES;
        return Rt = this.toString("hex", 0, jt).replace(/(.{2})/g, "$1 ").trim(),
        this.length > jt && (Rt += " ... "),
        "<Buffer " + Rt + ">"
    }
    ,
    rt && (at.prototype[rt] = at.prototype.inspect),
    at.prototype.compare = function(Rt, jt, Ht, qt, Xt) {
        if (lr(Rt, Uint8Array) && (Rt = at.from(Rt, Rt.offset, Rt.byteLength)),
        !at.isBuffer(Rt))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Rt);
        if (jt === void 0 && (jt = 0),
        Ht === void 0 && (Ht = Rt ? Rt.length : 0),
        qt === void 0 && (qt = 0),
        Xt === void 0 && (Xt = this.length),
        jt < 0 || Ht > Rt.length || qt < 0 || Xt > this.length)
            throw new RangeError("out of range index");
        if (qt >= Xt && jt >= Ht)
            return 0;
        if (qt >= Xt)
            return -1;
        if (jt >= Ht)
            return 1;
        if (jt >>>= 0,
        Ht >>>= 0,
        qt >>>= 0,
        Xt >>>= 0,
        this === Rt)
            return 0;
        let nr = Xt - qt
          , Er = Ht - jt;
        const Dr = Math.min(nr, Er)
          , kr = this.slice(qt, Xt)
          , Fr = Rt.slice(jt, Ht);
        for (let Mr = 0; Mr < Dr; ++Mr)
            if (kr[Mr] !== Fr[Mr]) {
                nr = kr[Mr],
                Er = Fr[Mr];
                break
            }
        return nr < Er ? -1 : Er < nr ? 1 : 0
    }
    ;
    function _t(Wt, Rt, jt, Ht, qt) {
        if (Wt.length === 0)
            return -1;
        if (typeof jt == "string" ? (Ht = jt,
        jt = 0) : jt > 2147483647 ? jt = 2147483647 : jt < -2147483648 && (jt = -2147483648),
        jt = +jt,
        sr(jt) && (jt = qt ? 0 : Wt.length - 1),
        jt < 0 && (jt = Wt.length + jt),
        jt >= Wt.length) {
            if (qt)
                return -1;
            jt = Wt.length - 1
        } else if (jt < 0)
            if (qt)
                jt = 0;
            else
                return -1;
        if (typeof Rt == "string" && (Rt = at.from(Rt, Ht)),
        at.isBuffer(Rt))
            return Rt.length === 0 ? -1 : Et(Wt, Rt, jt, Ht, qt);
        if (typeof Rt == "number")
            return Rt = Rt & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? qt ? Uint8Array.prototype.indexOf.call(Wt, Rt, jt) : Uint8Array.prototype.lastIndexOf.call(Wt, Rt, jt) : Et(Wt, [Rt], jt, Ht, qt);
        throw new TypeError("val must be string, number or Buffer")
    }
    function Et(Wt, Rt, jt, Ht, qt) {
        let Xt = 1
          , nr = Wt.length
          , Er = Rt.length;
        if (Ht !== void 0 && (Ht = String(Ht).toLowerCase(),
        Ht === "ucs2" || Ht === "ucs-2" || Ht === "utf16le" || Ht === "utf-16le")) {
            if (Wt.length < 2 || Rt.length < 2)
                return -1;
            Xt = 2,
            nr /= 2,
            Er /= 2,
            jt /= 2
        }
        function Dr(Fr, Mr) {
            return Xt === 1 ? Fr[Mr] : Fr.readUInt16BE(Mr * Xt)
        }
        let kr;
        if (qt) {
            let Fr = -1;
            for (kr = jt; kr < nr; kr++)
                if (Dr(Wt, kr) === Dr(Rt, Fr === -1 ? 0 : kr - Fr)) {
                    if (Fr === -1 && (Fr = kr),
                    kr - Fr + 1 === Er)
                        return Fr * Xt
                } else
                    Fr !== -1 && (kr -= kr - Fr),
                    Fr = -1
        } else
            for (jt + Er > nr && (jt = nr - Er),
            kr = jt; kr >= 0; kr--) {
                let Fr = !0;
                for (let Mr = 0; Mr < Er; Mr++)
                    if (Dr(Wt, kr + Mr) !== Dr(Rt, Mr)) {
                        Fr = !1;
                        break
                    }
                if (Fr)
                    return kr
            }
        return -1
    }
    at.prototype.includes = function(Rt, jt, Ht) {
        return this.indexOf(Rt, jt, Ht) !== -1
    }
    ,
    at.prototype.indexOf = function(Rt, jt, Ht) {
        return _t(this, Rt, jt, Ht, !0)
    }
    ,
    at.prototype.lastIndexOf = function(Rt, jt, Ht) {
        return _t(this, Rt, jt, Ht, !1)
    }
    ;
    function xt(Wt, Rt, jt, Ht) {
        jt = Number(jt) || 0;
        const qt = Wt.length - jt;
        Ht ? (Ht = Number(Ht),
        Ht > qt && (Ht = qt)) : Ht = qt;
        const Xt = Rt.length;
        Ht > Xt / 2 && (Ht = Xt / 2);
        let nr;
        for (nr = 0; nr < Ht; ++nr) {
            const Er = parseInt(Rt.substr(nr * 2, 2), 16);
            if (sr(Er))
                return nr;
            Wt[jt + nr] = Er
        }
        return nr
    }
    function Ct(Wt, Rt, jt, Ht) {
        return tr(Yr(Rt, Wt.length - jt), Wt, jt, Ht)
    }
    function Tt(Wt, Rt, jt, Ht) {
        return tr(Hr(Rt), Wt, jt, Ht)
    }
    function It(Wt, Rt, jt, Ht) {
        return tr(Jt(Rt), Wt, jt, Ht)
    }
    function Nt(Wt, Rt, jt, Ht) {
        return tr(Gt(Rt, Wt.length - jt), Wt, jt, Ht)
    }
    at.prototype.write = function(Rt, jt, Ht, qt) {
        if (jt === void 0)
            qt = "utf8",
            Ht = this.length,
            jt = 0;
        else if (Ht === void 0 && typeof jt == "string")
            qt = jt,
            Ht = this.length,
            jt = 0;
        else if (isFinite(jt))
            jt = jt >>> 0,
            isFinite(Ht) ? (Ht = Ht >>> 0,
            qt === void 0 && (qt = "utf8")) : (qt = Ht,
            Ht = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Xt = this.length - jt;
        if ((Ht === void 0 || Ht > Xt) && (Ht = Xt),
        Rt.length > 0 && (Ht < 0 || jt < 0) || jt > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        qt || (qt = "utf8");
        let nr = !1;
        for (; ; )
            switch (qt) {
            case "hex":
                return xt(this, Rt, jt, Ht);
            case "utf8":
            case "utf-8":
                return Ct(this, Rt, jt, Ht);
            case "ascii":
            case "latin1":
            case "binary":
                return Tt(this, Rt, jt, Ht);
            case "base64":
                return It(this, Rt, jt, Ht);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Nt(this, Rt, jt, Ht);
            default:
                if (nr)
                    throw new TypeError("Unknown encoding: " + qt);
                qt = ("" + qt).toLowerCase(),
                nr = !0
            }
    }
    ,
    at.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function Ft(Wt, Rt, jt) {
        return Rt === 0 && jt === Wt.length ? et.fromByteArray(Wt) : et.fromByteArray(Wt.slice(Rt, jt))
    }
    function Lt(Wt, Rt, jt) {
        jt = Math.min(Wt.length, jt);
        const Ht = [];
        let qt = Rt;
        for (; qt < jt; ) {
            const Xt = Wt[qt];
            let nr = null
              , Er = Xt > 239 ? 4 : Xt > 223 ? 3 : Xt > 191 ? 2 : 1;
            if (qt + Er <= jt) {
                let Dr, kr, Fr, Mr;
                switch (Er) {
                case 1:
                    Xt < 128 && (nr = Xt);
                    break;
                case 2:
                    Dr = Wt[qt + 1],
                    (Dr & 192) === 128 && (Mr = (Xt & 31) << 6 | Dr & 63,
                    Mr > 127 && (nr = Mr));
                    break;
                case 3:
                    Dr = Wt[qt + 1],
                    kr = Wt[qt + 2],
                    (Dr & 192) === 128 && (kr & 192) === 128 && (Mr = (Xt & 15) << 12 | (Dr & 63) << 6 | kr & 63,
                    Mr > 2047 && (Mr < 55296 || Mr > 57343) && (nr = Mr));
                    break;
                case 4:
                    Dr = Wt[qt + 1],
                    kr = Wt[qt + 2],
                    Fr = Wt[qt + 3],
                    (Dr & 192) === 128 && (kr & 192) === 128 && (Fr & 192) === 128 && (Mr = (Xt & 15) << 18 | (Dr & 63) << 12 | (kr & 63) << 6 | Fr & 63,
                    Mr > 65535 && Mr < 1114112 && (nr = Mr))
                }
            }
            nr === null ? (nr = 65533,
            Er = 1) : nr > 65535 && (nr -= 65536,
            Ht.push(nr >>> 10 & 1023 | 55296),
            nr = 56320 | nr & 1023),
            Ht.push(nr),
            qt += Er
        }
        return $t(Ht)
    }
    const Mt = 4096;
    function $t(Wt) {
        const Rt = Wt.length;
        if (Rt <= Mt)
            return String.fromCharCode.apply(String, Wt);
        let jt = ""
          , Ht = 0;
        for (; Ht < Rt; )
            jt += String.fromCharCode.apply(String, Wt.slice(Ht, Ht += Mt));
        return jt
    }
    function kt(Wt, Rt, jt) {
        let Ht = "";
        jt = Math.min(Wt.length, jt);
        for (let qt = Rt; qt < jt; ++qt)
            Ht += String.fromCharCode(Wt[qt] & 127);
        return Ht
    }
    function At(Wt, Rt, jt) {
        let Ht = "";
        jt = Math.min(Wt.length, jt);
        for (let qt = Rt; qt < jt; ++qt)
            Ht += String.fromCharCode(Wt[qt]);
        return Ht
    }
    function Pt(Wt, Rt, jt) {
        const Ht = Wt.length;
        (!Rt || Rt < 0) && (Rt = 0),
        (!jt || jt < 0 || jt > Ht) && (jt = Ht);
        let qt = "";
        for (let Xt = Rt; Xt < jt; ++Xt)
            qt += ir[Wt[Xt]];
        return qt
    }
    function Dt(Wt, Rt, jt) {
        const Ht = Wt.slice(Rt, jt);
        let qt = "";
        for (let Xt = 0; Xt < Ht.length - 1; Xt += 2)
            qt += String.fromCharCode(Ht[Xt] + Ht[Xt + 1] * 256);
        return qt
    }
    at.prototype.slice = function(Rt, jt) {
        const Ht = this.length;
        Rt = ~~Rt,
        jt = jt === void 0 ? Ht : ~~jt,
        Rt < 0 ? (Rt += Ht,
        Rt < 0 && (Rt = 0)) : Rt > Ht && (Rt = Ht),
        jt < 0 ? (jt += Ht,
        jt < 0 && (jt = 0)) : jt > Ht && (jt = Ht),
        jt < Rt && (jt = Rt);
        const qt = this.subarray(Rt, jt);
        return Object.setPrototypeOf(qt, at.prototype),
        qt
    }
    ;
    function Bt(Wt, Rt, jt) {
        if (Wt % 1 !== 0 || Wt < 0)
            throw new RangeError("offset is not uint");
        if (Wt + Rt > jt)
            throw new RangeError("Trying to access beyond buffer length")
    }
    at.prototype.readUintLE = at.prototype.readUIntLE = function(Rt, jt, Ht) {
        Rt = Rt >>> 0,
        jt = jt >>> 0,
        Ht || Bt(Rt, jt, this.length);
        let qt = this[Rt]
          , Xt = 1
          , nr = 0;
        for (; ++nr < jt && (Xt *= 256); )
            qt += this[Rt + nr] * Xt;
        return qt
    }
    ,
    at.prototype.readUintBE = at.prototype.readUIntBE = function(Rt, jt, Ht) {
        Rt = Rt >>> 0,
        jt = jt >>> 0,
        Ht || Bt(Rt, jt, this.length);
        let qt = this[Rt + --jt]
          , Xt = 1;
        for (; jt > 0 && (Xt *= 256); )
            qt += this[Rt + --jt] * Xt;
        return qt
    }
    ,
    at.prototype.readUint8 = at.prototype.readUInt8 = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 1, this.length),
        this[Rt]
    }
    ,
    at.prototype.readUint16LE = at.prototype.readUInt16LE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 2, this.length),
        this[Rt] | this[Rt + 1] << 8
    }
    ,
    at.prototype.readUint16BE = at.prototype.readUInt16BE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 2, this.length),
        this[Rt] << 8 | this[Rt + 1]
    }
    ,
    at.prototype.readUint32LE = at.prototype.readUInt32LE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 4, this.length),
        (this[Rt] | this[Rt + 1] << 8 | this[Rt + 2] << 16) + this[Rt + 3] * 16777216
    }
    ,
    at.prototype.readUint32BE = at.prototype.readUInt32BE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 4, this.length),
        this[Rt] * 16777216 + (this[Rt + 1] << 16 | this[Rt + 2] << 8 | this[Rt + 3])
    }
    ,
    at.prototype.readBigUInt64LE = ur(function(Rt) {
        Rt = Rt >>> 0,
        _r(Rt, "offset");
        const jt = this[Rt]
          , Ht = this[Rt + 7];
        (jt === void 0 || Ht === void 0) && hr(Rt, this.length - 8);
        const qt = jt + this[++Rt] * 2 ** 8 + this[++Rt] * 2 ** 16 + this[++Rt] * 2 ** 24
          , Xt = this[++Rt] + this[++Rt] * 2 ** 8 + this[++Rt] * 2 ** 16 + Ht * 2 ** 24;
        return BigInt(qt) + (BigInt(Xt) << BigInt(32))
    }),
    at.prototype.readBigUInt64BE = ur(function(Rt) {
        Rt = Rt >>> 0,
        _r(Rt, "offset");
        const jt = this[Rt]
          , Ht = this[Rt + 7];
        (jt === void 0 || Ht === void 0) && hr(Rt, this.length - 8);
        const qt = jt * 2 ** 24 + this[++Rt] * 2 ** 16 + this[++Rt] * 2 ** 8 + this[++Rt]
          , Xt = this[++Rt] * 2 ** 24 + this[++Rt] * 2 ** 16 + this[++Rt] * 2 ** 8 + Ht;
        return (BigInt(qt) << BigInt(32)) + BigInt(Xt)
    }),
    at.prototype.readIntLE = function(Rt, jt, Ht) {
        Rt = Rt >>> 0,
        jt = jt >>> 0,
        Ht || Bt(Rt, jt, this.length);
        let qt = this[Rt]
          , Xt = 1
          , nr = 0;
        for (; ++nr < jt && (Xt *= 256); )
            qt += this[Rt + nr] * Xt;
        return Xt *= 128,
        qt >= Xt && (qt -= Math.pow(2, 8 * jt)),
        qt
    }
    ,
    at.prototype.readIntBE = function(Rt, jt, Ht) {
        Rt = Rt >>> 0,
        jt = jt >>> 0,
        Ht || Bt(Rt, jt, this.length);
        let qt = jt
          , Xt = 1
          , nr = this[Rt + --qt];
        for (; qt > 0 && (Xt *= 256); )
            nr += this[Rt + --qt] * Xt;
        return Xt *= 128,
        nr >= Xt && (nr -= Math.pow(2, 8 * jt)),
        nr
    }
    ,
    at.prototype.readInt8 = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 1, this.length),
        this[Rt] & 128 ? (255 - this[Rt] + 1) * -1 : this[Rt]
    }
    ,
    at.prototype.readInt16LE = function(Rt, jt) {
        Rt = Rt >>> 0,
        jt || Bt(Rt, 2, this.length);
        const Ht = this[Rt] | this[Rt + 1] << 8;
        return Ht & 32768 ? Ht | 4294901760 : Ht
    }
    ,
    at.prototype.readInt16BE = function(Rt, jt) {
        Rt = Rt >>> 0,
        jt || Bt(Rt, 2, this.length);
        const Ht = this[Rt + 1] | this[Rt] << 8;
        return Ht & 32768 ? Ht | 4294901760 : Ht
    }
    ,
    at.prototype.readInt32LE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 4, this.length),
        this[Rt] | this[Rt + 1] << 8 | this[Rt + 2] << 16 | this[Rt + 3] << 24
    }
    ,
    at.prototype.readInt32BE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 4, this.length),
        this[Rt] << 24 | this[Rt + 1] << 16 | this[Rt + 2] << 8 | this[Rt + 3]
    }
    ,
    at.prototype.readBigInt64LE = ur(function(Rt) {
        Rt = Rt >>> 0,
        _r(Rt, "offset");
        const jt = this[Rt]
          , Ht = this[Rt + 7];
        (jt === void 0 || Ht === void 0) && hr(Rt, this.length - 8);
        const qt = this[Rt + 4] + this[Rt + 5] * 2 ** 8 + this[Rt + 6] * 2 ** 16 + (Ht << 24);
        return (BigInt(qt) << BigInt(32)) + BigInt(jt + this[++Rt] * 2 ** 8 + this[++Rt] * 2 ** 16 + this[++Rt] * 2 ** 24)
    }),
    at.prototype.readBigInt64BE = ur(function(Rt) {
        Rt = Rt >>> 0,
        _r(Rt, "offset");
        const jt = this[Rt]
          , Ht = this[Rt + 7];
        (jt === void 0 || Ht === void 0) && hr(Rt, this.length - 8);
        const qt = (jt << 24) + this[++Rt] * 2 ** 16 + this[++Rt] * 2 ** 8 + this[++Rt];
        return (BigInt(qt) << BigInt(32)) + BigInt(this[++Rt] * 2 ** 24 + this[++Rt] * 2 ** 16 + this[++Rt] * 2 ** 8 + Ht)
    }),
    at.prototype.readFloatLE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 4, this.length),
        tt.read(this, Rt, !0, 23, 4)
    }
    ,
    at.prototype.readFloatBE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 4, this.length),
        tt.read(this, Rt, !1, 23, 4)
    }
    ,
    at.prototype.readDoubleLE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 8, this.length),
        tt.read(this, Rt, !0, 52, 8)
    }
    ,
    at.prototype.readDoubleBE = function(Rt, jt) {
        return Rt = Rt >>> 0,
        jt || Bt(Rt, 8, this.length),
        tt.read(this, Rt, !1, 52, 8)
    }
    ;
    function zt(Wt, Rt, jt, Ht, qt, Xt) {
        if (!at.isBuffer(Wt))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (Rt > qt || Rt < Xt)
            throw new RangeError('"value" argument is out of bounds');
        if (jt + Ht > Wt.length)
            throw new RangeError("Index out of range")
    }
    at.prototype.writeUintLE = at.prototype.writeUIntLE = function(Rt, jt, Ht, qt) {
        if (Rt = +Rt,
        jt = jt >>> 0,
        Ht = Ht >>> 0,
        !qt) {
            const Er = Math.pow(2, 8 * Ht) - 1;
            zt(this, Rt, jt, Ht, Er, 0)
        }
        let Xt = 1
          , nr = 0;
        for (this[jt] = Rt & 255; ++nr < Ht && (Xt *= 256); )
            this[jt + nr] = Rt / Xt & 255;
        return jt + Ht
    }
    ,
    at.prototype.writeUintBE = at.prototype.writeUIntBE = function(Rt, jt, Ht, qt) {
        if (Rt = +Rt,
        jt = jt >>> 0,
        Ht = Ht >>> 0,
        !qt) {
            const Er = Math.pow(2, 8 * Ht) - 1;
            zt(this, Rt, jt, Ht, Er, 0)
        }
        let Xt = Ht - 1
          , nr = 1;
        for (this[jt + Xt] = Rt & 255; --Xt >= 0 && (nr *= 256); )
            this[jt + Xt] = Rt / nr & 255;
        return jt + Ht
    }
    ,
    at.prototype.writeUint8 = at.prototype.writeUInt8 = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 1, 255, 0),
        this[jt] = Rt & 255,
        jt + 1
    }
    ,
    at.prototype.writeUint16LE = at.prototype.writeUInt16LE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 2, 65535, 0),
        this[jt] = Rt & 255,
        this[jt + 1] = Rt >>> 8,
        jt + 2
    }
    ,
    at.prototype.writeUint16BE = at.prototype.writeUInt16BE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 2, 65535, 0),
        this[jt] = Rt >>> 8,
        this[jt + 1] = Rt & 255,
        jt + 2
    }
    ,
    at.prototype.writeUint32LE = at.prototype.writeUInt32LE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 4, 4294967295, 0),
        this[jt + 3] = Rt >>> 24,
        this[jt + 2] = Rt >>> 16,
        this[jt + 1] = Rt >>> 8,
        this[jt] = Rt & 255,
        jt + 4
    }
    ,
    at.prototype.writeUint32BE = at.prototype.writeUInt32BE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 4, 4294967295, 0),
        this[jt] = Rt >>> 24,
        this[jt + 1] = Rt >>> 16,
        this[jt + 2] = Rt >>> 8,
        this[jt + 3] = Rt & 255,
        jt + 4
    }
    ;
    function Yt(Wt, Rt, jt, Ht, qt) {
        Wr(Rt, Ht, qt, Wt, jt, 7);
        let Xt = Number(Rt & BigInt(4294967295));
        Wt[jt++] = Xt,
        Xt = Xt >> 8,
        Wt[jt++] = Xt,
        Xt = Xt >> 8,
        Wt[jt++] = Xt,
        Xt = Xt >> 8,
        Wt[jt++] = Xt;
        let nr = Number(Rt >> BigInt(32) & BigInt(4294967295));
        return Wt[jt++] = nr,
        nr = nr >> 8,
        Wt[jt++] = nr,
        nr = nr >> 8,
        Wt[jt++] = nr,
        nr = nr >> 8,
        Wt[jt++] = nr,
        jt
    }
    function rr(Wt, Rt, jt, Ht, qt) {
        Wr(Rt, Ht, qt, Wt, jt, 7);
        let Xt = Number(Rt & BigInt(4294967295));
        Wt[jt + 7] = Xt,
        Xt = Xt >> 8,
        Wt[jt + 6] = Xt,
        Xt = Xt >> 8,
        Wt[jt + 5] = Xt,
        Xt = Xt >> 8,
        Wt[jt + 4] = Xt;
        let nr = Number(Rt >> BigInt(32) & BigInt(4294967295));
        return Wt[jt + 3] = nr,
        nr = nr >> 8,
        Wt[jt + 2] = nr,
        nr = nr >> 8,
        Wt[jt + 1] = nr,
        nr = nr >> 8,
        Wt[jt] = nr,
        jt + 8
    }
    at.prototype.writeBigUInt64LE = ur(function(Rt, jt=0) {
        return Yt(this, Rt, jt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    at.prototype.writeBigUInt64BE = ur(function(Rt, jt=0) {
        return rr(this, Rt, jt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    at.prototype.writeIntLE = function(Rt, jt, Ht, qt) {
        if (Rt = +Rt,
        jt = jt >>> 0,
        !qt) {
            const Dr = Math.pow(2, 8 * Ht - 1);
            zt(this, Rt, jt, Ht, Dr - 1, -Dr)
        }
        let Xt = 0
          , nr = 1
          , Er = 0;
        for (this[jt] = Rt & 255; ++Xt < Ht && (nr *= 256); )
            Rt < 0 && Er === 0 && this[jt + Xt - 1] !== 0 && (Er = 1),
            this[jt + Xt] = (Rt / nr >> 0) - Er & 255;
        return jt + Ht
    }
    ,
    at.prototype.writeIntBE = function(Rt, jt, Ht, qt) {
        if (Rt = +Rt,
        jt = jt >>> 0,
        !qt) {
            const Dr = Math.pow(2, 8 * Ht - 1);
            zt(this, Rt, jt, Ht, Dr - 1, -Dr)
        }
        let Xt = Ht - 1
          , nr = 1
          , Er = 0;
        for (this[jt + Xt] = Rt & 255; --Xt >= 0 && (nr *= 256); )
            Rt < 0 && Er === 0 && this[jt + Xt + 1] !== 0 && (Er = 1),
            this[jt + Xt] = (Rt / nr >> 0) - Er & 255;
        return jt + Ht
    }
    ,
    at.prototype.writeInt8 = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 1, 127, -128),
        Rt < 0 && (Rt = 255 + Rt + 1),
        this[jt] = Rt & 255,
        jt + 1
    }
    ,
    at.prototype.writeInt16LE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 2, 32767, -32768),
        this[jt] = Rt & 255,
        this[jt + 1] = Rt >>> 8,
        jt + 2
    }
    ,
    at.prototype.writeInt16BE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 2, 32767, -32768),
        this[jt] = Rt >>> 8,
        this[jt + 1] = Rt & 255,
        jt + 2
    }
    ,
    at.prototype.writeInt32LE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 4, 2147483647, -2147483648),
        this[jt] = Rt & 255,
        this[jt + 1] = Rt >>> 8,
        this[jt + 2] = Rt >>> 16,
        this[jt + 3] = Rt >>> 24,
        jt + 4
    }
    ,
    at.prototype.writeInt32BE = function(Rt, jt, Ht) {
        return Rt = +Rt,
        jt = jt >>> 0,
        Ht || zt(this, Rt, jt, 4, 2147483647, -2147483648),
        Rt < 0 && (Rt = 4294967295 + Rt + 1),
        this[jt] = Rt >>> 24,
        this[jt + 1] = Rt >>> 16,
        this[jt + 2] = Rt >>> 8,
        this[jt + 3] = Rt & 255,
        jt + 4
    }
    ,
    at.prototype.writeBigInt64LE = ur(function(Rt, jt=0) {
        return Yt(this, Rt, jt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    at.prototype.writeBigInt64BE = ur(function(Rt, jt=0) {
        return rr(this, Rt, jt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function ar(Wt, Rt, jt, Ht, qt, Xt) {
        if (jt + Ht > Wt.length)
            throw new RangeError("Index out of range");
        if (jt < 0)
            throw new RangeError("Index out of range")
    }
    function or(Wt, Rt, jt, Ht, qt) {
        return Rt = +Rt,
        jt = jt >>> 0,
        qt || ar(Wt, Rt, jt, 4),
        tt.write(Wt, Rt, jt, Ht, 23, 4),
        jt + 4
    }
    at.prototype.writeFloatLE = function(Rt, jt, Ht) {
        return or(this, Rt, jt, !0, Ht)
    }
    ,
    at.prototype.writeFloatBE = function(Rt, jt, Ht) {
        return or(this, Rt, jt, !1, Ht)
    }
    ;
    function pr(Wt, Rt, jt, Ht, qt) {
        return Rt = +Rt,
        jt = jt >>> 0,
        qt || ar(Wt, Rt, jt, 8),
        tt.write(Wt, Rt, jt, Ht, 52, 8),
        jt + 8
    }
    at.prototype.writeDoubleLE = function(Rt, jt, Ht) {
        return pr(this, Rt, jt, !0, Ht)
    }
    ,
    at.prototype.writeDoubleBE = function(Rt, jt, Ht) {
        return pr(this, Rt, jt, !1, Ht)
    }
    ,
    at.prototype.copy = function(Rt, jt, Ht, qt) {
        if (!at.isBuffer(Rt))
            throw new TypeError("argument should be a Buffer");
        if (Ht || (Ht = 0),
        !qt && qt !== 0 && (qt = this.length),
        jt >= Rt.length && (jt = Rt.length),
        jt || (jt = 0),
        qt > 0 && qt < Ht && (qt = Ht),
        qt === Ht || Rt.length === 0 || this.length === 0)
            return 0;
        if (jt < 0)
            throw new RangeError("targetStart out of bounds");
        if (Ht < 0 || Ht >= this.length)
            throw new RangeError("Index out of range");
        if (qt < 0)
            throw new RangeError("sourceEnd out of bounds");
        qt > this.length && (qt = this.length),
        Rt.length - jt < qt - Ht && (qt = Rt.length - jt + Ht);
        const Xt = qt - Ht;
        return this === Rt && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(jt, Ht, qt) : Uint8Array.prototype.set.call(Rt, this.subarray(Ht, qt), jt),
        Xt
    }
    ,
    at.prototype.fill = function(Rt, jt, Ht, qt) {
        if (typeof Rt == "string") {
            if (typeof jt == "string" ? (qt = jt,
            jt = 0,
            Ht = this.length) : typeof Ht == "string" && (qt = Ht,
            Ht = this.length),
            qt !== void 0 && typeof qt != "string")
                throw new TypeError("encoding must be a string");
            if (typeof qt == "string" && !at.isEncoding(qt))
                throw new TypeError("Unknown encoding: " + qt);
            if (Rt.length === 1) {
                const nr = Rt.charCodeAt(0);
                (qt === "utf8" && nr < 128 || qt === "latin1") && (Rt = nr)
            }
        } else
            typeof Rt == "number" ? Rt = Rt & 255 : typeof Rt == "boolean" && (Rt = Number(Rt));
        if (jt < 0 || this.length < jt || this.length < Ht)
            throw new RangeError("Out of range index");
        if (Ht <= jt)
            return this;
        jt = jt >>> 0,
        Ht = Ht === void 0 ? this.length : Ht >>> 0,
        Rt || (Rt = 0);
        let Xt;
        if (typeof Rt == "number")
            for (Xt = jt; Xt < Ht; ++Xt)
                this[Xt] = Rt;
        else {
            const nr = at.isBuffer(Rt) ? Rt : at.from(Rt, qt)
              , Er = nr.length;
            if (Er === 0)
                throw new TypeError('The value "' + Rt + '" is invalid for argument "value"');
            for (Xt = 0; Xt < Ht - jt; ++Xt)
                this[Xt + jt] = nr[Xt % Er]
        }
        return this
    }
    ;
    const gr = {};
    function Sr(Wt, Rt, jt) {
        gr[Wt] = class extends jt {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: Rt.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${Wt}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return Wt
            }
            set code(qt) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: qt,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${Wt}]: ${this.message}`
            }
        }
    }
    Sr("ERR_BUFFER_OUT_OF_BOUNDS", function(Wt) {
        return Wt ? `${Wt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    Sr("ERR_INVALID_ARG_TYPE", function(Wt, Rt) {
        return `The "${Wt}" argument must be of type number. Received type ${typeof Rt}`
    }, TypeError),
    Sr("ERR_OUT_OF_RANGE", function(Wt, Rt, jt) {
        let Ht = `The value of "${Wt}" is out of range.`
          , qt = jt;
        return Number.isInteger(jt) && Math.abs(jt) > 2 ** 32 ? qt = br(String(jt)) : typeof jt == "bigint" && (qt = String(jt),
        (jt > BigInt(2) ** BigInt(32) || jt < -(BigInt(2) ** BigInt(32))) && (qt = br(qt)),
        qt += "n"),
        Ht += ` It must be ${Rt}. Received ${qt}`,
        Ht
    }, RangeError);
    function br(Wt) {
        let Rt = ""
          , jt = Wt.length;
        const Ht = Wt[0] === "-" ? 1 : 0;
        for (; jt >= Ht + 4; jt -= 3)
            Rt = `_${Wt.slice(jt - 3, jt)}${Rt}`;
        return `${Wt.slice(0, jt)}${Rt}`
    }
    function Pr(Wt, Rt, jt) {
        _r(Rt, "offset"),
        (Wt[Rt] === void 0 || Wt[Rt + jt] === void 0) && hr(Rt, Wt.length - (jt + 1))
    }
    function Wr(Wt, Rt, jt, Ht, qt, Xt) {
        if (Wt > jt || Wt < Rt) {
            const nr = typeof Rt == "bigint" ? "n" : "";
            let Er;
            throw Xt > 3 ? Rt === 0 || Rt === BigInt(0) ? Er = `>= 0${nr} and < 2${nr} ** ${(Xt + 1) * 8}${nr}` : Er = `>= -(2${nr} ** ${(Xt + 1) * 8 - 1}${nr}) and < 2 ** ${(Xt + 1) * 8 - 1}${nr}` : Er = `>= ${Rt}${nr} and <= ${jt}${nr}`,
            new gr.ERR_OUT_OF_RANGE("value",Er,Wt)
        }
        Pr(Ht, qt, Xt)
    }
    function _r(Wt, Rt) {
        if (typeof Wt != "number")
            throw new gr.ERR_INVALID_ARG_TYPE(Rt,"number",Wt)
    }
    function hr(Wt, Rt, jt) {
        throw Math.floor(Wt) !== Wt ? (_r(Wt, jt),
        new gr.ERR_OUT_OF_RANGE(jt || "offset","an integer",Wt)) : Rt < 0 ? new gr.ERR_BUFFER_OUT_OF_BOUNDS : new gr.ERR_OUT_OF_RANGE(jt || "offset",`>= ${jt ? 1 : 0} and <= ${Rt}`,Wt)
    }
    const Vr = /[^+/0-9A-Za-z-_]/g;
    function Xr(Wt) {
        if (Wt = Wt.split("=")[0],
        Wt = Wt.trim().replace(Vr, ""),
        Wt.length < 2)
            return "";
        for (; Wt.length % 4 !== 0; )
            Wt = Wt + "=";
        return Wt
    }
    function Yr(Wt, Rt) {
        Rt = Rt || 1 / 0;
        let jt;
        const Ht = Wt.length;
        let qt = null;
        const Xt = [];
        for (let nr = 0; nr < Ht; ++nr) {
            if (jt = Wt.charCodeAt(nr),
            jt > 55295 && jt < 57344) {
                if (!qt) {
                    if (jt > 56319) {
                        (Rt -= 3) > -1 && Xt.push(239, 191, 189);
                        continue
                    } else if (nr + 1 === Ht) {
                        (Rt -= 3) > -1 && Xt.push(239, 191, 189);
                        continue
                    }
                    qt = jt;
                    continue
                }
                if (jt < 56320) {
                    (Rt -= 3) > -1 && Xt.push(239, 191, 189),
                    qt = jt;
                    continue
                }
                jt = (qt - 55296 << 10 | jt - 56320) + 65536
            } else
                qt && (Rt -= 3) > -1 && Xt.push(239, 191, 189);
            if (qt = null,
            jt < 128) {
                if ((Rt -= 1) < 0)
                    break;
                Xt.push(jt)
            } else if (jt < 2048) {
                if ((Rt -= 2) < 0)
                    break;
                Xt.push(jt >> 6 | 192, jt & 63 | 128)
            } else if (jt < 65536) {
                if ((Rt -= 3) < 0)
                    break;
                Xt.push(jt >> 12 | 224, jt >> 6 & 63 | 128, jt & 63 | 128)
            } else if (jt < 1114112) {
                if ((Rt -= 4) < 0)
                    break;
                Xt.push(jt >> 18 | 240, jt >> 12 & 63 | 128, jt >> 6 & 63 | 128, jt & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return Xt
    }
    function Hr(Wt) {
        const Rt = [];
        for (let jt = 0; jt < Wt.length; ++jt)
            Rt.push(Wt.charCodeAt(jt) & 255);
        return Rt
    }
    function Gt(Wt, Rt) {
        let jt, Ht, qt;
        const Xt = [];
        for (let nr = 0; nr < Wt.length && !((Rt -= 2) < 0); ++nr)
            jt = Wt.charCodeAt(nr),
            Ht = jt >> 8,
            qt = jt % 256,
            Xt.push(qt),
            Xt.push(Ht);
        return Xt
    }
    function Jt(Wt) {
        return et.toByteArray(Xr(Wt))
    }
    function tr(Wt, Rt, jt, Ht) {
        let qt;
        for (qt = 0; qt < Ht && !(qt + jt >= Rt.length || qt >= Wt.length); ++qt)
            Rt[qt + jt] = Wt[qt];
        return qt
    }
    function lr(Wt, Rt) {
        return Wt instanceof Rt || Wt != null && Wt.constructor != null && Wt.constructor.name != null && Wt.constructor.name === Rt.name
    }
    function sr(Wt) {
        return Wt !== Wt
    }
    const ir = function() {
        const Wt = "0123456789abcdef"
          , Rt = new Array(256);
        for (let jt = 0; jt < 16; ++jt) {
            const Ht = jt * 16;
            for (let qt = 0; qt < 16; ++qt)
                Rt[Ht + qt] = Wt[jt] + Wt[qt]
        }
        return Rt
    }();
    function ur(Wt) {
        return typeof BigInt > "u" ? Cr : Wt
    }
    function Cr() {
        throw new Error("BigInt not supported")
    }
}
)(buffer);
var $l;
typeof window < "u" && (window.Buffer || (window.Buffer = buffer.Buffer),
window.global || (window.global = window),
window.process || (window.process = {}),
($l = window.process) != null && $l.env || (window.process = {
    env: {}
}));
coinbaseWallet.type = "coinbaseWallet";
function coinbaseWallet(_e) {
    let tt, rt;
    return nt=>({
        id: "coinbaseWalletSDK",
        name: "Coinbase Wallet",
        type: coinbaseWallet.type,
        async connect({chainId: it}={}) {
            try {
                const st = await this.getProvider()
                  , at = (await st.request({
                    method: "eth_requestAccounts"
                })).map(lt=>getAddress(lt));
                st.on("accountsChanged", this.onAccountsChanged),
                st.on("chainChanged", this.onChainChanged),
                st.on("disconnect", this.onDisconnect.bind(this));
                let ot = await this.getChainId();
                if (it && ot !== it) {
                    const lt = await this.switchChain({
                        chainId: it
                    }).catch(dt=>{
                        if (dt.code === UserRejectedRequestError.code)
                            throw dt;
                        return {
                            id: ot
                        }
                    }
                    );
                    ot = (lt == null ? void 0 : lt.id) ?? ot
                }
                return {
                    accounts: at,
                    chainId: ot
                }
            } catch (st) {
                throw /(user closed modal|accounts received is empty|user denied account)/i.test(st.message) ? new UserRejectedRequestError(st) : st
            }
        },
        async disconnect() {
            const it = await this.getProvider();
            it.removeListener("accountsChanged", this.onAccountsChanged),
            it.removeListener("chainChanged", this.onChainChanged),
            it.removeListener("disconnect", this.onDisconnect.bind(this)),
            it.disconnect(),
            it.close()
        },
        async getAccounts() {
            return (await (await this.getProvider()).request({
                method: "eth_accounts"
            })).map(st=>getAddress(st))
        },
        async getChainId() {
            const st = await (await this.getProvider()).request({
                method: "eth_chainId"
            });
            return normalizeChainId(st)
        },
        async getProvider() {
            var it;
            if (!rt) {
                const {default: st} = await __vitePreload(()=>import("./index-BbdLNzVy.js").then(ut=>ut.i), __vite__mapDeps([0, 1]));
                let at;
                typeof st != "function" && typeof st.default == "function" ? at = st.default : at = st,
                tt = new at({
                    reloadOnDisconnect: !1,
                    ..._e
                });
                const ot = (it = tt.walletExtension) == null ? void 0 : it.getChainId()
                  , lt = nt.chains.find(ut=>_e.chainId ? ut.id === _e.chainId : ut.id === ot) || nt.chains[0]
                  , dt = _e.chainId || (lt == null ? void 0 : lt.id)
                  , ct = _e.jsonRpcUrl || (lt == null ? void 0 : lt.rpcUrls.default.http[0]);
                rt = tt.makeWeb3Provider(ct, dt)
            }
            return rt
        },
        async isAuthorized() {
            try {
                return !!(await this.getAccounts()).length
            } catch {
                return !1
            }
        },
        async switchChain({chainId: it}) {
            var lt, dt;
            const st = nt.chains.find(ct=>ct.id === it);
            if (!st)
                throw new SwitchChainError(new ChainNotConfiguredError);
            const at = await this.getProvider()
              , ot = numberToHex(st.id);
            try {
                return await at.request({
                    method: "wallet_switchEthereumChain",
                    params: [{
                        chainId: ot
                    }]
                }),
                st
            } catch (ct) {
                if (ct.code === 4902)
                    try {
                        return await at.request({
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: ot,
                                chainName: st.name,
                                nativeCurrency: st.nativeCurrency,
                                rpcUrls: [((lt = st.rpcUrls.default) == null ? void 0 : lt.http[0]) ?? ""],
                                blockExplorerUrls: [(dt = st.blockExplorers) == null ? void 0 : dt.default.url]
                            }]
                        }),
                        st
                    } catch (ut) {
                        throw new UserRejectedRequestError(ut)
                    }
                throw new SwitchChainError(ct)
            }
        },
        onAccountsChanged(it) {
            it.length === 0 ? nt.emitter.emit("disconnect") : nt.emitter.emit("change", {
                accounts: it.map(st=>getAddress(st))
            })
        },
        onChainChanged(it) {
            const st = normalizeChainId(it);
            nt.emitter.emit("change", {
                chainId: st
            })
        },
        async onDisconnect(it) {
            nt.emitter.emit("disconnect");
            const st = await this.getProvider();
            st.removeListener("accountsChanged", this.onAccountsChanged),
            st.removeListener("chainChanged", this.onChainChanged),
            st.removeListener("disconnect", this.onDisconnect.bind(this))
        }
    })
}
walletConnect.type = "walletConnect";
function walletConnect(_e) {
    const et = _e.isNewChainsStale ?? !0;
    let tt, rt;
    const nt = "eip155";
    return it=>({
        id: "walletConnect",
        name: "WalletConnect",
        type: walletConnect.type,
        async setup() {
            const st = await this.getProvider().catch(()=>null);
            st && (st.on("connect", this.onConnect.bind(this)),
            st.on("session_delete", this.onSessionDelete.bind(this)))
        },
        async connect({chainId: st, ...at}={}) {
            var ot, lt;
            try {
                const dt = await this.getProvider();
                if (!dt)
                    throw new ProviderNotFoundError;
                dt.on("display_uri", this.onDisplayUri);
                let ct = st;
                if (!ct) {
                    const gt = await ((ot = it.storage) == null ? void 0 : ot.getItem("state")) ?? {};
                    it.chains.some(pt=>pt.id === gt.chainId) ? ct = gt.chainId : ct = (lt = it.chains[0]) == null ? void 0 : lt.id
                }
                if (!ct)
                    throw new Error("No chains found on connector.");
                const ut = await this.isChainsStale();
                if (dt.session && ut && await dt.disconnect(),
                !dt.session || ut) {
                    const gt = it.chains.filter(bt=>bt.id !== ct).map(bt=>bt.id);
                    await dt.connect({
                        optionalChains: [ct, ...gt],
                        ..."pairingTopic"in at ? {
                            pairingTopic: at.pairingTopic
                        } : {}
                    }),
                    this.setRequestedChainsIds(it.chains.map(bt=>bt.id))
                }
                const ft = (await dt.enable()).map(gt=>getAddress(gt))
                  , ht = await this.getChainId();
                return dt.removeListener("display_uri", this.onDisplayUri),
                dt.removeListener("connect", this.onConnect.bind(this)),
                dt.on("accountsChanged", this.onAccountsChanged.bind(this)),
                dt.on("chainChanged", this.onChainChanged),
                dt.on("disconnect", this.onDisconnect.bind(this)),
                dt.on("session_delete", this.onSessionDelete.bind(this)),
                {
                    accounts: ft,
                    chainId: ht
                }
            } catch (dt) {
                throw /(user rejected|connection request reset)/i.test(dt == null ? void 0 : dt.message) ? new UserRejectedRequestError(dt) : dt
            }
        },
        async disconnect() {
            const st = await this.getProvider();
            try {
                await (st == null ? void 0 : st.disconnect())
            } catch (at) {
                if (!/No matching key/i.test(at.message))
                    throw at
            } finally {
                st == null || st.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
                st == null || st.removeListener("chainChanged", this.onChainChanged),
                st == null || st.removeListener("disconnect", this.onDisconnect.bind(this)),
                st == null || st.removeListener("session_delete", this.onSessionDelete.bind(this)),
                st == null || st.on("connect", this.onConnect.bind(this)),
                this.setRequestedChainsIds([])
            }
        },
        async getAccounts() {
            return (await this.getProvider()).accounts.map(at=>getAddress(at))
        },
        async getProvider({chainId: st}={}) {
            var ot;
            async function at() {
                const lt = it.chains.map(ct=>ct.id);
                if (!lt.length)
                    return;
                const {EthereumProvider: dt} = await __vitePreload(()=>import("./index.es-BvAIITeK.js"), __vite__mapDeps([2, 1]));
                return await dt.init({
                    ..._e,
                    disableProviderPing: !0,
                    optionalChains: lt,
                    projectId: _e.projectId,
                    rpcMap: Object.fromEntries(it.chains.map(ct=>[ct.id, ct.rpcUrls.default.http[0]])),
                    showQrModal: _e.showQrModal ?? !0
                })
            }
            return tt || (rt || (rt = at()),
            tt = await rt,
            tt == null || tt.events.setMaxListeners(1 / 0)),
            st && await ((ot = this.switchChain) == null ? void 0 : ot.call(this, {
                chainId: st
            })),
            tt
        },
        async getChainId() {
            return (await this.getProvider()).chainId
        },
        async isAuthorized() {
            try {
                const [st,at] = await Promise.all([this.getAccounts(), this.getProvider()]);
                return st.length ? await this.isChainsStale() && at.session ? (await at.disconnect().catch(()=>{}
                ),
                !1) : !0 : !1
            } catch {
                return !1
            }
        },
        async switchChain({chainId: st}) {
            var ot;
            const at = it.chains.find(lt=>lt.id === st);
            if (!at)
                throw new SwitchChainError(new ChainNotConfiguredError);
            try {
                const lt = await this.getProvider()
                  , dt = this.getNamespaceChainsIds()
                  , ct = this.getNamespaceMethods();
                if (!dt.includes(st) && ct.includes("wallet_addEthereumChain")) {
                    await lt.request({
                        method: "wallet_addEthereumChain",
                        params: [{
                            chainId: numberToHex(at.id),
                            blockExplorerUrls: [(ot = at.blockExplorers) == null ? void 0 : ot.default.url],
                            chainName: at.name,
                            nativeCurrency: at.nativeCurrency,
                            rpcUrls: [...at.rpcUrls.default.http]
                        }]
                    });
                    const ft = await this.getRequestedChainsIds();
                    this.setRequestedChainsIds([...ft, st])
                }
                return await lt.request({
                    method: "wallet_switchEthereumChain",
                    params: [{
                        chainId: numberToHex(st)
                    }]
                }),
                at
            } catch (lt) {
                const dt = typeof lt == "string" ? lt : lt == null ? void 0 : lt.message;
                throw /user rejected request/i.test(dt) ? new UserRejectedRequestError(lt) : new SwitchChainError(lt)
            }
        },
        onAccountsChanged(st) {
            st.length === 0 ? this.onDisconnect() : it.emitter.emit("change", {
                accounts: st.map(at=>getAddress(at))
            })
        },
        onChainChanged(st) {
            const at = normalizeChainId(st);
            it.emitter.emit("change", {
                chainId: at
            })
        },
        async onConnect(st) {
            const at = normalizeChainId(st.chainId)
              , ot = await this.getAccounts();
            it.emitter.emit("connect", {
                accounts: ot,
                chainId: at
            })
        },
        async onDisconnect(st) {
            this.setRequestedChainsIds([]),
            it.emitter.emit("disconnect");
            const at = await this.getProvider();
            at.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
            at.removeListener("chainChanged", this.onChainChanged),
            at.removeListener("disconnect", this.onDisconnect.bind(this)),
            at.removeListener("session_delete", this.onSessionDelete.bind(this)),
            at.on("connect", this.onConnect.bind(this))
        },
        onDisplayUri(st) {
            it.emitter.emit("message", {
                type: "display_uri",
                data: st
            })
        },
        onSessionDelete() {
            this.onDisconnect()
        },
        getNamespaceChainsIds() {
            var at, ot, lt;
            return tt ? ((lt = (ot = (at = tt.session) == null ? void 0 : at.namespaces[nt]) == null ? void 0 : ot.chains) == null ? void 0 : lt.map(dt=>parseInt(dt.split(":")[1] || ""))) ?? [] : []
        },
        getNamespaceMethods() {
            var at, ot;
            return tt ? ((ot = (at = tt.session) == null ? void 0 : at.namespaces[nt]) == null ? void 0 : ot.methods) ?? [] : []
        },
        async getRequestedChainsIds() {
            var st;
            return await ((st = it.storage) == null ? void 0 : st.getItem(this.requestedChainsStorageKey)) ?? []
        },
        async isChainsStale() {
            if (this.getNamespaceMethods().includes("wallet_addEthereumChain") || !et)
                return !1;
            const at = it.chains.map(dt=>dt.id)
              , ot = this.getNamespaceChainsIds();
            if (ot.length && !ot.some(dt=>at.includes(dt)))
                return !1;
            const lt = await this.getRequestedChainsIds();
            return !at.every(dt=>lt.includes(dt))
        },
        async setRequestedChainsIds(st) {
            var at;
            await ((at = it.storage) == null ? void 0 : at.setItem(this.requestedChainsStorageKey, st))
        },
        get requestedChainsStorageKey() {
            return `${this.id}.requestedChains`
        }
    })
}
function emailConnector(_e) {
    return et=>({
        id: ConstantsUtil.EMAIL_CONNECTOR_ID,
        name: "Web3Modal Email",
        type: "w3mEmail",
        async connect(tt={}) {
            const rt = await this.getProvider()
              , {address: nt, chainId: it} = await rt.connect({
                chainId: tt.chainId
            });
            return {
                accounts: [nt],
                account: nt,
                chainId: it,
                chain: {
                    id: it,
                    unsuported: !1
                }
            }
        },
        async disconnect() {
            await (await this.getProvider()).disconnect()
        },
        async getAccounts() {
            const tt = await this.getProvider()
              , {address: rt} = await tt.connect();
            return [rt]
        },
        async getProvider() {
            return this.provider || (this.provider = new W3mFrameProvider(_e.options.projectId)),
            Promise.resolve(this.provider)
        },
        async getChainId() {
            const tt = await this.getProvider()
              , {chainId: rt} = await tt.getChainId();
            return rt
        },
        async isAuthorized() {
            const tt = await this.getProvider()
              , {isConnected: rt} = await tt.isConnected();
            return rt
        },
        async switchChain({chainId: tt}) {
            try {
                const rt = et.chains.find(it=>it.id === tt);
                if (!rt)
                    throw new SwitchChainError(new Error("chain not found on connector."));
                return await (await this.getProvider()).switchNetwork(tt),
                et.emitter.emit("change", {
                    chainId: normalizeChainId(tt)
                }),
                rt
            } catch (rt) {
                throw rt instanceof Error ? new SwitchChainError(rt) : rt
            }
        },
        onAccountsChanged(tt) {
            tt.length === 0 ? this.onDisconnect() : et.emitter.emit("change", {
                accounts: tt.map(getAddress)
            })
        },
        onChainChanged(tt) {
            const rt = normalizeChainId(tt);
            et.emitter.emit("change", {
                chainId: rt
            })
        },
        async onConnect(tt) {
            const rt = normalizeChainId(tt.chainId)
              , nt = await this.getAccounts();
            et.emitter.emit("connect", {
                accounts: nt,
                chainId: rt
            })
        },
        async onDisconnect(tt) {
            await (await this.getProvider()).disconnect()
        }
    })
}
function defaultWagmiConfig({projectId: _e, chains: et, metadata: tt, enableInjected: rt, enableCoinbase: nt, enableEmail: it, enableWalletConnect: st, enableEIP6963: at, ...ot}) {
    const lt = []
      , dt = et.map(ut=>[ut.id, getTransport({
        chainId: ut.id,
        projectId: _e
    })])
      , ct = Object.fromEntries(dt);
    return st !== !1 && lt.push(walletConnect({
        projectId: _e,
        metadata: tt,
        showQrModal: !1
    })),
    rt !== !1 && lt.push(injected({
        shimDisconnect: !0
    })),
    nt !== !1 && lt.push(coinbaseWallet({
        appName: (tt == null ? void 0 : tt.name) ?? "Unknown",
        appLogoUrl: (tt == null ? void 0 : tt.icons[0]) ?? "Unknown",
        enableMobileWalletLink: !0
    })),
    it === !0 && lt.push(emailConnector({
        chains: [...et],
        options: {
            projectId: _e
        }
    })),
    createConfig({
        chains: et,
        multiInjectedProviderDiscovery: at !== !1,
        transports: ct,
        ...ot,
        connectors: lt
    })
}
const queryClient = new QueryClient
  , projectId = "3caaf15f8abed7c3c2db8f4305ec5ea2"
  , metadata = {
    name: "Web3Modal",
    description: "Web3Modal Example",
    url: "https://web3modal.com",
    icons: ["https://avatars.githubusercontent.com/u/37784886"]
}
  , chains = [mainnet, bsc]
  , wagmiOptions = {
    autoConnect: !1
}
  , config = defaultWagmiConfig({
    chains,
    projectId,
    metadata,
    enableWalletConnect: !0,
    enableInjected: !0,
    enableEIP6963: !0,
    enableCoinbase: !0,
    ...wagmiOptions
});
createWeb3Modal({
    wagmiConfig: config,
    projectId,
    enableAnalytics: !0
});
function ContextProvider({children: _e}) {
    return jsxRuntimeExports.jsx(WagmiProvider, {
        config,
        children: jsxRuntimeExports.jsx(QueryClientProvider, {
            client: queryClient,
            children: _e
        })
    })
}
const store = configureStore({
    reducer: {
        [apiSlice.reducerPath]: apiSlice.reducer,
        pageSlice: pageSlice$1
    },
    middleware: _e=>_e({
        serializableCheck: !1
    }).concat(apiSlice.middleware),
    devTools: !0
});
client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React$1.StrictMode, {
    children: jsxRuntimeExports.jsx(Provider_default, {
        store,
        children: jsxRuntimeExports.jsx(ContextProvider, {
            children: jsxRuntimeExports.jsx(App, {})
        })
    })
}));
export {BaseError$2 as B, EventEmitter as E, HttpRequestError as H, InvalidAddressError as I, __vitePreload as _, proxy as a, snapshot as b, getUrl as c, stringify as d, decodeErrorResult as e, call as f, getDefaultExportFromCjs as g, concat as h, isAddress as i, encodeAbiParameters as j, isHex as k, getAugmentedNamespace as l, browser$1 as m, commonjsGlobal as n, buffer as o, patterns as p, reactExports as r, subscribe as s, utils as u};
function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = ["assets/index-BbdLNzVy.js", "assets/___vite-browser-external_commonjs-proxy-L6IBOLkW.js", "assets/index.es-BvAIITeK.js"]
    }
    return indexes.map((i)=>__vite__mapDeps.viteFileDeps[i])
}
